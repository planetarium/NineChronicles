<?xml version="1.0"?>
<doc>
    <assembly>
        <name>zxing.unity</name>
    </assembly>
    <members>
        <member name="T:ZXing.Aztec.Internal.AztecDetectorResult">
            <summary>
            Extends <see cref="T:ZXing.Common.DetectorResult" /> with more information specific to the Aztec format,
            like the number of layers and whether it's compact.
            </summary>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecDetectorResult.Compact">
            <summary>
            Gets a value indicating whether this Aztec code is compact.
            </summary>
            <value>
              <c>true</c> if compact; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecDetectorResult.NbDatablocks">
            <summary>
            Gets the nb datablocks.
            </summary>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecDetectorResult.NbLayers">
            <summary>
            Gets the nb layers.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.AztecDetectorResult.#ctor(ZXing.Common.BitMatrix,ZXing.ResultPoint[],System.Boolean,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Aztec.Internal.AztecDetectorResult"/> class.
            </summary>
            <param name="bits">The bits.</param>
            <param name="points">The points.</param>
            <param name="compact">if set to <c>true</c> [compact].</param>
            <param name="nbDatablocks">The nb datablocks.</param>
            <param name="nbLayers">The nb layers.</param>
        </member>
        <member name="T:ZXing.Aztec.Internal.Decoder">
            <summary>
            The main class which implements Aztec Code decoding -- as opposed to locating and extracting
            the Aztec Code from an image.
            </summary>
            <author>David Olivier</author>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.decode(ZXing.Aztec.Internal.AztecDetectorResult)">
            <summary>
            Decodes the specified detector result.
            </summary>
            <param name="detectorResult">The detector result.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.highLevelDecode(System.Boolean[])">
            <summary>
            This method is used for testing the high-level encoder
            </summary>
            <param name="correctedBits"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.getEncodedData(System.Boolean[])">
            <summary>
            Gets the string encoded in the aztec code bits
            </summary>
            <param name="correctedBits">The corrected bits.</param>
            <returns>the decoded string</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.getTable(System.Char)">
            <summary>
            gets the table corresponding to the char passed
            </summary>
            <param name="t">The t.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.getCharacter(System.String[],System.Int32)">
            <summary>
            Gets the character (or string) corresponding to the passed code in the given table
            </summary>
            <param name="table">the table used</param>
            <param name="code">the code of the character</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.correctBits(System.Boolean[])">
             <summary>
            Performs RS error correction on an array of bits.
             </summary>
             <param name="rawbits">The rawbits.</param>
             <returns>the corrected array</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.extractBits(ZXing.Common.BitMatrix)">
            <summary>
            Gets the array of bits from an Aztec Code matrix
            </summary>
            <param name="matrix">The matrix.</param>
            <returns>the array of bits</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.readCode(System.Boolean[],System.Int32,System.Int32)">
            <summary>
            Reads a code of given length and at given index in an array of bits
            </summary>
            <param name="rawbits">The rawbits.</param>
            <param name="startIndex">The start index.</param>
            <param name="length">The length.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.readByte(System.Boolean[],System.Int32)">
            <summary>
            Reads a code of length 8 in an array of bits, padding with zeros
            </summary>
            <param name="rawbits"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Decoder.convertBoolArrayToByteArray(System.Boolean[])">
            <summary>
            Packs a bit array into bytes, most significant bit first
            </summary>
            <param name="boolArr"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Aztec.Internal.Detector">
            <summary>
            Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code
            is rotated or skewed, or partially obscured.
            </summary>
            <author>David Olivier</author>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Aztec.Internal.Detector"/> class.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.detect">
            <summary>
            Detects an Aztec Code in an image.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.detect(System.Boolean)">
            <summary>
            Detects an Aztec Code in an image.
            </summary>
            <param name="isMirror">if true, image is a mirror-image of original.</param>
            <returns>
            encapsulating results of detecting an Aztec Code
            </returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.extractParameters(ZXing.ResultPoint[])">
            <summary>
            Extracts the number of data layers and data blocks from the layer around the bull's eye 
            </summary>
            <param name="bullsEyeCorners">bullEyeCornerPoints the array of bull's eye corners</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.getCorrectedParameterData(System.Int64,System.Boolean)">
            <summary>
            Corrects the parameter bits using Reed-Solomon algorithm
            </summary>
            <param name="parameterData">paremeter bits</param>
            <param name="compact">compact true if this is a compact Aztec code</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.getBullsEyeCorners(ZXing.Aztec.Internal.Detector.Point)">
            <summary>
            Finds the corners of a bull-eye centered on the passed point
            This returns the centers of the diagonal points just outside the bull's eye
            Returns [topRight, bottomRight, bottomLeft, topLeft]
            </summary>
            <param name="pCenter">Center point</param>
            <returns>The corners of the bull-eye</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.getMatrixCenter">
            <summary>
            Finds a candidate center point of an Aztec code from an image
            </summary>
            <returns>the center point</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.getMatrixCornerPoints(ZXing.ResultPoint[])">
            <summary>
            Gets the Aztec code corners from the bull's eye corners and the parameters.
            </summary>
            <param name="bullsEyeCorners">the array of bull's eye corners</param>
            <returns>the array of aztec code corners</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.sampleGrid(ZXing.Common.BitMatrix,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            Creates a BitMatrix by sampling the provided image.
            topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the
            diagonal just outside the bull's eye.
            </summary>
            <param name="image">The image.</param>
            <param name="topLeft">The top left.</param>
            <param name="bottomLeft">The bottom left.</param>
            <param name="bottomRight">The bottom right.</param>
            <param name="topRight">The top right.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.sampleLine(ZXing.ResultPoint,ZXing.ResultPoint,System.Int32)">
            <summary>
            Samples a line
            </summary>
            <param name="p1">start point (inclusive)</param>
            <param name="p2">end point (exclusive)</param>
            <param name="size">number of bits</param>
            <returns> the array of bits as an int (first bit is high-order bit of result)</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.isWhiteOrBlackRectangle(ZXing.Aztec.Internal.Detector.Point,ZXing.Aztec.Internal.Detector.Point,ZXing.Aztec.Internal.Detector.Point,ZXing.Aztec.Internal.Detector.Point)">
            <summary>
            Determines whether [is white or black rectangle] [the specified p1].
            </summary>
            <param name="p1">The p1.</param>
            <param name="p2">The p2.</param>
            <param name="p3">The p3.</param>
            <param name="p4">The p4.</param>
            <returns>true if the border of the rectangle passed in parameter is compound of white points only
            or black points only</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.getColor(ZXing.Aztec.Internal.Detector.Point,ZXing.Aztec.Internal.Detector.Point)">
            <summary>
            Gets the color of a segment
            </summary>
            <param name="p1">The p1.</param>
            <param name="p2">The p2.</param>
            <returns>1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.getFirstDifferent(ZXing.Aztec.Internal.Detector.Point,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Gets the coordinate of the first point with a different color in the given direction
            </summary>
            <param name="init">The init.</param>
            <param name="color">if set to <c>true</c> [color].</param>
            <param name="dx">The dx.</param>
            <param name="dy">The dy.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Detector.expandSquare(ZXing.ResultPoint[],System.Int32,System.Int32)">
            <summary>
            Expand the square represented by the corner points by pushing out equally in all directions
            </summary>
            <param name="cornerPoints">the corners of the square, which has the bull's eye at its center</param>
            <param name="oldSide">the original length of the side of the square in the target bit matrix</param>
            <param name="newSide">the new length of the size of the square in the target bit matrix</param>
            <returns>the corners of the expanded square</returns>
        </member>
        <member name="T:ZXing.Aztec.Internal.AztecCode">
            <summary>
            Aztec 2D code representation
            </summary>
            <author>Rustam Abdullaev</author>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecCode.isCompact">
            <summary>
            Compact or full symbol indicator
            </summary>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecCode.Size">
            <summary>
            Size in pixels (width and height)
            </summary>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecCode.Layers">
            <summary>
            Number of levels
            </summary>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecCode.CodeWords">
            <summary>
            Number of data codewords
            </summary>
        </member>
        <member name="P:ZXing.Aztec.Internal.AztecCode.Matrix">
            <summary>
            The symbol image
            </summary>
        </member>
        <member name="T:ZXing.Aztec.Internal.BinaryShiftToken">
            <summary>
            represents a token for a binary shift
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.BinaryShiftToken.#ctor(ZXing.Aztec.Internal.Token,System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="previous"></param>
            <param name="binaryShiftStart"></param>
            <param name="binaryShiftByteCount"></param>
        </member>
        <member name="M:ZXing.Aztec.Internal.BinaryShiftToken.appendTo(ZXing.Common.BitArray,System.Byte[])">
            <summary>
            appends the byte array to the BitArray
            </summary>
            <param name="bitArray"></param>
            <param name="text"></param>
        </member>
        <member name="M:ZXing.Aztec.Internal.BinaryShiftToken.ToString">
            <summary>
            string representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Aztec.Internal.Encoder">
            <summary>
            Generates Aztec 2D barcodes.
            </summary>
            <author>Rustam Abdullaev</author>
        </member>
        <member name="F:ZXing.Aztec.Internal.Encoder.DEFAULT_EC_PERCENT">
            <summary>
            default EC percent 33
            </summary>
        </member>
        <member name="F:ZXing.Aztec.Internal.Encoder.DEFAULT_AZTEC_LAYERS">
            <summary>
            default layers 0
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.String)">
            <summary>
            Encodes the given string content as an Aztec symbol (without ECI code)
            </summary>
            <param name="data">input data string; must be encodable as ISO/IEC 8859-1 (Latin-1)</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.String,System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="data">input data string; must be encodable as ISO/IEC 8859-1 (Latin-1)</param>
            <param name="minECCPercent">minimal percentage of error check words (According to ISO/IEC 24778:2008, a minimum of 23% + 3 words is recommended)</param>
            <param name="userSpecifiedLayers">if non-zero, a user-specified value for the number of layers</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.String,System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            Encodes the given string content as an Aztec symbol
            </summary>
            <param name="data">input data string</param>
            <param name="minECCPercent">minimal percentage of error check words (According to ISO/IEC 24778:2008, a minimum of 23% + 3 words is recommended)</param>
            <param name="userSpecifiedLayers">if non-zero, a user-specified value for the number of layers</param>
            <param name="encoding">character set in which to encode string using ECI; if null, no ECI code will be inserted, and the string must be encodable as ISO/IEC 8859-1 (Latin-1), the default encoding of the symbol.</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.String,System.Int32,System.Int32,System.Text.Encoding,System.Boolean)">
            <summary>
            Encodes the given string content as an Aztec symbol
            </summary>
            <param name="data">input data string</param>
            <param name="minECCPercent">minimal percentage of error check words (According to ISO/IEC 24778:2008, a minimum of 23% + 3 words is recommended)</param>
            <param name="userSpecifiedLayers">if non-zero, a user-specified value for the number of layers</param>
            <param name="encoding">character set in which to encode string using ECI; if null, no ECI code will be inserted, and the string must be encodable as ISO/IEC 8859-1 (Latin-1), the default encoding of the symbol.</param>
            <param name="disableEci">if true, dont't add ECI segment</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.Byte[])">
            <summary>
            Encodes the given binary content as an Aztec symbol (without ECI code)
            </summary>
            <param name="data">input data</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes the given binary content as an Aztec symbol (without ECI code)
            </summary>
            <param name="data">input data string</param>
            <param name="minECCPercent">minimal percentage of error check words (According to ISO/IEC 24778:2008, a minimum of 23% + 3 words is recommended)</param>
            <param name="userSpecifiedLayers">if non-zero, a user-specified value for the number of layers</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            Encodes the given binary content as an Aztec symbol
            </summary>
            <param name="data">input data string</param>
            <param name="minECCPercent">minimal percentage of error check words (According to ISO/IEC 24778:2008, a minimum of 23% + 3 words is recommended)</param>
            <param name="userSpecifiedLayers">if non-zero, a user-specified value for the number of layers</param>
            <param name="encoding">character set to mark using ECI; if null, no ECI code will be inserted, and the default encoding of ISO/IEC 8859-1 will be assuming by readers.</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Encoder.encode(System.Byte[],System.Int32,System.Int32,System.Text.Encoding,System.Boolean)">
            <summary>
            Encodes the given binary content as an Aztec symbol
            </summary>
            <param name="data">input data string</param>
            <param name="minECCPercent">minimal percentage of error check words (According to ISO/IEC 24778:2008, a minimum of 23% + 3 words is recommended)</param>
            <param name="userSpecifiedLayers">if non-zero, a user-specified value for the number of layers</param>
            <param name="encoding">character set to mark using ECI; if null, no ECI code will be inserted, and the default encoding of ISO/IEC 8859-1 will be assuming by readers.</param>
            <param name="disableEci">if true, don't add ECI segment, regardless if encoding ist set</param>
            <returns>Aztec symbol matrix with metadata</returns>
        </member>
        <member name="T:ZXing.Aztec.Internal.HighLevelEncoder">
            <summary>
            This produces nearly optimal encodings of text into the first-level of
            encoding used by Aztec code.
            It uses a dynamic algorithm.  For each prefix of the string, it determines
            a set of encodings that could lead to this prefix.  We repeatedly add a
            character and generate a new set of optimal encodings until we have read
            through the entire input.
            @author Frank Yellin
            @author Rustam Abdullaev
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.HighLevelEncoder.#ctor(System.Byte[])">
            <summary>
            
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:ZXing.Aztec.Internal.HighLevelEncoder.#ctor(System.Byte[],System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:ZXing.Aztec.Internal.HighLevelEncoder.#ctor(System.Byte[],System.Text.Encoding,System.Boolean)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="encoding"></param>
            <param name="disableEci">if true, disable ECI segment</param>
        </member>
        <member name="M:ZXing.Aztec.Internal.HighLevelEncoder.encode">
            <summary>
            Convert the text represented by this High Level Encoder into a BitArray.
            </summary>
            <returns>text represented by this encoder encoded as a <see cref="T:ZXing.Common.BitArray"/></returns>
        </member>
        <member name="T:ZXing.Aztec.Internal.SimpleToken">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.SimpleToken.#ctor(ZXing.Aztec.Internal.Token,System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="previous"></param>
            <param name="value"></param>
            <param name="bitCount"></param>
        </member>
        <member name="M:ZXing.Aztec.Internal.SimpleToken.appendTo(ZXing.Common.BitArray,System.Byte[])">
            <summary>
            append token to bitarray
            </summary>
            <param name="bitArray"></param>
            <param name="text"></param>
        </member>
        <member name="M:ZXing.Aztec.Internal.SimpleToken.ToString">
            <summary>
            string representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Aztec.Internal.State">
            <summary>
            State represents all information about a sequence necessary to generate the current output.
            Note that a state is immutable.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.State.latchAndAppend(System.Int32,System.Int32)">
            <summary>
            Create a new state representing this state with a latch to a (not
            necessary different) mode, and then a code.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.State.shiftAndAppend(System.Int32,System.Int32)">
            <summary>
            Create a new state representing this state, with a temporary shift
            to a different mode to output a single value.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.State.addBinaryShiftChar(System.Int32)">
            <summary>
            Create a new state representing this state, but an additional character
            output in Binary Shift mode.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.State.endBinaryShift(System.Int32)">
            <summary>
            Create the state identical to this one, but we are no longer in
            Binary Shift mode.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.State.isBetterThanOrEqualTo(ZXing.Aztec.Internal.State)">
            <summary>
            Returns true if "this" state is better (or equal) to be in than "that"
            state under all possible circumstances.
            </summary>
        </member>
        <member name="T:ZXing.Aztec.Internal.Token">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.Aztec.Internal.Token.EMPTY">
            <summary>
            represents an empty token
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.Token.#ctor(ZXing.Aztec.Internal.Token)">
            <summary>
            constructor
            </summary>
            <param name="previous"></param>
        </member>
        <member name="P:ZXing.Aztec.Internal.Token.Previous">
            <summary>
            previous token
            </summary>
        </member>
        <member name="M:ZXing.Aztec.Internal.Token.add(System.Int32,System.Int32)">
            <summary>
            adds a new simple token
            </summary>
            <param name="value"></param>
            <param name="bitCount"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Token.addBinaryShift(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="byteCount"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Aztec.Internal.Token.appendTo(ZXing.Common.BitArray,System.Byte[])">
            <summary>
            append to bitarray
            </summary>
            <param name="bitArray"></param>
            <param name="text"></param>
        </member>
        <member name="T:ZXing.Aztec.AztecReader">
            <summary>
            This implementation can detect and decode Aztec codes in an image.
            </summary>
            <author>David Olivier</author>
        </member>
        <member name="M:ZXing.Aztec.AztecReader.decode(ZXing.BinaryBitmap)">
            <summary>
            Locates and decodes a barcode in some format within an image.
            </summary>
            <param name="image">image of barcode to decode</param>
            <returns>
            a String representing the content encoded by the Data Matrix code
            </returns>
        </member>
        <member name="M:ZXing.Aztec.AztecReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
             Locates and decodes a Data Matrix code in an image.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a {@link java.util.Hashtable} from {@link com.google.zxing.DecodeHintType}
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.Aztec.AztecReader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="T:ZXing.Aztec.AztecResultMetadata">
            <summary>
            Aztec result meta data.
            </summary>
        </member>
        <member name="P:ZXing.Aztec.AztecResultMetadata.Compact">
            <summary>
            Gets a value indicating whether this Aztec code is compact.
            </summary>
            <value>
              <c>true</c> if compact; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Aztec.AztecResultMetadata.Datablocks">
            <summary>
            Gets the nb datablocks.
            </summary>
        </member>
        <member name="P:ZXing.Aztec.AztecResultMetadata.Layers">
            <summary>
            Gets the nb layers.
            </summary>
        </member>
        <member name="M:ZXing.Aztec.AztecResultMetadata.#ctor(System.Boolean,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="compact"></param>
            <param name="datablocks"></param>
            <param name="layers"></param>
        </member>
        <member name="M:ZXing.Aztec.AztecResultMetadata.ToString">
            <summary>
            string represenation of that instance
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Aztec.AztecWriter">
            <summary>
            Renders an Aztec code as a <see cref="T:ZXing.Common.BitMatrix" />
            </summary>
        </member>
        <member name="F:ZXing.Aztec.AztecWriter.DEFAULT_CHARSET">
            <summary>
            default character set
            </summary>
        </member>
        <member name="M:ZXing.Aztec.AztecWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            Encode a barcode using the default settings.
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.Aztec.AztecWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <param name="hints">Additional parameters to supply to the encoder</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.Aztec.AztecWriter.encode(System.Byte[],ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <param name="hints">Additional parameters to supply to the encoder</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.Aztec.AztecWriter.encode(System.Byte[],ZXing.BarcodeFormat,System.Int32,System.Int32,System.Text.Encoding,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <param name="charset">Encoding of the byte array</param>
            <param name="hints">Additional parameters to supply to the encoder</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="T:ZXing.Aztec.AztecEncodingOptions">
            <summary>
            The class holds the available options for the <see cref="T:ZXing.Aztec.AztecWriter" />
            </summary>
        </member>
        <member name="P:ZXing.Aztec.AztecEncodingOptions.ErrorCorrection">
            <summary>
            Representing the minimal percentage of error correction words. 
            Note: an Aztec symbol should have a minimum of 25% EC words.
            </summary>
        </member>
        <member name="P:ZXing.Aztec.AztecEncodingOptions.Layers">
            <summary>
            Specifies the required number of layers for an Aztec code:
            a negative number (-1, -2, -3, -4) specifies a compact Aztec code
            0 indicates to use the minimum number of layers (the default)
            a positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code
            </summary>
        </member>
        <member name="P:ZXing.Aztec.AztecEncodingOptions.CharacterSet">
            <summary>
            Specifies what character encoding to use where applicable (type <see cref="T:System.String"/>)
            </summary>
        </member>
        <member name="T:ZXing.BarcodeFormat">
            <summary>
            Enumerates barcode formats known to this package.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.BarcodeFormat.AZTEC">
            <summary>Aztec 2D barcode format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.CODABAR">
            <summary>CODABAR 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.CODE_39">
            <summary>Code 39 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.CODE_93">
            <summary>Code 93 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.CODE_128">
            <summary>Code 128 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.DATA_MATRIX">
            <summary>Data Matrix 2D barcode format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.EAN_8">
            <summary>EAN-8 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.EAN_13">
            <summary>EAN-13 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.ITF">
            <summary>ITF (Interleaved Two of Five) 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.MAXICODE">
            <summary>MaxiCode 2D barcode format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.PDF_417">
            <summary>PDF417 format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.QR_CODE">
            <summary>QR Code 2D barcode format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.RSS_14">
            <summary>RSS 14</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.RSS_EXPANDED">
            <summary>RSS EXPANDED</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.UPC_A">
            <summary>UPC-A 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.UPC_E">
            <summary>UPC-E 1D format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.UPC_EAN_EXTENSION">
            <summary>UPC/EAN extension format. Not a stand-alone format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.MSI">
            <summary>MSI</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.PLESSEY">
            <summary>Plessey</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.IMB">
            <summary>Intelligent Mail barcode</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.PHARMA_CODE">
            <summary>Pharmacode format.</summary>
        </member>
        <member name="F:ZXing.BarcodeFormat.All_1D">
            <summary>
            UPC_A | UPC_E | EAN_13 | EAN_8 | CODABAR | CODE_39 | CODE_93 | CODE_128 | ITF | RSS_14 | RSS_EXPANDED
            without MSI (to many false-positives) and IMB (not enough tested, and it looks more like a 2D)
            </summary>
        </member>
        <member name="T:ZXing.BarcodeReader">
            <summary>
            A smart class to decode the barcode inside a bitmap object
            </summary>
        </member>
        <member name="M:ZXing.BarcodeReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.BarcodeReader.#ctor(ZXing.Reader,System.Func{UnityEngine.Color32[],System.Int32,System.Int32,ZXing.LuminanceSource},System.Func{ZXing.LuminanceSource,ZXing.Binarizer})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReader"/> class.
            </summary>
            <param name="reader">Sets the reader which should be used to find and decode the barcode.
            If null then MultiFormatReader is used</param>
            <param name="createLuminanceSource">Sets the function to create a luminance source object for a bitmap.
            If null, an exception is thrown when Decode is called</param>
            <param name="createBinarizer">Sets the function to create a binarizer object for a luminance source.
            If null then HybridBinarizer is used</param>
        </member>
        <member name="M:ZXing.BarcodeReader.#ctor(ZXing.Reader,System.Func{UnityEngine.Color32[],System.Int32,System.Int32,ZXing.LuminanceSource},System.Func{ZXing.LuminanceSource,ZXing.Binarizer},System.Func{System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat,ZXing.LuminanceSource})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReader"/> class.
            </summary>
            <param name="reader">Sets the reader which should be used to find and decode the barcode.
            If null then MultiFormatReader is used</param>
            <param name="createLuminanceSource">Sets the function to create a luminance source object for a bitmap.
            If null, an exception is thrown when Decode is called</param>
            <param name="createBinarizer">Sets the function to create a binarizer object for a luminance source.
            If null then HybridBinarizer is used</param>
            <param name="createRGBLuminanceSource">Sets the function to create a luminance source object for a rgb raw byte array.</param>
        </member>
        <member name="P:ZXing.BarcodeReader.CreateLuminanceSource">
            <summary>
            Optional: Gets or sets the function to create a luminance source object for a bitmap.
            If null a platform specific default LuminanceSource is used
            </summary>
            <value>
            The function to create a luminance source object.
            </value>
        </member>
        <member name="M:ZXing.BarcodeReader.Decode(UnityEngine.Color32[],System.Int32,System.Int32)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="rawColor32"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns>the result data or null</returns>
        </member>
        <member name="M:ZXing.BarcodeReader.DecodeMultiple(UnityEngine.Color32[],System.Int32,System.Int32)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="rawColor32"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns>the result data or null</returns>
        </member>
        <member name="T:ZXing.BarcodeReader`1">
            <summary>
            A smart class to decode the barcode inside a bitmap object
            </summary>
        </member>
        <member name="M:ZXing.BarcodeReader`1.#ctor(System.Func{`0,ZXing.LuminanceSource})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReader`1"/> class.
            </summary>
        </member>
        <member name="M:ZXing.BarcodeReader`1.#ctor(ZXing.Reader,System.Func{`0,ZXing.LuminanceSource},System.Func{ZXing.LuminanceSource,ZXing.Binarizer})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReader`1"/> class.
            </summary>
            <param name="reader">Sets the reader which should be used to find and decode the barcode.
            If null then MultiFormatReader is used</param>
            <param name="createLuminanceSource">Sets the function to create a luminance source object for a bitmap.
            If null, an exception is thrown when Decode is called</param>
            <param name="createBinarizer">Sets the function to create a binarizer object for a luminance source.
            If null then HybridBinarizer is used</param>
        </member>
        <member name="M:ZXing.BarcodeReader`1.#ctor(ZXing.Reader,System.Func{`0,ZXing.LuminanceSource},System.Func{ZXing.LuminanceSource,ZXing.Binarizer},System.Func{System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat,ZXing.LuminanceSource})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReader`1"/> class.
            </summary>
            <param name="reader">Sets the reader which should be used to find and decode the barcode.
            If null then MultiFormatReader is used</param>
            <param name="createLuminanceSource">Sets the function to create a luminance source object for a bitmap.
            If null, an exception is thrown when Decode is called</param>
            <param name="createBinarizer">Sets the function to create a binarizer object for a luminance source.
            If null then HybridBinarizer is used</param>
            <param name="createRGBLuminanceSource">Sets the function to create a luminance source object for a rgb raw byte array.</param>
        </member>
        <member name="M:ZXing.BarcodeReader`1.#ctor(ZXing.Reader,System.Func{ZXing.LuminanceSource,ZXing.Binarizer},System.Func{System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat,ZXing.LuminanceSource})">
            <summary>
            Constructor for additional image formats for one BarcodeReader class
            </summary>
            <param name="reader">Sets the reader which should be used to find and decode the barcode.
            If null then MultiFormatReader is used</param>
            <param name="createBinarizer">Sets the function to create a binarizer object for a luminance source.
            If null then HybridBinarizer is used</param>
            <param name="createRGBLuminanceSource">Sets the function to create a luminance source object for a rgb raw byte array.</param>
        </member>
        <member name="P:ZXing.BarcodeReader`1.CreateLuminanceSource">
            <summary>
            Optional: Gets or sets the function to create a luminance source object for a bitmap.
            If null a platform specific default LuminanceSource is used
            </summary>
            <value>
            The function to create a luminance source object.
            </value>
        </member>
        <member name="M:ZXing.BarcodeReader`1.Decode(`0)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="barcodeBitmap">The barcode bitmap.</param>
            <returns>the result data or null</returns>
        </member>
        <member name="M:ZXing.BarcodeReader`1.DecodeMultiple(`0)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="barcodeBitmap">The barcode bitmap.</param>
            <returns>the result data or null</returns>
        </member>
        <member name="T:ZXing.BarcodeReaderGeneric">
            <summary>
            A smart class to decode the barcode inside a bitmap object
            </summary>
        </member>
        <member name="F:ZXing.BarcodeReaderGeneric.defaultCreateRGBLuminanceSource">
            <summary>
            represents the default function which is called to get a <see cref="T:ZXing.RGBLuminanceSource"/> instance from a raw byte array
            </summary>
        </member>
        <member name="P:ZXing.BarcodeReaderGeneric.Options">
            <summary>
            Gets or sets the options.
            </summary>
            <value>
            The options.
            </value>
        </member>
        <member name="P:ZXing.BarcodeReaderGeneric.Reader">
            <summary>
            Gets the reader which should be used to find and decode the barcode.
            </summary>
            <value>
            The reader.
            </value>
        </member>
        <member name="E:ZXing.BarcodeReaderGeneric.ResultPointFound">
            <summary>
            Gets or sets a method which is called if an important point is found
            </summary>
            <value>
            The result point callback.
            </value>
        </member>
        <member name="E:ZXing.BarcodeReaderGeneric.ResultFound">
            <summary>
            event is executed if a result was found via decode
            </summary>
        </member>
        <member name="P:ZXing.BarcodeReaderGeneric.AutoRotate">
            <summary>
            Gets or sets a value indicating whether the image should be automatically rotated.
            Rotation is supported for 90, 180 and 270 degrees
            </summary>
            <value>
              <c>true</c> if image should be rotated; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.BarcodeReaderGeneric.TryInverted">
            <summary>
            Gets or sets a value indicating whether the image should be automatically inverted
            if no result is found in the original image.
            ATTENTION: Please be carefully because it slows down the decoding process if it is used
            </summary>
            <value>
              <c>true</c> if image should be inverted; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.BarcodeReaderGeneric.CreateBinarizer">
            <summary>
            Optional: Gets or sets the function to create a binarizer object for a luminance source.
            If null then HybridBinarizer is used
            </summary>
            <value>
            The function to create a binarizer object.
            </value>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReaderGeneric"/> class.
            </summary>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.#ctor(ZXing.Reader,System.Func{ZXing.LuminanceSource,ZXing.Binarizer},System.Func{System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat,ZXing.LuminanceSource})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeReaderGeneric"/> class.
            </summary>
            <param name="reader">Sets the reader which should be used to find and decode the barcode.
            If null then MultiFormatReader is used</param>
            <param name="createBinarizer">Sets the function to create a binarizer object for a luminance source.
            If null then HybridBinarizer is used</param>
            <param name="createRGBLuminanceSource">Sets the function to create a luminance source object for a rgb array.
            If null the RGBLuminanceSource is used. The handler is only called when Decode with a byte[] array is called.</param>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.Decode(ZXing.LuminanceSource)">
            <summary>
            Tries to decode a barcode within an image which is given by a luminance source.
            That method gives a chance to prepare a luminance source completely before calling
            the time consuming decoding method. On the other hand there is a chance to create
            a luminance source which is independent from external resources (like Bitmap objects)
            and the decoding call can be made in a background thread.
            </summary>
            <param name="luminanceSource">The luminance source.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.DecodeMultiple(ZXing.LuminanceSource)">
            <summary>
            Tries to decode barcodes within an image which is given by a luminance source.
            That method gives a chance to prepare a luminance source completely before calling
            the time consuming decoding method. On the other hand there is a chance to create
            a luminance source which is independent from external resources (like Bitmap objects)
            and the decoding call can be made in a background thread.
            </summary>
            <param name="luminanceSource">The luminance source.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.OnResultsFound(System.Collections.Generic.IEnumerable{ZXing.Result})">
            <summary>
            raises the ResultFound event
            </summary>
            <param name="results"></param>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.OnResultFound(ZXing.Result)">
            <summary>
            raises the ResultFound event
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.OnResultPointFound(ZXing.ResultPoint)">
            <summary>
            calls the explicitResultPointFound action
            </summary>
            <param name="resultPoint"></param>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.Decode(System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="rawRGB">The image as byte[] array.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="format">The format.</param>
            <returns>
            the result data or null
            </returns>
        </member>
        <member name="M:ZXing.BarcodeReaderGeneric.DecodeMultiple(System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="rawRGB">The image as byte[] array.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="format">The format.</param>
            <returns>
            the result data or null
            </returns>
        </member>
        <member name="T:ZXing.BarcodeWriter">
            <summary>
            A smart class to encode some content to a barcode image
            </summary>
        </member>
        <member name="M:ZXing.BarcodeWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeWriter"/> class.
            </summary>
        </member>
        <member name="T:ZXing.BarcodeWriterPixelData">
            <summary>
            A smart class to encode some content to raw pixel data
            </summary>
        </member>
        <member name="M:ZXing.BarcodeWriterPixelData.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeWriterPixelData"/> class.
            </summary>
        </member>
        <member name="T:ZXing.BarcodeWriterSvg">
            <summary>
            A smart class to encode some content to a svg barcode image
            </summary>
        </member>
        <member name="M:ZXing.BarcodeWriterSvg.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BarcodeWriterSvg"/> class.
            </summary>
        </member>
        <member name="T:ZXing.BarcodeWriter`1">
            <summary>
            A base class for specific barcode writers with specific formats of barcode images.
            </summary>
            <typeparam name="TOutput">The type of the output.</typeparam>
        </member>
        <member name="P:ZXing.BarcodeWriter`1.Renderer">
            <summary>
            Gets or sets the renderer which should be used to render the encoded BitMatrix.
            </summary>
        </member>
        <member name="M:ZXing.BarcodeWriter`1.Write(System.String)">
            <summary>
            Encodes the specified contents and returns a rendered instance of the barcode.
            For rendering the instance of the property Renderer is used and has to be set before
            calling that method.
            </summary>
            <param name="contents">The contents.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.BarcodeWriter`1.Write(ZXing.Common.BitMatrix)">
            <summary>
            Returns a rendered instance of the barcode which is given by a BitMatrix.
            For rendering the instance of the property Renderer is used and has to be set before
            calling that method.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.BarcodeWriterGeneric">
            <summary>
            A base class for specific barcode writers with specific formats of barcode images.
            </summary>
        </member>
        <member name="P:ZXing.BarcodeWriterGeneric.Format">
            <summary>
            Gets or sets the barcode format.
            The value is only suitable if the MultiFormatWriter is used.
            </summary>
        </member>
        <member name="P:ZXing.BarcodeWriterGeneric.Options">
            <summary>
            Gets or sets the options container for the encoding and renderer process.
            </summary>
        </member>
        <member name="P:ZXing.BarcodeWriterGeneric.Encoder">
            <summary>
            Gets or sets the writer which encodes the content to a BitMatrix.
            If no value is set the MultiFormatWriter is used.
            </summary>
        </member>
        <member name="M:ZXing.BarcodeWriterGeneric.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.BarcodeWriterGeneric.#ctor(ZXing.Writer)">
            <summary>
            
            </summary>
            <param name="encoder"></param>
        </member>
        <member name="M:ZXing.BarcodeWriterGeneric.Encode(System.String)">
            <summary>
            Encodes the specified contents and returns a BitMatrix array.
            That array has to be rendered manually or with a IBarcodeRenderer.
            </summary>
            <param name="contents">The contents.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.BaseLuminanceSource">
            <summary>
            The base class for luminance sources which supports 
            cropping and rotating based upon the luminance values.
            </summary>
        </member>
        <member name="F:ZXing.BaseLuminanceSource.RChannelWeight">
            <summary>
            weight of the red channel for calculating a gray scale image
            </summary>
        </member>
        <member name="F:ZXing.BaseLuminanceSource.GChannelWeight">
            <summary>
            weight of the green channel for calculating a gray scale image
            </summary>
        </member>
        <member name="F:ZXing.BaseLuminanceSource.BChannelWeight">
            <summary>
            weight of the blue channel for calculating a gray scale image
            </summary>
        </member>
        <member name="F:ZXing.BaseLuminanceSource.ChannelWeight">
            <summary>
            numbers of bits which for right shifting
            </summary>
        </member>
        <member name="F:ZXing.BaseLuminanceSource.luminances">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BaseLuminanceSource"/> class.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.BaseLuminanceSource"/> class.
            </summary>
            <param name="luminanceArray">The luminance array.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.getRow(System.Int32,System.Byte[])">
            <summary>
            Fetches one row of luminance data from the underlying platform's bitmap. Values range from
            0 (black) to 255 (white). It is preferable for implementations of this method
            to only fetch this row rather than the whole image, since no 2D Readers may be installed and
            getMatrix() may never be called.
            </summary>
            <param name="y">The row to fetch, 0 &lt;= y &lt; Height.</param>
            <param name="row">An optional preallocated array. If null or too small, it will be ignored.
            Always use the returned object, and ignore the .length of the array.</param>
            <returns>
            An array containing the luminance data.
            </returns>
        </member>
        <member name="P:ZXing.BaseLuminanceSource.Matrix">
            <summary>
            gets the luminance matrix
            </summary>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.rotateCounterClockwise">
            <summary>
            Returns a new object with rotated image data by 90 degrees counterclockwise.
            Only callable if {@link #isRotateSupported()} is true.
            </summary>
            <returns>
            A rotated version of this object.
            </returns>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.rotateCounterClockwise45">
            <summary>
            TODO: not implemented yet
            </summary>
            <returns>
            A rotated version of this object.
            </returns>
        </member>
        <member name="P:ZXing.BaseLuminanceSource.RotateSupported">
            <summary>
            </summary>
            <returns> Whether this subclass supports counter-clockwise rotation.</returns>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.crop(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new object with cropped image data. Implementations may keep a reference to the
            original data rather than a copy. Only callable if CropSupported is true.
            </summary>
            <param name="left">The left coordinate, 0 &lt;= left &lt; Width.</param>
            <param name="top">The top coordinate, 0 &lt;= top &lt;= Height.</param>
            <param name="width">The width of the rectangle to crop.</param>
            <param name="height">The height of the rectangle to crop.</param>
            <returns>
            A cropped version of this object.
            </returns>
        </member>
        <member name="P:ZXing.BaseLuminanceSource.CropSupported">
            <summary>
            </summary>
            <returns> Whether this subclass supports cropping.</returns>
        </member>
        <member name="P:ZXing.BaseLuminanceSource.InversionSupported">
            <summary>
            </summary>
            <returns>Whether this subclass supports invertion.</returns>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.invert">
            <summary>
            Inverts the luminance values (newValue = 255 - oldValue)
            </summary>
        </member>
        <member name="M:ZXing.BaseLuminanceSource.CreateLuminanceSource(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Should create a new luminance source with the right class type.
            The method is used in methods crop and rotate.
            </summary>
            <param name="newLuminances">The new luminances.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Binarizer">
            <summary> This class hierarchy provides a set of methods to convert luminance data to 1 bit data.
            It allows the algorithm to vary polymorphically, for example allowing a very expensive
            thresholding technique for servers and a fast one for mobile. It also permits the implementation
            to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.
            
            <author>dswitkin@google.com (Daniel Switkin)</author>
            </summary>
        </member>
        <member name="M:ZXing.Binarizer.#ctor(ZXing.LuminanceSource)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Binarizer"/> class.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="P:ZXing.Binarizer.LuminanceSource">
            <summary>
            Gets the luminance source object.
            </summary>
        </member>
        <member name="M:ZXing.Binarizer.getBlackRow(System.Int32,ZXing.Common.BitArray)">
            <summary> Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
            cached data. Callers should assume this method is expensive and call it as seldom as possible.
            This method is intended for decoding 1D barcodes and may choose to apply sharpening.
            For callers which only examine one row of pixels at a time, the same BitArray should be reused
            and passed in with each call for performance. However it is legal to keep more than one row
            at a time if needed.
            </summary>
            <param name="y">The row to fetch, which must be in [0, bitmap height)</param>
            <param name="row">An optional preallocated array. If null or too small, it will be ignored.
            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
            </param>
            <returns> The array of bits for this row (true means black).</returns>
        </member>
        <member name="P:ZXing.Binarizer.BlackMatrix">
            <summary> Converts a 2D array of luminance data to 1 bit data. As above, assume this method is expensive
            and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
            may not apply sharpening. Therefore, a row from this matrix may not be identical to one
            fetched using getBlackRow(), so don't mix and match between them.
            </summary>
            <returns> The 2D array of bits for the image (true means black).</returns>
        </member>
        <member name="M:ZXing.Binarizer.createBinarizer(ZXing.LuminanceSource)">
            <summary> Creates a new object with the same type as this Binarizer implementation, but with pristine
            state. This is needed because Binarizer implementations may be stateful, e.g. keeping a cache
            of 1 bit data. See Effective Java for why we can't use Java's clone() method.
            </summary>
            <param name="source">The LuminanceSource this Binarizer will operate on.</param>
            <returns> A new concrete Binarizer implementation object.</returns>
        </member>
        <member name="P:ZXing.Binarizer.Width">
            <summary>
            Gets the width of the luminance source object.
            </summary>
        </member>
        <member name="P:ZXing.Binarizer.Height">
            <summary>
            Gets the height of the luminance source object.
            </summary>
        </member>
        <member name="T:ZXing.BinaryBitmap">
            <summary>
            This class is the core bitmap class used by ZXing to represent 1 bit data. Reader objects
            accept a BinaryBitmap and attempt to decode it.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="M:ZXing.BinaryBitmap.#ctor(ZXing.Binarizer)">
            <summary>
            
            </summary>
            <param name="binarizer"></param>
        </member>
        <member name="P:ZXing.BinaryBitmap.Width">
            <returns>
            The width of the bitmap.
            </returns>
        </member>
        <member name="P:ZXing.BinaryBitmap.Height">
            <returns>
            The height of the bitmap.
            </returns>
        </member>
        <member name="M:ZXing.BinaryBitmap.getBlackRow(System.Int32,ZXing.Common.BitArray)">
            <summary>
            Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
            cached data. Callers should assume this method is expensive and call it as seldom as possible.
            This method is intended for decoding 1D barcodes and may choose to apply sharpening.
            </summary>
            <param name="y">The row to fetch, which must be in [0, bitmap height).</param>
            <param name="row">An optional preallocated array. If null or too small, it will be ignored.
            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
            </param>
            <returns> The array of bits for this row (true means black).</returns>
        </member>
        <member name="P:ZXing.BinaryBitmap.BlackMatrix">
            <summary>
            Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
            and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
            may not apply sharpening. Therefore, a row from this matrix may not be identical to one
            fetched using getBlackRow(), so don't mix and match between them.
            </summary>
            <returns> The 2D array of bits for the image (true means black).</returns>
        </member>
        <member name="P:ZXing.BinaryBitmap.CropSupported">
            <returns>
            Whether this bitmap can be cropped.
            </returns>
        </member>
        <member name="M:ZXing.BinaryBitmap.crop(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new object with cropped image data. Implementations may keep a reference to the
            original data rather than a copy. Only callable if isCropSupported() is true.
            </summary>
            <param name="left">The left coordinate, which must be in [0, Width)</param>
            <param name="top">The top coordinate, which must be in [0, Height)</param>
            <param name="width">The width of the rectangle to crop.</param>
            <param name="height">The height of the rectangle to crop.</param>
            <returns> A cropped version of this object.</returns>
        </member>
        <member name="P:ZXing.BinaryBitmap.RotateSupported">
            <returns>
            Whether this bitmap supports counter-clockwise rotation.
            </returns>
        </member>
        <member name="M:ZXing.BinaryBitmap.rotateCounterClockwise">
            <summary>
            Returns a new object with rotated image data by 90 degrees counterclockwise.
            Only callable if <see cref="P:ZXing.BinaryBitmap.RotateSupported"/> is true.
            </summary>
            <returns>A rotated version of this object.</returns>
        </member>
        <member name="M:ZXing.BinaryBitmap.rotateCounterClockwise45">
            <summary>
            Returns a new object with rotated image data by 45 degrees counterclockwise.
            Only callable if <see cref="P:ZXing.BinaryBitmap.RotateSupported"/> is true.
            </summary>
            <returns>A rotated version of this object.</returns>
        </member>
        <member name="M:ZXing.BinaryBitmap.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ZXing.Client.Result.AbstractDoCoMoResultParser">
            <summary> <p>See
            <a href="http://www.nttdocomo.co.jp/english/service/imode/make/content/barcode/about/s2.html">
            DoCoMo's documentation</a> about the result types represented by subclasses of this class.</p>
            
            <p>Thanks to Jeff Griffin for proposing rewrite of these classes that relies less
            on exception-based mechanisms during parsing.</p>
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.AddressBookAUResultParser">
            <summary> Implements KDDI AU's address book format. See
            <a href="http://www.au.kddi.com/ezfactory/tec/two_dimensions/index.html">
            http://www.au.kddi.com/ezfactory/tec/two_dimensions/index.html</a>.
            (Thanks to Yuzo for translating!)
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.AddressBookDoCoMoResultParser">
            <summary> Implements the "MECARD" address book entry format.
            
            Supported keys: N, SOUND, TEL, EMAIL, NOTE, ADR, BDAY, URL, plus ORG
            Unsupported keys: TEL-AV, NICKNAME
            
            Except for TEL, multiple values for keys are also not supported;
            the first one found takes precedence.
            
            Our understanding of the MECARD format is based on this document:
            
            http://www.mobicode.org.tw/files/OMIA%20Mobile%20Bar%20Code%20Standard%20v3.2.1.doc
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.AddressBookParsedResult">
            <summary>
            Represents a parsed result that encodes contact information, like that in an address book entry.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.AddressBookParsedResult.#ctor(System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.String[])">
            <summary>
            initializing constructor
            </summary>
            <param name="names"></param>
            <param name="phoneNumbers"></param>
            <param name="phoneTypes"></param>
            <param name="emails"></param>
            <param name="emailTypes"></param>
            <param name="addresses"></param>
            <param name="addressTypes"></param>
        </member>
        <member name="M:ZXing.Client.Result.AddressBookParsedResult.#ctor(System.String[],System.String[],System.String,System.String[],System.String[],System.String[],System.String[],System.String,System.String,System.String[],System.String[],System.String,System.String,System.String,System.String[],System.String[])">
            <summary>
            initializing constructor
            </summary>
            <param name="names"></param>
            <param name="nicknames"></param>
            <param name="pronunciation"></param>
            <param name="phoneNumbers"></param>
            <param name="phoneTypes"></param>
            <param name="emails"></param>
            <param name="emailTypes"></param>
            <param name="instantMessenger"></param>
            <param name="note"></param>
            <param name="addresses"></param>
            <param name="addressTypes"></param>
            <param name="org"></param>
            <param name="birthday"></param>
            <param name="title"></param>
            <param name="urls"></param>
            <param name="geo"></param>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Names">
            <summary>
            the names
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Nicknames">
            <summary>
            the nicknames
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Pronunciation">
            <summary>
            In Japanese, the name is written in kanji, which can have multiple readings. Therefore a hint
            is often provided, called furigana, which spells the name phonetically.
            </summary>
            <return>The pronunciation of the getNames() field, often in hiragana or katakana.</return>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.PhoneNumbers">
            <summary>
            the phone numbers
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.PhoneTypes">
            <return>optional descriptions of the type of each phone number. It could be like "HOME", but,
            there is no guaranteed or standard format.</return>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Emails">
            <summary>
            the e-mail addresses
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.EmailTypes">
            <return>optional descriptions of the type of each e-mail. It could be like "WORK", but,
            there is no guaranteed or standard format.</return>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.InstantMessenger">
            <summary>
            the instant messenger addresses
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Note">
            <summary>
            the note field
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Addresses">
            <summary>
            the addresses
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.AddressTypes">
            <return>optional descriptions of the type of each e-mail. It could be like "WORK", but,
            there is no guaranteed or standard format.</return>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Title">
            <summary>
            the title
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Org">
            <summary>
            the organisations
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.URLs">
            <summary>
            the urls
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Birthday">
            <return>birthday formatted as yyyyMMdd (e.g. 19780917)</return>
        </member>
        <member name="P:ZXing.Client.Result.AddressBookParsedResult.Geo">
            <return>a location as a latitude/longitude pair</return>
        </member>
        <member name="T:ZXing.Client.Result.BizcardResultParser">
            <summary> Implements the "BIZCARD" address book entry format, though this has been
            largely reverse-engineered from examples observed in the wild -- still
            looking for a definitive reference.
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.BookmarkDoCoMoResultParser">
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.CalendarParsedResult">
             <summary>
             Represents a parsed result that encodes a calendar event at a certain time, optionally with attendees and a location.
             </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.CalendarParsedResult.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String[],System.String,System.Double,System.Double)">
            <summary>
            initializing constructor
            </summary>
            <param name="summary"></param>
            <param name="startString"></param>
            <param name="endString"></param>
            <param name="durationString"></param>
            <param name="location"></param>
            <param name="organizer"></param>
            <param name="attendees"></param>
            <param name="description"></param>
            <param name="latitude"></param>
            <param name="longitude"></param>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Summary">
            <summary>
            summary
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Start">
            <summary>
            Gets the start.
            </summary>
        </member>
        <member name="M:ZXing.Client.Result.CalendarParsedResult.isStartAllDay">
            <summary>
            Determines whether [is start all day].
            </summary>
            <returns>if start time was specified as a whole day</returns>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.End">
            <summary>
            event end <see cref="T:System.DateTime"/>, or null if event has no duration
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.isEndAllDay">
            <summary>
            Gets a value indicating whether this instance is end all day.
            </summary>
            <value>true if end time was specified as a whole day</value>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Location">
            <summary>
            location
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Organizer">
            <summary>
            organizer
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Attendees">
            <summary>
            attendees
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Description">
            <summary>
            description
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Latitude">
            <summary>
            latitude
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.CalendarParsedResult.Longitude">
            <summary>
            longitude
            </summary>
        </member>
        <member name="M:ZXing.Client.Result.CalendarParsedResult.parseDate(System.String)">
            <summary>
            Parses a string as a date. RFC 2445 allows the start and end fields to be of type DATE (e.g. 20081021)
            or DATE-TIME (e.g. 20081021T123000 for local time, or 20081021T123000Z for UTC).
            </summary>
            <param name="when">The string to parse</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">if not a date formatted string</exception>
        </member>
        <member name="T:ZXing.Client.Result.EmailAddressParsedResult">
            <summary>
            Represents a parsed result that encodes an email message including recipients, subject and body text.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.Client.Result.EmailAddressParsedResult.EmailAddress">
            <summary>
            the email address
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.EmailAddressParsedResult.Tos">
            <summary>
            the TOs
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.EmailAddressParsedResult.CCs">
            <summary>
            the CCs
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.EmailAddressParsedResult.BCCs">
            <summary>
            the BCCs
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.EmailAddressParsedResult.Subject">
            <summary>
            the subject
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.EmailAddressParsedResult.Body">
            <summary>
            the body
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.EmailAddressParsedResult.MailtoURI">
            <summary>
            the mailto: uri
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.EmailAddressResultParser">
            <summary>
            Represents a result that encodes an e-mail address, either as a plain address
            like "joe@example.org" or a mailto: URL like "mailto:joe@example.org".
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="T:ZXing.Client.Result.EmailDoCoMoResultParser">
            <summary>
            Implements the "MATMSG" email message entry format.
            
            Supported keys: TO, SUB, BODY
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.EmailDoCoMoResultParser.isBasicallyValidEmailAddress(System.String)">
            <summary>
            This implements only the most basic checking for an email address's validity -- that it contains
            an '@' and contains no characters disallowed by RFC 2822. This is an overly lenient definition of
            validity. We want to generally be lenient here since this class is only intended to encapsulate what's
            in a barcode, not "judge" it.
            </summary>
            <param name="email">The email.</param>
            <returns>
              <c>true</c> if it is basically a valid email address; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:ZXing.Client.Result.ExpandedProductParsedResult">
            <summary>
            Represents a parsed result that encodes extended product information as encoded by the RSS format, like weight, price, dates, etc.
            </summary>
            <author> Antonio Manuel Benjumea Conde, Servinform, S.A.</author>
            <author> Agustín Delgado, Servinform, S.A.</author>
        </member>
        <member name="F:ZXing.Client.Result.ExpandedProductParsedResult.KILOGRAM">
            <summary>
            extension for kilogram weight type
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ExpandedProductParsedResult.POUND">
            <summary>
            extension for pounds weight type
            </summary>
        </member>
        <member name="M:ZXing.Client.Result.ExpandedProductParsedResult.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            initializing constructor
            </summary>
            <param name="rawText"></param>
            <param name="productID"></param>
            <param name="sscc"></param>
            <param name="lotNumber"></param>
            <param name="productionDate"></param>
            <param name="packagingDate"></param>
            <param name="bestBeforeDate"></param>
            <param name="expirationDate"></param>
            <param name="weight"></param>
            <param name="weightType"></param>
            <param name="weightIncrement"></param>
            <param name="price"></param>
            <param name="priceIncrement"></param>
            <param name="priceCurrency"></param>
            <param name="uncommonAIs"></param>
        </member>
        <member name="M:ZXing.Client.Result.ExpandedProductParsedResult.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ExpandedProductParsedResult.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.RawText">
            <summary>
            the raw text
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.ProductID">
            <summary>
            the product id
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.Sscc">
            <summary>
            the sscc
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.LotNumber">
            <summary>
            the lot number
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.ProductionDate">
            <summary>
            the production date
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.PackagingDate">
            <summary>
            the packaging date
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.BestBeforeDate">
            <summary>
            the best before date
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.ExpirationDate">
            <summary>
            the expiration date
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.Weight">
            <summary>
            the weight
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.WeightType">
            <summary>
            the weight type
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.WeightIncrement">
            <summary>
            the weight increment
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.Price">
            <summary>
            the price
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.PriceIncrement">
            <summary>
            the price increment
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.PriceCurrency">
            <summary>
            the price currency
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.UncommonAIs">
            <summary>
            the uncommon AIs
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ExpandedProductParsedResult.DisplayResult">
            <summary>
            the display representation (raw text)
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.ExpandedProductResultParser">
            <summary>
            Parses strings of digits that represent a RSS Extended code.
            </summary>
            <author>Antonio Manuel Benjumea Conde, Servinform, S.A.</author>
            <author>Agustín Delgado, Servinform, S.A.</author>
        </member>
        <member name="M:ZXing.Client.Result.ExpandedProductResultParser.parse(ZXing.Result)">
            <summary>
            tries to parse a text representation to a specific result object
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Client.Result.GeoParsedResult">
            <summary>
            Represents a parsed result that encodes a geographic coordinate, with latitude, longitude and altitude.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.Client.Result.GeoParsedResult.Latitude">
            <returns> latitude in degrees
            </returns>
        </member>
        <member name="P:ZXing.Client.Result.GeoParsedResult.Longitude">
            <returns> longitude in degrees
            </returns>
        </member>
        <member name="P:ZXing.Client.Result.GeoParsedResult.Altitude">
            <returns> altitude in meters. If not specified, in the geo URI, returns 0.0
            </returns>
        </member>
        <member name="P:ZXing.Client.Result.GeoParsedResult.Query">
            <return> query string associated with geo URI or null if none exists</return>
        </member>
        <member name="P:ZXing.Client.Result.GeoParsedResult.GeoURI">
            <summary>
            the geo URI
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.GeoParsedResult.GoogleMapsURI">
            <returns> a URI link to Google Maps which display the point on the Earth described
            by this instance, and sets the zoom level in a way that roughly reflects the
            altitude, if specified
            </returns>
        </member>
        <member name="T:ZXing.Client.Result.GeoResultParser">
            <summary> Parses a "geo:" URI result, which specifies a location on the surface of
            the Earth as well as an optional altitude above the surface. See
            <a href="http://tools.ietf.org/html/draft-mayrhofer-geo-uri-00">
            http://tools.ietf.org/html/draft-mayrhofer-geo-uri-00</a>.
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.ISBNParsedResult">
            <summary>
            Represents a parsed result that encodes a product ISBN number.
            </summary>
            <author>jbreiden@google.com (Jeff Breidenbach)</author>
        </member>
        <member name="P:ZXing.Client.Result.ISBNParsedResult.ISBN">
            <summary>
            the ISBN number
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.ISBNResultParser">
            <summary> Parses strings of digits that represent a ISBN.
            
            </summary>
            <author>  jbreiden@google.com (Jeff Breidenbach)
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="M:ZXing.Client.Result.ISBNResultParser.parse(ZXing.Result)">
            <summary>
            See <a href="http://www.bisg.org/isbn-13/for.dummies.html">ISBN-13 For Dummies</a>
            </summary>
            <param name="result">The result.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Client.Result.ParsedResult">
            <summary> <p>Abstract class representing the result of decoding a barcode, as more than
            a String -- as some type of structured data. This might be a subclass which represents
            a URL, or an e-mail address. {@link ResultParser#parseResult(Result)} will turn a raw
            decoded string into the most appropriate type of structured representation.</p>
            
            <p>Thanks to Jeff Griffin for proposing rewrite of these classes that relies less
            on exception-based mechanisms during parsing.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResult.displayResultValue">
            <summary>
            user friendly value
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ParsedResult.Type">
            <summary>
            gets the type of the parsed result
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ParsedResult.DisplayResult">
            <summary>
            user friendly value
            </summary>
        </member>
        <member name="M:ZXing.Client.Result.ParsedResult.#ctor(ZXing.Client.Result.ParsedResultType)">
            <summary>
            constructor
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:ZXing.Client.Result.ParsedResult.ToString">
            <summary>
            gets a user friendly value
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ParsedResult.Equals(System.Object)">
            <summary>
            compare two objects
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ParsedResult.GetHashCode">
            <summary>
            gets the hashcode
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ParsedResult.maybeAppend(System.String,System.Text.StringBuilder)">
            <summary>
            append to result if not null or empty
            </summary>
            <param name="value"></param>
            <param name="result"></param>
        </member>
        <member name="M:ZXing.Client.Result.ParsedResult.maybeAppend(System.String[],System.Text.StringBuilder)">
            <summary>
            append to result if not null or empty
            </summary>
            <param name="values"></param>
            <param name="result"></param>
        </member>
        <member name="T:ZXing.Client.Result.ParsedResultType">
            <summary>
            Represents the type of data encoded by a barcode -- from plain text, to a
            URI, to an e-mail address, etc.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.ADDRESSBOOK">
            <summary>
            address book
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.EMAIL_ADDRESS">
            <summary>
            email address
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.PRODUCT">
            <summary>
            product
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.URI">
            <summary>
            URI
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.TEXT">
            <summary>
            Text
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.GEO">
            <summary>
            geo coordinates
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.TEL">
            <summary>
            telefon
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.SMS">
            <summary>
            sms
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.CALENDAR">
            <summary>
            calendar
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.WIFI">
            <summary>
            wifi
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.ISBN">
            <summary>
            ISBN
            </summary>
        </member>
        <member name="F:ZXing.Client.Result.ParsedResultType.VIN">
            <summary>
            VIN
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.ProductParsedResult">
            <summary>
            Represents a parsed result that encodes a product by an identifier of some kind.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="P:ZXing.Client.Result.ProductParsedResult.ProductID">
            <summary>
            product id
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.ProductParsedResult.NormalizedProductID">
            <summary>
            normalized product id
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.ProductResultParser">
            <summary>
            Parses strings of digits that represent a UPC code.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="T:ZXing.Client.Result.ResultParser">
            <summary> <p>Abstract class representing the result of decoding a barcode, as more than
            a String -- as some type of structured data. This might be a subclass which represents
            a URL, or an e-mail address. {@link #parseResult(com.google.zxing.Result)} will turn a raw
            decoded string into the most appropriate type of structured representation.</p>
            
            <p>Thanks to Jeff Griffin for proposing rewrite of these classes that relies less
            on exception-based mechanisms during parsing.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.parse(ZXing.Result)">
            <summary>
            Attempts to parse the raw {@link Result}'s contents as a particular type
            of information (email, URL, etc.) and return a {@link ParsedResult} encapsulating
            the result of parsing.
            </summary>
            <param name="theResult">the raw <see cref="N:ZXing.Client.Result"/> to parse</param>
            <returns><see cref="T:ZXing.Client.Result.ParsedResult" /> encapsulating the parsing result</returns>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.parseResult(ZXing.Result)">
            <summary>
            Parses the result.
            </summary>
            <param name="theResult">The result.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.maybeAppend(System.String,System.Text.StringBuilder)">
            <summary>
            append value to result, if not null
            </summary>
            <param name="value"></param>
            <param name="result"></param>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.maybeAppend(System.String[],System.Text.StringBuilder)">
            <summary>
            append value to result, if not null
            </summary>
            <param name="value"></param>
            <param name="result"></param>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.maybeWrap(System.String)">
            <summary>
            wrap, if not null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.unescapeBackslash(System.String)">
            <summary>
            unescape backslash
            </summary>
            <param name="escaped"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.parseHexDigit(System.Char)">
            <summary>
            parse hex digit
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Client.Result.ResultParser.urlDecode(System.String)">
            <summary>
            decodes url
            </summary>
            <param name="escaped"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Client.Result.SMSMMSResultParser">
            <summary> <p>Parses an "sms:" URI result, which specifies a number to SMS and optional
            "via" number. See <a href="http://gbiv.com/protocols/uri/drafts/draft-antti-gsm-sms-url-04.txt">
            the IETF draft</a> on this.</p>
            
            <p>This actually also parses URIs starting with "mms:", "smsto:", "mmsto:", "SMSTO:", and
            "MMSTO:", and treats them all the same way, and effectively converts them to an "sms:" URI
            for purposes of forwarding to the platform.</p>
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.SMSParsedResult">
            <summary>
            Represents a parsed result that encodes an SMS message, including recipients, subject and body text.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.SMSParsedResult.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="number"></param>
            <param name="via"></param>
            <param name="subject"></param>
            <param name="body"></param>
        </member>
        <member name="M:ZXing.Client.Result.SMSParsedResult.#ctor(System.String[],System.String[],System.String,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="numbers"></param>
            <param name="vias"></param>
            <param name="subject"></param>
            <param name="body"></param>
        </member>
        <member name="P:ZXing.Client.Result.SMSParsedResult.Numbers">
            <summary>
            numbers
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.SMSParsedResult.Vias">
            <summary>
             vias
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.SMSParsedResult.Subject">
            <summary>
            subject
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.SMSParsedResult.Body">
            <summary>
            body
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.SMSParsedResult.SMSURI">
            <summary>
            sms uri
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.SMSTOMMSTOResultParser">
            <summary>
            <p>Parses an "smsto:" URI result, whose format is not standardized but appears to be like:
            {@code smsto:number(:body)}.</p>
            <p>This actually also parses URIs starting with "smsto:", "mmsto:", "SMSTO:", and
            "MMSTO:", and treats them all the same way, and effectively converts them to an "sms:" URI
            for purposes of forwarding to the platform.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.SMSTOMMSTOResultParser.parse(ZXing.Result)">
            <summary>
            attempt to parse the raw result to the specific type
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Client.Result.SMTPResultParser">
            <summary>
            <p>Parses an "smtp:" URI result, whose format is not standardized but appears to be like:
            <code>smtp[:subject[:body]]}</code>.</p>
            <p>See http://code.google.com/p/zxing/issues/detail?id=536</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.SMTPResultParser.parse(ZXing.Result)">
            <summary>
            attempt to parse the raw result to the specific type
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Client.Result.TelParsedResult">
            <summary>
            Represents a parsed result that encodes a telephone number.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.TelParsedResult.#ctor(System.String,System.String,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="number"></param>
            <param name="telURI"></param>
            <param name="title"></param>
        </member>
        <member name="P:ZXing.Client.Result.TelParsedResult.Number">
            <summary>
            number
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.TelParsedResult.TelURI">
            <summary>
            URI
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.TelParsedResult.Title">
            <summary>
            title
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.TelResultParser">
            <summary>
            Parses a "tel:" URI result, which specifies a phone number.
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.TextParsedResult">
            <summary>
            A simple result type encapsulating a string that has no further interpretation.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.TextParsedResult.#ctor(System.String,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="text"></param>
            <param name="language"></param>
        </member>
        <member name="P:ZXing.Client.Result.TextParsedResult.Text">
            <summary>
            text
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.TextParsedResult.Language">
            <summary>
            language
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.URIParsedResult">
            <summary>
            A simple result type encapsulating a URI that has no further interpretation.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.Client.Result.URIParsedResult.URI">
            <summary>
            URI
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.URIParsedResult.Title">
            <summary>
            title
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.URIParsedResult.PossiblyMaliciousURI">
            <returns> true if the URI contains suspicious patterns that may suggest it intends to
            mislead the user about its true nature. At the moment this looks for the presence
            of user/password syntax in the host/authority portion of a URI which may be used
            in attempts to make the URI's host appear to be other than it is. Example:
            http://yourbank.com@phisher.com  This URI connects to phisher.com but may appear
            to connect to yourbank.com at first glance.
            </returns>
        </member>
        <member name="M:ZXing.Client.Result.URIParsedResult.#ctor(System.String,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="uri"></param>
            <param name="title"></param>
        </member>
        <member name="M:ZXing.Client.Result.URIParsedResult.massageURI(System.String)">
            <summary> Transforms a string that represents a URI into something more proper, by adding or canonicalizing
            the protocol.
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.URIResultParser">
            <summary>
            Tries to parse results that are a URI of some kind.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.URIResultParser.isPossiblyMaliciousURI(System.String)">
            @return true if the URI contains suspicious patterns that may suggest it intends to
             mislead the user about its true nature. At the moment this looks for the presence
             of user/password syntax in the host/authority portion of a URI which may be used
             in attempts to make the URI's host appear to be other than it is. Example:
             http://yourbank.com@phisher.com  This URI connects to phisher.com but may appear
             to connect to yourbank.com at first glance.
        </member>
        <member name="T:ZXing.Client.Result.URLTOResultParser">
            <summary> Parses the "URLTO" result format, which is of the form "URLTO:[title]:[url]".
            This seems to be used sometimes, but I am not able to find documentation
            on its origin or official format?
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.VCardResultParser">
            <summary>
            Parses contact information formatted according to the VCard (2.1) format. This is not a complete
            implementation but should parse information as commonly encoded in 2D barcodes.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Client.Result.VCardResultParser.formatNames(System.Collections.Generic.IEnumerable{System.Collections.Generic.List{System.String}})">
             Formats name fields of the form "Public;John;Q.;Reverend;III" into a form like
             "Reverend John Q. Public III".
            
             @param names name values to format, in place
        </member>
        <member name="T:ZXing.Client.Result.VEventResultParser">
            <summary>
            Partially implements the iCalendar format's "VEVENT" format for specifying a
            calendar event. See RFC 2445. This supports SUMMARY, DTSTART and DTEND fields.
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="T:ZXing.Client.Result.VINParsedResult">
            <summary>
            Represents a parsed result that encodes a Vehicle Identification Number (VIN).
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.VIN">
            <summary>
            VIN
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.WorldManufacturerID">
            <summary>
            manufacturer id
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.VehicleDescriptorSection">
            <summary>
            vehicle descriptor section
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.VehicleIdentifierSection">
            <summary>
            vehicle identifier section
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.CountryCode">
            <summary>
            country code
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.VehicleAttributes">
            <summary>
            vehicle attributes
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.ModelYear">
            <summary>
            model year
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.PlantCode">
            <summary>
            plant code
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.SequentialNumber">
            <summary>
            sequential number
            </summary>
        </member>
        <member name="M:ZXing.Client.Result.VINParsedResult.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Char,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="vin"></param>
            <param name="worldManufacturerID"></param>
            <param name="vehicleDescriptorSection"></param>
            <param name="vehicleIdentifierSection"></param>
            <param name="countryCode"></param>
            <param name="vehicleAttributes"></param>
            <param name="modelYear"></param>
            <param name="plantCode"></param>
            <param name="sequentialNumber"></param>
        </member>
        <member name="P:ZXing.Client.Result.VINParsedResult.DisplayResult">
            <summary>
            a user friendly representation
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.VINResultParser">
            <summary>
            Detects a result that is likely a vehicle identification number.
            @author Sean Owen
            </summary>
        </member>
        <member name="M:ZXing.Client.Result.VINResultParser.parse(ZXing.Result)">
            <summary>
            attempt to parse the raw result to the specific type
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Client.Result.WifiParsedResult">
            <summary>
            Represents a parsed result that encodes wifi network information, like SSID and password.
            </summary>
            <author>Vikram Aggarwal</author>
        </member>
        <member name="M:ZXing.Client.Result.WifiParsedResult.#ctor(System.String,System.String,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="networkEncryption"></param>
            <param name="ssid"></param>
            <param name="password"></param>
        </member>
        <member name="M:ZXing.Client.Result.WifiParsedResult.#ctor(System.String,System.String,System.String,System.Boolean)">
            <summary>
            initializing constructor
            </summary>
            <param name="networkEncryption"></param>
            <param name="ssid"></param>
            <param name="password"></param>
            <param name="hidden"></param>
        </member>
        <member name="M:ZXing.Client.Result.WifiParsedResult.#ctor(System.String,System.String,System.String,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="networkEncryption"></param>
            <param name="ssid"></param>
            <param name="password"></param>
            <param name="hidden"></param>
            <param name="identity"></param>
            <param name="anonymousIdentity"></param>
            <param name="eapMethod"></param>
            <param name="phase2Method"></param>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.Ssid">
            <summary>
            SSID
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.NetworkEncryption">
            <summary>
            network encryption
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.Password">
            <summary>
            password
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.Hidden">
            <summary>
            hidden flag
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.Identity">
            <summary>
            identity
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.AnonymousIdentity">
            <summary>
            anonymous
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.EapMethod">
            <summary>
            eap
            </summary>
        </member>
        <member name="P:ZXing.Client.Result.WifiParsedResult.Phase2Method">
            <summary>
            phase 2 method
            </summary>
        </member>
        <member name="T:ZXing.Client.Result.WifiResultParser">
            <summary>
            <p>Parses a WIFI configuration string. Strings will be of the form:</p>
            <p>{@code WIFI:T:[network type];S:[network SSID];P:[network password];H:[hidden?];;}</p>
            <p>The fields can appear in any order. Only "S:" is required.</p>
            <p>For WPA2 enterprise(EAP), strings will be of the form:</p>
            <p>{@code WIFI:T:WPA2-EAP;S:[network SSID];H:[hidden?];E:[EAP method];PH2:[Phase 2 method];A:[anonymous identity];I:[username];P:[password];;}</p>
            <p>"EAP method" can e.g.be "TTLS" or "PWD" or one of the other fields in <a href = "https://developer.android.com/reference/android/net/wifi/WifiEnterpriseConfig.Eap.html"> WifiEnterpriseConfig.Eap </a> and "Phase 2 method" can e.g.be "MSCHAPV2" or any of the other fields in <a href = "https://developer.android.com/reference/android/net/wifi/WifiEnterpriseConfig.Phase2.html"> WifiEnterpriseConfig.Phase2 </a></p>
            </summary>
            <author>Vikram Aggarwal</author>
            <author>Sean Owen</author>
            <author>Steffen Kieß</author>
        </member>
        <member name="M:ZXing.Client.Result.WifiResultParser.parse(ZXing.Result)">
            <summary>
            attempt to parse the raw result to the specific type
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.BitArray">
            <summary>
            A simple, fast array of bits, represented compactly by an array of ints internally.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.Common.BitArray.Size">
            <summary>
            size of the array, number of elements
            </summary>
        </member>
        <member name="P:ZXing.Common.BitArray.SizeInBytes">
            <summary>
            size of the array in bytes
            </summary>
        </member>
        <member name="P:ZXing.Common.BitArray.Item(System.Int32)">
            <summary>
            index accessor
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.BitArray.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:ZXing.Common.BitArray.#ctor(System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="size">desired size of the array</param>
        </member>
        <member name="M:ZXing.Common.BitArray.flip(System.Int32)">
            <summary>
            Flips bit i.
            </summary>
            <param name="i">bit to set
            </param>
        </member>
        <member name="M:ZXing.Common.BitArray.getNextSet(System.Int32)">
            <summary>
            Gets the next set.
            </summary>
            <param name="from">first bit to check</param>
            <returns>index of first bit that is set, starting from the given index, or size if none are set
            at or beyond this given index</returns>
        </member>
        <member name="M:ZXing.Common.BitArray.getNextUnset(System.Int32)">
            <summary>
            see getNextSet(int)
            </summary>
            <param name="from">index to start looking for unset bit</param>
            <returns>index of next unset bit, or <see cref="P:ZXing.Common.BitArray.Size"/> if none are unset until the end</returns>
        </member>
        <member name="M:ZXing.Common.BitArray.setBulk(System.Int32,System.Int32)">
            <summary> Sets a block of 32 bits, starting at bit i.
            
            </summary>
            <param name="i">first bit to set
            </param>
            <param name="newBits">the new value of the next 32 bits. Note again that the least-significant bit
            corresponds to bit i, the next-least-significant to i+1, and so on.
            </param>
        </member>
        <member name="M:ZXing.Common.BitArray.setRange(System.Int32,System.Int32)">
            <summary>
            Sets a range of bits.
            </summary>
            <param name="start">start of range, inclusive.</param>
            <param name="end">end of range, exclusive</param>
        </member>
        <member name="M:ZXing.Common.BitArray.clear">
            <summary> Clears all bits (sets to false).</summary>
        </member>
        <member name="M:ZXing.Common.BitArray.isRange(System.Int32,System.Int32,System.Boolean)">
            <summary> Efficient method to check if a range of bits is set, or not set.
            
            </summary>
            <param name="start">start of range, inclusive.
            </param>
            <param name="end">end of range, exclusive
            </param>
            <param name="value">if true, checks that bits in range are set, otherwise checks that they are not set
            </param>
            <returns> true iff all bits are set or not set in range, according to value argument</returns>
            <throws><exception cref="T:System.ArgumentException" /> if end is less than start or the range is not contained in the array</throws>
        </member>
        <member name="M:ZXing.Common.BitArray.appendBit(System.Boolean)">
            <summary>
            Appends the bit.
            </summary>
            <param name="bit">The bit.</param>
        </member>
        <member name="P:ZXing.Common.BitArray.Array">
            <returns> underlying array of ints. The first element holds the first 32 bits, and the least
            significant bit is bit 0.
            </returns>
        </member>
        <member name="M:ZXing.Common.BitArray.appendBits(System.Int32,System.Int32)">
            <summary>
            Appends the least-significant bits, from value, in order from most-significant to
            least-significant. For example, appending 6 bits from 0x000001E will append the bits
            0, 1, 1, 1, 1, 0 in that order.
            </summary>
            <param name="value"><see cref="T:System.Int32"/> containing bits to append</param>
            <param name="numBits">bits from value to append</param>
        </member>
        <member name="M:ZXing.Common.BitArray.appendBitArray(ZXing.Common.BitArray)">
            <summary>
            adds the array to the end
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:ZXing.Common.BitArray.xor(ZXing.Common.BitArray)">
            <summary>
            XOR operation
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:ZXing.Common.BitArray.toBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            converts to bytes.
            </summary>
            <param name="bitOffset">first bit to start writing</param>
            <param name="array">array to write into. Bytes are written most-significant byte first. This is the opposite
            of the internal representation, which is exposed by BitArray</param>
            <param name="offset">position in array to start writing</param>
            <param name="numBytes">how many bytes to write</param>
        </member>
        <member name="M:ZXing.Common.BitArray.reverse">
            <summary> Reverses all bits in the array.</summary>
        </member>
        <member name="M:ZXing.Common.BitArray.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="o">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ZXing.Common.BitArray.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:ZXing.Common.BitArray.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.Common.BitArray.Clone">
            <summary>
            Erstellt ein neues Objekt, das eine Kopie der aktuellen Instanz darstellt.
            </summary>
            <returns>
            Ein neues Objekt, das eine Kopie dieser Instanz darstellt.
            </returns>
        </member>
        <member name="T:ZXing.Common.BitMatrix">
            <summary>
              <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common
            module, x is the column position, and y is the row position. The ordering is always x, y.
            The origin is at the top-left.</p>
              <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins
            with a new int. This is done intentionally so that we can copy out a row into a <see cref="T:ZXing.Common.BitArray"/> very
            efficiently.</p>
              <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,
            meaning they represent lower x values. This is compatible with <see cref="T:ZXing.Common.BitArray"/>'s implementation.</p>
            </summary>
            <author>Sean Owen</author>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="P:ZXing.Common.BitMatrix.Width">
            <returns> The width of the matrix
            </returns>
        </member>
        <member name="P:ZXing.Common.BitMatrix.Height">
            <returns> The height of the matrix
            </returns>
        </member>
        <member name="P:ZXing.Common.BitMatrix.Dimension">
            <summary> This method is for compatibility with older code. It's only logical to call if the matrix
            is square, so I'm throwing if that's not the case.
            
            </summary>
            <returns> row/column dimension of this matrix
            </returns>
        </member>
        <member name="P:ZXing.Common.BitMatrix.RowSize">
            <returns>
            The rowsize of the matrix
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.#ctor(System.Int32)">
            <summary>
            Creates an empty square <see cref="T:ZXing.Common.BitMatrix"/>.
            </summary>
            <param name="dimension">height and width</param>
        </member>
        <member name="M:ZXing.Common.BitMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates an empty square <see cref="T:ZXing.Common.BitMatrix"/>.
            </summary>
            <param name="width">bit matrix width</param>
            <param name="height">bit matrix height</param>
        </member>
        <member name="M:ZXing.Common.BitMatrix.parse(System.Boolean[][])">
            <summary>
            Interprets a 2D array of booleans as a <see cref="T:ZXing.Common.BitMatrix"/>, where "true" means an "on" bit.
            </summary>
            <param name="image">bits of the image, as a row-major 2D array. Elements are arrays representing rows</param>
            <returns><see cref="T:ZXing.Common.BitMatrix"/> representation of image</returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.parse(System.String,System.String,System.String)">
            <summary>
            parse the string representation to a bitmatrix
            </summary>
            <param name="stringRepresentation"></param>
            <param name="setString"></param>
            <param name="unsetString"></param>
            <returns></returns>
        </member>
        <member name="P:ZXing.Common.BitMatrix.Item(System.Int32,System.Int32)">
            <summary> <p>Gets the requested bit, where true means black.</p>
            
            </summary>
            <param name="x">The horizontal component (i.e. which column)
            </param>
            <param name="y">The vertical component (i.e. which row)
            </param>
            <returns> value of given bit in matrix
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.flip(System.Int32,System.Int32)">
            <summary>
            <p>Flips the given bit.</p>
            </summary>
            <param name="x">The horizontal component (i.e. which column)</param>
            <param name="y">The vertical component (i.e. which row)</param>
        </member>
        <member name="M:ZXing.Common.BitMatrix.flip">
            <summary>
            <p>Flips every bit in the matrix.</p>
            </summary>
        </member>
        <member name="M:ZXing.Common.BitMatrix.flipWhen(System.Func{System.Int32,System.Int32,System.Boolean})">
            <summary>
            flip all of the bits, if shouldBeFlipped is true for the coordinates
            </summary>
            <param name="shouldBeFlipped">should return true, if the bit at a given coordinate should be flipped</param>
        </member>
        <member name="M:ZXing.Common.BitMatrix.xor(ZXing.Common.BitMatrix)">
            <summary>
            Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding
            mask bit is set.
            </summary>
            <param name="mask">The mask.</param>
        </member>
        <member name="M:ZXing.Common.BitMatrix.clear">
            <summary> Clears all bits (sets to false).</summary>
        </member>
        <member name="M:ZXing.Common.BitMatrix.setRegion(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> <p>Sets a square region of the bit matrix to true.</p>
            
            </summary>
            <param name="left">The horizontal position to begin at (inclusive)
            </param>
            <param name="top">The vertical position to begin at (inclusive)
            </param>
            <param name="width">The width of the region
            </param>
            <param name="height">The height of the region
            </param>
        </member>
        <member name="M:ZXing.Common.BitMatrix.getRow(System.Int32,ZXing.Common.BitArray)">
            <summary> A fast method to retrieve one row of data from the matrix as a BitArray.
            
            </summary>
            <param name="y">The row to retrieve
            </param>
            <param name="row">An optional caller-allocated BitArray, will be allocated if null or too small
            </param>
            <returns> The resulting BitArray - this reference should always be used even when passing
            your own row
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.setRow(System.Int32,ZXing.Common.BitArray)">
            <summary>
            Sets the row.
            </summary>
            <param name="y">row to set</param>
            <param name="row">{@link BitArray} to copy from</param>
        </member>
        <member name="M:ZXing.Common.BitMatrix.rotate(System.Int32)">
            <summary>
            Modifies this {@code BitMatrix} to represent the same but rotated the given degrees(0, 90, 180, 270)
            </summary>
            <param name="degrees">number of degrees to rotate through counter-clockwise(0, 90, 180, 270)</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:ZXing.Common.BitMatrix.rotate180">
            <summary>
            Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees
            </summary>
        </member>
        <member name="M:ZXing.Common.BitMatrix.rotate90">
            <summary>
            Modifies this {@code BitMatrix} to represent the same but rotated 90 degrees counterclockwise
            </summary>
        </member>
        <member name="M:ZXing.Common.BitMatrix.getEnclosingRectangle">
            <summary>
            This is useful in detecting the enclosing rectangle of a 'pure' barcode.
            </summary>
            <returns>{left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white</returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.getTopLeftOnBit">
            <summary>
            This is useful in detecting a corner of a 'pure' barcode.
            </summary>
            <returns>{x,y} coordinate of top-left-most 1 bit, or null if it is all white</returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.getBottomRightOnBit">
            <summary>
            bottom right
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.ToString(System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="setString">The set string.</param>
            <param name="unsetString">The unset string.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <param name="setString">The set string.</param>
            <param name="unsetString">The unset string.</param>
            <param name="lineSeparator">The line separator.</param>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.Common.BitMatrix.Clone">
            <summary>
            Clones this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.BitSource">
            <summary> <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the
            number of bits read is not often a multiple of 8.</p>
            
            <p>This class is thread-safe but not reentrant. Unless the caller modifies the bytes array
            it passed in, in which case all bets are off.</p>
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="M:ZXing.Common.BitSource.#ctor(System.Byte[])">
            <param name="bytes">bytes from which this will read bits. Bits will be read from the first byte first.
            Bits are read within a byte from most-significant to least-significant bit.
            </param>
        </member>
        <member name="P:ZXing.Common.BitSource.BitOffset">
            <summary>
            index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.
            </summary>
        </member>
        <member name="P:ZXing.Common.BitSource.ByteOffset">
            <summary>
            index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.
            </summary>
        </member>
        <member name="M:ZXing.Common.BitSource.readBits(System.Int32)">
            <param name="numBits">number of bits to read
            </param>
            <returns> int representing the bits read. The bits will appear as the least-significant
            bits of the int
            </returns>
            <exception cref="T:System.ArgumentException">if numBits isn't in [1,32] or more than is available</exception>
        </member>
        <member name="M:ZXing.Common.BitSource.available">
            <returns> number of bits that can be read successfully
            </returns>
        </member>
        <member name="T:ZXing.Common.CharacterSetECI">
            <summary> Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1
            of ISO 18004.
            
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.Common.CharacterSetECI.EncodingName">
            <summary>
            encoding name
            </summary>
        </member>
        <member name="M:ZXing.Common.CharacterSetECI.getCharacterSetECIByValue(System.Int32)">
            <param name="value">character set ECI value</param>
            <returns><see cref="T:ZXing.Common.CharacterSetECI"/> representing ECI of given value, or null if it is legal but unsupported</returns>
        </member>
        <member name="M:ZXing.Common.CharacterSetECI.getCharacterSetECIByName(System.String)">
            <param name="name">character set ECI encoding name</param>
            <returns><see cref="T:ZXing.Common.CharacterSetECI"/> representing ECI for character encoding, or null if it is legal but unsupported</returns>
        </member>
        <member name="M:ZXing.Common.CharacterSetECI.getCharacterSetECI(System.Text.Encoding)">
            <summary>
            </summary>
            <param name="encoding">encoding</param>
            <returns>CharacterSetECI representing ECI for character encoding, or null if it is legal but unsupported</returns>
        </member>
        <member name="M:ZXing.Common.CharacterSetECI.getEncoding(ZXing.Common.CharacterSetECI)">
            <summary>
            returns the encoding object fo the specified charset
            </summary>
            <param name="charsetECI"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.CharacterSetECI.getEncoding(System.String)">
            <summary>
            returns the encoding object fo the specified name
            </summary>
            <param name="encodingName"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.DecoderResult">
            <summary>
            Encapsulates the result of decoding a matrix of bits. This typically
            applies to 2D barcode formats. For now it contains the raw bytes obtained,
            as well as a String interpretation of those bytes, if applicable.
            <author>Sean Owen</author>
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.RawBytes">
            <summary>
            raw bytes representing the result, or null if not applicable
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.NumBits">
            <summary>
            how many bits of<see cref="P:ZXing.Common.DecoderResult.RawBytes"/> are valid; typically 8 times its length
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.Text">
            <summary>
            text representation of the result
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.ByteSegments">
            <summary>
            list of byte segments in the result, or null if not applicable
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.ECLevel">
            <summary>
            name of error correction level used, or null if not applicable
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.StructuredAppend">
            <summary>
            gets a value which describe if structure append data was found
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.ErrorsCorrected">
            <summary>
            number of errors corrected, or null if not applicable
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.StructuredAppendSequenceNumber">
            <summary>
            gives the sequence number of the result if structured append was found
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.Erasures">
            <summary>
            number of erasures corrected, or null if not applicable
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.StructuredAppendParity">
            <summary>
            gives the parity information if structured append was found
            </summary>
        </member>
        <member name="P:ZXing.Common.DecoderResult.Other">
            <summary>
            Miscellanseous data value for the various decoders
            </summary>
            <value>The other.</value>
        </member>
        <member name="P:ZXing.Common.DecoderResult.SymbologyModifier">
            <summary>
            gives the symbology identifier
            </summary>
        </member>
        <member name="M:ZXing.Common.DecoderResult.#ctor(System.Byte[],System.String,System.Collections.Generic.List{System.Byte[]},System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="rawBytes"></param>
            <param name="text"></param>
            <param name="byteSegments"></param>
            <param name="ecLevel"></param>
        </member>
        <member name="M:ZXing.Common.DecoderResult.#ctor(System.Byte[],System.String,System.Collections.Generic.IList{System.Byte[]},System.String,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="rawBytes"></param>
            <param name="text"></param>
            <param name="byteSegments"></param>
            <param name="ecLevel"></param>
            <param name="symbologyModifier"></param>
        </member>
        <member name="M:ZXing.Common.DecoderResult.#ctor(System.Byte[],System.String,System.Collections.Generic.List{System.Byte[]},System.String,System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="rawBytes"></param>
            <param name="text"></param>
            <param name="byteSegments"></param>
            <param name="ecLevel"></param>
            <param name="saSequence"></param>
            <param name="saParity"></param>
        </member>
        <member name="M:ZXing.Common.DecoderResult.#ctor(System.Byte[],System.String,System.Collections.Generic.IList{System.Byte[]},System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="rawBytes"></param>
            <param name="text"></param>
            <param name="byteSegments"></param>
            <param name="ecLevel"></param>
            <param name="saSequence"></param>
            <param name="saParity"></param>
            <param name="symbologyModifier"></param>
        </member>
        <member name="M:ZXing.Common.DecoderResult.#ctor(System.Byte[],System.Int32,System.String,System.Collections.Generic.IList{System.Byte[]},System.String)">
            <summary>
            initializing constructor
            </summary>
            <param name="rawBytes"></param>
            <param name="numBits"></param>
            <param name="text"></param>
            <param name="byteSegments"></param>
            <param name="ecLevel"></param>
        </member>
        <member name="M:ZXing.Common.DecoderResult.#ctor(System.Byte[],System.Int32,System.String,System.Collections.Generic.IList{System.Byte[]},System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="rawBytes"></param>
            <param name="numBits"></param>
            <param name="text"></param>
            <param name="byteSegments"></param>
            <param name="ecLevel"></param>
            <param name="saSequence"></param>
            <param name="saParity"></param>
            <param name="symbologyModifier"></param>
        </member>
        <member name="T:ZXing.Common.DecodingOptions">
            <summary>
            Defines an container for encoder options
            </summary>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.Hints">
            <summary>
            Gets the data container for all options
            </summary>
        </member>
        <member name="E:ZXing.Common.DecodingOptions.ValueChanged">
            <summary>
            event is raised when a value is changed
            </summary>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.TryHarder">
            <summary>
            Gets or sets a flag which cause a deeper look into the bitmap
            </summary>
            <value>
              <c>true</c> if [try harder]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.TryInverted">
            <summary>
            Gets or sets a value indicating whether the image should be automatically inverted
            if no result is found in the original image.
            ATTENTION: Please be carefully because it slows down the decoding process if it is used
            </summary>
            <value>
              <c>true</c> if image should be inverted; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.PureBarcode">
            <summary>
            Image is a pure monochrome image of a barcode.
            </summary>
            <value>
              <c>true</c> if monochrome image of a barcode; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.CharacterSet">
            <summary>
            Specifies what character encoding to use when decoding, where applicable (type String)
            </summary>
            <value>
            The character set.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.PossibleFormats">
            <summary>
            Image is known to be of one of a few possible formats.
            Maps to a {@link java.util.List} of {@link BarcodeFormat}s.
            </summary>
            <value>
            The possible formats.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.UseCode39ExtendedMode">
            <summary>
            if Code39 could be detected try to use extended mode for full ASCII character set
            </summary>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.UseCode39RelaxedExtendedMode">
            <summary>
            Don't fail if a Code39 is detected but can't be decoded in extended mode.
            Return the raw Code39 result instead. Maps to <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.AssumeCode39CheckDigit">
            <summary>
            Assume Code 39 codes employ a check digit. Maps to <see cref="T:System.Boolean" />.
            </summary>
            <value>
              <c>true</c> if it should assume a Code 39 check digit; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.ReturnCodabarStartEnd">
            <summary>
            If true, return the start and end digits in a Codabar barcode instead of stripping them. They
            are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them
            to not be. Doesn't matter what it maps to; use <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.AssumeGS1">
            <summary>
            Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.
            For example this affects FNC1 handling for Code 128 (aka GS1-128).
            </summary>
            <value>
              <c>true</c> if it should assume GS1; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.AssumeMSICheckDigit">
            <summary>
            Assume MSI codes employ a check digit. Maps to <see cref="T:System.Boolean" />.
            </summary>
            <value>
              <c>true</c> if it should assume a MSI check digit; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.AllowedLengths">
            <summary>
            Allowed lengths of encoded data -- reject anything else. Maps to an int[].
            </summary>
        </member>
        <member name="P:ZXing.Common.DecodingOptions.AllowedEANExtensions">
            <summary>
            Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.
            Maps to an int[] of the allowed extension lengths, for example [2], [5], or [2, 5].
            If it is optional to have an extension, do not set this hint. If this is set,
            and a UPC or EAN barcode is found but an extension is not, then no result will be returned
            at all.
            </summary>
        </member>
        <member name="M:ZXing.Common.DecodingOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Common.DecodingOptions"/> class.
            </summary>
        </member>
        <member name="T:ZXing.Common.DefaultGridSampler">
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="M:ZXing.Common.DefaultGridSampler.sampleGrid(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            </summary>
            <param name="image"></param>
            <param name="dimensionX"></param>
            <param name="dimensionY"></param>
            <param name="p1ToX"></param>
            <param name="p1ToY"></param>
            <param name="p2ToX"></param>
            <param name="p2ToY"></param>
            <param name="p3ToX"></param>
            <param name="p3ToY"></param>
            <param name="p4ToX"></param>
            <param name="p4ToY"></param>
            <param name="p1FromX"></param>
            <param name="p1FromY"></param>
            <param name="p2FromX"></param>
            <param name="p2FromY"></param>
            <param name="p3FromX"></param>
            <param name="p3FromY"></param>
            <param name="p4FromX"></param>
            <param name="p4FromY"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.DefaultGridSampler.sampleGrid(ZXing.Common.BitMatrix,System.Int32,System.Int32,ZXing.Common.PerspectiveTransform)">
            <summary>
            </summary>
            <param name="image"></param>
            <param name="dimensionX"></param>
            <param name="dimensionY"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.DetectorResult">
            <summary>
            <p>Encapsulates the result of detecting a barcode in an image. This includes the raw
            matrix of black/white pixels corresponding to the barcode, and possibly points of interest
            in the image, like the location of finder patterns or corners of the barcode in the image.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.Common.DetectorResult.Bits">
            <summary>
            the detected bits
            </summary>
        </member>
        <member name="P:ZXing.Common.DetectorResult.Points">
            <summary>
            the pixel points where the result is found
            </summary>
        </member>
        <member name="M:ZXing.Common.DetectorResult.#ctor(ZXing.Common.BitMatrix,ZXing.ResultPoint[])">
            <summary>
            initializing constructor
            </summary>
            <param name="bits"></param>
            <param name="points"></param>
        </member>
        <member name="T:ZXing.Common.Detector.MathUtils">
            <summary>
            General math-related and numeric utility functions.
            </summary>
        </member>
        <member name="M:ZXing.Common.Detector.MathUtils.round(System.Single)">
            <summary>
            Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
            argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
            differ slightly from {@link Math#round(float)} in that half rounds down for negative
            values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
            </summary>
            <param name="d">real value to round</param>
            <returns>nearest <c>int</c></returns>
        </member>
        <member name="M:ZXing.Common.Detector.MathUtils.distance(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="aX"></param>
            <param name="aY"></param>
            <param name="bX"></param>
            <param name="bY"></param>
            <returns>Euclidean distance between points A and B</returns>
        </member>
        <member name="M:ZXing.Common.Detector.MathUtils.distance(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="aX"></param>
            <param name="aY"></param>
            <param name="bX"></param>
            <param name="bY"></param>
            <returns>Euclidean distance between points A and B</returns>
        </member>
        <member name="M:ZXing.Common.Detector.MathUtils.sum(System.Int32[])">
            <summary>
            </summary>
            <param name="array">values to sum</param>
            <returns>sum of values in array</returns>
        </member>
        <member name="T:ZXing.Common.Detector.MonochromeRectangleDetector">
            <summary> <p>A somewhat generic detector that looks for a barcode-like rectangular region within an image.
            It looks within a mostly white region of an image for a region of black and white, but mostly
            black. It returns the four corners of the region, as best it can determine.</p>
            
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Common.Detector.MonochromeRectangleDetector.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            initializing constructor
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:ZXing.Common.Detector.MonochromeRectangleDetector.detect">
            <summary>
            <p>Detects a rectangular region of black and white -- mostly black -- with a region of mostly
            white, in an image.</p>
            </summary>
            <returns><see cref="T:ZXing.ResultPoint"/>[] describing the corners of the rectangular region. The first and
            last points are opposed on the diagonal, as are the second and third. The first point will be
            the topmost point and the last, the bottommost. The second point will be leftmost and the
            third, the rightmost
            </returns>
        </member>
        <member name="M:ZXing.Common.Detector.MonochromeRectangleDetector.findCornerFromCenter(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Attempts to locate a corner of the barcode by scanning up, down, left or right from a center
            point which should be within the barcode.
            
            </summary>
            <param name="centerX">center's x component (horizontal)
            </param>
            <param name="deltaX">same as deltaY but change in x per step instead
            </param>
            <param name="left">minimum value of x
            </param>
            <param name="right">maximum value of x
            </param>
            <param name="centerY">center's y component (vertical)
            </param>
            <param name="deltaY">change in y per step. If scanning up this is negative; down, positive;
            left or right, 0
            </param>
            <param name="top">minimum value of y to search through (meaningless when di == 0)
            </param>
            <param name="bottom">maximum value of y
            </param>
            <param name="maxWhiteRun">maximum run of white pixels that can still be considered to be within
            the barcode
            </param>
            <returns> a <see cref="T:ZXing.ResultPoint"/> encapsulating the corner that was found
            </returns>
        </member>
        <member name="M:ZXing.Common.Detector.MonochromeRectangleDetector.blackWhiteRange(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary> Computes the start and end of a region of pixels, either horizontally or vertically, that could
            be part of a Data Matrix barcode.
            
            </summary>
            <param name="fixedDimension">if scanning horizontally, this is the row (the fixed vertical location)
            where we are scanning. If scanning vertically it's the column, the fixed horizontal location
            </param>
            <param name="maxWhiteRun">largest run of white pixels that can still be considered part of the
            barcode region
            </param>
            <param name="minDim">minimum pixel location, horizontally or vertically, to consider
            </param>
            <param name="maxDim">maximum pixel location, horizontally or vertically, to consider
            </param>
            <param name="horizontal">if true, we're scanning left-right, instead of up-down
            </param>
            <returns> int[] with start and end of found range, or null if no such range is found
            (e.g. only white was found)
            </returns>
        </member>
        <member name="T:ZXing.Common.Detector.WhiteRectangleDetector">
            <summary>
            Detects a candidate barcode-like rectangular region within an image. It
            starts around the center of the image, increases the size of the candidate
            region until it finds a white rectangular region. By keeping track of the
            last black points it encountered, it determines the corners of the barcode.
            </summary>
            <author>David Olivier</author>
        </member>
        <member name="M:ZXing.Common.Detector.WhiteRectangleDetector.Create(ZXing.Common.BitMatrix)">
            <summary>
            Creates a WhiteRectangleDetector instance
            </summary>
            <param name="image">The image.</param>
            <returns>null, if image is too small, otherwise a WhiteRectangleDetector instance</returns>
        </member>
        <member name="M:ZXing.Common.Detector.WhiteRectangleDetector.Create(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a WhiteRectangleDetector instance
            </summary>
            <param name="image">barcode image to find a rectangle in</param>
            <param name="initSize">initial size of search area around center</param>
            <param name="x">x position of search center</param>
            <param name="y">y position of search center</param>
            <returns>
            null, if image is too small, otherwise a WhiteRectangleDetector instance
            </returns>
        </member>
        <member name="M:ZXing.Common.Detector.WhiteRectangleDetector.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Common.Detector.WhiteRectangleDetector"/> class.
            </summary>
            <param name="image">The image.</param>
            <exception cref="T:System.ArgumentException">if image is too small</exception>
        </member>
        <member name="M:ZXing.Common.Detector.WhiteRectangleDetector.#ctor(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Common.Detector.WhiteRectangleDetector"/> class.
            </summary>
            <param name="image">The image.</param>
            <param name="initSize">Size of the init.</param>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
        </member>
        <member name="M:ZXing.Common.Detector.WhiteRectangleDetector.detect">
            <summary>
            Detects a candidate barcode-like rectangular region within an image. It
            starts around the center of the image, increases the size of the candidate
            region until it finds a white rectangular region.
            </summary>
            <returns><see cref="T:ZXing.ResultPoint" />[] describing the corners of the rectangular
            region. The first and last points are opposed on the diagonal, as
            are the second and third. The first point will be the topmost
            point and the last, the bottommost. The second point will be
            leftmost and the third, the rightmost</returns>
        </member>
        <member name="M:ZXing.Common.Detector.WhiteRectangleDetector.centerEdges(ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            recenters the points of a constant distance towards the center
            </summary>
            <param name="y">bottom most point</param>
            <param name="z">left most point</param>
            <param name="x">right most point</param>
            <param name="t">top most point</param>
            <returns><see cref="T:ZXing.ResultPoint"/>[] describing the corners of the rectangular
            region. The first and last points are opposed on the diagonal, as
            are the second and third. The first point will be the topmost
            point and the last, the bottommost. The second point will be
            leftmost and the third, the rightmost</returns>
        </member>
        <member name="M:ZXing.Common.Detector.WhiteRectangleDetector.containsBlackPoint(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determines whether a segment contains a black point
            </summary>
            <param name="a">min value of the scanned coordinate</param>
            <param name="b">max value of the scanned coordinate</param>
            <param name="fixed">value of fixed coordinate</param>
            <param name="horizontal">set to true if scan must be horizontal, false if vertical</param>
            <returns>
              true if a black point has been found, else false.
            </returns>
        </member>
        <member name="T:ZXing.Common.ECI">
            <summary>
            Superclass of classes encapsulating types ECIs, according to "Extended Channel Interpretations"
            5.3 of ISO 18004.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.Common.ECI.Value">
            <summary>
            the ECI value
            </summary>
        </member>
        <member name="M:ZXing.Common.ECI.getECIByValue(System.Int32)">
            <param name="val">ECI value</param>
            <returns><see cref="T:ZXing.Common.ECI"/> representing ECI of given value, or null if it is legal but unsupported</returns>
            <throws>ArgumentException if ECI value is invalid </throws>
        </member>
        <member name="T:ZXing.Common.ECIEncoderSet">
            <summary>
            Set of CharsetEncoders for a given input string
            Invariants:
            - The list contains only encoders from CharacterSetECI(list is shorter then the list of encoders available on
              the platform for which ECI values are defined).
            - The list contains encoders at least one encoder for every character in the input.
            - The first encoder in the list is always the ISO-8859-1 encoder even of no character in the input can be encoded
            by it.
            - If the input contains a character that is not in ISO-8859-1 then the last two entries in the list will be the
            UTF-8 encoder and the UTF-16BE encoder.
            
            @author Alex Geller
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.#ctor(System.String,System.Text.Encoding,System.Int32)">
            <summary>
            Constructs an encoder set
            </summary>
            <param name="stringToEncode">the string that needs to be encoded</param>
            <param name="priorityCharset">The preferred { @link Charset } or null.</param>
            <param name="fnc1">fnc1 denotes the character in the input that represents the FNC1 character or -1 for a non-GS1 bar
            code.When specified, it is considered an error to pass it as argument to the methods canEncode() or encode().</param>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.canEncode(System.Text.Encoding,System.Char)">
            <summary>
            
            </summary>
            <param name="encoding"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="P:ZXing.Common.ECIEncoderSet.Length">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.getCharsetName(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.getCharset(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.getECIValue(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.getPriorityEncoderIndex">
            <summary>
            returns -1 if no priority charset was defined
            </summary>
            <returns>-1 if no priority charset was defined</returns>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.canEncode(System.Char,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.encode(System.Char,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.encode(System.String,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIEncoderSet.Clone(System.Text.Encoding)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ZXing.Common.ECIInput">
            <summary>
            Interface to navigate a sequence of ECIs and bytes.
            @author Alex Geller
            </summary>
        </member>
        <member name="P:ZXing.Common.ECIInput.Length">
            <summary>
            Returns the length of this input.The length is the number of {@code byte}s in or ECIs in the sequence.
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIInput.charAt(System.Int32)">
            <summary>
            Returns the {@code byte} value at the specified index.  An index ranges from zero to {@code length() - 1}.  The first { @code byte}
            value of the sequence is at index zero, the next at index one, and so on, as for array indexing.
            </summary>
            <param name="index">the index of the {@code byte} value to be returned</param>
            <returns>the specified {@code byte} value as character or the FNC1 character</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the {@code index} argument is negative or not less than {@code Length}</exception>
            <exception cref="T:System.ArgumentException">if the value at the {@code index} argument is an ECI (@see #isECI)</exception>
        </member>
        <member name="M:ZXing.Common.ECIInput.subSequence(System.Int32,System.Int32)">
            <summary>
            Returns a {@code CharSequence} that is a subsequence of this sequence.
            The subsequence starts with the {@code char} value at the specified index and
            ends with the {@code char} value at index {@code end - 1}.  The length
            (in {@code char}s) of the
            returned sequence is {@code end - start}, so if {@code start == end}
            then an empty sequence is returned.
            </summary>
            <param name="start">the start index, inclusive</param>
            <param name="end">the start index, inclusive</param>
            <returns>the specified subsequence</returns>
            <exception cref="T:System.IndexOutOfRangeException">if {@code start} or {@code end} are negative,
            if {@code end} is greater than { @code length()},
            or if {@code start} is greater than { @code end}</exception>
            <exception cref="T:System.ArgumentException">if a value in the range {@code start}-{@code end} is an ECI (@see #isECI)</exception>
        </member>
        <member name="M:ZXing.Common.ECIInput.isECI(System.Int32)">
            <summary>
            Determines if a value is an ECI
            </summary>
            <param name="index">the index of the value</param>
            <returns>true if the value at position {@code index} is an ECI</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the {@code index} argument is negative or not less than {@code length()}</exception>
        </member>
        <member name="M:ZXing.Common.ECIInput.getECIValue(System.Int32)">
            <summary>
            Returns the {@code int} ECI value at the specified index.  An index ranges from zero
            to {@code length() - 1}.  The first {@code byte} value of the sequence is at
            index zero, the next at index one, and so on, as for array
            indexing.
            </summary>
            <param name="index">the index of the {@code int} value to be returned</param>
            <returns>the specified {@code int} ECI value. 
            The ECI specified the encoding of all bytes with a higher index until the
            next ECI or until the end of the input if no other ECI follows.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the value at the {@code index} argument is not an ECI (@see #isECI)</exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:ZXing.Common.ECIInput.haveNCharacters(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.ECIStringBuilder">
             <summary>
             Class that converts a sequence of ECIs and bytes into a string
            
             @author Alex Geller
             </summary>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.#ctor(System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="standardEncoding"></param>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="initialCapacity"></param>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.#ctor(System.Int32,System.Text.Encoding,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="initialCapacity"></param>
            <param name="standardEncoding"></param>
            <param name="startWithEncoding"></param>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.Append(System.Char)">
            <summary>
            Appends {@code value} as a byte value
            </summary>
            <param name="value">character whose lowest byte is to be appended</param>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.Append(System.Byte)">
            <summary>
            Appends {@code value} as a byte value
            </summary>
            <param name="value">byte to append</param>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.Append(System.String)">
            <summary>
            Appends the characters in {@code value} as bytes values
            </summary>
            <param name="value">string to append</param>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.Append(System.Int32)">
            <summary>
            Append the string repesentation of {@code value} (short for {@code append(String.valueOf(value))})
            </summary>
            <param name="value">int to append as a string</param>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.AppendECI(System.Int32)">
            <summary>
            Appends ECI value to output.
            </summary>
            <param name="value">ECI value to append, as an int</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.AppendCharacters(System.Text.StringBuilder)">
            <summary>
            Appends the characters from {@code value} (unlike all other append methods of this class who append bytes)
            </summary>
            <param name="value">characters to append</param>
        </member>
        <member name="P:ZXing.Common.ECIStringBuilder.Length">
            <summary>
            Short for {@code toString().length()} (if possible, use {@link #isEmpty()} instead)
            </summary>
            <returns>length of string representation in characters</returns>
        </member>
        <member name="P:ZXing.Common.ECIStringBuilder.isEmpty">
            <summary>
            true if nothing has been appended
            </summary>
        </member>
        <member name="M:ZXing.Common.ECIStringBuilder.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.EncodingOptions">
            <summary>
            Defines an container for encoder options
            </summary>
        </member>
        <member name="P:ZXing.Common.EncodingOptions.Hints">
            <summary>
            Gets the data container for all options
            </summary>
        </member>
        <member name="P:ZXing.Common.EncodingOptions.Height">
            <summary>
            Specifies the height of the barcode image
            </summary>
        </member>
        <member name="P:ZXing.Common.EncodingOptions.Width">
            <summary>
            Specifies the width of the barcode image
            </summary>
        </member>
        <member name="P:ZXing.Common.EncodingOptions.PureBarcode">
            <summary>
            Don't put the content string into the output image.
            </summary>
        </member>
        <member name="P:ZXing.Common.EncodingOptions.Margin">
            <summary>
            Specifies margin, in pixels, to use when generating the barcode. The meaning can vary
            by format; for example it controls margin before and after the barcode horizontally for
            most 1D formats.
            </summary>
        </member>
        <member name="P:ZXing.Common.EncodingOptions.GS1Format">
            <summary>
            Specifies whether the data should be encoded to the GS1 standard;
            FNC1 character is added in front of the data
            </summary>
        </member>
        <member name="P:ZXing.Common.EncodingOptions.NoPadding">
            <summary>
            Don't add a white area around the generated barcode if the requested size is larger than then barcode.
            </summary>
        </member>
        <member name="M:ZXing.Common.EncodingOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Common.EncodingOptions"/> class.
            </summary>
        </member>
        <member name="T:ZXing.Common.GlobalHistogramBinarizer">
            <summary> This Binarizer implementation uses the old ZXing global histogram approach. It is suitable
            for low-end mobile devices which don't have enough CPU or memory to use a local thresholding
            algorithm. However, because it picks a global black point, it cannot handle difficult shadows
            and gradients.
            
            Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.
            
            <author>dswitkin@google.com (Daniel Switkin)</author>
            <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.Common.GlobalHistogramBinarizer.#ctor(ZXing.LuminanceSource)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Common.GlobalHistogramBinarizer"/> class.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:ZXing.Common.GlobalHistogramBinarizer.getBlackRow(System.Int32,ZXing.Common.BitArray)">
            <summary>
            Applies simple sharpening to the row data to improve performance of the 1D Readers.
            </summary>
            <param name="y"></param>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="P:ZXing.Common.GlobalHistogramBinarizer.BlackMatrix">
            <summary>
            Does not sharpen the data, as this call is intended to only be used by 2D Readers.
            </summary>
        </member>
        <member name="M:ZXing.Common.GlobalHistogramBinarizer.createBinarizer(ZXing.LuminanceSource)">
            <summary>
            Creates a new object with the same type as this Binarizer implementation, but with pristine
            state. This is needed because Binarizer implementations may be stateful, e.g. keeping a cache
            of 1 bit data. See Effective Java for why we can't use Java's clone() method.
            </summary>
            <param name="source">The LuminanceSource this Binarizer will operate on.</param>
            <returns>
            A new concrete Binarizer implementation object.
            </returns>
        </member>
        <member name="T:ZXing.Common.GridSampler">
            <summary> Implementations of this class can, given locations of finder patterns for a QR code in an
            image, sample the right points in the image to reconstruct the QR code, accounting for
            perspective distortion. It is abstracted since it is relatively expensive and should be allowed
            to take advantage of platform-specific optimized implementations, like Sun's Java Advanced
            Imaging library, but which may not be available in other environments such as J2ME, and vice
            versa.
            
            The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}
            with an instance of a class which implements this interface.
            </summary>
            <author> Sean Owen</author>
        </member>
        <member name="P:ZXing.Common.GridSampler.Instance">
            <returns> the current implementation of <see cref="T:ZXing.Common.GridSampler"/>
            </returns>
        </member>
        <member name="M:ZXing.Common.GridSampler.setGridSampler(ZXing.Common.GridSampler)">
            <summary> Sets the implementation of <see cref="T:ZXing.Common.GridSampler"/> used by the library. One global
            instance is stored, which may sound problematic. But, the implementation provided
            ought to be appropriate for the entire platform, and all uses of this library
            in the whole lifetime of the JVM. For instance, an Android activity can swap in
            an implementation that takes advantage of native platform libraries.
            </summary>
            <param name="newGridSampler">The platform-specific object to install.</param>
        </member>
        <member name="M:ZXing.Common.GridSampler.sampleGrid(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
              <p>Samples an image for a square matrix of bits of the given dimension. This is used to extract
            the black/white modules of a 2D barcode like a QR Code found in an image. Because this barcode
            may be rotated or perspective-distorted, the caller supplies four points in the source image
            that define known points in the barcode, so that the image may be sampled appropriately.</p>
              <p>The last eight "from" parameters are four X/Y coordinate pairs of locations of points in
            the image that define some significant points in the image to be sample. For example,
            these may be the location of finder pattern in a QR Code.</p>
              <p>The first eight "to" parameters are four X/Y coordinate pairs measured in the destination
            <see cref="T:ZXing.Common.BitMatrix"/>, from the top left, where the known points in the image given by the "from"
            parameters map to.</p>
              <p>These 16 parameters define the transformation needed to sample the image.</p>
            </summary>
            <param name="image">image to sample</param>
            <param name="dimensionX">The dimension X.</param>
            <param name="dimensionY">The dimension Y.</param>
            <param name="p1ToX">The p1 preimage X.</param>
            <param name="p1ToY">The p1 preimage  Y.</param>
            <param name="p2ToX">The p2 preimage  X.</param>
            <param name="p2ToY">The p2 preimage  Y.</param>
            <param name="p3ToX">The p3 preimage  X.</param>
            <param name="p3ToY">The p3 preimage  Y.</param>
            <param name="p4ToX">The p4 preimage  X.</param>
            <param name="p4ToY">The p4 preimage  Y.</param>
            <param name="p1FromX">The p1 image X.</param>
            <param name="p1FromY">The p1 image Y.</param>
            <param name="p2FromX">The p2 image X.</param>
            <param name="p2FromY">The p2 image Y.</param>
            <param name="p3FromX">The p3 image X.</param>
            <param name="p3FromY">The p3 image Y.</param>
            <param name="p4FromX">The p4 image X.</param>
            <param name="p4FromY">The p4 image Y.</param>
            <returns>
            <see cref="T:ZXing.Common.BitMatrix"/> representing a grid of points sampled from the image within a region
            defined by the "from" parameters
            </returns>
            <throws>  ReaderException if image can't be sampled, for example, if the transformation defined </throws>
        </member>
        <member name="M:ZXing.Common.GridSampler.sampleGrid(ZXing.Common.BitMatrix,System.Int32,System.Int32,ZXing.Common.PerspectiveTransform)">
            <summary>
            
            </summary>
            <param name="image"></param>
            <param name="dimensionX"></param>
            <param name="dimensionY"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.GridSampler.checkAndNudgePoints(ZXing.Common.BitMatrix,System.Single[])">
            <summary> <p>Checks a set of points that have been transformed to sample points on an image against
            the image's dimensions to see if the point are even within the image.</p>
            
            <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
            barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
            patterns in an image where the QR Code runs all the way to the image border.</p>
            
            <p>For efficiency, the method will check points from either end of the line until one is found
            to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
            
            </summary>
            <param name="image">image into which the points should map
            </param>
            <param name="points">actual points in x1,y1,...,xn,yn form
            </param>
        </member>
        <member name="T:ZXing.Common.HybridBinarizer">
            <summary> This class implements a local thresholding algorithm, which while slower than the
            GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for
            high frequency images of barcodes with black data on white backgrounds. For this application,
            it does a much better job than a global blackpoint with severe shadows and gradients.
            However it tends to produce artifacts on lower frequency images and is therefore not
            a good general purpose binarizer for uses outside ZXing.
            
            This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,
            and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already
            inherently local, and only fails for horizontal gradients. We can revisit that problem later,
            but for now it was not a win to use local blocks for 1D.
            
            This Binarizer is the default for the unit tests and the recommended class for library users.
            <author>dswitkin@google.com (Daniel Switkin)</author>
            </summary>
        </member>
        <member name="P:ZXing.Common.HybridBinarizer.BlackMatrix">
            <summary>
            gives the black matrix
            </summary>
        </member>
        <member name="M:ZXing.Common.HybridBinarizer.#ctor(ZXing.LuminanceSource)">
            <summary>
            initializing constructor
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:ZXing.Common.HybridBinarizer.createBinarizer(ZXing.LuminanceSource)">
            <summary>
            creates a new instance
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.HybridBinarizer.binarizeEntireImage">
            <summary>
            Calculates the final BitMatrix once for all requests. This could be called once from the
            constructor instead, but there are some advantages to doing it lazily, such as making
            profiling easier, and not doing heavy lifting when callers don't expect it.
            </summary>
        </member>
        <member name="M:ZXing.Common.HybridBinarizer.calculateThresholdForBlock(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[][],ZXing.Common.BitMatrix)">
            <summary>
            For each 8x8 block in the image, calculate the average black point using a 5x5 grid
            of the blocks around it. Also handles the corner cases (fractional blocks are computed based
            on the last 8 pixels in the row/column which are also used in the previous block).
            </summary>
            <param name="luminances">The luminances.</param>
            <param name="subWidth">Width of the sub.</param>
            <param name="subHeight">Height of the sub.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="blackPoints">The black points.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.Common.HybridBinarizer.thresholdBlock(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,ZXing.Common.BitMatrix)">
            <summary>
            Applies a single threshold to an 8x8 block of pixels.
            </summary>
            <param name="luminances">The luminances.</param>
            <param name="xoffset">The xoffset.</param>
            <param name="yoffset">The yoffset.</param>
            <param name="threshold">The threshold.</param>
            <param name="stride">The stride.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.Common.HybridBinarizer.calculateBlackPoints(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates a single black point for each 8x8 block of pixels and saves it away.
            See the following thread for a discussion of this algorithm:
            http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
            </summary>
            <param name="luminances">The luminances.</param>
            <param name="subWidth">Width of the sub.</param>
            <param name="subHeight">Height of the sub.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.MinimalECIInput">
            <summary>
            Class that converts a character string into a sequence of ECIs and bytes
            The implementation uses the Dijkstra algorithm to produce minimal encodings
            @author Alex Geller
            </summary>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.#ctor(System.String,System.Text.Encoding,System.Int32)">
            <summary>
            Constructs a minimal input
            </summary>
            <param name="stringToEncode">the character string to encode</param>
            <param name="priorityCharset">The preferred {@link Charset}. When the value of the argument is null, the algorithm
            chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority
            charset to encode any character in the input that can be encoded by it if the charset is among the
            supported charsets.</param>
            <param name="fnc1">denotes the character in the input that represents the FNC1 character or -1 if this is not GS1
            input.</param>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.getFNC1Character">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:ZXing.Common.MinimalECIInput.Length">
            <summary>
            Returns the length of this input.  The length is the number
            of {@code byte}s, FNC1 characters or ECIs in the sequence.
            </summary>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.haveNCharacters(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.charAt(System.Int32)">
            <summary>
            Returns the {@code byte} value at the specified index.  An index ranges from zero
            to {@code length() - 1}.  The first {@code byte} value of the sequence is at
            index zero, the next at index one, and so on, as for array
            indexing.
            </summary>
            <param name="index">the index of the {@code byte} value to be returned</param>
            <returns>the specified {@code byte} value as character or the FNC1 character</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the {@code index} argument is negative or not less than
            {@code length()}</exception>
            <exception cref="T:System.ArgumentException">if the value at the {@code index} argument is an ECI (@see #isECI)</exception>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.subSequence(System.Int32,System.Int32)">
            <summary>
            Returns a {@code CharSequence} that is a subsequence of this sequence.
            The subsequence starts with the {@code char} value at the specified index and
            ends with the {@code char} value at index {@code end - 1}.  The length
            (in {@code char}s) of the
            returned sequence is {@code end - start}, so if {@code start == end}
            then an empty sequence is returned.
            </summary>
            <param name="start">the start index, inclusive</param>
            <param name="end">the end index, exclusive</param>
            <returns>the specified subsequence</returns>
            <exception cref="T:System.IndexOutOfRangeException">if {@code start} or {@code end} are negative,
            if {@code end} is greater than {@code length()},
            or if {@code start} is greater than {@code end}</exception>
            <exception cref="T:System.ArgumentException">if a value in the range {@code start}-{@code end} is an ECI (@see #isECI)</exception>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.isECI(System.Int32)">
            <summary>
            Determines if a value is an ECI
            </summary>
            <param name="index">the index of the value</param>
            <returns>true if the value at position {@code index} is an ECI</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the {@code index} argument is negative or not less than
            {@code length()}</exception>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.isFNC1(System.Int32)">
            <summary>
            Determines if a value is the FNC1 character
            </summary>
            <param name="index">the index of the value</param>
            <returns>true if the value at position {@code index} is the FNC1 character</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the {@code index} argument is negative or not less than
            {@code length()}</exception>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.getECIValue(System.Int32)">
            <summary>
            Returns the {@code int} ECI value at the specified index.  An index ranges from zero
            to {@code length() - 1}.  The first {@code byte} value of the sequence is at
            index zero, the next at index one, and so on, as for array
            indexing.
            </summary>
            <param name="index">the index of the {@code int} value to be returned</param>
            <returns>the specified {@code int} ECI value.
            The ECI specified the encoding of all bytes with a higher index until the
            next ECI or until the end of the input if no other ECI follows.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the {@code index} argument is negative or not less than
            {@code length()}</exception>
            <exception cref="T:System.ArgumentException">if the value at the {@code index} argument is not an ECI (@see #isECI)</exception>
        </member>
        <member name="M:ZXing.Common.MinimalECIInput.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.PerspectiveTransform">
            <summary> <p>This class implements a perspective transform in two dimensions. Given four source and four
            destination points, it will compute the transformation implied between them. The code is based
            directly upon section 3.4.2 of George Wolberg's "Digital Image Warping"; see pages 54-56.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Common.PerspectiveTransform.quadrilateralToQuadrilateral(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="x0p"></param>
            <param name="y0p"></param>
            <param name="x1p"></param>
            <param name="y1p"></param>
            <param name="x2p"></param>
            <param name="y2p"></param>
            <param name="x3p"></param>
            <param name="y3p"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.PerspectiveTransform.transformPoints(System.Single[])">
            <summary>
            
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:ZXing.Common.PerspectiveTransform.transformPoints(System.Single[],System.Single[])">
            <summary>Convenience method, not optimized for performance. </summary>
        </member>
        <member name="M:ZXing.Common.PerspectiveTransform.squareToQuadrilateral(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Common.PerspectiveTransform.quadrilateralToSquare(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Common.ReedSolomon.GenericGF">
            <summary>
              <p>This class contains utility methods for performing mathematical operations over
            the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
              <p>Throughout this package, elements of the GF are represented as an {@code int}
            for convenience and speed (but at the cost of memory).
              </p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.AZTEC_DATA_12">
            <summary>
            Aztec data 12
            </summary>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.AZTEC_DATA_10">
            <summary>
            Aztec data 10
            </summary>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.AZTEC_DATA_6">
            <summary>
            Aztec data 6
            </summary>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.AZTEC_PARAM">
            <summary>
            Aztec param
            </summary>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.QR_CODE_FIELD_256">
            <summary>
            QR Code
            </summary>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.DATA_MATRIX_FIELD_256">
            <summary>
            Data Matrix
            </summary>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.AZTEC_DATA_8">
            <summary>
            Aztec data 8
            </summary>
        </member>
        <member name="F:ZXing.Common.ReedSolomon.GenericGF.MAXICODE_FIELD_64">
            <summary>
            Maxicode
            </summary>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a representation of GF(size) using the given primitive polynomial.
            </summary>
            <param name="primitive">irreducible polynomial whose coefficients are represented by
            *  the bits of an int, where the least-significant bit represents the constant
            *  coefficient</param>
            <param name="size">the size of the field</param>
            <param name="genBase">the factor b in the generator polynomial can be 0- or 1-based
            *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
            *  In most cases it should be 1, but for QR code it is 0.</param>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.buildMonomial(System.Int32,System.Int32)">
            <summary>
            Builds the monomial.
            </summary>
            <param name="degree">The degree.</param>
            <param name="coefficient">The coefficient.</param>
            <returns>the monomial representing coefficient * x^degree</returns>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.addOrSubtract(System.Int32,System.Int32)">
            <summary>
            Implements both addition and subtraction -- they are the same in GF(size).
            </summary>
            <returns>sum/difference of a and b</returns>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.exp(System.Int32)">
            <summary>
            Exps the specified a.
            </summary>
            <returns>2 to the power of a in GF(size)</returns>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.log(System.Int32)">
            <summary>
            Logs the specified a.
            </summary>
            <param name="a">A.</param>
            <returns>base 2 log of a in GF(size)</returns>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.inverse(System.Int32)">
            <summary>
            Inverses the specified a.
            </summary>
            <returns>multiplicative inverse of a</returns>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.multiply(System.Int32,System.Int32)">
            <summary>
            Multiplies the specified a with b.
            </summary>
            <param name="a">A.</param>
            <param name="b">The b.</param>
            <returns>product of a and b in GF(size)</returns>
        </member>
        <member name="P:ZXing.Common.ReedSolomon.GenericGF.Size">
            <summary>
            Gets the size.
            </summary>
        </member>
        <member name="P:ZXing.Common.ReedSolomon.GenericGF.GeneratorBase">
            <summary>
            Gets the generator base.
            </summary>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGF.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ZXing.Common.ReedSolomon.GenericGFPoly">
            <summary>
            <p>Represents a polynomial whose coefficients are elements of a GF.
            Instances of this class are immutable.</p>
            <p>Much credit is due to William Rucklidge since portions of this code are an indirect
            port of his C++ Reed-Solomon implementation.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGFPoly.#ctor(ZXing.Common.ReedSolomon.GenericGF,System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Common.ReedSolomon.GenericGFPoly"/> class.
            </summary>
            <param name="field">the {@link GenericGF} instance representing the field to use
            to perform computations</param>
            <param name="coefficients">coefficients as ints representing elements of GF(size), arranged
            from most significant (highest-power term) coefficient to least significant</param>
            <exception cref="T:System.ArgumentException">if argument is null or empty,
            or if leading coefficient is 0 and this is not a
            constant polynomial (that is, it is not the monomial "0")</exception>
        </member>
        <member name="P:ZXing.Common.ReedSolomon.GenericGFPoly.Degree">
            <summary>
            degree of this polynomial
            </summary>
        </member>
        <member name="P:ZXing.Common.ReedSolomon.GenericGFPoly.isZero">
            <summary>
            Gets a value indicating whether this <see cref="T:ZXing.Common.ReedSolomon.GenericGFPoly"/> is zero.
            </summary>
            <value>true iff this polynomial is the monomial "0"</value>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGFPoly.getCoefficient(System.Int32)">
            <summary>
            coefficient of x^degree term in this polynomial
            </summary>
            <param name="degree">The degree.</param>
            <returns>coefficient of x^degree term in this polynomial</returns>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.GenericGFPoly.evaluateAt(System.Int32)">
            <summary>
            evaluation of this polynomial at a given point
            </summary>
            <param name="a">A.</param>
            <returns>evaluation of this polynomial at a given point</returns>
        </member>
        <member name="T:ZXing.Common.ReedSolomon.ReedSolomonDecoder">
            <summary> <p>Implements Reed-Solomon decoding, as the name implies.</p>
            
            <p>The algorithm will not be explained here, but the following references were helpful
            in creating this implementation:</p>
            
            <ul>
            <li>Bruce Maggs.
            <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">
            "Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>
            <li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">
            "Chapter 5. Generalized Reed-Solomon Codes"</a>
            (see discussion of Euclidean algorithm)</li>
            </ul>
            
            <p>Much credit is due to William Rucklidge since portions of this code are an indirect
            port of his C++ Reed-Solomon implementation.</p>
            
            </summary>
            <author>Sean Owen</author>
            <author>William Rucklidge</author>
            <author>sanfordsquires</author>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.ReedSolomonDecoder.#ctor(ZXing.Common.ReedSolomon.GenericGF)">
            <summary>
            constructor
            </summary>
            <param name="field"></param>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.ReedSolomonDecoder.decode(System.Int32[],System.Int32)">
            <summary>
              <p>Decodes given set of received codewords, which include both data and error-correction
            codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
            in the input.</p>
            </summary>
            <param name="received">data and error-correction codewords</param>
            <param name="twoS">number of error-correction codewords available</param>
            <returns>false: decoding fails</returns>
        </member>
        <member name="T:ZXing.Common.ReedSolomon.ReedSolomonEncoder">
            <summary>
            Implements Reed-Solomon encoding, as the name implies.
            </summary>
            <author>Sean Owen</author>
            <author>William Rucklidge</author>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.ReedSolomonEncoder.#ctor(ZXing.Common.ReedSolomon.GenericGF)">
            <summary>
            constructor
            </summary>
            <param name="field"></param>
        </member>
        <member name="M:ZXing.Common.ReedSolomon.ReedSolomonEncoder.encode(System.Int32[],System.Int32)">
            <summary>
            encodes
            </summary>
            <param name="toEncode"></param>
            <param name="ecBytes"></param>
        </member>
        <member name="T:ZXing.Common.StringUtils">
            <summary>
            Common string-related functions.
            </summary>
            <author>Sean Owen</author>
            <author>Alex Dupre</author>
        </member>
        <member name="F:ZXing.Common.StringUtils.PLATFORM_DEFAULT_ENCODING">
            <summary>
            default encoding of the current platform (name)
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.PLATFORM_DEFAULT_ENCODING_T">
            <summary>
            default encoding of the current platform (type)
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.SHIFT_JIS_ENCODING">
            <summary>
            Shift JIS encoding if available
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.GB2312_ENCODING">
            <summary>
            GB 2312 encoding if available
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.EUC_JP_ENCODING">
            <summary>
            ECU JP encoding if available
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.ISO88591_ENCODING">
            <summary>
            ISO8859-1 encoding if available
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.SHIFT_JIS">
            <summary>
            SJIS
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.GB2312">
            <summary>
            GB2312
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.EUC_JP">
            <summary>
            EUC-JP
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.UTF8">
            <summary>
            UTF-8
            </summary>
        </member>
        <member name="F:ZXing.Common.StringUtils.ISO88591">
            <summary>
            ISO-8859-1
            </summary>
        </member>
        <member name="M:ZXing.Common.StringUtils.guessEncoding(System.Byte[],System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Guesses the encoding.
            </summary>
            <param name="bytes">bytes encoding a string, whose encoding should be guessed</param>
            <param name="hints">decode hints if applicable</param>
            <return> name of guessed encoding; at the moment will only guess one of:
            "SJIS", "UTF8", "ISO8859_1", or the platform default encoding if none
            of these can possibly be correct</return>
        </member>
        <member name="M:ZXing.Common.StringUtils.guessCharset(System.Byte[],System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary></summary>
            <param name="bytes">bytes encoding a string, whose encoding should be guessed</param>
            <param name="hints">decode hints if applicable</param>
            <returns>Charset of guessed encoding; at the moment will only guess one of:
             {@link #SHIFT_JIS_CHARSET}, {@link StandardCharsets#UTF_8},
             {@link StandardCharsets#ISO_8859_1}, {@link StandardCharsets#UTF_16},
             or the platform default encoding if
             none of these can possibly be correct</returns>
        </member>
        <member name="T:ZXing.Datamatrix.DataMatrixReader">
             <summary>
             This implementation can detect and decode Data Matrix codes in an image.
            
             <author>bbrown@google.com (Brian Brown)</author>
             </summary>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixReader.decode(ZXing.BinaryBitmap)">
            <summary>
            Locates and decodes a Data Matrix code in an image.
            </summary>
            <param name="image"></param>
            <returns>a String representing the content encoded by the Data Matrix code</returns>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes a Data Matrix code in an image.
            </summary>
            <param name="image"></param>
            <param name="hints"></param>
            <returns>a String representing the content encoded by the Data Matrix code</returns>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixReader.reset">
            <summary>
            does nothing here
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixReader.extractPureBits(ZXing.Common.BitMatrix)">
             <summary>
             This method detects a code in a "pure" image -- that is, pure monochrome image
             which contains only an unrotated, unskewed, image of a code, with some white border
             around it. This is a specialized method that works exceptionally fast in this special
             case.
            
             <seealso cref="M:ZXing.QrCode.QRCodeReader.extractPureBits(ZXing.Common.BitMatrix)" />
             </summary>
        </member>
        <member name="T:ZXing.Datamatrix.DataMatrixWriter">
            <summary>
            This object renders a Data Matrix code as a BitMatrix 2D array of greyscale values.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
            <author>Guillaume Le Biller Added to zxing lib.</author>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            encodes the content to a BitMatrix
            </summary>
            <param name="contents"></param>
            <param name="format"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            encodes the content to a BitMatrix
            </summary>
            <param name="contents"></param>
            <param name="format"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="hints"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixWriter.encodeLowLevel(ZXing.Datamatrix.Encoder.DefaultPlacement,ZXing.Datamatrix.Encoder.SymbolInfo,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Encode the given symbol info to a bit matrix.
            </summary>
            <param name="placement">The DataMatrix placement.</param>
            <param name="symbolInfo">The symbol info to encode.</param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="margin"></param>
            <param name="noPadding"></param>
            <returns>The bit matrix generated.</returns>
        </member>
        <member name="M:ZXing.Datamatrix.DataMatrixWriter.convertByteMatrixToBitMatrix(ZXing.QrCode.Internal.ByteMatrix,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Convert the ByteMatrix to BitMatrix.
            </summary>
            <param name="matrix">The input matrix.</param>
            <param name="reqWidth">The requested width of the image (in pixels) with the Datamatrix code</param>
            <param name="reqHeight">The requested height of the image (in pixels) with the Datamatrix code</param>
            <param name="margin"></param>
            <param name="noPadding"></param>
            <returns>The output matrix.</returns>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.BitMatrixParser">
            <summary>
            <author>bbrown@google.com (Brian Brown)</author>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            <param name="bitMatrix"><see cref="T:ZXing.Common.BitMatrix" />to parse</param>
            <exception cref="T:ZXing.FormatException">if dimension is &lt; 8 or &gt; 144 or not 0 mod 2</exception>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readVersion(ZXing.Common.BitMatrix)">
             <summary>
             <p>Creates the version object based on the dimension of the original bit matrix from 
             the datamatrix code.</p>
            
             <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>
             
             <param name="bitMatrix">Original <see cref="T:ZXing.Common.BitMatrix" />including alignment patterns</param>
             <returns><see cref="P:ZXing.Datamatrix.Internal.BitMatrixParser.Version" />encapsulating the Data Matrix Code's "version"</returns>
             <exception cref="T:ZXing.FormatException">if the dimensions of the mapping matrix are not valid</exception>
             Data Matrix dimensions.
             </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readCodewords">
             <summary>
             <p>Reads the bits in the <see cref="T:ZXing.Common.BitMatrix" />representing the mapping matrix (No alignment patterns)
             in the correct order in order to reconstitute the codewords bytes contained within the
             Data Matrix Code.</p>
            
             <returns>bytes encoded within the Data Matrix Code</returns>
             <exception cref="T:ZXing.FormatException">if the exact number of bytes expected is not read</exception>
             </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readModule(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>
            
            <param name="row">Row to read in the mapping matrix</param>
            <param name="column">Column to read in the mapping matrix</param>
            <param name="numRows">Number of rows in the mapping matrix</param>
            <param name="numColumns">Number of columns in the mapping matrix</param>
            <returns>value of the given bit in the mapping matrix</returns>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readUtah(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>
            
            <p>See ISO 16022:2006, 5.8.1 Figure 6</p>
            
            <param name="row">Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern</param>
            <param name="column">Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern</param>
            <param name="numRows">Number of rows in the mapping matrix</param>
            <param name="numColumns">Number of columns in the mapping matrix</param>
            <returns>byte from the utah shape</returns>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readCorner1(System.Int32,System.Int32)">
            <summary>
            <p>Reads the 8 bits of the special corner condition 1.</p>
            
            <p>See ISO 16022:2006, Figure F.3</p>
            
            <param name="numRows">Number of rows in the mapping matrix</param>
            <param name="numColumns">Number of columns in the mapping matrix</param>
            <returns>byte from the Corner condition 1</returns>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readCorner2(System.Int32,System.Int32)">
            <summary>
            <p>Reads the 8 bits of the special corner condition 2.</p>
            
            <p>See ISO 16022:2006, Figure F.4</p>
            
            <param name="numRows">Number of rows in the mapping matrix</param>
            <param name="numColumns">Number of columns in the mapping matrix</param>
            <returns>byte from the Corner condition 2</returns>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readCorner3(System.Int32,System.Int32)">
            <summary>
            <p>Reads the 8 bits of the special corner condition 3.</p>
            
            <p>See ISO 16022:2006, Figure F.5</p>
            
            <param name="numRows">Number of rows in the mapping matrix</param>
            <param name="numColumns">Number of columns in the mapping matrix</param>
            <returns>byte from the Corner condition 3</returns>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.readCorner4(System.Int32,System.Int32)">
            <summary>
            <p>Reads the 8 bits of the special corner condition 4.</p>
            
            <p>See ISO 16022:2006, Figure F.6</p>
            
            <param name="numRows">Number of rows in the mapping matrix</param>
            <param name="numColumns">Number of columns in the mapping matrix</param>
            <returns>byte from the Corner condition 4</returns>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.BitMatrixParser.extractDataRegion(ZXing.Common.BitMatrix)">
            <summary>
            <p>Extracts the data region from a <see cref="T:ZXing.Common.BitMatrix" />that contains
            alignment patterns.</p>
            
            <param name="bitMatrix">Original <see cref="T:ZXing.Common.BitMatrix" />with alignment patterns</param>
            <returns>BitMatrix that has the alignment patterns removed</returns>
            </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.DataBlock">
             <summary>
             <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into
             multiple blocks, each of which is a unit of data and error-correction codewords. Each
             is represented by an instance of this class.</p>
            
             <author>bbrown@google.com (Brian Brown)</author>
             </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DataBlock.getDataBlocks(System.Byte[],ZXing.Datamatrix.Internal.Version)">
             <summary>
             <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.
             That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
             method will separate the data into original blocks.</p>
            
             <param name="rawCodewords">bytes as read directly from the Data Matrix Code</param>
             <param name="version">version of the Data Matrix Code</param>
             <returns>DataBlocks containing original bytes, "de-interleaved" from representation in the</returns>
                     Data Matrix Code
             </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.DecodedBitStreamParser">
             <summary>
             <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes
             in one Data Matrix Code. This class decodes the bits back into text.</p>
            
             <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>
            
             <author>bbrown@google.com (Brian Brown)</author>
             <author>Sean Owen</author>
             </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Internal.DecodedBitStreamParser.C40_BASIC_SET_CHARS">
            <summary>
            See ISO 16022:2006, Annex C Table C.1
            The C40 Basic Character Set (*'s used for placeholders for the shift values)
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Internal.DecodedBitStreamParser.TEXT_BASIC_SET_CHARS">
            <summary>
            See ISO 16022:2006, Annex C Table C.2
            The Text Basic Character Set (*'s used for placeholders for the shift values)
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.decodeAsciiSegment(ZXing.Common.BitSource,ZXing.Common.ECIStringBuilder,System.Text.StringBuilder,System.Collections.Generic.List{System.Int32},ZXing.Datamatrix.Internal.DecodedBitStreamParser.Mode@)">
            <summary>
            See ISO 16022:2006, 5.2.3 and Annex C, Table C.2
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.decodeC40Segment(ZXing.Common.BitSource,ZXing.Common.ECIStringBuilder,System.Collections.Generic.List{System.Int32})">
            <summary>
            See ISO 16022:2006, 5.2.5 and Annex C, Table C.1
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.decodeTextSegment(ZXing.Common.BitSource,ZXing.Common.ECIStringBuilder,System.Collections.Generic.List{System.Int32})">
            <summary>
            See ISO 16022:2006, 5.2.6 and Annex C, Table C.2
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.decodeAnsiX12Segment(ZXing.Common.BitSource,ZXing.Common.ECIStringBuilder)">
            <summary>
            See ISO 16022:2006, 5.2.7
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.decodeEdifactSegment(ZXing.Common.BitSource,ZXing.Common.ECIStringBuilder)">
            <summary>
            See ISO 16022:2006, 5.2.8 and Annex C Table C.3
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.decodeBase256Segment(ZXing.Common.BitSource,ZXing.Common.ECIStringBuilder,System.Collections.Generic.IList{System.Byte[]})">
            <summary>
            See ISO 16022:2006, 5.2.9 and Annex B, B.2
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.decodeECISegment(ZXing.Common.BitSource,ZXing.Common.ECIStringBuilder)">
            See ISO 16022:2007, 5.4.1
        </member>
        <member name="M:ZXing.Datamatrix.Internal.DecodedBitStreamParser.unrandomize255State(System.Int32,System.Int32)">
            <summary>
            See ISO 16022:2006, Annex B, B.2
            </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.Decoder">
             <summary>
             <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting
             the Data Matrix Code from an image.</p>
            
             <author>bbrown@google.com (Brian Brown)</author>
             </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Decoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Datamatrix.Internal.Decoder"/> class.
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Decoder.decode(System.Boolean[][])">
             <summary>
             <p>Convenience method that can decode a Data Matrix Code represented as a 2D array of booleans.
             "true" is taken to mean a black module.</p>
            
             <param name="image">booleans representing white/black Data Matrix Code modules</param>
             <returns>text and bytes encoded within the Data Matrix Code</returns>
             <exception cref="T:ZXing.FormatException">if the Data Matrix Code cannot be decoded</exception>
             </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Decoder.decode(ZXing.Common.BitMatrix)">
            <summary>
            <p>Decodes a Data Matrix Code represented as a <see cref="T:ZXing.Common.BitMatrix" />. A 1 or "true" is taken
            to mean a black module.</p>
            </summary>
            <param name="bits">booleans representing white/black Data Matrix Code modules</param>
            <returns>text and bytes encoded within the Data Matrix Code</returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Decoder.correctErrors(System.Byte[],System.Int32)">
             <summary>
             <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
             correct the errors in-place using Reed-Solomon error correction.</p>
            
             <param name="codewordBytes">data and error correction codewords</param>
             <param name="numDataCodewords">number of codewords that are data bytes</param>
             </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.Version">
             <summary>
             The Version object encapsulates attributes about a particular
             size Data Matrix Code.
            
             <author>bbrown@google.com (Brian Brown)</author>
             </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.getVersionNumber">
            <summary>
            returns the version numer
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.getSymbolSizeRows">
            <summary>
            returns the symbol size rows
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.getSymbolSizeColumns">
            <summary>
            returns the symbols size columns
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.getDataRegionSizeRows">
            <summary>
            retursn the data region size rows
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.getDataRegionSizeColumns">
            <summary>
            returns the data region size columns
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.getTotalCodewords">
            <summary>
            returns the total codewords count
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.getVersionForDimensions(System.Int32,System.Int32)">
             <summary>
             <p>Deduces version information from Data Matrix dimensions.</p>
            
             <param name="numRows">Number of rows in modules</param>
             <param name="numColumns">Number of columns in modules</param>
             <returns>Version for a Data Matrix Code of those dimensions</returns>
             <exception cref="T:ZXing.FormatException">if dimensions do correspond to a valid Data Matrix size</exception>
             </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.Version.ECBlocks">
            <summary>
            <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
            use blocks of differing sizes within one version, so, this encapsulates the parameters for
            each set of blocks. It also holds the number of error-correction codewords per block since it
            will be the same across all blocks within one version.</p>
            </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.Version.ECB">
            <summary>
            <p>Encapsulates the parameters for one error-correction block in one symbol version.
            This includes the number of data codewords, and the number of times a block with these
            parameters is used consecutively in the Data Matrix code version's format.</p>
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.ToString">
            <summary>
            returns the version number as string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Version.buildVersions">
            <summary>
            See ISO 16022:2006 5.5.1 Table 7
            </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Internal.Detector">
            <summary>
            <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code
            is rotated or skewed, or partially obscured.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Detector.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Datamatrix.Internal.Detector"/> class.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Detector.detect">
            <summary>
            <p>Detects a Data Matrix Code in an image.</p>
            </summary>
            <returns><see cref="T:ZXing.Common.DetectorResult" />encapsulating results of detecting a Data Matrix Code or null</returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Detector.detectSolid1(ZXing.ResultPoint[])">
            <summary>
            Detect a solid side which has minimum transition.
            </summary>
            <param name="cornerPoints"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Detector.detectSolid2(ZXing.ResultPoint[])">
            <summary>
            Detect a second solid side next to first solid side.
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Detector.correctTopRight(ZXing.ResultPoint[])">
            <summary>
            Calculates the corner position of the white top right module.
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Detector.shiftToModuleCenter(ZXing.ResultPoint[])">
            <summary>
            Shift the edge points to the module center.
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Internal.Detector.transitionsBetween(ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.C40Encoder.handleEOD(ZXing.Datamatrix.Encoder.EncoderContext,System.Text.StringBuilder)">
            <summary>
            Handle "end of data" situations
            </summary>
            <param name="context">the encoder context</param>
            <param name="buffer">the buffer with the remaining encoded characters</param>
        </member>
        <member name="T:ZXing.Datamatrix.Encoder.DefaultPlacement">
            <summary>
            Symbol Character Placement Program. Adapted from Annex M.1 in ISO/IEC 16022:2000(E).
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.DefaultPlacement.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Main constructor
            </summary>
            <param name="codewords">the codewords to place</param>
            <param name="numcols">the number of columns</param>
            <param name="numrows">the number of rows</param>
        </member>
        <member name="P:ZXing.Datamatrix.Encoder.DefaultPlacement.Numrows">
            <summary>
            num rows
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.Encoder.DefaultPlacement.Numcols">
            <summary>
            num cols
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.Encoder.DefaultPlacement.Bits">
            <summary>
            bits
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.DefaultPlacement.getBit(System.Int32,System.Int32)">
            <summary>
            get a specific bit
            </summary>
            <param name="col"></param>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.DefaultPlacement.place">
            <summary>
            place
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.DefaultPlacement.utah(System.Int32,System.Int32,System.Int32)">
            <summary>
            Places the 8 bits of a utah-shaped symbol character in ECC200.
            </summary>
            <param name="row">The row.</param>
            <param name="col">The col.</param>
            <param name="pos">character position</param>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.EdifactEncoder.handleEOD(ZXing.Datamatrix.Encoder.EncoderContext,System.Text.StringBuilder)">
            <summary>
            Handle "end of data" situations
            </summary>
            <param name="context">the encoder context</param>
            <param name="buffer">the buffer with the remaining encoded characters</param>
        </member>
        <member name="T:ZXing.Datamatrix.Encoder.Encodation">
            <summary>
            Enumeration for encodation types
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.Encodation.ASCII">
            <summary>
            ASCII
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.Encodation.C40">
            <summary>
            C40
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.Encodation.TEXT">
            <summary>
            TEXT
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.Encodation.X12">
            <summary>
            X12
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.Encodation.EDIFACT">
            <summary>
            EDIFACT
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.Encodation.BASE256">
            <summary>
            BASE256
            </summary>
        </member>
        <member name="T:ZXing.Datamatrix.Encoder.ErrorCorrection">
            <summary>
            Error Correction Code for ECC200.
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.ErrorCorrection.FACTOR_SETS">
            <summary>
            Lookup table which factors to use for which number of error correction codewords.
            See FACTORS.
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.ErrorCorrection.FACTORS">
            <summary>
            Precomputed polynomial factors for ECC 200.
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.ErrorCorrection.encodeECC200(System.String,ZXing.Datamatrix.Encoder.SymbolInfo)">
            <summary>
            Creates the ECC200 error correction for an encoded message.
            </summary>
            <param name="codewords">The codewords.</param>
            <param name="symbolInfo">information about the symbol to be encoded</param>
            <returns>the codewords with interleaved error correction.</returns>
        </member>
        <member name="T:ZXing.Datamatrix.Encoder.HighLevelEncoder">
            <summary>
            DataMatrix ECC 200 data encoder following the algorithm described in ISO/IEC 16022:200(E) in
            annex S.
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.PAD">
            <summary>
            Padding character
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.LATCH_TO_C40">
            <summary>
            mode latch to C40 encodation mode
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.LATCH_TO_BASE256">
            <summary>
            mode latch to Base 256 encodation mode
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.FNC1">
            <summary>
            FNC1 Codeword
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.STRUCTURED_APPEND">
            <summary>
            Structured Append Codeword
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.READER_PROGRAMMING">
            <summary>
            Reader Programming
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.UPPER_SHIFT">
            <summary>
            Upper Shift
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.MACRO_05">
            <summary>
            05 Macro
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.MACRO_06">
            <summary>
            06 Macro
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.LATCH_TO_ANSIX12">
            <summary>
            mode latch to ANSI X.12 encodation mode
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.LATCH_TO_TEXT">
            <summary>
            mode latch to Text encodation mode
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.LATCH_TO_EDIFACT">
            <summary>
            mode latch to EDIFACT encodation mode
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.ECI">
            <summary>
            ECI character (Extended Channel Interpretation)
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.C40_UNLATCH">
            <summary>
            Unlatch from C40 encodation
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.X12_UNLATCH">
            <summary>
            Unlatch from X12 encodation
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.MACRO_05_HEADER">
            <summary>
            05 Macro header
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.MACRO_06_HEADER">
            <summary>
            06 Macro header
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.HighLevelEncoder.MACRO_TRAILER">
            <summary>
            Macro trailer
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.HighLevelEncoder.encodeHighLevel(System.String)">
            <summary>
            Performs message encoding of a DataMatrix message using the algorithm described in annex P
            of ISO/IEC 16022:2000(E).
            </summary>
            <param name="msg">the message</param>
            <returns>the encoded message (the char values range from 0 to 255)</returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.HighLevelEncoder.encodeHighLevel(System.String,ZXing.Datamatrix.Encoder.SymbolShapeHint,ZXing.Dimension,ZXing.Dimension,System.Int32)">
            <summary>
            Performs message encoding of a DataMatrix message using the algorithm described in annex P
            of ISO/IEC 16022:2000(E).
            </summary>
            <param name="msg">the message</param>
            <param name="shape">requested shape. May be {@code SymbolShapeHint.FORCE_NONE},{@code SymbolShapeHint.FORCE_SQUARE} or {@code SymbolShapeHint.FORCE_RECTANGLE}.</param>
            <param name="minSize">the minimum symbol size constraint or null for no constraint</param>
            <param name="maxSize">the maximum symbol size constraint or null for no constraint</param>
            <param name="defaultEncodation">encoding mode to start with</param>
            <returns>the encoded message (the char values range from 0 to 255)</returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.HighLevelEncoder.encodeHighLevel(System.String,ZXing.Datamatrix.Encoder.SymbolShapeHint,ZXing.Dimension,ZXing.Dimension,System.Int32,System.Boolean,System.Text.Encoding,System.Boolean)">
            <summary>
            Performs message encoding of a DataMatrix message using the algorithm described in annex P
            of ISO/IEC 16022:2000(E).
            </summary>
            <param name="msg">the message</param>
            <param name="shape">requested shape. May be {@code SymbolShapeHint.FORCE_NONE},{@code SymbolShapeHint.FORCE_SQUARE} or {@code SymbolShapeHint.FORCE_RECTANGLE}.</param>
            <param name="minSize">the minimum symbol size constraint or null for no constraint</param>
            <param name="maxSize">the maximum symbol size constraint or null for no constraint</param>
            <param name="defaultEncodation">encoding mode to start with</param>
            <param name="forceC40">enforce C40 encoding</param>
            <param name="encoding"></param>
            <param name="disableEci"></param>
            <returns>the encoded message (the char values range from 0 to 255)</returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.HighLevelEncoder.determineConsecutiveDigitCount(System.String,System.Int32)">
            <summary>
            Determines the number of consecutive characters that are encodable using numeric compaction.
            </summary>
            <param name="msg">the message</param>
            <param name="startpos">the start position within the message</param>
            <returns>the requested character count</returns>
        </member>
        <member name="T:ZXing.Datamatrix.Encoder.MinimalEncoder">
            <summary>
            Encoder that encodes minimally
            
            Algorithm:
            
            Uses Dijkstra to produce mathematically minimal encodings that are in some cases smaller than the results produced
            by the algorithm described in annex S in the specification ISO/IEC 16022:200(E). The biggest improvment of this
            algorithm over that one is the case when the algorithm enters the most inefficient mode, the B256 mode.The
            algorithm from the specification algorithm will exit this mode only if it encounters digits so that arbitrarily
            inefficient results can be produced if the postfix contains no digits.
            
            Multi ECI support and ECI switching:
            
            For multi language content the algorithm selects the most compact representation using ECI modes.Note that unlike
            the compaction algorithm used for QR-Codes, this implementation operates in two stages and therfore is not
            mathematically optimal.In the first stage, the input string is encoded minimally as a stream of ECI character set
            selectors and bytes encoded in the selected encoding.In this stage the algorithm might for example decide to
            encode ocurrences of the characters "\u0150\u015C" (O-double-acute, S-circumflex) in UTF-8 by a single ECI or
            alternatively by multiple ECIs that switch between IS0-8859-2 and ISO-8859-3 (e.g. in the case that the input
            contains many * characters from ISO-8859-2 (Latin 2) and few from ISO-8859-3 (Latin 3)).
            In a second stage this stream of ECIs and bytes is minimally encoded using the various Data Matrix encoding modes.
            While both stages encode mathematically minimally it is not ensured that the result is mathematically minimal since
            the size growth for inserting an ECI in the first stage can only be approximated as the first stage does not know
            in which mode the ECI will occur in the second stage(may, or may not require an extra latch to ASCII depending on
            the current mode). The reason for this shortcoming are difficulties in implementing it in a straightforward and
            readable manner.
            
            GS1 support
            
            FNC1 delimiters can be encoded in the input string by using the FNC1 character specified in the encoding function.
            When a FNC1 character is specified then a leading FNC1 will be encoded and all ocurrences of delimiter characters
            while result in FNC1 codewords in the symbol.
            
            @author Alex Geller
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.encodeHighLevel(System.String)">
             Performs message encoding of a DataMatrix message
            
             @param msg the message
             @return the encoded message (the char values range from 0 to 255)
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.encodeHighLevel(System.String,System.Text.Encoding,System.Int32,ZXing.Datamatrix.Encoder.SymbolShapeHint)">
             Performs message encoding of a DataMatrix message
            
             @param msg the message
             @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm
               chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority
               charset to encode any character in the input that can be encoded by it if the charset is among the
               supported charsets.
             @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1
               bar code. If the value is not -1 then a FNC1 is also prepended.
             @param shape requested shape.
             @return the encoded message (the char values range from 0 to 255)
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.encode(System.String,System.Text.Encoding,System.Int32,ZXing.Datamatrix.Encoder.SymbolShapeHint,System.Int32)">
             Encodes input minimally and returns an array of the codewords
            
             @param input The string to encode
             @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm
               chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority
               charset to encode any character in the input that can be encoded by it if the charset is among the
               supported charsets.
             @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1
               bar code. If the value is not -1 then a FNC1 is also prepended.
             @param shape requested shape.
             @param macroId Prepends the specified macro function in case that a value of 5 or 6 is specified.
             @return An array of bytes representing the codewords of a minimal encoding.
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.getNumberOfC40Words(ZXing.Datamatrix.Encoder.MinimalEncoder.Input,System.Int32,System.Boolean,System.Int32[])">
            @return the number of words in which the string starting at from can be encoded in c40 or text mode.
            The number of characters encoded is returned in characterLength.
            The number of characters encoded is also minimal in the sense that the algorithm stops as soon
            as a character encoding fills a C40 word competely (three C40 values). An exception is at the
            end of the string where two C40 values are allowed (according to the spec the third c40 value
            is filled  with 0 (Shift 1) in this case).
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.Edge.getEndMode">
            Returns Mode.ASCII in case that:
             - Mode is EDIFACT and characterLength is less than 4 or the remaining characters can be encoded in at most 2
               ASCII bytes.
             - Mode is C40, TEXT or X12 and the remaining characters can be encoded in at most 1 ASCII byte.
             Returns mode in all other cases.
            
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.Edge.getLastASCII">
            Peeks ahead and returns 1 if the postfix consists of exactly two digits, 2 if the postfix consists of exactly
              two consecutive digits and a non extended character or of 4 digits.
              Returns 0 in any other case
            
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.Edge.getMinSymbolSize(System.Int32)">
            Returns the capacity in codewords of the smallest symbol that has enough capacity to fit the given minimal
             number of codewords.
            
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.MinimalEncoder.Edge.getCodewordsRemaining(System.Int32)">
            Returns the remaining capacity in codewords of the smallest symbol that has enough capacity to fit the given
             minimal number of codewords.
            
        </member>
        <member name="P:ZXing.Datamatrix.Encoder.MinimalEncoder.Result.Size">
            @return the size in bytes
        </member>
        <member name="T:ZXing.Datamatrix.Encoder.SymbolInfo">
            <summary>
            Symbol info table for DataMatrix.
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.SymbolInfo.matrixWidth">
            <summary>
            matrix width
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.SymbolInfo.matrixHeight">
            <summary>
            matrix height
            </summary>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.overrideSymbolSet(ZXing.Datamatrix.Encoder.SymbolInfo[])">
             Overrides the symbol info set used by this class. Used for testing purposes.
            
             @param override the symbol info set to use
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="rectangular"></param>
            <param name="dataCapacity"></param>
            <param name="errorCodewords"></param>
            <param name="matrixWidth"></param>
            <param name="matrixHeight"></param>
            <param name="dataRegions"></param>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.lookup(System.Int32)">
            <summary>
            
            </summary>
            <param name="dataCodewords"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.lookup(System.Int32,ZXing.Datamatrix.Encoder.SymbolShapeHint)">
            <summary>
            
            </summary>
            <param name="dataCodewords"></param>
            <param name="shape"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.lookup(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="dataCodewords"></param>
            <param name="allowRectangular"></param>
            <param name="fail"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.lookup(System.Int32,ZXing.Datamatrix.Encoder.SymbolShapeHint,ZXing.Dimension,ZXing.Dimension,System.Boolean)">
            <summary>
            
            </summary>
            <param name="dataCodewords"></param>
            <param name="shape"></param>
            <param name="minSize"></param>
            <param name="maxSize"></param>
            <param name="fail"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getSymbolDataWidth">
            <summary>
            symbol data width
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getSymbolDataHeight">
            <summary>
            symbol data height
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getSymbolWidth">
            <summary>
            symbol width
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getSymbolHeight">
            <summary>
            symbol height
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getCodewordCount">
            <summary>
            codeword count
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getInterleavedBlockCount">
            <summary>
            interleaved block count
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getDataLengthForInterleavedBlock(System.Int32)">
            <summary>
            data length for interleaved block
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.getErrorLengthForInterleavedBlock(System.Int32)">
            <summary>
            error length for interleaved block
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Datamatrix.Encoder.SymbolInfo.ToString">
            <summary>
            user friendly representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Datamatrix.Encoder.SymbolShapeHint">
            <summary>
            Enumeration for DataMatrix symbol shape hint. It can be used to force square or rectangular
            symbols.   
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.SymbolShapeHint.FORCE_NONE">
            <summary>
            doesn't force anything
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.SymbolShapeHint.FORCE_SQUARE">
            <summary>
            forces square image
            </summary>
        </member>
        <member name="F:ZXing.Datamatrix.Encoder.SymbolShapeHint.FORCE_RECTANGLE">
            <summary>
            forces rectangle image
            </summary>
        </member>
        <member name="T:ZXing.Datamatrix.DatamatrixEncodingOptions">
            <summary>
            The class holds the available options for the DatamatrixWriter
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.DatamatrixEncodingOptions.SymbolShape">
            <summary>
            Specifies the matrix shape for Data Matrix
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.DatamatrixEncodingOptions.MinSize">
            <summary>
            Specifies a minimum barcode size
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.DatamatrixEncodingOptions.MaxSize">
            <summary>
            Specifies a maximum barcode size
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.DatamatrixEncodingOptions.DefaultEncodation">
            <summary>
            Specifies the default encodation
            Make sure that the content fits into the encodation value, otherwise there will be an exception thrown.
            standard value: Encodation.ASCII
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.DatamatrixEncodingOptions.CompactEncoding">
            <summary>
            Specifies whether to use compact mode for Data Matrix (type {@link Boolean}, or "true" or "false"
            The compact encoding mode also supports the encoding of characters that are not in the ISO-8859-1
            character set via ECIs.
            Please note that in that case, the most compact character encoding is chosen for characters in
            the input that are not in the ISO-8859-1 character set. Based on experience, some scanners do not
            support encodings like cp-1256 (Arabic). In such cases the encoding can be forced to UTF-8 by
            means of the {@link #CHARACTER_SET} encoding hint.
            Compact encoding also provides GS1-FNC1 support when {@link #GS1_FORMAT} is selected. In this case
            group-separator character (ASCII 29 decimal) can be used to encode the positions of FNC1 codewords
            for the purpose of delimiting AIs.
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.DatamatrixEncodingOptions.ForceC40">
            <summary>
            Forces C40 encoding for data-matrix (type {@link Boolean}, or "true" or "false") {@link String } value). This 
            option and {@link #DATA_MATRIX_COMPACT} are mutually exclusive.
            </summary>
        </member>
        <member name="P:ZXing.Datamatrix.DatamatrixEncodingOptions.CharacterSet">
            <summary>
            Specifies what character encoding to use where applicable (type {@link String})
            </summary>
        </member>
        <member name="T:ZXing.DecodeHintType">
            <summary>
            Encapsulates a type of hint that a caller may pass to a barcode reader to help it
            more quickly or accurately decode it. It is up to implementations to decide what,
            if anything, to do with the information that is supplied.
            <seealso cref="M:ZXing.Reader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})" />
            </summary>
            <author>Sean Owen</author>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="F:ZXing.DecodeHintType.OTHER">
            <summary>
            Unspecified, application-specific hint. Maps to an unspecified <see cref="T:System.Object" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.PURE_BARCODE">
            <summary>
            Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;
            use <see cref="T:System.Boolean" /> = true.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.POSSIBLE_FORMATS">
            <summary>
            Image is known to be of one of a few possible formats.
            Maps to a <see cref="T:System.Collections.ICollection" /> of <see cref="T:ZXing.BarcodeFormat" />s.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.TRY_HARDER">
            <summary>
            Spend more time to try to find a barcode; optimize for accuracy, not speed.
            Doesn't matter what it maps to; use <see cref="T:System.Boolean" /> = true.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.CHARACTER_SET">
            <summary>
            Specifies what character encoding to use when decoding, where applicable (type String)
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.ALLOWED_LENGTHS">
            <summary>
            Allowed lengths of encoded data -- reject anything else. Maps to an int[].
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.ASSUME_CODE_39_CHECK_DIGIT">
            <summary>
            Assume Code 39 codes employ a check digit. Maps to <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.NEED_RESULT_POINT_CALLBACK">
            <summary>
            The caller needs to be notified via callback when a possible <see cref="T:ZXing.ResultPoint" />
            is found. Maps to a <see cref="T:ZXing.ResultPointCallback" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.ASSUME_MSI_CHECK_DIGIT">
            <summary>
            Assume MSI codes employ a check digit. Maps to <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.USE_CODE_39_EXTENDED_MODE">
            <summary>
            if Code39 could be detected try to use extended mode for full ASCII character set
            Maps to <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.RELAXED_CODE_39_EXTENDED_MODE">
            <summary>
            Don't fail if a Code39 is detected but can't be decoded in extended mode.
            Return the raw Code39 result instead. Maps to <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.TRY_HARDER_WITHOUT_ROTATION">
            <summary>
            1D readers supporting rotation with TRY_HARDER enabled.
            But BarcodeReader class can do auto-rotating for 1D and 2D codes.
            Enabling that option prevents 1D readers doing double rotation.
            BarcodeReader enables that option automatically if "global" auto-rotation is enabled.
            Maps to <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.ASSUME_GS1">
            <summary>
            Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.
            For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;
            use <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.RETURN_CODABAR_START_END">
            <summary>
            If true, return the start and end digits in a Codabar barcode instead of stripping them. They
            are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them
            to not be. Doesn't matter what it maps to; use <see cref="T:System.Boolean" />.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.ALLOWED_EAN_EXTENSIONS">
            <summary>
            Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.
            Maps to an int[] of the allowed extension lengths, for example [2], [5], or [2, 5].
            If it is optional to have an extension, do not set this hint. If this is set,
            and a UPC or EAN barcode is found but an extension is not, then no result will be returned
            at all.
            </summary>
        </member>
        <member name="F:ZXing.DecodeHintType.ALSO_INVERTED">
            <summary>
            If true, also tries to decode as inverted image. All configured decoders are simply called a
            second time with an inverted image. Doesn't matter what it maps to; use {@link Boolean#TRUE}.
            </summary>
        </member>
        <member name="T:ZXing.Dimension">
            <summary>
            Simply encapsulates a width and height.
            </summary>
        </member>
        <member name="M:ZXing.Dimension.#ctor(System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="P:ZXing.Dimension.Width">
            <summary>
            the width
            </summary>
        </member>
        <member name="P:ZXing.Dimension.Height">
            <summary>
            the height
            </summary>
        </member>
        <member name="M:ZXing.Dimension.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Dimension.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.Dimension.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.EncodeHintType">
            <summary>
            These are a set of hints that you may pass to Writers to specify their behavior.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="F:ZXing.EncodeHintType.WIDTH">
            <summary>
            Specifies the width of the barcode image
            type: <see cref="T:System.Int32" />
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.HEIGHT">
            <summary>
            Specifies the height of the barcode image
            type: <see cref="T:System.Int32" />
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PURE_BARCODE">
            <summary>
            Don't put the content string into the output image.
            type: <see cref="T:System.Boolean" />
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.ERROR_CORRECTION">
            <summary>
            Specifies what degree of error correction to use, for example in QR Codes.
            Type depends on the encoder. For example for QR codes it's type
            <see cref="T:ZXing.QrCode.Internal.ErrorCorrectionLevel" />
            For Aztec it is of type <see cref="T:System.Int32" />, representing the minimal percentage of error correction words. 
            In all cases, it can also be a <see cref="T:System.String" /> representation of the desired value as well.
            Note: an Aztec symbol should have a minimum of 25% EC words.
            For PDF417 it is of type <see cref="T:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel"/> or <see cref="T:System.Int32" /> (between 0 and 8),
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.CHARACTER_SET">
            <summary>
            Specifies what character encoding to use where applicable.
            type: <see cref="T:System.String" />
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.MARGIN">
            <summary>
            Specifies margin, in pixels, to use when generating the barcode. The meaning can vary
            by format; for example it controls margin before and after the barcode horizontally for
            most 1D formats.
            type: <see cref="T:System.Int32" />, or <see cref="T:System.String" /> representation of the integer value
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PDF417_ASPECT_RATIO">
            <summary>
            Specifies the aspect ratio to use.  Default is 4.
            type: <see cref="T:ZXing.PDF417.Internal.PDF417AspectRatio" />, or 1-4.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PDF417_IMAGE_ASPECT_RATIO">
            <summary>
            Specifies the desired aspect ratio (number of columns / number of rows) of the output image.  Default is 3.
            type: <see cref="T:System.Single" />.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PDF417_COMPACT">
            <summary>
            Specifies whether to use compact mode for PDF417
            type: <see cref="T:System.Boolean" />, or "true" or "false"
            <see cref="T:System.String" /> value
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PDF417_COMPACTION">
            <summary>
            Specifies what compaction mode to use for PDF417.
            type: <see cref="T:ZXing.PDF417.Internal.Compaction" /> or <see cref="T:System.String" /> value of one of its
            enum values
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PDF417_DIMENSIONS">
            <summary>
            Specifies the minimum and maximum number of rows and columns for PDF417.
            type: <see cref="T:ZXing.PDF417.Internal.Dimensions" />
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PDF417_MACRO_META_DATA">
            <summary>
            The Specifies that the PDF417 will contain macro metadata.
            type: <see cref="T:ZXing.PDF417.PDF417MacroMetadata"/>
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.DISABLE_ECI">
            <summary>
            Don't append ECI segment.
            That is against the specification of QR Code but some
            readers have problems if the charset is switched from
            ISO-8859-1 (default) to UTF-8 with the necessary ECI segment.
            If you set the property to true you can use UTF-8 encoding
            and the ECI segment is omitted.
            type: <see cref="T:System.Boolean" />
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.DATA_MATRIX_SHAPE">
            <summary>
            Specifies the matrix shape for Data Matrix (type <see cref="T:ZXing.Datamatrix.Encoder.SymbolShapeHint"/>)
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.MIN_SIZE">
            <summary>
            Specifies a minimum barcode size (type <see cref="T:ZXing.Dimension"/>). Only applicable to Data Matrix now.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.MAX_SIZE">
            <summary>
            Specifies a maximum barcode size (type <see cref="T:ZXing.Dimension"/>). Only applicable to Data Matrix now.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.CODE128_FORCE_CODESET_B">
            <summary>
            if true, don't switch to codeset C for numbers
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.DATA_MATRIX_DEFAULT_ENCODATION">
            <summary>
            Specifies the default encodation for Data Matrix (type <see cref="T:ZXing.Datamatrix.Encoder.Encodation"/>)
            Make sure that the content fits into the encodation value, otherwise there will be an exception thrown.
            standard value: Encodation.ASCII
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.AZTEC_LAYERS">
            <summary>
            Specifies the required number of layers for an Aztec code.
            A negative number (-1, -2, -3, -4) specifies a compact Aztec code
            0 indicates to use the minimum number of layers (the default)
            A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code
            type: <see cref="T:System.Int32" />, or <see cref="T:System.String" /> representation of the integer value
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.QR_VERSION">
            <summary>
            Specifies the exact version of QR code to be encoded.
            (Type <see cref="T:System.Int32" />, or <see cref="T:System.String" /> representation of the integer value).
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.GS1_FORMAT">
            <summary>
            Specifies whether the data should be encoded to the GS1 standard
            type: <see cref="T:System.Boolean" />, or "true" or "false"
            <see cref="T:System.String" /> value
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.QR_MASK_PATTERN">
            <summary>
             Specifies the QR code mask pattern to be used. Allowed values are
            0..QRCode.NUM_MASK_PATTERNS-1. By default the code will automatically select
            the optimal mask pattern.
            (Type <see cref="T:System.Int32" />, or <see cref="T:System.String" /> representation of the integer value).
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.FORCE_CODE_SET">
            <summary>
            Forces which encoding will be used. Currently only used for Code-128 code sets (Type <see cref="T:System.String" />).
            Valid values are "A", "B", "C".
            see also CODE128_FORCE_CODESET_B
            This option and {@link #CODE128_COMPACT} are mutually exclusive.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.QR_COMPACT">
            <summary>
            Specifies whether to use compact mode for QR code (type <see cref="T:System.Boolean" />, or "true" or "false"
            Please note that when compaction is performed, the most compact character encoding is chosen
            for characters in the input that are not in the ISO-8859-1 character set. Based on experience,
            some scanners do not support encodings like cp-1256 (Arabic). In such cases the encoding can
            be forced to UTF-8 by means of the <see cref="F:ZXing.EncodeHintType.CHARACTER_SET"/> encoding hint.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.NO_PADDING">
            <summary>
            if set to true, barcode writer uses WIDTH and HEIGHT as maximum values and in combination with MARGIN=0
            there is no white border added. The resulting image would be smaller than the requested size.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.DATA_MATRIX_COMPACT">
            <summary>
            Specifies whether to use compact mode for Data Matrix (type {@link Boolean}, or "true" or "false"
            The compact encoding mode also supports the encoding of characters that are not in the ISO-8859-1
            character set via ECIs.
            Please note that in that case, the most compact character encoding is chosen for characters in
            the input that are not in the ISO-8859-1 character set. Based on experience, some scanners do not
            support encodings like cp-1256 (Arabic). In such cases the encoding can be forced to UTF-8 by
            means of the {@link #CHARACTER_SET} encoding hint.
            Compact encoding also provides GS1-FNC1 support when {@link #GS1_FORMAT} is selected. In this case
            group-separator character (ASCII 29 decimal) can be used to encode the positions of FNC1 codewords
            for the purpose of delimiting AIs.
            This option and {@link #FORCE_C40} are mutually exclusive.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.CODE128_COMPACT">
            <summary>
            Specifies whether to use compact mode for Code-128 code (type {@link Boolean}, or "true" or "false"
            This can yield slightly smaller bar codes. This option and {@link #FORCE_CODE_SET} are mutually
            exclusive options.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.FORCE_C40">
            <summary>
            Forces C40 encoding for data-matrix (type {@link Boolean}, or "true" or "false") {@link String } value). This 
            option and {@link #DATA_MATRIX_COMPACT} are mutually exclusive.
            </summary>
        </member>
        <member name="F:ZXing.EncodeHintType.PDF417_AUTO_ECI">
            <summary>
            Specifies whether to automatically insert ECIs when encoding PDF417 (type {@link Boolean}, or "true" or "false"
            {@link String} value). 
            Please note that in that case, the most compact character encoding is chosen for characters in
            the input that are not in the ISO-8859-1 character set. Based on experience, some scanners do not
            support encodings like cp-1256 (Arabic). In such cases the encoding can be forced to UTF-8 by
            means of the {@link #CHARACTER_SET} encoding hint.
            </summary>
        </member>
        <member name="T:ZXing.FormatException">
            <summary>
            Thrown when a barcode was successfully detected, but some aspect of
            the content did not conform to the barcode's format rules. This could have
            been due to a mis-detection.
            <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.FormatException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.FormatException.#ctor(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.FormatException.#ctor(System.Exception)">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.FormatException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
        </member>
        <member name="T:ZXing.IBarcodeReader">
            <summary>
            Interface for a smart class to decode the barcode inside a bitmap object
            </summary>
            <summary>
            Interface for a smart class to decode the barcode inside a bitmap object
            </summary>
            <summary>
            Interface for a smart class to decode multiple barcodes inside a bitmap object
            </summary>
            <summary>
            Interface for a smart class to decode multiple barcodes inside a bitmap object
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeReader.Decode(UnityEngine.Color32[],System.Int32,System.Int32)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="rawColor32">The image as Color32 array.</param>
            <param name="width">the width of the image which is represented by rawColor32</param>
            <param name="height">the height of the image which is represented by rawColor32</param>
            <returns>the result data or null</returns>
        </member>
        <member name="E:ZXing.IBarcodeReader.ResultPointFound">
            <summary>
            event is executed when a result point was found
            </summary>
        </member>
        <member name="E:ZXing.IBarcodeReader.ResultFound">
            <summary>
            event is executed when a result was found via decode
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeReader.Options">
            <summary>
            Specifies some options which influence the decoding process
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeReader.Decode(System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            Decodes the specified barcode bitmap which is given by a generic byte array with the order RGB24.
            </summary>
            <param name="rawRGB">The image as RGB24 array.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="format">The format.</param>
            <returns>
            the result data or null
            </returns>
        </member>
        <member name="M:ZXing.IBarcodeReader.Decode(ZXing.LuminanceSource)">
            <summary>
            Tries to decode a barcode within an image which is given by a luminance source.
            That method gives a chance to prepare a luminance source completely before calling
            the time consuming decoding method. On the other hand there is a chance to create
            a luminance source which is independent from external resources (like Bitmap objects)
            and the decoding call can be made in a background thread.
            </summary>
            <param name="luminanceSource">The luminance source.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.IBarcodeReader.DecodeMultiple(UnityEngine.Color32[],System.Int32,System.Int32)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="rawColor32">The image as Color32 array.</param>
            <param name="width">the width of the image which is represented by rawColor32</param>
            <param name="height">the height of the image which is represented by rawColor32</param>
            <returns>the result data or null</returns>
        </member>
        <member name="M:ZXing.IBarcodeReader.DecodeMultiple(System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            Decodes the specified barcode bitmap which is given by a generic byte array with the order RGB24.
            </summary>
            <param name="rawRGB">The image as RGB24 array.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="format">The format.</param>
            <returns>
            the result data or null
            </returns>
        </member>
        <member name="M:ZXing.IBarcodeReader.DecodeMultiple(ZXing.LuminanceSource)">
            <summary>
            Tries to decode barcodes within an image which is given by a luminance source.
            That method gives a chance to prepare a luminance source completely before calling
            the time consuming decoding method. On the other hand there is a chance to create
            a luminance source which is independent from external resources (like Bitmap objects)
            and the decoding call can be made in a background thread.
            </summary>
            <param name="luminanceSource">The luminance source.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.IBarcodeReader`1">
            <summary>
            Interface for a smart class to decode the barcode inside a bitmap object
            </summary>
            <summary>
            Interface for a smart class to decode multiple barcodes inside a bitmap object
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeReader`1.Decode(`0)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="barcodeBitmap">The barcode bitmap.</param>
            <returns>the result data or null</returns>
        </member>
        <member name="M:ZXing.IBarcodeReader`1.DecodeMultiple(`0)">
            <summary>
            Decodes the specified barcode bitmap.
            </summary>
            <param name="barcodeBitmap">The barcode bitmap.</param>
            <returns>the result data or null</returns>
        </member>
        <member name="T:ZXing.IBarcodeReaderGeneric">
            <summary>
            Interface for a smart class to decode the barcode inside a bitmap object
            </summary>
            <summary>
            Interface for a smart class to decode multiple barcodes inside a bitmap object
            </summary>
        </member>
        <member name="E:ZXing.IBarcodeReaderGeneric.ResultPointFound">
            <summary>
            event is executed when a result point was found
            </summary>
        </member>
        <member name="E:ZXing.IBarcodeReaderGeneric.ResultFound">
            <summary>
            event is executed when a result was found via decode
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeReaderGeneric.Options">
            <summary>
            Specifies some options which influence the decoding process
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeReaderGeneric.Decode(System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            Decodes the specified barcode bitmap which is given by a generic byte array.
            </summary>
            <param name="rawRGB">The barcode bitmap.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="format">The format.</param>
            <returns>
            the result data or null
            </returns>
        </member>
        <member name="M:ZXing.IBarcodeReaderGeneric.Decode(ZXing.LuminanceSource)">
            <summary>
            Tries to decode a barcode within an image which is given by a luminance source.
            That method gives a chance to prepare a luminance source completely before calling
            the time consuming decoding method. On the other hand there is a chance to create
            a luminance source which is independent from external resources (like Bitmap objects)
            and the decoding call can be made in a background thread.
            </summary>
            <param name="luminanceSource">The luminance source.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.IBarcodeReaderGeneric.DecodeMultiple(System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            Decodes the specified barcode bitmap which is given by a generic byte array with the order RGB24.
            </summary>
            <param name="rawRGB">The barcode bitmap.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="format">The format.</param>
            <returns>
            the result data or null
            </returns>
        </member>
        <member name="M:ZXing.IBarcodeReaderGeneric.DecodeMultiple(ZXing.LuminanceSource)">
            <summary>
            Tries to decode barcodes within an image which is given by a luminance source.
            That method gives a chance to prepare a luminance source completely before calling
            the time consuming decoding method. On the other hand there is a chance to create
            a luminance source which is independent from external resources (like Bitmap objects)
            and the decoding call can be made in a background thread.
            </summary>
            <param name="luminanceSource">The luminance source.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.IBarcodeWriter">
            <summary>
            Interface for a smart class to encode some content into a barcode
            </summary>
            <summary>
            Interface for a smart class to encode some content into a barcode
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriter.Write(System.String)">
            <summary>
            Creates a visual representation of the contents
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriter.Write(ZXing.Common.BitMatrix)">
            <summary>
            Returns a rendered instance of the barcode which is given by a BitMatrix.
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeWriter.Format">
            <summary>
            Get or sets the barcode format which should be generated
            (only suitable if MultiFormatWriter is used for property Encoder which is the default)
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeWriter.Options">
            <summary>
            Gets or sets the options container for the encoding and renderer process.
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeWriter.Encoder">
            <summary>
            Gets or sets the writer which encodes the content to a BitMatrix.
            If no value is set the MultiFormatWriter is used.
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriter.Encode(System.String)">
            <summary>
            Encodes the specified contents.
            </summary>
            <param name="contents">The contents.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.IBarcodeWriterPixelData">
            <summary>
            Interface for a smart class to encode some content into a barcode
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriterPixelData.Write(System.String)">
            <summary>
            Creates a visual representation of the contents
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriterPixelData.Write(ZXing.Common.BitMatrix)">
            <summary>
            Returns a rendered instance of the barcode which is given by a BitMatrix.
            </summary>
        </member>
        <member name="T:ZXing.IBarcodeWriterSvg">
            <summary>
            Interface for a smart class to encode some content into a barcode
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriterSvg.Write(System.String)">
            <summary>
            Creates a visual representation of the contents
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriterSvg.Write(ZXing.Common.BitMatrix)">
            <summary>
            Returns a rendered instance of the barcode which is given by a BitMatrix.
            </summary>
        </member>
        <member name="T:ZXing.IBarcodeWriter`1">
            <summary>
            Interface for a smart class to encode some content into a barcode
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriter`1.Write(System.String)">
            <summary>
            Creates a visual representation of the contents
            </summary>
            <param name="contents">The contents.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.IBarcodeWriter`1.Write(ZXing.Common.BitMatrix)">
            <summary>
            Returns a rendered instance of the barcode which is given by a BitMatrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.IBarcodeWriterGeneric">
            <summary>
            Interface for a smart class to encode some content into a barcode
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeWriterGeneric.Format">
            <summary>
            Get or sets the barcode format which should be generated
            (only suitable if MultiFormatWriter is used for property Encoder which is the default)
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeWriterGeneric.Options">
            <summary>
            Gets or sets the options container for the encoding and renderer process.
            </summary>
        </member>
        <member name="P:ZXing.IBarcodeWriterGeneric.Encoder">
            <summary>
            Gets or sets the writer which encodes the content to a BitMatrix.
            If no value is set the MultiFormatWriter is used.
            </summary>
        </member>
        <member name="M:ZXing.IBarcodeWriterGeneric.Encode(System.String)">
            <summary>
            Encodes the specified contents.
            </summary>
            <param name="contents">The contents.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.IMB.IMBReader">
            <summary>
            implements an Intelligent Mail barcode
            <author>Rishabh Hatgadkar</author>
            </summary>
        </member>
        <member name="M:ZXing.IMB.IMBReader.doDecode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            decode the image
            </summary>
            <param name="image"></param>
            <param name="hints"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.IMB.IMBReader.reset">
            <summary>
            resets internal state
            </summary>
        </member>
        <member name="M:ZXing.IMB.IMBReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="T:ZXing.InvertedLuminanceSource">
            <summary>
            A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes
            white and vice versa, and each value becomes (255-value).
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.InvertedLuminanceSource.#ctor(ZXing.LuminanceSource)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.InvertedLuminanceSource"/> class.
            </summary>
            <param name="delegate">The @delegate.</param>
        </member>
        <member name="M:ZXing.InvertedLuminanceSource.getRow(System.Int32,System.Byte[])">
            <summary>
            Fetches one row of luminance data from the underlying platform's bitmap. Values range from
            0 (black) to 255 (white). Because Java does not have an unsigned byte type, callers will have
            to bitwise and with 0xff for each value. It is preferable for implementations of this method
            to only fetch this row rather than the whole image, since no 2D Readers may be installed and
            getMatrix() may never be called.
            </summary>
            <param name="y">The row to fetch, 0 &lt;= y &lt; Height.</param>
            <param name="row">An optional preallocated array. If null or too small, it will be ignored.
            Always use the returned object, and ignore the .length of the array.</param>
            <returns>
            An array containing the luminance data.
            </returns>
        </member>
        <member name="P:ZXing.InvertedLuminanceSource.Matrix">
            <summary>
            Fetches luminance data for the underlying bitmap. Values should be fetched using:
            int luminance = array[y * width + x] &amp; 0xff;
            </summary>
            <returns> A row-major 2D array of luminance values. Do not use result.length as it may be
            larger than width * height bytes on some platforms. Do not modify the contents
            of the result.
              </returns>
        </member>
        <member name="P:ZXing.InvertedLuminanceSource.CropSupported">
            <summary>
            </summary>
            <returns> Whether this subclass supports cropping.</returns>
        </member>
        <member name="M:ZXing.InvertedLuminanceSource.crop(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new object with cropped image data. Implementations may keep a reference to the
            original data rather than a copy. Only callable if CropSupported is true.
            </summary>
            <param name="left">The left coordinate, 0 &lt;= left &lt; Width.</param>
            <param name="top">The top coordinate, 0 &lt;= top &lt;= Height.</param>
            <param name="width">The width of the rectangle to crop.</param>
            <param name="height">The height of the rectangle to crop.</param>
            <returns>
            A cropped version of this object.
            </returns>
        </member>
        <member name="P:ZXing.InvertedLuminanceSource.RotateSupported">
            <summary>
            </summary>
            <returns> Whether this subclass supports counter-clockwise rotation.</returns>
        </member>
        <member name="M:ZXing.InvertedLuminanceSource.invert">
            <summary>
            Inverts this instance.
            </summary>
            <returns>original delegate {@link LuminanceSource} since invert undoes itself</returns>
        </member>
        <member name="M:ZXing.InvertedLuminanceSource.rotateCounterClockwise">
            <summary>
            Returns a new object with rotated image data by 90 degrees counterclockwise.
            Only callable if {@link #isRotateSupported()} is true.
            </summary>
            <returns>
            A rotated version of this object.
            </returns>
        </member>
        <member name="M:ZXing.InvertedLuminanceSource.rotateCounterClockwise45">
            <summary>
            Returns a new object with rotated image data by 45 degrees counterclockwise.
            Only callable if {@link #isRotateSupported()} is true.
            </summary>
            <returns>
            A rotated version of this object.
            </returns>
        </member>
        <member name="T:ZXing.LuminanceSource">
            <summary>
            The purpose of this class hierarchy is to abstract different bitmap implementations across
            platforms into a standard interface for requesting greyscale luminance values. The interface
            only provides immutable methods; therefore crop and rotation create copies. This is to ensure
            that one Reader does not modify the original luminance source and leave it in an unknown state
            for other Readers in the chain.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="M:ZXing.LuminanceSource.#ctor(System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:ZXing.LuminanceSource.getRow(System.Int32,System.Byte[])">
            <summary>
            Fetches one row of luminance data from the underlying platform's bitmap. Values range from
            0 (black) to 255 (white). Because Java does not have an unsigned byte type, callers will have
            to bitwise and with 0xff for each value. It is preferable for implementations of this method
            to only fetch this row rather than the whole image, since no 2D Readers may be installed and
            getMatrix() may never be called.
            </summary>
            <param name="y">The row to fetch, which must be in [0, bitmap height)</param>
            <param name="row">An optional preallocated array. If null or too small, it will be ignored.
            Always use the returned object, and ignore the .length of the array.
            </param>
            <returns> An array containing the luminance data.</returns>
        </member>
        <member name="P:ZXing.LuminanceSource.Matrix">
            <summary>
            Fetches luminance data for the underlying bitmap. Values should be fetched using:
            <code>int luminance = array[y * width + x] &amp; 0xff</code>
            </summary>
            <returns>
            A row-major 2D array of luminance values. Do not use result.length as it may be
            larger than width * height bytes on some platforms. Do not modify the contents
            of the result.
            </returns>
        </member>
        <member name="P:ZXing.LuminanceSource.Width">
            <returns> The width of the bitmap.</returns>
        </member>
        <member name="P:ZXing.LuminanceSource.Height">
            <returns> The height of the bitmap.</returns>
        </member>
        <member name="P:ZXing.LuminanceSource.CropSupported">
            <returns> Whether this subclass supports cropping.</returns>
        </member>
        <member name="M:ZXing.LuminanceSource.crop(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> 
            Returns a new object with cropped image data. Implementations may keep a reference to the
            original data rather than a copy. Only callable if CropSupported is true.
            </summary>
            <param name="left">The left coordinate, which must be in [0, Width)</param>
            <param name="top">The top coordinate, which must be in [0, Height)</param>
            <param name="width">The width of the rectangle to crop.</param>
            <param name="height">The height of the rectangle to crop.</param>
            <returns> A cropped version of this object.</returns>
        </member>
        <member name="P:ZXing.LuminanceSource.RotateSupported">
            <returns> Whether this subclass supports counter-clockwise rotation.</returns>
        </member>
        <member name="M:ZXing.LuminanceSource.rotateCounterClockwise">
            <summary>
            Returns a new object with rotated image data by 90 degrees counterclockwise.
            Only callable if <see cref="P:ZXing.LuminanceSource.RotateSupported"/> is true.
            </summary>
            <returns>A rotated version of this object.</returns>
        </member>
        <member name="M:ZXing.LuminanceSource.rotateCounterClockwise45">
            <summary>
            Returns a new object with rotated image data by 45 degrees counterclockwise.
            Only callable if <see cref="P:ZXing.LuminanceSource.RotateSupported"/> is true.
            </summary>
            <returns>A rotated version of this object.</returns>
        </member>
        <member name="P:ZXing.LuminanceSource.InversionSupported">
            <summary>
            </summary>
            <returns>Whether this subclass supports invertion.</returns>
        </member>
        <member name="M:ZXing.LuminanceSource.invert">
            <summary>
            inverts the luminance values, not supported here. has to implemented in sub classes
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.LuminanceSource.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.Maxicode.Internal.BitMatrixParser">
            <summary>
            <author>mike32767</author>
            <author>Manuel Kasten</author>
            </summary>
        </member>
        <member name="M:ZXing.Maxicode.Internal.BitMatrixParser.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            <param name="bitMatrix"><see cref="T:ZXing.Common.BitMatrix" />to parse</param>
            </summary>
        </member>
        <member name="T:ZXing.Maxicode.Internal.DecodedBitStreamParser">
             <summary>
             <p>MaxiCodes can encode text or structured information as bits in one of several modes,
             with multiple character sets in one code. This class decodes the bits back into text.</p>
            
             <author>mike32767</author>
             <author>Manuel Kasten</author>
             </summary>
        </member>
        <member name="T:ZXing.Maxicode.Internal.Decoder">
             <summary>
             <p>The main class which implements MaxiCode decoding -- as opposed to locating and extracting
             the MaxiCode from an image.</p>
            
             <author>Manuel Kasten</author>
             </summary>
        </member>
        <member name="M:ZXing.Maxicode.Internal.Decoder.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:ZXing.Maxicode.Internal.Decoder.decode(ZXing.Common.BitMatrix)">
            <summary>
            decode the bits
            </summary>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Maxicode.Internal.Decoder.decode(ZXing.Common.BitMatrix,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            decode the bits
            </summary>
            <param name="bits"></param>
            <param name="hints"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Maxicode.MaxiCodeReader">
            <summary>
            This implementation can detect and decode a MaxiCode in an image.
            </summary>
        </member>
        <member name="M:ZXing.Maxicode.MaxiCodeReader.decode(ZXing.BinaryBitmap)">
             <summary>
             Locates and decodes a MaxiCode in an image.
            
             <returns>a String representing the content encoded by the MaxiCode</returns>
             <exception cref="T:ZXing.FormatException">if a MaxiCode cannot be decoded</exception>
             </summary>
        </member>
        <member name="M:ZXing.Maxicode.MaxiCodeReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes a MaxiCode within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:ZXing.DecodeHintType"/>
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.Maxicode.MaxiCodeReader.reset">
            <summary>
            does nothing here
            </summary>
        </member>
        <member name="M:ZXing.Maxicode.MaxiCodeReader.extractPureBits(ZXing.Common.BitMatrix)">
             <summary>
             This method detects a code in a "pure" image -- that is, pure monochrome image
             which contains only an unrotated, unskewed, image of a code, with some white border
             around it. This is a specialized method that works exceptionally fast in this special
             case.
            
             <seealso cref="M:ZXing.Datamatrix.DataMatrixReader.extractPureBits(ZXing.Common.BitMatrix)" />
             <seealso cref="M:ZXing.QrCode.QRCodeReader.extractPureBits(ZXing.Common.BitMatrix)" />
             </summary>
        </member>
        <member name="T:ZXing.MultiFormatReader">
            <summary>
            MultiFormatReader is a convenience class and the main entry point into the library for most uses.
            By default it attempts to decode all barcode formats that the library supports. Optionally, you
            can provide a hints object to request different behavior, for example only decoding QR codes.
            </summary>
            <author>Sean Owen</author>
            <author>dswitkin@google.com (Daniel Switkin)</author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source</author>
        </member>
        <member name="M:ZXing.MultiFormatReader.decode(ZXing.BinaryBitmap)">
            <summary> This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it
            passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.
            Use setHints() followed by decodeWithState() for continuous scan applications.
            
            </summary>
            <param name="image">The pixel data to decode
            </param>
            <returns> The contents of the image
            </returns>
            <throws>  ReaderException Any errors which occurred </throws>
        </member>
        <member name="M:ZXing.MultiFormatReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary> Decode an image using the hints provided. Does not honor existing state.
            
            </summary>
            <param name="image">The pixel data to decode
            </param>
            <param name="hints">The hints to use, clearing the previous state.
            </param>
            <returns> The contents of the image
            </returns>
            <throws>  ReaderException Any errors which occurred </throws>
        </member>
        <member name="M:ZXing.MultiFormatReader.decodeWithState(ZXing.BinaryBitmap)">
            <summary> Decode an image using the state set up by calling setHints() previously. Continuous scan
            clients will get a <b>large</b> speed increase by using this instead of decode().
            
            </summary>
            <param name="image">The pixel data to decode
            </param>
            <returns> The contents of the image
            </returns>
            <throws>  ReaderException Any errors which occurred </throws>
        </member>
        <member name="P:ZXing.MultiFormatReader.Hints">
            <summary> This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls
            to decodeWithState(image) can reuse the same set of readers without reallocating memory. This
            is important for performance in continuous scan clients.
            
            </summary>
        </member>
        <member name="M:ZXing.MultiFormatReader.reset">
            <summary>
            resets all specific readers
            </summary>
        </member>
        <member name="T:ZXing.MultiFormatWriter">
            <summary> This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat
            requested and encodes the barcode with the supplied contents.
            
            </summary>
            <author>  dswitkin@google.com (Daniel Switkin)
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="P:ZXing.MultiFormatWriter.SupportedWriters">
            <summary>
            Gets the collection of supported writers.
            </summary>
        </member>
        <member name="M:ZXing.MultiFormatWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            encode the given data
            </summary>
            <param name="contents"></param>
            <param name="format"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.MultiFormatWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            encode the given data
            </summary>
            <param name="contents"></param>
            <param name="format"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="hints"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Multi.ByQuadrantReader">
            <summary>
            This class attempts to decode a barcode from an image, not by scanning the whole image,
            but by scanning subsets of the image. This is important when there may be multiple barcodes in
            an image, and detecting a barcode may find parts of multiple barcode and fail to decode
            (e.g. QR Codes). Instead this scans the four quadrants of the image -- and also the center
            'quadrant' to cover the case where a barcode is found in the center.
            </summary>
            <seealso cref="T:ZXing.Multi.GenericMultipleBarcodeReader" />
        </member>
        <member name="M:ZXing.Multi.ByQuadrantReader.#ctor(ZXing.Reader)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Multi.ByQuadrantReader"/> class.
            </summary>
            <param name="delegate">The @delegate.</param>
        </member>
        <member name="M:ZXing.Multi.ByQuadrantReader.decode(ZXing.BinaryBitmap)">
            <summary>
            Locates and decodes a barcode in some format within an image.
            </summary>
            <param name="image">image of barcode to decode</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.Multi.ByQuadrantReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes a barcode in some format within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:ZXing.DecodeHintType"/>
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.Multi.ByQuadrantReader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="T:ZXing.Multi.GenericMultipleBarcodeReader">
            <summary>
              <p>Attempts to locate multiple barcodes in an image by repeatedly decoding portion of the image.
            After one barcode is found, the areas left, above, right and below the barcode's
            {@link com.google.zxing.ResultPoint}s are scanned, recursively.</p>
              <p>A caller may want to also employ {@link ByQuadrantReader} when attempting to find multiple
            2D barcodes, like QR Codes, in an image, where the presence of multiple barcodes might prevent
            detecting any one of them.</p>
              <p>That is, instead of passing a {@link Reader} a caller might pass
              <code>new ByQuadrantReader(reader)</code>.</p>
              <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.Multi.GenericMultipleBarcodeReader.#ctor(ZXing.Reader)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Multi.GenericMultipleBarcodeReader"/> class.
            </summary>
            <param name="delegate">The @delegate.</param>
        </member>
        <member name="M:ZXing.Multi.GenericMultipleBarcodeReader.decodeMultiple(ZXing.BinaryBitmap)">
            <summary>
            Decodes the multiple.
            </summary>
            <param name="image">The image.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Multi.GenericMultipleBarcodeReader.decodeMultiple(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Decodes the multiple.
            </summary>
            <param name="image">The image.</param>
            <param name="hints">The hints.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Multi.GenericMultipleBarcodeReader.decode(ZXing.BinaryBitmap)">
            <summary>
            Locates and decodes a barcode in some format within an image.
            </summary>
            <param name="image">image of barcode to decode</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.Multi.GenericMultipleBarcodeReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes a barcode in some format within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:ZXing.DecodeHintType"/>
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.Multi.GenericMultipleBarcodeReader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="T:ZXing.Multi.MultipleBarcodeReader">
            <summary>
            Implementation of this interface attempt to read several barcodes from one image.
            <author>Sean Owen</author>
            	<seealso cref="T:ZXing.Reader"/>
            </summary>
        </member>
        <member name="M:ZXing.Multi.MultipleBarcodeReader.decodeMultiple(ZXing.BinaryBitmap)">
            <summary>
            Decodes the multiple.
            </summary>
            <param name="image">The image.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Multi.MultipleBarcodeReader.decodeMultiple(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Decodes the multiple.
            </summary>
            <param name="image">The image.</param>
            <param name="hints">The hints.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Multi.QrCode.Internal.MultiDetector">
             <summary>
             <p>Encapsulates logic that can detect one or more QR Codes in an image, even if the QR Code
             is rotated or skewed, or partially obscured.</p>
            
             <author>Sean Owen</author>
             <author>Hannes Erven</author>
             </summary>
        </member>
        <member name="M:ZXing.Multi.QrCode.Internal.MultiDetector.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Multi.QrCode.Internal.MultiDetector"/> class.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="M:ZXing.Multi.QrCode.Internal.MultiDetector.detectMulti(System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Detects the multi.
            </summary>
            <param name="hints">The hints.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder">
             <summary>
             <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square
             markers at three corners of a QR Code.</p>
            
             <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>
            
             <p>In contrast to <see cref="T:ZXing.QrCode.Internal.FinderPatternFinder" />, this class will return an array of all possible
             QR code locations in the image.</p>
            
             <p>Use the TRY_HARDER hint to ask for a more thorough detection.</p>
            
             <author>Sean Owen</author>
             <author>Hannes Erven</author>
             </summary>
        </member>
        <member name="F:ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder.DIFF_MODSIZE_CUTOFF_PERCENT">
            <summary>
            More or less arbitrary cutoff point for determining if two finder patterns might belong
            to the same code if they differ less than DIFF_MODSIZE_CUTOFF_PERCENT percent in their
            estimated modules sizes.
            </summary>
        </member>
        <member name="F:ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder.DIFF_MODSIZE_CUTOFF">
            <summary>
            More or less arbitrary cutoff point for determining if two finder patterns might belong
            to the same code if they differ less than DIFF_MODSIZE_CUTOFF pixels/module in their
            estimated modules sizes.
            </summary>
        </member>
        <member name="T:ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder.ModuleSizeComparator">
            <summary>
            A comparator that orders FinderPatterns by their estimated module size.
            </summary>
        </member>
        <member name="M:ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder.#ctor(ZXing.Common.BitMatrix,ZXing.ResultPointCallback)">
             <summary>
             <p>Creates a finder that will search the image for three finder patterns.</p>
            
             <param name="image">image to search</param>
             <param name="resultPointCallback">callback for result points</param>
             </summary>
        </member>
        <member name="M:ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder.selectMultipleBestPatterns">
            <summary>
            </summary>
            <returns>the 3 best <see cref="T:ZXing.QrCode.Internal.FinderPattern" />s from our list of candidates. The "best" are
                    those that have been detected at least CENTER_QUORUM times, and whose module
                    size differs from the average among those patterns the least
            </returns>
        </member>
        <member name="M:ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder.findMulti(System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            try to find patterns
            </summary>
            <param name="hints"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Multi.QrCode.QRCodeMultiReader">
            <summary>
            This implementation can detect and decode multiple QR Codes in an image.
            </summary>
        </member>
        <member name="M:ZXing.Multi.QrCode.QRCodeMultiReader.decodeMultiple(ZXing.BinaryBitmap)">
            <summary>
            Decodes the multiple.
            </summary>
            <param name="image">The image.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Multi.QrCode.QRCodeMultiReader.decodeMultiple(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Decodes the multiple.
            </summary>
            <param name="image">The image.</param>
            <param name="hints">The hints.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.CodaBarReader">
             <summary>
             <p>Decodes Codabar barcodes.</p>
            
             <author>Bas Vijfwinkel</author>
             </summary>
        </member>
        <member name="F:ZXing.OneD.CodaBarReader.CHARACTER_ENCODINGS">
            These represent the encodings of characters, as patterns of wide and narrow bars. The 7 least-significant bits of
            each int correspond to the pattern of wide and narrow, with 1s representing "wide" and 0s representing narrow.
        </member>
        <member name="M:ZXing.OneD.CodaBarReader.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.OneD.CodaBarReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="M:ZXing.OneD.CodaBarReader.setCounters(ZXing.Common.BitArray)">
            <summary>
            Records the size of all runs of white and black pixels, starting with white.
            This is just like recordPattern, except it records all the counters, and
            uses our builtin "counters" member for storage.
            </summary>
            <param name="row">row to count from</param>
        </member>
        <member name="T:ZXing.OneD.CodaBarWriter">
            <summary>
            This class renders CodaBar as <see cref="T:System.Boolean" />[].
            </summary>
            <author>dsbnatut@gmail.com (Kazuki Nishiura)</author>
        </member>
        <member name="P:ZXing.OneD.CodaBarWriter.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.CodaBarWriter.encode(System.String)">
            <summary>
            encodes the content
            </summary>
            <param name="contents"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.Code128EncodingOptions">
            <summary>
            The class holds the available options for the Code128 1D Writer
            </summary>
        </member>
        <member name="P:ZXing.OneD.Code128EncodingOptions.ForceCodesetB">
            <summary>
            if true, don't switch to codeset C for numbers
            </summary>
        </member>
        <member name="P:ZXing.OneD.Code128EncodingOptions.ForceCodeset">
            <summary>
            Forces which encoding will be used. Currently only used for Code-128 code sets (Type <see cref="T:System.String" />). Valid values are "A", "B", "C".
            </summary>
        </member>
        <member name="P:ZXing.OneD.Code128EncodingOptions.CompactEncoding">
            <summary>
            Specifies whether to use compact mode for Code-128 code (type {@link Boolean}, or "true" or "false"
            This can yield slightly smaller bar codes. This option and {@link #FORCE_CODE_SET} are mutually
            exclusive options.
            </summary>
        </member>
        <member name="T:ZXing.OneD.Code128EncodingOptions.Codesets">
            <summary>
            avaiable codesets
            </summary>
        </member>
        <member name="F:ZXing.OneD.Code128EncodingOptions.Codesets.None">
            <summary>
            none specified
            </summary>
        </member>
        <member name="F:ZXing.OneD.Code128EncodingOptions.Codesets.A">
            <summary>
            Codeset A
            </summary>
        </member>
        <member name="F:ZXing.OneD.Code128EncodingOptions.Codesets.B">
            <summary>
            Codeset B
            </summary>
        </member>
        <member name="F:ZXing.OneD.Code128EncodingOptions.Codesets.C">
            <summary>
            Codeset C
            </summary>
        </member>
        <member name="T:ZXing.OneD.Code128Reader">
             <summary>
             <p>Decodes Code 128 barcodes.</p>
            
             <author>Sean Owen</author>
             </summary>
        </member>
        <member name="M:ZXing.OneD.Code128Reader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="T:ZXing.OneD.Code128Writer">
            <summary>
            This object renders a CODE128 code as a <see cref="T:ZXing.Common.BitMatrix" />.
            
            <author>erik.barbara@gmail.com (Erik Barbara)</author>
            </summary>
        </member>
        <member name="P:ZXing.OneD.Code128Writer.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code128Writer.encode(System.String)">
            <summary>
            Encode the contents following specified format.
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code128Writer.encode(System.String,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            starts encoding
            </summary>
            <param name="contents"></param>
            <param name="hints"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.MinimalEncoder">
             Encodes minimally using Divide-And-Conquer with Memoization
            
        </member>
        <member name="M:ZXing.OneD.MinimalEncoder.encode(System.String,ZXing.OneD.MinimalEncoder.Charset,System.Int32)">
             Encode the string starting at position position starting with the character set charset
            
        </member>
        <member name="T:ZXing.OneD.Code39Reader">
            <summary>
              <p>Decodes Code 39 barcodes. Supports "Full ASCII Code 39" if USE_CODE_39_EXTENDED_MODE is set.</p>
            	<author>Sean Owen</author>
            @see Code93Reader
            </summary>
        </member>
        <member name="P:ZXing.OneD.Code39Reader.Alphabet">
            <summary>
            Returns a string with all possible characters
            </summary>
        </member>
        <member name="F:ZXing.OneD.Code39Reader.CHARACTER_ENCODINGS">
            <summary>
            These represent the encodings of characters, as patterns of wide and narrow bars.
            The 9 least-significant bits of each int correspond to the pattern of wide and narrow,
            with 1s representing "wide" and 0s representing narrow.
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code39Reader.#ctor">
            <summary>
            Creates a reader that assumes all encoded data is data, and does not treat the final
            character as a check digit. It will not decoded "extended Code 39" sequences.
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code39Reader.#ctor(System.Boolean)">
            <summary>
            Creates a reader that can be configured to check the last character as a check digit.
            It will not decoded "extended Code 39" sequences.
            </summary>
            <param name="usingCheckDigit">if true, treat the last data character as a check digit, not
            data, and verify that the checksum passes.</param>
        </member>
        <member name="M:ZXing.OneD.Code39Reader.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Creates a reader that can be configured to check the last character as a check digit,
            or optionally attempt to decode "extended Code 39" sequences that are used to encode
            the full ASCII character set.
            </summary>
            <param name="usingCheckDigit">if true, treat the last data character as a check digit, not
            data, and verify that the checksum passes.</param>
            <param name="extendedMode">if true, will attempt to decode extended Code 39 sequences in the text.</param>
        </member>
        <member name="M:ZXing.OneD.Code39Reader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns><see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode</returns>
        </member>
        <member name="T:ZXing.OneD.Code39Writer">
            <summary>
            This object renders a CODE39 code as a <see cref="T:ZXing.Common.BitMatrix"/>.
            <author>erik.barbara@gmail.com (Erik Barbara)</author>
            </summary>
        </member>
        <member name="P:ZXing.OneD.Code39Writer.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code39Writer.encode(System.String)">
            <summary>
            Encode the contents to byte array expression of one-dimensional barcode.
            Start code and end code should be included in result, and side margins should not be included.
            <returns>a {@code boolean[]} of horizontal pixels (false = white, true = black)</returns>
            </summary>
            <param name="contents"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.Code93Reader">
            <summary>
              <p>Decodes Code 93 barcodes.</p>
            	<author>Sean Owen</author>
            <see cref="T:ZXing.OneD.Code39Reader" />
            </summary>
        </member>
        <member name="F:ZXing.OneD.Code93Reader.CHARACTER_ENCODINGS">
            <summary>
            These represent the encodings of characters, as patterns of wide and narrow bars.
            The 9 least-significant bits of each int correspond to the pattern of wide and narrow.
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code93Reader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.Code93Reader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code93Reader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns><see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode</returns>
        </member>
        <member name="T:ZXing.OneD.Code93Writer">
            <summary>
            This object renders a CODE93 code as a BitMatrix
            </summary>
        </member>
        <member name="P:ZXing.OneD.Code93Writer.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.Code93Writer.encode(System.String)">
            <summary>
            </summary>
            <param name="contents">barcode contents to encode.It should not be encoded for extended characters.</param>
            <returns>a { @code bool[]} of horizontal pixels(false = white, true = black)</returns>
        </member>
        <member name="M:ZXing.OneD.Code93Writer.appendPattern(System.Boolean[],System.Int32,System.Int32[],System.Boolean)">
            <summary>
            </summary>
            <param name="target">output to append to</param>
            <param name="pos">start position</param>
            <param name="pattern">pattern to append</param>
            <param name="startColor">unused</param>
            <returns>9</returns>
        </member>
        <member name="T:ZXing.OneD.EAN13Reader">
             <summary>
             <p>Implements decoding of the EAN-13 format.</p>
            
             <author>dswitkin@google.com (Daniel Switkin)</author>
             <author>Sean Owen</author>
             <author>alasdair@google.com (Alasdair Mackintosh)</author>
             </summary>
        </member>
        <member name="M:ZXing.OneD.EAN13Reader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.EAN13Reader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.OneD.EAN13Reader.decodeMiddle(ZXing.Common.BitArray,System.Int32[],System.Text.StringBuilder)">
            <summary>
            Subclasses override this to decode the portion of a barcode between the start
            and end guard patterns.
            </summary>
            <param name="row">row of black/white values to search</param>
            <param name="startRange">start/end offset of start guard pattern</param>
            <param name="resultString"><see cref="T:System.Text.StringBuilder"/>to append decoded chars to</param>
            <returns>
            horizontal offset of first pixel after the "middle" that was decoded or -1 if decoding could not complete successfully
            </returns>
        </member>
        <member name="P:ZXing.OneD.EAN13Reader.BarcodeFormat">
            <summary>
            Get the format of this decoder.
            <returns>The 1D format.</returns>
            </summary>
        </member>
        <member name="M:ZXing.OneD.EAN13Reader.determineFirstDigit(System.Text.StringBuilder,System.Int32)">
            <summary>
            Based on pattern of odd-even ('L' and 'G') patterns used to encoded the explicitly-encoded
            digits in a barcode, determines the implicitly encoded first digit and adds it to the
            result string.
            </summary>
            <param name="resultString">string to insert decoded first digit into</param>
            <param name="lgPatternFound">int whose bits indicates the pattern of odd/even L/G patterns used to</param>
             encode digits
            <return>-1 if first digit cannot be determined</return>
        </member>
        <member name="T:ZXing.OneD.EAN13Writer">
            <summary>
            This object renders an EAN13 code as a <see cref="T:ZXing.Common.BitMatrix"/>.
            <author>aripollak@gmail.com (Ari Pollak)</author>
            </summary>
        </member>
        <member name="P:ZXing.OneD.EAN13Writer.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.EAN13Writer.encode(System.String)">
            <summary>
            Encode the contents to byte array expression of one-dimensional barcode.
            Start code and end code should be included in result, and side margins should not be included.
            <returns>a {@code boolean[]} of horizontal pixels (false = white, true = black)</returns>
            </summary>
            <param name="contents"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.EAN8Reader">
            <summary>
              <p>Implements decoding of the EAN-8 format.</p>
              <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.OneD.EAN8Reader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.EAN8Reader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.OneD.EAN8Reader.decodeMiddle(ZXing.Common.BitArray,System.Int32[],System.Text.StringBuilder)">
            <summary>
            Decodes the middle.
            </summary>
            <param name="row">The row.</param>
            <param name="startRange">The start range.</param>
            <param name="result">The result.</param>
            <returns></returns>
        </member>
        <member name="P:ZXing.OneD.EAN8Reader.BarcodeFormat">
            <summary>
            Get the format of this decoder.
            <returns>The 1D format.</returns>
            </summary>
        </member>
        <member name="T:ZXing.OneD.EAN8Writer">
            <summary>
            This object renders an EAN8 code as a <see cref="T:ZXing.Common.BitMatrix"/>.
            <author>aripollak@gmail.com (Ari Pollak)</author>
            </summary>
        </member>
        <member name="P:ZXing.OneD.EAN8Writer.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.EAN8Writer.encode(System.String)">
            <summary>
            </summary>
            <returns>
            a byte array of horizontal pixels (false = white, true = black)
            </returns>
        </member>
        <member name="T:ZXing.OneD.EANManufacturerOrgSupport">
             <summary>
             Records EAN prefix to GS1 Member Organization, where the member organization
             correlates strongly with a country. This is an imperfect means of identifying
             a country of origin by EAN-13 barcode value. See
             <a href="http://en.wikipedia.org/wiki/List_of_GS1_country_codes">
             http://en.wikipedia.org/wiki/List_of_GS1_country_codes</a>.
            
             <author>Sean Owen</author>
             </summary>
        </member>
        <member name="T:ZXing.OneD.ITFReader">
             <summary>
             <p>Implements decoding of the ITF format, or Interleaved Two of Five.</p>
            
             <p>This Reader will scan ITF barcodes of certain lengths only.
             At the moment it reads length 6, 8, 10, 12, 14, 16, 18, 20, 24, 44 and 48 as these have appeared "in the wild". Not all
             lengths are scanned, especially shorter ones, to avoid false positives. This in turn is due to a lack of
             required checksum function.</p>
            
             <p>The checksum is optional and is not applied by this Reader. The consumer of the decoded
             value will have to apply a checksum if required.</p>
            
             <p><a href="http://en.wikipedia.org/wiki/Interleaved_2_of_5">http://en.wikipedia.org/wiki/Interleaved_2_of_5</a>
             is a great reference for Interleaved 2 of 5 information.</p>
            
             <author>kevin.osullivan@sita.aero, SITA Lab.</author>
             </summary>
        </member>
        <member name="F:ZXing.OneD.ITFReader.DEFAULT_ALLOWED_LENGTHS">
            <summary>
            Valid ITF lengths. Anything longer than the largest value is also allowed.
            </summary>
        </member>
        <member name="F:ZXing.OneD.ITFReader.START_PATTERN">
             <summary>
             Start/end guard pattern.
            
             Note: The end pattern is reversed because the row is reversed before
             searching for the END_PATTERN
             </summary>
        </member>
        <member name="F:ZXing.OneD.ITFReader.PATTERNS">
            <summary>
            Patterns of Wide / Narrow lines to indicate each digit
            </summary>
        </member>
        <member name="M:ZXing.OneD.ITFReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Attempts to decode a one-dimensional barcode format given a single row of
            an image.
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode
            </returns>
        </member>
        <member name="M:ZXing.OneD.ITFReader.decodeMiddle(ZXing.Common.BitArray,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            </summary>
            <param name="row">row of black/white values to search</param>
            <param name="payloadStart">offset of start pattern</param>
            <param name="payloadEnd">The payload end.</param>
            <param name="resultString"><see cref="T:System.Text.StringBuilder"/>to append decoded chars to</param>
            <returns>
            false, if decoding could not complete successfully
            </returns>
        </member>
        <member name="M:ZXing.OneD.ITFReader.decodeStart(ZXing.Common.BitArray)">
            <summary>
            Identify where the start of the middle / payload section starts.
            </summary>
            <param name="row">row of black/white values to search</param>
            <returns>Array, containing index of start of 'start block' and end of 'start block'</returns>
        </member>
        <member name="M:ZXing.OneD.ITFReader.validateQuietZone(ZXing.Common.BitArray,System.Int32)">
             <summary>
             The start &amp; end patterns must be pre/post fixed by a quiet zone. This
             zone must be at least 10 times the width of a narrow line.  Scan back until
             we either get to the start of the barcode or match the necessary number of
             quiet zone pixels.
            
             Note: Its assumed the row is reversed when using this method to find
             quiet zone after the end pattern.
            
             ref: http://www.barcode-1.net/i25code.html
             </summary>
             <param name="row">bit array representing the scanned barcode.</param>
             <param name="startPattern">index into row of the start or end pattern.</param>
             <returns>false, if the quiet zone cannot be found</returns>
        </member>
        <member name="M:ZXing.OneD.ITFReader.skipWhiteSpace(ZXing.Common.BitArray)">
            <summary>
            Skip all whitespace until we get to the first black line.
            </summary>
            <param name="row">row of black/white values to search</param>
            <returns>index of the first black line or -1 if no black lines are found in the row.</returns>
        </member>
        <member name="M:ZXing.OneD.ITFReader.decodeEnd(ZXing.Common.BitArray)">
            <summary>
            Identify where the end of the middle / payload section ends.
            </summary>
            <param name="row">row of black/white values to search</param>
            <returns>Array, containing index of start of 'end block' and end of 'end
            block' or null, if nothing found</returns>
        </member>
        <member name="M:ZXing.OneD.ITFReader.findGuardPattern(ZXing.Common.BitArray,System.Int32,System.Int32[])">
            <summary>
            </summary>
            <param name="row">row of black/white values to search</param>
            <param name="rowOffset">position to start search</param>
            <param name="pattern">pattern of counts of number of black and white pixels that are being searched for as a pattern</param>
            <returns>start/end horizontal offset of guard pattern, as an array of two ints</returns>
        </member>
        <member name="M:ZXing.OneD.ITFReader.decodeDigit(System.Int32[],System.Int32@)">
            <summary>
            Attempts to decode a sequence of ITF black/white lines into single
            digit.
            </summary>
            <param name="counters">the counts of runs of observed black/white/black/... values</param>
            <param name="bestMatch">The decoded digit</param>
            <returns>
            false, if digit cannot be decoded
            </returns>
        </member>
        <member name="T:ZXing.OneD.ITFWriter">
            <summary>
            This object renders a ITF code as a <see cref="T:ZXing.Common.BitMatrix" />.
            
            <author>erik.barbara@gmail.com (Erik Barbara)</author>
            </summary>
        </member>
        <member name="P:ZXing.OneD.ITFWriter.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.ITFWriter.encode(System.String)">
            <summary>
            Encode the contents to bool array expression of one-dimensional barcode.
            Start code and end code should be included in result, and side margins should not be included.
            <returns>a {@code bool[]} of horizontal pixels (false = white, true = black)</returns>
            </summary>
            <param name="contents"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.MSIReader">
            <summary>
            Decodes MSI barcodes.
            </summary>
        </member>
        <member name="F:ZXing.OneD.MSIReader.CHARACTER_ENCODINGS">
            <summary>
            These represent the encodings of characters, as patterns of wide and narrow bars.
            The 9 least-significant bits of each int correspond to the pattern of wide and narrow,
            with 1s representing "wide" and 0s representing narrow.
            </summary>
        </member>
        <member name="M:ZXing.OneD.MSIReader.#ctor">
            <summary>
            Creates a reader that assumes all encoded data is data, and does not treat the final
            character as a check digit.
            </summary>
        </member>
        <member name="M:ZXing.OneD.MSIReader.#ctor(System.Boolean)">
            <summary>
            Creates a reader that can be configured to check the last character as a check digit,
            </summary>
            <param name="usingCheckDigit">if true, treat the last data character as a check digit, not
            data, and verify that the checksum passes.</param>
        </member>
        <member name="M:ZXing.OneD.MSIReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns><see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode</returns>
        </member>
        <member name="T:ZXing.OneD.MSIWriter">
            <summary>
            This object renders a MSI code as a <see cref="T:ZXing.Common.BitMatrix"/>.
            </summary>
        </member>
        <member name="P:ZXing.OneD.MSIWriter.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.MSIWriter.encode(System.String)">
            <summary>
            Encode the contents to byte array expression of one-dimensional barcode.
            Start code and end code should be included in result, and side margins should not be included.
            <returns>a {@code boolean[]} of horizontal pixels (false = white, true = black)</returns>
            </summary>
            <param name="contents"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.MultiFormatOneDReader">
            <summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
            <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.OneD.MultiFormatOneDReader.#ctor(System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.MultiFormatOneDReader"/> class.
            </summary>
            <param name="hints">The hints.</param>
        </member>
        <member name="M:ZXing.OneD.MultiFormatOneDReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="M:ZXing.OneD.MultiFormatOneDReader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="T:ZXing.OneD.MultiFormatUPCEANReader">
            <summary>
              <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to
            read all such formats, it is most efficient to use this implementation rather than invoke
            individual readers.</p>
              <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.OneD.MultiFormatUPCEANReader.#ctor(System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.MultiFormatUPCEANReader"/> class.
            </summary>
            <param name="hints">The hints.</param>
        </member>
        <member name="M:ZXing.OneD.MultiFormatUPCEANReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="M:ZXing.OneD.MultiFormatUPCEANReader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="T:ZXing.OneD.OneDimensionalCodeWriter">
            <summary>
              <p>Encapsulates functionality and implementation that is common to one-dimensional barcodes.</p>
              <author>dsbnatut@gmail.com (Kazuki Nishiura)</author>
            </summary>
        </member>
        <member name="P:ZXing.OneD.OneDimensionalCodeWriter.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.encode(System.String)">
            <summary>
            Encode the contents to boolean array expression of one-dimensional barcode.
            Start code and end code should be included in result, and side margins should not be included.
            </summary>
            <param name="contents">barcode contents to encode</param>
            <returns>a <c>bool[]</c> of horizontal pixels (false = white, true = black)</returns>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.encode(System.String,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            Can be overwritten if the encode requires to read the hints map. Otherwise it defaults to {@code encode}.
            </summary>
            <param name="contents">barcode contents to encode</param>
            <param name="hints">encoding hints</param>
            <returns>a <c>bool[]</c> of horizontal pixels (false = white, true = black)</returns>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            Encode a barcode using the default settings.
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            Encode the contents following specified format.
            {@code width} and {@code height} are required size. This method may return bigger size
            {@code BitMatrix} when specified size is too small. The user can set both {@code width} and
            {@code height} to zero to get minimum size barcode. If negative value is set to {@code width}
            or {@code height}, {@code IllegalArgumentException} is thrown.
            </summary>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.renderResult(System.Boolean[],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            </summary>
            <returns>a byte array of horizontal pixels (0 = white, 1 = black)</returns>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.checkNumeric(System.String)">
            <summary>
            Throw ArgumentException if input contains characters other than digits 0-9.
            </summary>
            <param name="contents">string to check for numeric characters</param>
            <exception cref="T:System.ArgumentException">if input contains characters other than digits 0-9.</exception>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.appendPattern(System.Boolean[],System.Int32,System.Int32[],System.Boolean)">
            <summary>
            Appends the given pattern to the target array starting at pos.
            </summary>
            <param name="target">encode black/white pattern into this array</param>
            <param name="pos">position to start encoding at in <c>target</c></param>
            <param name="pattern">lengths of black/white runs to encode</param>
            <param name="startColor">starting color - false for white, true for black</param>
            <returns>the number of elements added to target.</returns>
        </member>
        <member name="P:ZXing.OneD.OneDimensionalCodeWriter.DefaultMargin">
            <summary>
            Gets the default margin.
            </summary>
        </member>
        <member name="M:ZXing.OneD.OneDimensionalCodeWriter.CalculateChecksumDigitModulo10(System.String)">
            <summary>
            Calculates the checksum digit modulo10.
            </summary>
            <param name="contents">The contents.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.OneDReader">
            <summary>
            Encapsulates functionality and implementation that is common to all families
            of one-dimensional barcodes.
            <author>dswitkin@google.com (Daniel Switkin)</author>
            <author>Sean Owen</author>
            </summary>
        </member>
        <member name="F:ZXing.OneD.OneDReader.INTEGER_MATH_SHIFT">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.OneD.OneDReader.PATTERN_MATCH_RESULT_SCALE_FACTOR">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.OneD.OneDReader.decode(ZXing.BinaryBitmap)">
            <summary>
            Locates and decodes a barcode in some format within an image.
            </summary>
            <param name="image">image of barcode to decode</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.OneD.OneDReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes a barcode in some format within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            Note that we don't try rotation without the try harder flag, even if rotation was supported.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:ZXing.DecodeHintType"/>
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.OneD.OneDReader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="M:ZXing.OneD.OneDReader.doDecode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            We're going to examine rows from the middle outward, searching alternately above and below the
            middle, and farther out each time. rowStep is the number of rows between each successive
            attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then
            middle + rowStep, then middle - (2 * rowStep), etc.
            rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily
            decided that moving up and down by about 1/16 of the image is pretty good; we try more of the
            image if "trying harder".
            </summary>
            <param name="image">The image to decode</param>
            <param name="hints">Any hints that were requested</param>
            <returns>The contents of the decoded barcode</returns>
        </member>
        <member name="M:ZXing.OneD.OneDReader.recordPattern(ZXing.Common.BitArray,System.Int32,System.Int32[])">
            <summary>
            Records the size of successive runs of white and black pixels in a row, starting at a given point.
            The values are recorded in the given array, and the number of runs recorded is equal to the size
            of the array. If the row starts on a white pixel at the given start point, then the first count
            recorded is the run of white pixels starting from that point; likewise it is the count of a run
            of black pixels if the row begin on a black pixels at that point.
            </summary>
            <param name="row">row to count from</param>
            <param name="start">offset into row to start at</param>
            <param name="counters">array into which to record counts</param>
        </member>
        <member name="M:ZXing.OneD.OneDReader.recordPattern(ZXing.Common.BitArray,System.Int32,System.Int32[],System.Int32)">
            <summary>
            Records the size of successive runs of white and black pixels in a row, starting at a given point.
            The values are recorded in the given array, and the number of runs recorded is equal to the size
            of the array. If the row starts on a white pixel at the given start point, then the first count
            recorded is the run of white pixels starting from that point; likewise it is the count of a run
            of black pixels if the row begin on a black pixels at that point.
            </summary>
            <param name="row">row to count from</param>
            <param name="start">offset into row to start at</param>
            <param name="counters">array into which to record counts</param>
            <param name="numCounters"></param>
        </member>
        <member name="M:ZXing.OneD.OneDReader.recordPatternInReverse(ZXing.Common.BitArray,System.Int32,System.Int32[])">
            <summary>
            Records the pattern in reverse.
            </summary>
            <param name="row">The row.</param>
            <param name="start">The start.</param>
            <param name="counters">The counters.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.OneDReader.patternMatchVariance(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Determines how closely a set of observed counts of runs of black/white values matches a given
            target pattern. This is reported as the ratio of the total variance from the expected pattern
            proportions across all pattern elements, to the length of the pattern.
            </summary>
            <param name="counters">observed counters</param>
            <param name="pattern">expected pattern</param>
            <param name="maxIndividualVariance">The most any counter can differ before we give up</param>
            <returns>ratio of total variance between counters and pattern compared to total pattern size,
             where the ratio has been multiplied by 256. So, 0 means no variance (perfect match); 256 means
             the total variance between counters and patterns equals the pattern length, higher values mean
             even more variance</returns>
        </member>
        <member name="M:ZXing.OneD.OneDReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Attempts to decode a one-dimensional barcode format given a single row of
            an image.
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode
            </returns>
        </member>
        <member name="T:ZXing.OneD.PharmaCodeReader">
            <summary>
            <p>Decodes PharmaCode</p>
            * @author Ruslan Karachun
            </summary>
        </member>
        <member name="M:ZXing.OneD.PharmaCodeReader.mean(System.Double[])">
            <summary>
            
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.PharmaCodeReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="T:ZXing.OneD.PlesseyWriter">
            <summary>
            This object renders a Plessey code as a <see cref="T:ZXing.Common.BitMatrix"/>.
            </summary>
        </member>
        <member name="P:ZXing.OneD.PlesseyWriter.SupportedWriteFormats">
            <summary>
            returns the list of supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.PlesseyWriter.encode(System.String)">
            <summary>
            Encode the contents to byte array expression of one-dimensional barcode.
            Start code and end code should be included in result, and side margins should not be included.
            <returns>a {@code boolean[]} of horizontal pixels (false = white, true = black)</returns>
            </summary>
            <param name="contents"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.RSS.AbstractRSSReader">
            <summary>
            Superclass of <see cref="T:ZXing.OneD.OneDReader" /> implementations that read barcodes in the RSS family of formats.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.RSS.AbstractRSSReader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.getDecodeFinderCounters">
            <summary>
            Gets the decode finder counters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.getDataCharacterCounters">
            <summary>
            Gets the data character counters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.getOddRoundingErrors">
            <summary>
            Gets the odd rounding errors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.getEvenRoundingErrors">
            <summary>
            Gets the even rounding errors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.getOddCounts">
            <summary>
            Gets the odd counts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.getEvenCounts">
            <summary>
            Gets the even counts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.parseFinderValue(System.Int32[],System.Int32[][],System.Int32@)">
            <summary>
            Parses the finder value.
            </summary>
            <param name="counters">The counters.</param>
            <param name="finderPatterns">The finder patterns.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.count(System.Int32[])">
            <summary>
            Counts the specified array.
            </summary>
            <param name="array">The array.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.increment(System.Int32[],System.Single[])">
            <summary>
            Increments the specified array.
            </summary>
            <param name="array">The array.</param>
            <param name="errors">The errors.</param>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.decrement(System.Int32[],System.Single[])">
            <summary>
            Decrements the specified array.
            </summary>
            <param name="array">The array.</param>
            <param name="errors">The errors.</param>
        </member>
        <member name="M:ZXing.OneD.RSS.AbstractRSSReader.isFinderPattern(System.Int32[])">
            <summary>
            Determines whether [is finder pattern] [the specified counters].
            </summary>
            <param name="counters">The counters.</param>
            <returns>
              <c>true</c> if [is finder pattern] [the specified counters]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:ZXing.OneD.RSS.DataCharacter">
            <summary>
            Encapsulates a since character value in an RSS barcode, including its checksum information.
            </summary>
        </member>
        <member name="P:ZXing.OneD.RSS.DataCharacter.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:ZXing.OneD.RSS.DataCharacter.ChecksumPortion">
            <summary>
            Gets the checksum portion.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.DataCharacter.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.RSS.DataCharacter"/> class.
            </summary>
            <param name="value">The value.</param>
            <param name="checksumPortion">The checksum portion.</param>
        </member>
        <member name="M:ZXing.OneD.RSS.DataCharacter.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.OneD.RSS.DataCharacter.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="o">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ZXing.OneD.RSS.DataCharacter.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.BitArrayBuilder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AbstractExpandedDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.Expanded.Decoders.AbstractExpandedDecoder.getInformation">
            <summary>
            Gets the information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.Expanded.Decoders.AbstractExpandedDecoder.parseInformation">
            <summary>
            Parses the information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.RSS.Expanded.Decoders.AbstractExpandedDecoder.createDecoder(ZXing.Common.BitArray)">
            <summary>
            Creates the decoder.
            </summary>
            <param name="information">The information.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI013103decoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI01320xDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI01392xDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI01393xDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI013x0x1xDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI013x0xDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI01AndOtherAIs">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI01decoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AI01weightDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.AnyAIDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.BlockParsedResult">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.CurrentParsingState">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.DecodedChar">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.DecodedInformation">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.DecodedNumeric">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.DecodedObject">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.FieldParser">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.Decoders.GeneralAppIdDecoder">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.ExpandedPair">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.ExpandedRow">
            <summary>
            One row of an RSS Expanded Stacked symbol, consisting of 1+ expanded pairs.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.Expanded.ExpandedRow.Equals(System.Object)">
            <summary>
            Two rows are equal if they contain the same pairs in the same order.
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.Expanded.RSSExpandedReader">
            <summary>
            <author>Pablo Orduña, University of Deusto (pablo.orduna@deusto.es)</author>
            <author>Eduardo Castillejo, University of Deusto (eduardo.castillejo@deusto.es)</author>
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.Expanded.RSSExpandedReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="M:ZXing.OneD.RSS.Expanded.RSSExpandedReader.reset">
            <summary>
            Resets this instance.
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.FinderPattern">
            <summary>
            Encapsulates an RSS barcode finder pattern, including its start/end position and row.
            </summary>
        </member>
        <member name="P:ZXing.OneD.RSS.FinderPattern.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:ZXing.OneD.RSS.FinderPattern.StartEnd">
            <summary>
            Gets the start end.
            </summary>
        </member>
        <member name="P:ZXing.OneD.RSS.FinderPattern.ResultPoints">
            <summary>
            Gets the result points.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.FinderPattern.#ctor(System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.RSS.FinderPattern"/> class.
            </summary>
            <param name="value">The value.</param>
            <param name="startEnd">The start end.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="rowNumber">The row number.</param>
        </member>
        <member name="M:ZXing.OneD.RSS.FinderPattern.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="o">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ZXing.OneD.RSS.FinderPattern.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:ZXing.OneD.RSS.RSS14Reader">
            <summary>
            Decodes RSS-14, including truncated and stacked variants. See ISO/IEC 24724:2006.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.RSS14Reader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.RSS.RSS14Reader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.RSS14Reader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="M:ZXing.OneD.RSS.RSS14Reader.reset">
            <summary>
            Resets this instance.
            </summary>
        </member>
        <member name="T:ZXing.OneD.RSS.RSSUtils">
            <summary>
            Adapted from listings in ISO/IEC 24724 Appendix B and Appendix G.
            </summary>
        </member>
        <member name="M:ZXing.OneD.RSS.RSSUtils.getRSSvalue(System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Gets the RS svalue.
            </summary>
            <param name="widths">The widths.</param>
            <param name="maxWidth">Width of the max.</param>
            <param name="noNarrow">if set to <c>true</c> [no narrow].</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.OneD.UPCAReader">
            <summary>
              <p>Implements decoding of the UPC-A format.</p>
              <author>dswitkin@google.com (Daniel Switkin)</author>
              <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCAReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Int32[],System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Like decodeRow(int, BitArray, java.util.Map), but
            allows caller to inform method about where the UPC/EAN start pattern is
            found. This allows this to be computed once and reused across many implementations.</p>
            </summary>
            <param name="rowNumber"></param>
            <param name="row"></param>
            <param name="startGuardRange"></param>
            <param name="hints"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.UPCAReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="M:ZXing.OneD.UPCAReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Decodes the specified image.
            </summary>
            <param name="image">The image.</param>
            <param name="hints">The hints.</param>
            <returns></returns>
        </member>
        <member name="P:ZXing.OneD.UPCAReader.BarcodeFormat">
            <summary>
            Get the format of this decoder.
            <returns>The 1D format.</returns>
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCAReader.decodeMiddle(ZXing.Common.BitArray,System.Int32[],System.Text.StringBuilder)">
            <summary>
            Subclasses override this to decode the portion of a barcode between the start
            and end guard patterns.
            </summary>
            <param name="row">row of black/white values to search</param>
            <param name="startRange">start/end offset of start guard pattern</param>
            <param name="resultString"><see cref="T:System.Text.StringBuilder"/>to append decoded chars to</param>
            <returns>
            horizontal offset of first pixel after the "middle" that was decoded or -1 if decoding could not complete successfully
            </returns>
        </member>
        <member name="T:ZXing.OneD.UPCAWriter">
            <summary>
            This object renders a UPC-A code as a <see cref="T:ZXing.Common.BitMatrix"/>.
            <author>qwandor@google.com (Andrew Walbran)</author>
            </summary>
        </member>
        <member name="P:ZXing.OneD.UPCAWriter.DefaultMargin">
            <summary>
            Gets the default margin.
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCAWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            Encode a barcode using the default settings.
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.OneD.UPCAWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <param name="hints">Additional parameters to supply to the encoder</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="T:ZXing.OneD.UPCEANExtension2Support">
            <summary>
            @see UPCEANExtension5Support
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEANExtension2Support.parseExtensionString(System.String)">
            <summary>
            Parses the extension string.
            </summary>
            <param name="raw">raw content of extension</param>
            <returns>formatted interpretation of raw content as a {@link Map} mapping</returns>
        </member>
        <member name="T:ZXing.OneD.UPCEANExtension5Support">
            @see UPCEANExtension2Support
        </member>
        <member name="M:ZXing.OneD.UPCEANExtension5Support.parseExtensionString(System.String)">
            <summary>
            Parses the extension string.
            </summary>
            <param name="raw">raw content of extension</param>
            <returns>formatted interpretation of raw content as a {@link Map} mapping
            one {@link ResultMetadataType} to appropriate value, or {@code null} if not known</returns>
        </member>
        <member name="T:ZXing.OneD.UPCEANReader">
            <summary>
              <p>Encapsulates functionality and implementation that is common to UPC and EAN families
            of one-dimensional barcodes.</p>
              <author>dswitkin@google.com (Daniel Switkin)</author>
              <author>Sean Owen</author>
              <author>alasdair@google.com (Alasdair Mackintosh)</author>
            </summary>
        </member>
        <member name="F:ZXing.OneD.UPCEANReader.START_END_PATTERN">
            <summary>
            Start/end guard pattern.
            </summary>
        </member>
        <member name="F:ZXing.OneD.UPCEANReader.MIDDLE_PATTERN">
            <summary>
            Pattern marking the middle of a UPC/EAN pattern, separating the two halves.
            </summary>
        </member>
        <member name="F:ZXing.OneD.UPCEANReader.END_PATTERN">
            <summary>
            end guard pattern.
            </summary>
        </member>
        <member name="F:ZXing.OneD.UPCEANReader.L_PATTERNS">
            <summary>
            "Odd", or "L" patterns used to encode UPC/EAN digits.
            </summary>
        </member>
        <member name="F:ZXing.OneD.UPCEANReader.L_AND_G_PATTERNS">
            <summary>
            As above but also including the "even", or "G" patterns used to encode UPC/EAN digits.
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.UPCEANReader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Attempts to decode a one-dimensional barcode format given a single row of
            an image.</p>
            </summary>
            <param name="rowNumber">row number from top of the row</param>
            <param name="row">the black/white pixel data of the row</param>
            <param name="hints">decode hints</param>
            <returns>
              <see cref="T:ZXing.Result"/>containing encoded string and start/end of barcode or null, if an error occurs or barcode cannot be found
            </returns>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Int32[],System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Like <see cref="M:ZXing.OneD.UPCEANReader.decodeRow(System.Int32,ZXing.Common.BitArray,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})"/>, but
            allows caller to inform method about where the UPC/EAN start pattern is
            found. This allows this to be computed once and reused across many implementations.</p>
            </summary>
            <param name="rowNumber">row index into the image</param>
            <param name="row">encoding of the row of the barcode image</param>
            <param name="startGuardRange">start/end column where the opening start pattern was found</param>
            <param name="hints">optional hints that influence decoding</param>
            <returns><see cref="T:ZXing.Result"/> encapsulating the result of decoding a barcode in the row</returns>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.checkChecksum(System.String)">
            <summary>
            </summary>
            <param name="s">string of digits to check</param>
            <returns>see <see cref="M:ZXing.OneD.UPCEANReader.checkStandardUPCEANChecksum(System.String)"/></returns>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.checkStandardUPCEANChecksum(System.String)">
            <summary>
            Computes the UPC/EAN checksum on a string of digits, and reports
            whether the checksum is correct or not.
            </summary>
            <param name="s">string of digits to check</param>
            <returns>true iff string of digits passes the UPC/EAN checksum algorithm</returns>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.decodeEnd(ZXing.Common.BitArray,System.Int32)">
            <summary>
            Decodes the end.
            </summary>
            <param name="row">The row.</param>
            <param name="endStart">The end start.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.findGuardPattern(ZXing.Common.BitArray,System.Int32,System.Boolean,System.Int32[],System.Int32[])">
            <summary>
            </summary>
            <param name="row">row of black/white values to search</param>
            <param name="rowOffset">position to start search</param>
            <param name="whiteFirst">if true, indicates that the pattern specifies white/black/white/...</param>
            pixel counts, otherwise, it is interpreted as black/white/black/...
            <param name="pattern">pattern of counts of number of black and white pixels that are being</param>
            searched for as a pattern
            <param name="counters">array of counters, as long as pattern, to re-use</param>
            <returns>start/end horizontal offset of guard pattern, as an array of two ints</returns>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.decodeDigit(ZXing.Common.BitArray,System.Int32[],System.Int32,System.Int32[][],System.Int32@)">
            <summary>
            Attempts to decode a single UPC/EAN-encoded digit.
            </summary>
            <param name="row">row of black/white values to decode</param>
            <param name="counters">the counts of runs of observed black/white/black/... values</param>
            <param name="rowOffset">horizontal offset to start decoding from</param>
            <param name="patterns">the set of patterns to use to decode -- sometimes different encodings</param>
            for the digits 0-9 are used, and this indicates the encodings for 0 to 9 that should
            be used
            <param name="digit">horizontal offset of first pixel beyond the decoded digit</param>
            <returns></returns>
        </member>
        <member name="P:ZXing.OneD.UPCEANReader.BarcodeFormat">
            <summary>
            Get the format of this decoder.
            </summary>
            <returns>The 1D format.</returns>
        </member>
        <member name="M:ZXing.OneD.UPCEANReader.decodeMiddle(ZXing.Common.BitArray,System.Int32[],System.Text.StringBuilder)">
            <summary>
            Subclasses override this to decode the portion of a barcode between the start
            and end guard patterns.
            </summary>
            <param name="row">row of black/white values to search</param>
            <param name="startRange">start/end offset of start guard pattern</param>
            <param name="resultString"><see cref="T:System.Text.StringBuilder" />to append decoded chars to</param>
            <returns>horizontal offset of first pixel after the "middle" that was decoded or -1 if decoding could not complete successfully</returns>
        </member>
        <member name="T:ZXing.OneD.UPCEANWriter">
            <summary>
              <p>Encapsulates functionality and implementation that is common to UPC and EAN families
            of one-dimensional barcodes.</p>
              <author>aripollak@gmail.com (Ari Pollak)</author>
              <author>dsbnatut@gmail.com (Kazuki Nishiura)</author>
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEANWriter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ZXing.OneD.UPCEReader">
            <summary>
              <p>Implements decoding of the UPC-E format.</p>
              <p><a href="http://www.barcodeisland.com/upce.phtml">This</a>is a great reference for
            UPC-E information.</p>
              <author>Sean Owen</author>
            </summary>
        </member>
        <member name="F:ZXing.OneD.UPCEReader.MIDDLE_END_PATTERN">
            <summary>
            The pattern that marks the middle, and end, of a UPC-E pattern.
            There is no "second half" to a UPC-E barcode.
            </summary>
        </member>
        <member name="F:ZXing.OneD.UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS">
            <summary>
            See L_AND_G_PATTERNS these values similarly represent patterns of
            even-odd parity encodings of digits that imply both the number system (0 or 1)
            used, and the check digit.
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.OneD.UPCEReader"/> class.
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEReader.decodeMiddle(ZXing.Common.BitArray,System.Int32[],System.Text.StringBuilder)">
            <summary>
            Decodes the middle.
            </summary>
            <param name="row">The row.</param>
            <param name="startRange">The start range.</param>
            <param name="result">The result.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.UPCEReader.decodeEnd(ZXing.Common.BitArray,System.Int32)">
            <summary>
            Decodes the end.
            </summary>
            <param name="row">The row.</param>
            <param name="endStart">The end start.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.UPCEReader.checkChecksum(System.String)">
            <summary>
              <returns>see checkStandardUPCEANChecksum(String)</returns>
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.OneD.UPCEReader.determineNumSysAndCheckDigit(System.Text.StringBuilder,System.Int32)">
            <summary>
            Determines the num sys and check digit.
            </summary>
            <param name="resultString">The result string.</param>
            <param name="lgPatternFound">The lg pattern found.</param>
            <returns></returns>
        </member>
        <member name="P:ZXing.OneD.UPCEReader.BarcodeFormat">
            <summary>
            Get the format of this decoder.
            <returns>The 1D format.</returns>
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEReader.convertUPCEtoUPCA(System.String)">
             <summary>
             Expands a UPC-E value back into its full, equivalent UPC-A code value.
            
             <param name="upce">UPC-E code as string of digits</param>
             <returns>equivalent UPC-A code as string of digits</returns>
             </summary>
        </member>
        <member name="T:ZXing.OneD.UPCEWriter">
            <summary>
            This object renders an UPC-E code as a {@link BitMatrix}.
            @author 0979097955s@gmail.com (RX)
            </summary>
        </member>
        <member name="P:ZXing.OneD.UPCEWriter.SupportedWriteFormats">
            <summary>
            returns supported formats
            </summary>
        </member>
        <member name="M:ZXing.OneD.UPCEWriter.encode(System.String)">
            <summary>
            content encoding method
            </summary>
            <param name="contents"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.BarcodeMetadata">
            <summary>
            Metadata about a PDF417 Barcode
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="P:ZXing.PDF417.Internal.BarcodeMetadata.ColumnCount">
            <summary>
            column count
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BarcodeMetadata.ErrorCorrectionLevel">
            <summary>
            error correction level
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BarcodeMetadata.RowCountUpper">
            <summary>
            row count upper
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BarcodeMetadata.RowCountLower">
            <summary>
            row count lower
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BarcodeMetadata.RowCount">
            <summary>
            row count
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeMetadata.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            initializing constructor
            </summary>
            <param name="columnCount"></param>
            <param name="rowCountUpperPart"></param>
            <param name="rowCountLowerPart"></param>
            <param name="errorCorrectionLevel"></param>
        </member>
        <member name="T:ZXing.PDF417.Internal.BarcodeValue">
            <summary>
            A Barcode Value for the PDF417 barcode.  
            The scanner will iterate through the bitmatrix, 
            and given the different methods or iterations 
            will increment a given barcode value's confidence.
            
            When done, this will return the values of highest confidence.
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeValue.setValue(System.Int32)">
             <summary>
             Incremenets the Confidence for a given value. (Adds an occurance of a value)
            
             </summary>
             <param name="value">Value.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeValue.getValue">
            <summary>
            Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.
            </summary>
            <returns>an array of int, containing the values with the highest occurrence, or null, if no value was set.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeValue.getConfidence(System.Int32)">
            <summary>
            Returns the confience value for a given barcode value
            </summary>
            <param name="barcodeValue">Barcode value.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.BoundingBox">
            <summary>
            A Bounding Box helper class
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.TopLeft">
            <summary>
            top left corner of the box
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.TopRight">
            <summary>
            top right corner of the box
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.BottomLeft">
            <summary>
            bottom left corner of the box
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.BottomRight">
            <summary>
            bottom right corner of the box
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.MinX">
            <summary>
            min x
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.MaxX">
            <summary>
            max x
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.MinY">
            <summary>
            min y
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.BoundingBox.MaxY">
            <summary>
            max y
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.BoundingBox.Create(ZXing.Common.BitMatrix,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.BoundingBox"/> class.
            returns null if the corner points don't match up correctly
            </summary>
            <param name="image">The image.</param>
            <param name="topLeft">The top left.</param>
            <param name="bottomLeft">The bottom left.</param>
            <param name="topRight">The top right.</param>
            <param name="bottomRight">The bottom right.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.BoundingBox.Create(ZXing.PDF417.Internal.BoundingBox)">
            <summary>
            Creates the specified box.
            </summary>
            <param name="box">The box.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.BoundingBox.#ctor(ZXing.Common.BitMatrix,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.BoundingBox"/> class.
            Will throw an exception if the corner points don't match up correctly
            </summary>
            <param name="image">Image.</param>
            <param name="topLeft">Top left.</param>
            <param name="topRight">Top right.</param>
            <param name="bottomLeft">Bottom left.</param>
            <param name="bottomRight">Bottom right.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.BoundingBox.merge(ZXing.PDF417.Internal.BoundingBox,ZXing.PDF417.Internal.BoundingBox)">
            <summary>
            Merge two Bounding Boxes, getting the left corners of left, and the right corners of right
            (Images should be the same)
            </summary>
            <param name="leftBox">Left.</param>
            <param name="rightBox">Right.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.BoundingBox.addMissingRows(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Adds the missing rows.
            </summary>
            <returns>The missing rows.</returns>
            <param name="missingStartRows">Missing start rows.</param>
            <param name="missingEndRows">Missing end rows.</param>
            <param name="isLeft">If set to <c>true</c> is left.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.Codeword">
            <summary>
            A Codeword in the PDF417 barcode
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="F:ZXing.PDF417.Internal.Codeword.BARCODE_ROW_UNKNOWN">
            <summary>
            Default value for the RowNumber (-1 being an invalid real number)
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Codeword.StartX">
            <summary>
            start of x coordinates
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Codeword.EndX">
            <summary>
            end of x coordinates
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Codeword.Bucket">
            <summary>
            bucket
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Codeword.Value">
            <summary>
            value
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Codeword.RowNumber">
            <summary>
            row number
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.Codeword.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.Codeword"/> class.
            </summary>
            <param name="startX">Start x.</param>
            <param name="endX">End x.</param>
            <param name="bucket">Bucket.</param>
            <param name="value">Value.</param>
        </member>
        <member name="P:ZXing.PDF417.Internal.Codeword.Width">
            <summary>
            Gets the width.
            </summary>
            <value>The width.</value>
        </member>
        <member name="P:ZXing.PDF417.Internal.Codeword.HasValidRowNumber">
            <summary>
            Gets a value indicating whether this instance has valid row number.
            </summary>
            <value><c>true</c> if this instance has valid row number; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:ZXing.PDF417.Internal.Codeword.IsValidRowNumber(System.Int32)">
            <summary>
            Determines whether this instance is valid row number the specified rowNumber.
            </summary>
            <returns><c>true</c> if this instance is valid row number the specified rowNumber; otherwise, <c>false</c>.</returns>
            <param name="rowNumber">Row number.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.Codeword.setRowNumberAsRowIndicatorColumn">
            <summary>
            Sets the row number as the row's indicator column.
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.Codeword.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.Codeword"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.Codeword"/>.</returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.DecodedBitStreamParser">
             <summary>
             <p>This class contains the methods for decoding the PDF417 codewords.</p>
            
             <author>SITA Lab (kevin.osullivan@sita.aero)</author>
             </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.DecodedBitStreamParser.EXP900">
            <summary>
            Table containing values for the exponent of 900.
            This is used in the numeric compaction decode algorithm.
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.DecodedBitStreamParser.textCompaction(System.Int32[],System.Int32,ZXing.Common.ECIStringBuilder)">
             <summary>
             Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be
             encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as
             well as selected control characters.
            
             <param name="codewords">The array of codewords (data + error)</param>
             <param name="codeIndex">The current index into the codeword array.</param>
             <param name="result">The decoded data is appended to the result.</param>
             <returns>The next index into the codeword array.</returns>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.DecodedBitStreamParser.decodeTextCompaction(System.Int32[],System.Int32[],System.Int32,ZXing.Common.ECIStringBuilder,ZXing.PDF417.Internal.DecodedBitStreamParser.Mode)">
            <summary>
            The Text Compaction mode includes all the printable ASCII characters
            (i.e. values from 32 to 126) and three ASCII control characters: HT or tab
            (ASCII value 9), LF or line feed (ASCII value 10), and CR or carriage
            return (ASCII value 13). The Text Compaction mode also includes various latch
            and shift characters which are used exclusively within the mode. The Text
            Compaction mode encodes up to 2 characters per codeword. The compaction rules
            for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode
            switches are defined in 5.4.2.3.
            </summary>
            <param name="textCompactionData">The text compaction data.</param>
            <param name="byteCompactionData">The byte compaction data if there was a mode shift.</param>
            <param name="length">The size of the text compaction and byte compaction data.</param>
            <param name="result">The decoded data is appended to the result.</param>
            <param name="startMode">The mode in which decoding starts</param>
            <returns>The mode in which decoding ended</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DecodedBitStreamParser.byteCompaction(System.Int32,System.Int32[],System.Int32,ZXing.Common.ECIStringBuilder)">
             <summary>
             Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.
             This includes all ASCII characters value 0 to 127 inclusive and provides for international
             character set support.
            
             <param name="mode">The byte compaction mode i.e. 901 or 924</param>
             <param name="codewords">The array of codewords (data + error)</param>
             <param name="codeIndex">The current index into the codeword array.</param>
             <param name="result">The decoded data is appended to the result.</param>
             <returns>The next index into the codeword array.</returns>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.DecodedBitStreamParser.numericCompaction(System.Int32[],System.Int32,ZXing.Common.ECIStringBuilder)">
             <summary>
             Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.
            
             <param name="codewords">The array of codewords (data + error)</param>
             <param name="codeIndex">The current index into the codeword array.</param>
             <param name="result">The decoded data is appended to the result.</param>
             <returns>The next index into the codeword array.</returns>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.DecodedBitStreamParser.decodeBase900toBase10(System.Int32[],System.Int32)">
            <summary>
            Convert a list of Numeric Compacted codewords from Base 900 to Base 10.
            EXAMPLE
            Encode the fifteen digit numeric string 000213298174000
            Prefix the numeric string with a 1 and set the initial value of
            t = 1 000 213 298 174 000
            Calculate codeword 0
            d0 = 1 000 213 298 174 000 mod 900 = 200
            
            t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082
            Calculate codeword 1
            d1 = 1 111 348 109 082 mod 900 = 282
            
            t = 1 111 348 109 082 div 900 = 1 234 831 232
            Calculate codeword 2
            d2 = 1 234 831 232 mod 900 = 632
            
            t = 1 234 831 232 div 900 = 1 372 034
            Calculate codeword 3
            d3 = 1 372 034 mod 900 = 434
            
            t = 1 372 034 div 900 = 1 524
            Calculate codeword 4
            d4 = 1 524 mod 900 = 624
            
            t = 1 524 div 900 = 1
            Calculate codeword 5
            d5 = 1 mod 900 = 1
            t = 1 div 900 = 0
            Codeword sequence is: 1, 624, 434, 632, 282, 200
            
            Decode the above codewords involves
              1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +
            632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000
            
            Remove leading 1 =>  Result is 000213298174000
            <param name="codewords">The array of codewords</param>
            <param name="count">The number of codewords</param>
            <returns>The decoded string representing the Numeric data.</returns>
            </summary>
        </member>
        <member name="T:ZXing.PDF417.Internal.DetectionResult">
            <summary>
            
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResult.Metadata">
            <summary>
            metadata which are found
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResult.DetectionResultColumns">
            <summary>
            result columns
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResult.Box">
            <summary>
            bounding box of the detected result
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResult.ColumnCount">
            <summary>
            column count
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResult.RowCount">
            <summary>
            row count
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResult.ErrorCorrectionLevel">
            <summary>
            error correction level
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.#ctor(ZXing.PDF417.Internal.BarcodeMetadata,ZXing.PDF417.Internal.BoundingBox)">
            <summary>
            initializing constructor
            </summary>
            <param name="metadata"></param>
            <param name="box"></param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.getDetectionResultColumns">
            <summary>
            Returns the DetectionResult Columns.  This does a fair bit of calculation, so call it sparingly.
            </summary>
            <returns>The detection result columns.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustIndicatorColumnRowNumbers(ZXing.PDF417.Internal.DetectionResultColumn)">
            <summary>
            Adjusts the indicator column row numbers.
            </summary>
            <param name="detectionResultColumn">Detection result column.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumbers">
            <summary>
            return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords .
            will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers
            </summary>
            <returns>The row numbers.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumbersByRow">
            <summary>
            Adjusts the row numbers by row.
            </summary>
            <returns>The row numbers by row.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumbersFromBothRI">
            <summary>
            Adjusts the row numbers from both Row Indicators
            </summary>
            <returns> zero </returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumbersFromRRI">
            <summary>
            Adjusts the row numbers from Right Row Indicator.
            </summary>
            <returns>The unadjusted row count.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumbersFromLRI">
            <summary>
            Adjusts the row numbers from Left Row Indicator.
            </summary>
            <returns> Unadjusted row Count.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumberIfValid(System.Int32,System.Int32,ZXing.PDF417.Internal.Codeword)">
            <summary>
            Adjusts the row number if valid.
            </summary>
            <returns>The invalid rows</returns>
            <param name="rowIndicatorRowNumber">Row indicator row number.</param>
            <param name="invalidRowCounts">Invalid row counts.</param>
            <param name="codeword">Codeword.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumbers(System.Int32,System.Int32,ZXing.PDF417.Internal.Codeword[])">
            <summary>
            Adjusts the row numbers.
            </summary>
            <param name="barcodeColumn">Barcode column.</param>
            <param name="codewordsRow">Codewords row.</param>
            <param name="codewords">Codewords.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.adjustRowNumber(ZXing.PDF417.Internal.Codeword,ZXing.PDF417.Internal.Codeword)">
            <summary>
            Adjusts the row number.
            </summary>
            <returns><c>true</c>, if row number was adjusted, <c>false</c> otherwise.</returns>
            <param name="codeword">Codeword.</param>
            <param name="otherCodeword">Other codeword.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResult.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.DetectionResult"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.DetectionResult"/>.</returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.DetectionResultColumn">
            <summary>
            Represents a Column in the Detection Result
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="F:ZXing.PDF417.Internal.DetectionResultColumn.MAX_NEARBY_DISTANCE">
            <summary>
            The maximum distance to search in the codeword array in both the positive and negative directions
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResultColumn.Box">
            <summary>
            The Bounding Box around the column (in the BitMatrix)
            </summary>
            <value>The box.</value>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResultColumn.Codewords">
            <summary>
            The Codewords the Box encodes for, offset by the Box minY.
            Remember to Access this ONLY through GetCodeword(imageRow) if you're accessing it in that manner.
            </summary>
            <value>The codewords.</value>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultColumn.#ctor(ZXing.PDF417.Internal.BoundingBox)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.DetectionResultColumn"/> class.
            </summary>
            <param name="box">The Bounding Box around the column (in the BitMatrix)</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultColumn.IndexForRow(System.Int32)">
            <summary>
            Converts the Image's Row to the index in the Codewords array
            </summary>
            <returns>The Codeword Index.</returns>
            <param name="imageRow">Image row.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultColumn.RowForIndex(System.Int32)">
            <summary>
            Converts the Codeword array index into a Row in the Image (BitMatrix)
            </summary>
            <returns>The Image Row.</returns>
            <param name="codewordIndex">Codeword index.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultColumn.getCodeword(System.Int32)">
            <summary>
            Gets the codeword for a given row
            </summary>
            <returns>The codeword.</returns>
            <param name="imageRow">Image row.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultColumn.getCodewordNearby(System.Int32)">
            <summary>
            Gets the codeword closest to the specified row in the image
            </summary>
            <param name="imageRow">Image row.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultColumn.setCodeword(System.Int32,ZXing.PDF417.Internal.Codeword)">
            <summary>
            Sets the codeword for an image row
            </summary>
            <param name="imageRow">Image row.</param>
            <param name="codeword">Codeword.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultColumn.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.DetectionResultColumn"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.DetectionResultColumn"/>.</returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn">
            <summary>
            Represents a Column in the Detection Result
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="P:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.IsLeft">
            <summary>
            Gets or sets a value indicating whether this instance is the left indicator
            </summary>
            <value><c>true</c> if this instance is left; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.#ctor(ZXing.PDF417.Internal.BoundingBox,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn"/> class.
            </summary>
            <param name="box">Box.</param>
            <param name="isLeft">If set to <c>true</c> is left.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.setRowNumbers">
            <summary>
            Sets the Row Numbers as Inidicator Columns
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.adjustCompleteIndicatorColumnRowNumbers(ZXing.PDF417.Internal.BarcodeMetadata)">
            <summary>
            TODO implement properly
            TODO maybe we should add missing codewords to store the correct row number to make
            finding row numbers for other columns easier
            use row height count to make detection of invalid row numbers more reliable
            </summary>
            <returns>The indicator column row numbers.</returns>
            <param name="metadata">Metadata.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.getRowHeights">
            <summary>
            Gets the row heights.
            </summary>
            <returns>The row heights.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.adjustIncompleteIndicatorColumnRowNumbers(ZXing.PDF417.Internal.BarcodeMetadata)">
            <summary>
            Adjusts the in omplete indicator column row numbers.
            </summary>
            <param name="metadata">Metadata.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.getBarcodeMetadata">
            <summary>
            Gets the barcode metadata.
            </summary>
            <returns>The barcode metadata.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.removeIncorrectCodewords(ZXing.PDF417.Internal.Codeword[],ZXing.PDF417.Internal.BarcodeMetadata)">
            <summary>
            Prune the codewords which do not match the metadata
            TODO Maybe we should keep the incorrect codewords for the start and end positions?
            </summary>
            <param name="codewords">Codewords.</param>
            <param name="metadata">Metadata.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn"/>.</returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.EC.ErrorCorrection">
            <summary>
            <p>PDF417 error correction implementation.</p>
            <p>This <a href="http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example">example</a>
            is quite useful in understanding the algorithm.</p>
            <author>Sean Owen</author>
            <see cref="T:ZXing.Common.ReedSolomon.ReedSolomonDecoder" />
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ErrorCorrection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.EC.ErrorCorrection"/> class.
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ErrorCorrection.decode(System.Int32[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            Decodes the specified received.
            </summary>
            <param name="received">received codewords</param>
            <param name="numECCodewords">number of those codewords used for EC</param>
            <param name="erasures">location of erasures</param>
            <param name="errorLocationsCount">The error locations count.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ErrorCorrection.runEuclideanAlgorithm(ZXing.PDF417.Internal.EC.ModulusPoly,ZXing.PDF417.Internal.EC.ModulusPoly,System.Int32)">
            <summary>
            Runs the euclidean algorithm (Greatest Common Divisor) until r's degree is less than R/2
            </summary>
            <returns>The euclidean algorithm.</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ErrorCorrection.findErrorLocations(ZXing.PDF417.Internal.EC.ModulusPoly)">
            <summary>
            Finds the error locations as a direct application of Chien's search
            </summary>
            <returns>The error locations.</returns>
            <param name="errorLocator">Error locator.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ErrorCorrection.findErrorMagnitudes(ZXing.PDF417.Internal.EC.ModulusPoly,ZXing.PDF417.Internal.EC.ModulusPoly,System.Int32[])">
            <summary>
            Finds the error magnitudes by directly applying Forney's Formula
            </summary>
            <returns>The error magnitudes.</returns>
            <param name="errorEvaluator">Error evaluator.</param>
            <param name="errorLocator">Error locator.</param>
            <param name="errorLocations">Error locations.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.EC.ModulusGF">
            <summary>
            <p>A field based on powers of a generator integer, modulo some modulus.</p>
            <see cref="T:ZXing.Common.ReedSolomon.GenericGFPoly"/>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="T:ZXing.PDF417.Internal.EC.ModulusPoly">
            <summary>
            <see cref="T:ZXing.Common.ReedSolomon.GenericGFPoly"/>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.PDF417.Internal.EC.ModulusPoly.Coefficients">
            <summary>
            Gets the coefficients.
            </summary>
            <value>The coefficients.</value>
        </member>
        <member name="P:ZXing.PDF417.Internal.EC.ModulusPoly.Degree">
            <summary>
            degree of this polynomial
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.EC.ModulusPoly.isZero">
            <summary>
            Gets a value indicating whether this instance is zero.
            </summary>
            <value>true if this polynomial is the monomial "0"
            </value>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.getCoefficient(System.Int32)">
            <summary>
            coefficient of x^degree term in this polynomial
            </summary>
            <param name="degree">The degree.</param>
            <returns>coefficient of x^degree term in this polynomial</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.evaluateAt(System.Int32)">
            <summary>
            evaluation of this polynomial at a given point
            </summary>
            <param name="a">A.</param>
            <returns>evaluation of this polynomial at a given point</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.add(ZXing.PDF417.Internal.EC.ModulusPoly)">
            <summary>
            Adds another Modulus
            </summary>
            <param name="other">Other.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.subtract(ZXing.PDF417.Internal.EC.ModulusPoly)">
            <summary>
            Subtract another Modulus
            </summary>
            <param name="other">Other.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.multiply(ZXing.PDF417.Internal.EC.ModulusPoly)">
            <summary>
            Multiply by another Modulus
            </summary>
            <param name="other">Other.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.getNegative">
            <summary>
            Returns a Negative version of this instance
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.multiply(System.Int32)">
            <summary>
            Multiply by a Scalar.
            </summary>
            <param name="scalar">Scalar.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.multiplyByMonomial(System.Int32,System.Int32)">
            <summary>
            Multiplies by a Monomial
            </summary>
            <returns>The by monomial.</returns>
            <param name="degree">Degree.</param>
            <param name="coefficient">Coefficient.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.EC.ModulusPoly.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.EC.ModulusPoly"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:ZXing.PDF417.Internal.EC.ModulusPoly"/>.</returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417CodewordDecoder">
            <summary>
            
            </summary>
            <author>Guenther Grau</author>
            <author>creatale GmbH (christoph.schulz@creatale.de)</author>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417CodewordDecoder.RATIOS_TABLE">
            <summary>
            The ratios table
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417CodewordDecoder.#cctor">
            <summary>
            Initializes the <see cref="T:ZXing.PDF417.Internal.PDF417CodewordDecoder"/> class &amp; Pre-computes the symbol ratio table.
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417CodewordDecoder.getDecodedValue(System.Int32[])">
            <summary>
            Gets the decoded value.
            </summary>
            <returns>The decoded value.</returns>
            <param name="moduleBitCount">Module bit count.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417CodewordDecoder.sampleBitCounts(System.Int32[])">
            <summary>
            Samples the bit counts.
            </summary>
            <returns>The bit counts.</returns>
            <param name="moduleBitCount">Module bit count.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417CodewordDecoder.getDecodedCodewordValue(System.Int32[])">
            <summary>
            Gets the decoded codeword value.
            </summary>
            <returns>The decoded codeword value.</returns>
            <param name="moduleBitCount">Module bit count.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417CodewordDecoder.getBitValue(System.Int32[])">
            <summary>
            Gets the bit value.
            </summary>
            <returns>The bit value.</returns>
            <param name="moduleBitCount">Module bit count.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417CodewordDecoder.getClosestDecodedValue(System.Int32[])">
            <summary>
            Gets the closest decoded value.
            </summary>
            <returns>The closest decoded value.</returns>
            <param name="moduleBitCount">Module bit count.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417ScanningDecoder">
            <summary>
            
            </summary>
            <author>Guenther Grau</author>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.decode(ZXing.Common.BitMatrix,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint,System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            Decode the specified image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth
            and maxCodewordWidth.
            TODO: don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern
            columns. That way width can be deducted from the pattern column.
            This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider 
            than it should be. This can happen if the scanner used a bad blackpoint.
            </summary>
            <param name="image">Image.</param>
            <param name="imageTopLeft">Image top left.</param>
            <param name="imageBottomLeft">Image bottom left.</param>
            <param name="imageTopRight">Image top right.</param>
            <param name="imageBottomRight">Image bottom right.</param>
            <param name="minCodewordWidth">Minimum codeword width.</param>
            <param name="maxCodewordWidth">Max codeword width.</param>
            <param name="startWithEncoding"></param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.merge(ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn,ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn)">
            <summary>
            Merge the specified leftRowIndicatorColumn and rightRowIndicatorColumn.
            </summary>
            <param name="leftRowIndicatorColumn">Left row indicator column.</param>
            <param name="rightRowIndicatorColumn">Right row indicator column.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.adjustBoundingBox(ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn)">
            <summary>
            Adjusts the bounding box.
            </summary>
            <returns>The bounding box.</returns>
            <param name="rowIndicatorColumn">Row indicator column.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getBarcodeMetadata(ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn,ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn)">
            <summary>
            Gets the barcode metadata.
            </summary>
            <returns>The barcode metadata.</returns>
            <param name="leftRowIndicatorColumn">Left row indicator column.</param>
            <param name="rightRowIndicatorColumn">Right row indicator column.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getRowIndicatorColumn(ZXing.Common.BitMatrix,ZXing.PDF417.Internal.BoundingBox,ZXing.ResultPoint,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Gets the row indicator column.
            </summary>
            <returns>The row indicator column.</returns>
            <param name="image">Image.</param>
            <param name="boundingBox">Bounding box.</param>
            <param name="startPoint">Start point.</param>
            <param name="leftToRight">If set to <c>true</c> left to right.</param>
            <param name="minCodewordWidth">Minimum codeword width.</param>
            <param name="maxCodewordWidth">Max codeword width.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.adjustCodewordCount(ZXing.PDF417.Internal.DetectionResult,ZXing.PDF417.Internal.BarcodeValue[][])">
            <summary>
            Adjusts the codeword count.
            </summary>
            <param name="detectionResult">Detection result.</param>
            <param name="barcodeMatrix">Barcode matrix.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.createDecoderResult(ZXing.PDF417.Internal.DetectionResult,System.Text.Encoding)">
            <summary>
            Creates the decoder result.
            </summary>
            <returns>The decoder result.</returns>
            <param name="detectionResult">Detection result.</param>
            <param name="startWithEncoding"></param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[][],System.Text.Encoding)">
            <summary>
            This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The
            current error correction implementation doesn't deal with erasures very well, so it's better to provide a value
            for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of
            the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the
            ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,
            so decoding the normal barcodes is not affected by this.
            </summary>
            <returns>The decoder result from ambiguous values.</returns>
            <param name="ecLevel">Ec level.</param>
            <param name="codewords">Codewords.</param>
            <param name="erasureArray">contains the indexes of erasures.</param>
            <param name="ambiguousIndexes">array with the indexes that have more than one most likely value.</param>
            <param name="ambiguousIndexValues">two dimensional array that contains the ambiguous values. The first dimension must
            be the same Length as the ambiguousIndexes array.</param>
            <param name="startWithEncoding"></param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.createBarcodeMatrix(ZXing.PDF417.Internal.DetectionResult)">
            <summary>
            Creates the barcode matrix.
            </summary>
            <returns>The barcode matrix.</returns>
            <param name="detectionResult">Detection result.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.isValidBarcodeColumn(ZXing.PDF417.Internal.DetectionResult,System.Int32)">
            <summary>
            Tests to see if the Barcode Column is Valid
            </summary>
            <returns><c>true</c>, if barcode column is valid, <c>false</c> otherwise.</returns>
            <param name="detectionResult">Detection result.</param>
            <param name="barcodeColumn">Barcode column.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getStartColumn(ZXing.PDF417.Internal.DetectionResult,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets the start column.
            </summary>
            <returns>The start column.</returns>
            <param name="detectionResult">Detection result.</param>
            <param name="barcodeColumn">Barcode column.</param>
            <param name="imageRow">Image row.</param>
            <param name="leftToRight">If set to <c>true</c> left to right.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.detectCodeword(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Detects the codeword.
            </summary>
            <returns>The codeword.</returns>
            <param name="image">Image.</param>
            <param name="minColumn">Minimum column.</param>
            <param name="maxColumn">Max column.</param>
            <param name="leftToRight">If set to <c>true</c> left to right.</param>
            <param name="startColumn">Start column.</param>
            <param name="imageRow">Image row.</param>
            <param name="minCodewordWidth">Minimum codeword width.</param>
            <param name="maxCodewordWidth">Max codeword width.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getModuleBitCount(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Gets the module bit count.
            </summary>
            <returns>The module bit count.</returns>
            <param name="image">Image.</param>
            <param name="minColumn">Minimum column.</param>
            <param name="maxColumn">Max column.</param>
            <param name="leftToRight">If set to <c>true</c> left to right.</param>
            <param name="startColumn">Start column.</param>
            <param name="imageRow">Image row.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getNumberOfECCodeWords(System.Int32)">
            <summary>
            Gets the number of EC code words.
            </summary>
            <returns>The number of EC code words.</returns>
            <param name="barcodeECLevel">Barcode EC level.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.adjustCodewordStartColumn(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Adjusts the codeword start column.
            </summary>
            <returns>The codeword start column.</returns>
            <param name="image">Image.</param>
            <param name="minColumn">Minimum column.</param>
            <param name="maxColumn">Max column.</param>
            <param name="leftToRight">If set to <c>true</c> left to right.</param>
            <param name="codewordStartColumn">Codeword start column.</param>
            <param name="imageRow">Image row.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.checkCodewordSkew(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks the codeword for any skew.
            </summary>
            <returns><c>true</c>, if codeword is within the skew, <c>false</c> otherwise.</returns>
            <param name="codewordSize">Codeword size.</param>
            <param name="minCodewordWidth">Minimum codeword width.</param>
            <param name="maxCodewordWidth">Max codeword width.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.decodeCodewords(System.Int32[],System.Int32,System.Int32[],System.Text.Encoding)">
            <summary>
            Decodes the codewords.
            </summary>
            <returns>The codewords.</returns>
            <param name="codewords">Codewords.</param>
            <param name="ecLevel">Ec level.</param>
            <param name="erasures">Erasures.</param>
            <param name="startWithEncoding"></param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.correctErrors(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Given data and error-correction codewords received, possibly corrupted by errors, attempts to
            correct the errors in-place.
            </summary>
            <returns>The errors.</returns>
            <param name="codewords">data and error correction codewords.</param>
            <param name="erasures">positions of any known erasures.</param>
            <param name="numECCodewords">number of error correction codewords that are available in codewords.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.verifyCodewordCount(System.Int32[],System.Int32)">
            <summary>
            Verifies that all is well with the codeword array.
            </summary>
            <param name="codewords">Codewords.</param>
            <param name="numECCodewords">Number EC codewords.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getBitCountForCodeword(System.Int32)">
            <summary>
            Gets the bit count for codeword.
            </summary>
            <returns>The bit count for codeword.</returns>
            <param name="codeword">Codeword.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getCodewordBucketNumber(System.Int32)">
            <summary>
            Gets the codeword bucket number.
            </summary>
            <returns>The codeword bucket number.</returns>
            <param name="codeword">Codeword.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.getCodewordBucketNumber(System.Int32[])">
            <summary>
            Gets the codeword bucket number.
            </summary>
            <returns>The codeword bucket number.</returns>
            <param name="moduleBitCount">Module bit count.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ScanningDecoder.ToString(ZXing.PDF417.Internal.BarcodeValue[][])">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the <see cref="T:ZXing.PDF417.Internal.BarcodeValue"/> jagged array.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the <see cref="T:ZXing.PDF417.Internal.BarcodeValue"/> jagged array.</returns>
            <param name="barcodeMatrix">Barcode matrix as a jagged array.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.Detector">
             <summary>
             <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the
             PDF417 Code is rotated or skewed, or partially obscured.</p>
            
             <author>SITA Lab (kevin.osullivan@sita.aero)</author>
             <author>dswitkin@google.com (Daniel Switkin)</author>
             <author> Guenther Grau</author>
             </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Detector.START_PATTERN">
            <summary>
            B S B S B S B S Bar/Space pattern
            11111111 0 1 0 1 0 1 000.
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Detector.STOP_PATTERN">
            <summary>
            1111111 0 1 000 1 0 1 00 1
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Detector.SKIPPED_ROW_COUNT_MAX">
            <summary>
            if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.
            if we set the value too high, then we might detect the start pattern from a neighbor barcode.
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Detector.ROW_STEP">
            <summary>
            A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least
            9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.detect(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object},System.Boolean)">
            <summary>
              <p>Detects a PDF417 Code in an image. Checks 0, 90, 180, and 270 degree rotations.</p>
            </summary>
            <param name="image">barcode image to decode</param>
            <param name="hints">optional hints to detector</param>
            <param name="multiple">if true, then the image is searched for multiple codes. If false, then at most one code will be found and returned</param>
            <returns>
              <see cref="T:ZXing.PDF417.Internal.PDF417DetectorResult"/> encapsulating results of detecting a PDF417 code
            </returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.applyRotation(ZXing.Common.BitMatrix,System.Int32)">
            <summary>
            Applies a rotation to the supplied BitMatrix.
            </summary>
            <param name="matrix">bit matrix to apply rotation to</param>
            <param name="rotation">the degrees of rotation to apply</param>
            <returns>BitMatrix with applied rotation</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.detect(System.Boolean,ZXing.Common.BitMatrix)">
            <summary>
            Detects PDF417 codes in an image. Only checks 0 degree rotation (so rotate the matrix and check again outside of this method)
            </summary>
            <param name="multiple">multiple if true, then the image is searched for multiple codes. If false, then at most one code will be found and returned.</param>
            <param name="bitMatrix">bit matrix to detect barcodes in.</param>
            <returns>List of ResultPoint arrays containing the coordinates of found barcodes</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.findVertices(ZXing.Common.BitMatrix,System.Int32,System.Int32)">
            <summary>
            Locate the vertices and the codewords area of a black blob using the Start and Stop patterns as locators.
            </summary>
            <param name="matrix">Matrix.</param>
            <param name="startRow">Start row.</param>
            <param name="startColumn">Start column.</param>
            <returns> an array containing the vertices:
                      vertices[0] x, y top left barcode
                      vertices[1] x, y bottom left barcode
                      vertices[2] x, y top right barcode
                      vertices[3] x, y bottom right barcode
                      vertices[4] x, y top left codeword area
                      vertices[5] x, y bottom left codeword area
                      vertices[6] x, y top right codeword area
                      vertices[7] x, y bottom right codeword area
            </returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.copyToResult(ZXing.ResultPoint[],ZXing.ResultPoint[],System.Int32[])">
            <summary>
            Copies the temp data to the final result
            </summary>
            <param name="result">Result.</param>
            <param name="tmpResult">Temp result.</param>
            <param name="destinationIndexes">Destination indexes.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.findRowsWithPattern(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
            Finds the rows with the given pattern.
            </summary>
            <returns>The rows with pattern.</returns>
            <param name="matrix">Matrix.</param>
            <param name="height">Height.</param>
            <param name="width">Width.</param>
            <param name="startRow">Start row.</param>
            <param name="startColumn">Start column.</param>
            <param name="pattern">Pattern.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.findGuardPattern(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Finds the guard pattern.  Uses System.Linq.Enumerable.Repeat to fill in counters.  This might be a performance issue?
            </summary>
            <returns>start/end horizontal offset of guard pattern, as an array of two ints.</returns>
            <param name="matrix">matrix row of black/white values to search</param>
            <param name="column">column x position to start search.</param>
            <param name="row">row y position to start search.</param>
            <param name="width">width the number of pixels to search on this row.</param>
            <param name="pattern">pattern of counts of number of black and white pixels that are being searched for as a pattern.</param>
            <param name="counters">counters array of counters, as long as pattern, to re-use .</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.Detector.patternMatchVariance(System.Int32[],System.Int32[])">
            <summary>
            Determines how closely a set of observed counts of runs of black/white.
            values matches a given target pattern. This is reported as the ratio of
            the total variance from the expected pattern proportions across all
            pattern elements, to the length of the pattern.
            </summary>
            <returns>
            ratio of total variance between counters and pattern compared to
            total pattern size, where the ratio has been multiplied by 256.
            So, 0 means no variance (perfect match); 256 means the total
            variance between counters and patterns equals the pattern length,
            higher values mean even more variance
            </returns>
            <param name="counters">observed counters.</param>
            <param name="pattern">expected pattern.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417DetectorResult">
            <summary>
            PDF 417 Detector Result class.  Skipped private backing stores.
            <author>Guenther Grau</author> 
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.PDF417DetectorResult.Bits">
            <summary>
            bit matrix of the detected result
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.PDF417DetectorResult.Points">
            <summary>
            points of the detected result in the image
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.PDF417DetectorResult.Rotation">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417DetectorResult.#ctor(ZXing.Common.BitMatrix,System.Collections.Generic.List{ZXing.ResultPoint[]},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.PDF417DetectorResult"/> class.
            </summary>
            <param name="bits">Bits.</param>
            <param name="points">Points.</param>
            <param name="rotation">Rotation.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417DetectorResult.#ctor(ZXing.Common.BitMatrix,System.Collections.Generic.List{ZXing.ResultPoint[]})">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.PDF417DetectorResult"/> class.
            </summary>
            <param name="bits">Bits.</param>
            <param name="points">Points.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417AspectRatio">
            <summary>
            defines the aspect ratio of the image
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417AspectRatio.A1">
            <summary>
            ratio 1
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417AspectRatio.A2">
            <summary>
            ratio 2
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417AspectRatio.A3">
            <summary>
            ratio 3
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417AspectRatio.A4">
            <summary>
            ratio 4
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417AspectRatio.AUTO">
            <summary>
            automatic selection
            </summary>
        </member>
        <member name="T:ZXing.PDF417.Internal.BarcodeMatrix">
             <summary>
             Holds all of the information for a barcode in a format where it can be easily accessible
            
             <author>Jacob Haynes</author>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeMatrix.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            <param name="height">the height of the matrix (Rows)</param>
            <param name="width">the width of the matrix (Cols)</param>
            <param name="compact">defines if a compact PDF417 should be encoded</param>
            </summary>
        </member>
        <member name="T:ZXing.PDF417.Internal.BarcodeRow">
            <summary>
            <author>Jacob Haynes</author>
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeRow.#ctor(System.Int32)">
            <summary>
            Creates a Barcode row of the width
            </summary>
            <param name="width">The width.</param>
        </member>
        <member name="P:ZXing.PDF417.Internal.BarcodeRow.Item(System.Int32)">
             <summary>
             Sets a specific location in the bar
            
             <param name="x">The location in the bar</param>
             <return>Black if true, white if false;</return>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeRow.set(System.Int32,System.Boolean)">
             <summary>
             Sets a specific location in the bar
            
             <param name="x">The location in the bar</param>
             <param name="black">Black if true, white if false;</param>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeRow.addBar(System.Boolean,System.Int32)">
            <summary>
            <param name="black">A boolean which is true if the bar black false if it is white</param>
            <param name="width">How many spots wide the bar is.</param>
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.BarcodeRow.getScaledRow(System.Int32)">
             <summary>
             This function scales the row
            
             <param name="scale">How much you want the image to be scaled, must be greater than or equal to 1.</param>
             <returns>the scaled row</returns>
             </summary>
        </member>
        <member name="T:ZXing.PDF417.Internal.Compaction">
            <summary>
            Represents possible PDF417 barcode compaction types.
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Compaction.AUTO">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Compaction.TEXT">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Compaction.BYTE">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.Compaction.NUMERIC">
            <summary>
            
            </summary>
        </member>
        <member name="T:ZXing.PDF417.Internal.Dimensions">
            <summary>
            Data object to specify the minimum and maximum number of rows and columns for a PDF417 barcode.
            @author qwandor@google.com (Andrew Walbran)
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.Dimensions.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PDF417.Internal.Dimensions"/> class.
            </summary>
            <param name="minCols">The min cols.</param>
            <param name="maxCols">The max cols.</param>
            <param name="minRows">The min rows.</param>
            <param name="maxRows">The max rows.</param>
        </member>
        <member name="P:ZXing.PDF417.Internal.Dimensions.MinCols">
            <summary>
            Gets the min cols.
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Dimensions.MaxCols">
            <summary>
            Gets the max cols.
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Dimensions.MinRows">
            <summary>
            Gets the min rows.
            </summary>
        </member>
        <member name="P:ZXing.PDF417.Internal.Dimensions.MaxRows">
            <summary>
            Gets the max rows.
            </summary>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417">
            <summary>
            Top-level class for the logic part of the PDF417 implementation.
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417.START_PATTERN">
            <summary>
            The start pattern (17 bits)
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417.STOP_PATTERN">
            <summary>
            The stop pattern (18 bits)
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417.MACRO_LAST_SEGMENT">
            <summary>
            The macro last segment
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417.MACRO_SEGMENT_ID">
            <summary>
            The macro segment identifier
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417.CODEWORD_TABLE">
            <summary>
            The codeword table from the Annex A of ISO/IEC 15438:2001(E).
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.calculateNumberOfRows(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the necessary number of rows as described in annex Q of ISO/IEC 15438:2001(E).
            </summary>
            <param name="m">the number of source codewords prior to the additional of the Symbol Length</param>
                     Descriptor and any pad codewords
            <param name="k">the number of error correction codewords</param>
            <param name="c">the number of columns in the symbol in the data region (excluding start, stop and</param>
                     row indicator codewords)
            <returns>the number of rows in the symbol (r)</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.getNumberOfPadCodewords(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the number of pad codewords as described in 4.9.2 of ISO/IEC 15438:2001(E).
            </summary>
            <param name="m">the number of source codewords prior to the additional of the Symbol Length</param>
                     Descriptor and any pad codewords
            <param name="k">the number of error correction codewords</param>
            <param name="c">the number of columns in the symbol in the data region (excluding start, stop and</param>
                     row indicator codewords)
            <param name="r">the number of rows in the symbol</param>
            <returns>the number of pad codewords</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.generateBarcodeLogic(System.String,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Generates the barcode logic.
            </summary>
            <param name="msg">the message to encode</param>
            <param name="errorCorrectionLevel">PDF417 error correction level to use</param>
            <param name="longDimension"></param>
            <param name="shortDimension"></param>
            <param name="aspectRatio"></param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.generateBarcodeLogic(System.String,System.Int32,System.Int32,System.Int32,System.Int32@,System.Boolean)">
            <summary>
            Generates the barcode logic.
            </summary>
            <param name="msg">the message to encode</param>
            <param name="errorCorrectionLevel">PDF417 error correction level to use</param>
            <param name="longDimension"></param>
            <param name="shortDimension"></param>
            <param name="aspectRatio"></param>
            <param name="autoECI">automatically insert ECIs if needed</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.getMacroBlock(System.Int32@)">
            <summary>
            Gets the macro block.
            </summary>
            <returns>System.String.</returns>
            <exception cref="T:ZXing.WriterException">
            The macro segment index must be greater than or equal to 0.
            or
            The macro segment index must be less than the segment count.
            or
            The macro segment count must be greater than 0.
            </exception>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.appendMacroOptionalField(ZXing.PDF417.Internal.PDF417OptionalMacroFields,System.String,System.Int32@,System.Text.StringBuilder)">
            <summary>
            Appends optional macro fields.
            </summary>
            <param name="field">The field.</param>
            <param name="value">The value.</param>
            <param name="sourceCodeWords">The source code word length.</param>
            <param name="macroCodewords">The macro codewords.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.determineDimensions(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Determine optimal nr of columns and rows for the specified number of
            codewords.
            </summary>
            <param name="sourceCodeWords">number of code words</param>
            <param name="errorCorrectionCodeWords">number of error correction code words</param>
            <param name="longDimension">The longest dimension of the barcode, used for columns</param>
            <param name="shortDimension">The short dimension of the barcode, used for rows</param>
            <param name="aspectRatio">The height of a row, will alter this parameter if aspectRatio>4 (aspectRatio==AUTO)</param>
            <returns>dimension object containing cols as width and rows as height</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.setDesiredAspectRatio(System.Single)">
            <summary>
            Sets the desired aspect ratio for the output image.
            </summary>
            <param name="ratio"></param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.setDimensions(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets max/min row/col values
            </summary>
            <param name="maxCols">maximum allowed columns</param>
            <param name="minCols">minimum allowed columns</param>
            <param name="maxRows">maximum allowed rows</param>
            <param name="minRows">minimum allowed rows</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.setCompaction(ZXing.PDF417.Internal.Compaction)">
            <summary>
            Sets compaction to values stored in <see cref="T:ZXing.PDF417.Internal.Compaction"/>enum
            </summary>
            <param name="compaction">compaction mode to use</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.setCompact(System.Boolean)">
            <summary>
            Sets compact to be true or false
            </summary>
            <param name="compact">if true, enables compaction</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.setEncoding(System.Text.Encoding)">
            <summary>
            Sets output encoding.
            </summary>
            <param name="encoding">sets character encoding to use</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.setDisableEci(System.Boolean)">
            <summary>
            Sets the disable eci.
            </summary>
            <param name="disabled">if set to <c>true</c> don't add an ECI segment for different encodings than default.</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417.setMetaData(ZXing.PDF417.PDF417MacroMetadata)">
            <summary>
            Sets the meta data.
            </summary>
            <param name="metadata">The metadata.</param>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417ErrorCorrection">
            <summary>
            PDF417 error correction code following the algorithm described in ISO/IEC 15438:2001(E) in
            chapter 4.10.
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrection.EC_COEFFICIENTS">
            <summary>
            Tables of coefficients for calculating error correction words
            (see annex F, ISO/IEC 15438:2001(E))
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ErrorCorrection.getErrorCorrectionCodewordCount(System.Int32)">
            <summary>
            Determines the number of error correction codewords for a specified error correction
            level.
            </summary>
            <param name="errorCorrectionLevel">the error correction level (0-8)</param>
            <returns>the number of codewords generated for error correction</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ErrorCorrection.getErrorCorrectionLevel(System.Int32,System.Int32)">
            <summary>
            Determines the error correction level for AUTO
            </summary>
            <param name="errorCorrectionLevel">The error correction level (0-9)</param>
            <param name="sourceCodeWords">The number of codewords for AUTO errorCorrectionLevel</param>
            <returns>the number of codewords generated for error correction</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ErrorCorrection.getRecommendedMinimumErrorCorrectionLevel(System.Int32)">
            <summary>
            Returns the recommended minimum error correction level as described in annex E of
            ISO/IEC 15438:2001(E).
            </summary>
            <param name="n">the number of data codewords</param>
            <returns>the recommended minimum error correction level</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417ErrorCorrection.generateErrorCorrection(System.String,System.Int32)">
            <summary>
            Generates the error correction codewords according to 4.10 in ISO/IEC 15438:2001(E).
            </summary>
            <param name="dataCodewords">the data codewords</param>
            <param name="errorCorrectionLevel">the error correction level (0-8)</param>
            <returns>the String representing the error correction codewords</returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel">
            <summary>
            defines the level of the error correction / count of error correction codewords
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L0">
            <summary>
            level 0
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L1">
            <summary>
            level 1
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L2">
            <summary>
            level 2
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L3">
            <summary>
            level 3
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L4">
            <summary>
            level 4
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L5">
            <summary>
            level 5
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L6">
            <summary>
            level 6
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L7">
            <summary>
            level 7
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.L8">
            <summary>
            level 8
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel.AUTO">
            <summary>
            automatic selection
            </summary>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417HighLevelEncoder">
            <summary>
            PDF417 high-level encoder following the algorithm described in ISO/IEC 15438:2001(E) in
            annex P.
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.TEXT_COMPACTION">
            <summary>
            code for Text compaction
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.BYTE_COMPACTION">
            <summary>
            code for Byte compaction
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.NUMERIC_COMPACTION">
            <summary>
            code for Numeric compaction
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.SUBMODE_ALPHA">
            <summary>
            Text compaction submode Alpha
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.SUBMODE_LOWER">
            <summary>
            Text compaction submode Lower
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.SUBMODE_MIXED">
            <summary>
            Text compaction submode Mixed
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.SUBMODE_PUNCTUATION">
            <summary>
            Text compaction submode Punctuation
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.LATCH_TO_TEXT">
            <summary>
            mode latch to Text Compaction mode
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.LATCH_TO_BYTE_PADDED">
            <summary>
            mode latch to Byte Compaction mode (number of characters NOT a multiple of 6)
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.LATCH_TO_NUMERIC">
            <summary>
            mode latch to Numeric Compaction mode
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.SHIFT_TO_BYTE">
            <summary>
            mode shift to Byte Compaction mode
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.LATCH_TO_BYTE">
            <summary>
            mode latch to Byte Compaction mode (number of characters a multiple of 6)
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.ECI_USER_DEFINED">
            <summary>
            identifier for a user defined Extended Channel Interpretation (ECI)
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.ECI_GENERAL_PURPOSE">
            <summary>
            identifier for a general purpose ECO format
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.ECI_CHARSET">
            <summary>
            identifier for an ECI of a character set of code page
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.TEXT_MIXED_RAW">
            <summary>
            Raw code table for text compaction Mixed sub-mode
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417HighLevelEncoder.TEXT_PUNCTUATION_RAW">
            <summary>
            Raw code table for text compaction: Punctuation sub-mode
            </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417HighLevelEncoder.encodeHighLevel(System.String,ZXing.PDF417.Internal.Compaction,System.Text.Encoding,System.Boolean,System.Boolean)">
            <summary>
            Performs high-level encoding of a PDF417 message using the algorithm described in annex P
            of ISO/IEC 15438:2001(E). If byte compaction has been selected, then only byte compaction
            is used.
            </summary>
            <param name="msg">the message</param>
            <param name="compaction">compaction mode to use</param>
            <param name="encoding">character encoding used to encode in default or byte compaction
            or null for default / not applicable</param>
            <param name="disableEci">if true, don't add an ECI segment for different encodings than default</param>
            <param name="autoECI">encode input minimally using multiple ECIs if needed
            If autoECI encoding is specified and additionally {@code encoding} is specified, then the encoder
            will use the specified {@link Charset}
            for any character that can be encoded by it, regardless
            if a different encoding would lead to a more compact encoding. When no {@code encoding} is specified
            then charsets will be chosen so that the byte representation is minimal.</param>
            <returns>the encoded message (the char values range from 0 to 928)</returns>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417HighLevelEncoder.encodeText(ZXing.Common.ECIInput,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32)">
             <summary>
             Encode parts of the message using Text Compaction as described in ISO/IEC 15438:2001(E),
             chapter 4.4.2.
            
             <param name="input">the input</param>
             <param name="startpos">the start position within the message</param>
             <param name="count">the number of characters to encode</param>
             <param name="sb">receives the encoded codewords</param>
             <param name="initialSubmode">should normally be SUBMODE_ALPHA</param>
             <returns>the text submode in which this method ends</returns>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417HighLevelEncoder.encodeMultiECIBinary(ZXing.Common.ECIInput,System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Encode all of the message using Byte Compaction as described in ISO/IEC 15438:2001(E)
            </summary>
            <param name="input">the input</param>
            <param name="startpos">the start position within the message</param>
            <param name="count">the number of bytes to encode</param>
            <param name="startmode">the mode from which this method starts</param>
            <param name="sb">receives the encoded codewords</param>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417HighLevelEncoder.encodeBinary(System.Byte[],System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
             <summary>
             Encode parts of the message using Byte Compaction as described in ISO/IEC 15438:2001(E),
             chapter 4.4.3. The Unicode characters will be converted to binary using the cp437
             codepage.
            
             <param name="bytes">the message converted to a byte array</param>
             <param name="startpos">the start position within the message</param>
             <param name="count">the number of bytes to encode</param>
             <param name="startmode">the mode from which this method starts</param>
             <param name="sb">receives the encoded codewords</param>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417HighLevelEncoder.determineConsecutiveDigitCount(ZXing.Common.ECIInput,System.Int32)">
             <summary>
             Determines the number of consecutive characters that are encodable using numeric compaction.
            
             <param name="input">the input</param>
             <param name="startpos">the start position within the message</param>
             <returns>the requested character count</returns>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417HighLevelEncoder.determineConsecutiveTextCount(ZXing.Common.ECIInput,System.Int32)">
             <summary>
             Determines the number of consecutive characters that are encodable using text compaction.
            
             <param name="input">the input</param>
             <param name="startpos">the start position within the message</param>
             <returns>the requested character count</returns>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.Internal.PDF417HighLevelEncoder.determineConsecutiveBinaryCount(ZXing.Common.ECIInput,System.Int32,System.Text.Encoding)">
            <summary>
            Determines the number of consecutive characters that are encodable using binary compaction.
            </summary>
            <param name="input">the input</param>
            <param name="startpos">the start position within the message</param>
            <param name="encoding"></param>
            <returns>the requested character count</returns>
        </member>
        <member name="T:ZXing.PDF417.Internal.PDF417OptionalMacroFields">
            <summary>
            Macro PDF417 optional fields.
            </summary>
            <remarks>The values are set to their field designator.</remarks>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417OptionalMacroFields.FileName">
            <summary>
            The file name.
            Field designator: 0
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417OptionalMacroFields.SegmentCount">
            <summary>
            The segment count field can contain values from 1 to 99,999.
            Field designator: 1
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417OptionalMacroFields.TimeStamp">
            <summary>
            The time stamp of the source file expressed in Unix time.
            Field designator: 2
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417OptionalMacroFields.Sender">
            <summary>
            The sender.
            Field designator: 3
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417OptionalMacroFields.Addressee">
            <summary>
            The addressee.
            Field designator: 4
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417OptionalMacroFields.FileSize">
            <summary>
            The file size in bytes.
            Field designator: 5
            </summary>
        </member>
        <member name="F:ZXing.PDF417.Internal.PDF417OptionalMacroFields.Checksum">
            <summary>
            The 16-bit CRC checksum using the CCITT-16 polynomial.
            Field designator: 6
            </summary>
        </member>
        <member name="T:ZXing.PDF417.PDF417EncodingOptions">
            <summary>
            The class holds the available options for the <see cref="T:ZXing.PDF417.PDF417Writer" />
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.Compact">
            <summary>
            Specifies whether to use compact mode for PDF417 (type <see cref="T:System.Boolean" />).
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.Compaction">
            <summary>
            Specifies what compaction mode to use for PDF417 (type
            <see cref="P:ZXing.PDF417.PDF417EncodingOptions.Compaction" />).
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.Dimensions">
            <summary>
            Specifies the minimum and maximum number of rows and columns for PDF417 (type
            <see cref="P:ZXing.PDF417.PDF417EncodingOptions.Dimensions" />).
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.ErrorCorrection">
            <summary>
            Specifies what degree of error correction to use
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.AspectRatio">
            <summary>
            Specifies the aspect ratio of the smallest codeword.
            (Width of narrowest bar / Row Height)
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.ImageAspectRatio">
            <summary>
            Specifies the desired output image aspect ratio (Width / Height).
            The actual aspect ratio is calculated based on the necessary number of codewords.
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.CharacterSet">
            <summary>
            Specifies what character encoding to use where applicable (type {@link String})
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417EncodingOptions.DisableECI">
            <summary>
            Explicitly disables ECI segment when generating PDF417 Code
            That is against the specification but some
            readers have problems if the charset is switched from
            CP437 (default) to UTF-8 with the necessary ECI segment.
            If you set the property to true you can use different encodings
            and the ECI segment is omitted.
            </summary>
        </member>
        <member name="T:ZXing.PDF417.PDF417Common">
            <summary>
            <author>SITA Lab (kevin.osullivan@sita.aero) </author>
            <author>Guenther Grau</author>
            </summary>
        </member>
        <member name="F:ZXing.PDF417.PDF417Common.MAX_CODEWORDS_IN_BARCODE">
            <summary>
            Maximum Codewords (Data + Error).
            </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417Common.getBitCountSum(System.Int32[])">
            <summary>
            Gets the bit count sum.
            </summary>
            <returns>The bit count sum.</returns>
            <param name="moduleBitCount">Module bit count.</param>
        </member>
        <member name="M:ZXing.PDF417.PDF417Common.toIntArray(System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Converts an ICollection&lt;int&gt; to an int[]
            Carry-over from Java.  Will likely remove and replace with the Generic .ToArray() method.
            </summary>
            <returns>The int array.</returns>
            <param name="list">List.</param>
        </member>
        <member name="M:ZXing.PDF417.PDF417Common.getCodeword(System.Int64)">
            <summary>
            Translate the symbol into a codeword
            </summary>
            <returns>the codeword corresponding to the symbol.</returns>
            <param name="symbol">encoded symbol to translate to a codeword</param>
        </member>
        <member name="F:ZXing.PDF417.PDF417Common.SYMBOL_TABLE">
            <summary>
            The sorted table of all possible symbols. Extracted from the PDF417
            specification. The index of a symbol in this table corresponds to the
            index into the codeword table.
            </summary>
        </member>
        <member name="F:ZXing.PDF417.PDF417Common.CODEWORD_TABLE">
            <summary>
            This table contains to codewords for all symbols.
            </summary>
        </member>
        <member name="T:ZXing.PDF417.PDF417MacroMetadata">
            <summary>
            PDF417 Macro meta data.
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.SegmentIndex">
            <summary>
            The Segment ID represents the segment of the whole file distributed over different symbols.
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.FileId">
            <summary>
            Is the same for each related PDF417 symbol
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.IsLastSegment">
            <summary>
            true if it is the last segment
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.SegmentCount">
            <summary>
            count of segments, -1 if not set
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.Sender">
            <summary>
            sender
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.Addressee">
            <summary>
            address
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.FileName">
            <summary>
            Filename of the encoded file
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.FileSize">
            <summary>
            filesize in bytes of the encoded file
            returns filesize in bytes, -1 if not set
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.Checksum">
            <summary>
            16-bit CRC checksum using CCITT-16
            returns crc checksum, -1 if not set
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417MacroMetadata.Timestamp">
            <summary>
            unix epock timestamp, elapsed seconds since 1970-01-01
            returns elapsed seconds, -1 if not set
            </summary>
        </member>
        <member name="T:ZXing.PDF417.PDF417Reader">
             <summary>
             This implementation can detect and decode PDF417 codes in an image.
            
             <author>SITA Lab (kevin.osullivan@sita.aero)</author>
             <author>Guenther Grau</author>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.decode(ZXing.BinaryBitmap)">
             <summary>
             Locates and decodes a PDF417 code in an image.
            
             <returns>a String representing the content encoded by the PDF417 code</returns>
             <exception cref="T:ZXing.FormatException">if a PDF417 cannot be decoded</exception>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes a barcode in some format within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            **Note** this will return the FIRST barcode discovered if there are many.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:ZXing.DecodeHintType"/>
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.decodeMultiple(ZXing.BinaryBitmap)">
             <summary>
             Locates and decodes Multiple PDF417 codes in an image.
            
             <returns>an array of Strings representing the content encoded by the PDF417 codes</returns>
             </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.decodeMultiple(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes multiple barcodes in some format within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:ZXing.DecodeHintType"/>
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcodes encode
            </returns>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object},System.Boolean)">
            <summary>
            Decode the specified image, with the hints and optionally multiple barcodes.
            Based on Owen's Comments in <see cref="T:ZXing.ReaderException"/>, this method has been modified to continue silently
            if a barcode was not decoded where it was detected instead of throwing a new exception object.
            </summary>
            <param name="image">Image.</param>
            <param name="hints">Hints.</param>
            <param name="multiple">If set to <c>true</c> multiple.</param>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.getMaxWidth(ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            Gets the maximum width of the barcode
            </summary>
            <returns>The max width.</returns>
            <param name="p1">P1.</param>
            <param name="p2">P2.</param>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.getMinWidth(ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            Gets the minimum width of the barcode
            </summary>
            <returns>The minimum width.</returns>
            <param name="p1">P1.</param>
            <param name="p2">P2.</param>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.getMaxCodewordWidth(ZXing.ResultPoint[])">
            <summary>
            Gets the maximum width of the codeword.
            </summary>
            <returns>The max codeword width.</returns>
            <param name="p">P.</param>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.getMinCodewordWidth(ZXing.ResultPoint[])">
            <summary>
            Gets the minimum width of the codeword.
            </summary>
            <returns>The minimum codeword width.</returns>
            <param name="p">P.</param>
        </member>
        <member name="M:ZXing.PDF417.PDF417Reader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="T:ZXing.PDF417.PDF417ResultMetadata">
            <summary>
            PDF 417 result meta data.
            <author>Guenther Grau</author>
            </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417ResultMetadata.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.SegmentIndex">
            <summary>
            The Segment ID represents the segment of the whole file distributed over different symbols.
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.FileId">
            <summary>
            Is the same for each related PDF417 symbol
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.OptionalData">
            <summary>
            old optional data format as int array, always null
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.IsLastSegment">
            <summary>
            true if it is the last segment
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.SegmentCount">
            <summary>
            count of segments, -1 if not set
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.Sender">
            <summary>
            sender
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.Addressee">
            <summary>
            address
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.FileName">
            <summary>
            Filename of the encoded file
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.FileSize">
            <summary>
            filesize in bytes of the encoded file
            returns filesize in bytes, -1 if not set
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.Checksum">
            <summary>
            16-bit CRC checksum using CCITT-16
            returns crc checksum, -1 if not set
            </summary>
        </member>
        <member name="P:ZXing.PDF417.PDF417ResultMetadata.Timestamp">
            <summary>
            unix epock timestamp, elapsed seconds since 1970-01-01
            returns elapsed seconds, -1 if not set
            </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417ResultMetadata.ToString">
            <summary>
            string represenation of that instance
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.PDF417.PDF417Writer">
            <summary>
            <author>Jacob Haynes</author>
            <author>qwandor@google.com (Andrew Walbran)</author>
            </summary>
        </member>
        <member name="F:ZXing.PDF417.PDF417Writer.WHITE_SPACE">
            <summary>
            default white space (margin) around the code
            </summary>
        </member>
        <member name="F:ZXing.PDF417.PDF417Writer.DEFAULT_ERROR_CORRECTION_LEVEL">
            <summary>
            default error correction level
            </summary>
        </member>
        <member name="F:ZXing.PDF417.PDF417Writer.DEFAULT_ASPECT_RATIO">
            <summary>
            default aspect ratio
            </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417Writer.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <param name="hints">Additional parameters to supply to the encoder</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.PDF417.PDF417Writer.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            Encode a barcode using the default settings.
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.PDF417.PDF417Writer.bitMatrixFromEncoder(ZXing.PDF417.Internal.PDF417,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Takes encoder, accounts for width/height, and retrieves bit matrix
            </summary>
        </member>
        <member name="M:ZXing.PDF417.PDF417Writer.bitMatrixFromBitArray(System.SByte[][],System.Int32)">
            <summary>
            This takes an array holding the values of the PDF 417
            </summary>
            <param name="input">a byte array of information with 0 is black, and 1 is white</param>
            <param name="margin">border around the barcode</param>
            <returns>BitMatrix of the input</returns>
        </member>
        <member name="M:ZXing.PDF417.PDF417Writer.rotateArray(System.SByte[][])">
            <summary>
            Takes and rotates the it 90 degrees
            </summary>
        </member>
        <member name="T:ZXing.PlanarYUVLuminanceSource">
            <summary>
            This object extends LuminanceSource around an array of YUV data returned from the camera driver,
            with the option to crop to a rectangle within the full data. This can be used to exclude
            superfluous pixels around the perimeter and speed up decoding.
            It works for any pixel format where the Y channel is planar and appears first, including
            YCbCr_420_SP and YCbCr_422_SP.
            @author dswitkin@google.com (Daniel Switkin)
            </summary>
        </member>
        <member name="M:ZXing.PlanarYUVLuminanceSource.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PlanarYUVLuminanceSource"/> class.
            </summary>
            <param name="yuvData">The yuv data.</param>
            <param name="dataWidth">Width of the data.</param>
            <param name="dataHeight">Height of the data.</param>
            <param name="left">The left.</param>
            <param name="top">The top.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="reverseHoriz">if set to <c>true</c> [reverse horiz].</param>
        </member>
        <member name="M:ZXing.PlanarYUVLuminanceSource.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.PlanarYUVLuminanceSource"/> class.
            </summary>
            <param name="luminances">The luminances.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:ZXing.PlanarYUVLuminanceSource.getRow(System.Int32,System.Byte[])">
            <summary>
            Fetches one row of luminance data from the underlying platform's bitmap. Values range from
            0 (black) to 255 (white). Because Java does not have an unsigned byte type, callers will have
            to bitwise and with 0xff for each value. It is preferable for implementations of this method
            to only fetch this row rather than the whole image, since no 2D Readers may be installed and
            getMatrix() may never be called.
            </summary>
            <param name="y">The row to fetch, 0 &lt;= y &lt; Height.</param>
            <param name="row">An optional preallocated array. If null or too small, it will be ignored.
            Always use the returned object, and ignore the .length of the array.</param>
            <returns>
            An array containing the luminance data.
            </returns>
        </member>
        <member name="P:ZXing.PlanarYUVLuminanceSource.Matrix">
            <summary>
            
            </summary>
        </member>
        <member name="P:ZXing.PlanarYUVLuminanceSource.CropSupported">
            <summary>
            </summary>
            <returns> Whether this subclass supports cropping.</returns>
        </member>
        <member name="M:ZXing.PlanarYUVLuminanceSource.crop(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new object with cropped image data. Implementations may keep a reference to the
            original data rather than a copy. Only callable if CropSupported is true.
            </summary>
            <param name="left">The left coordinate, 0 &lt;= left &lt; Width.</param>
            <param name="top">The top coordinate, 0 &lt;= top &lt;= Height.</param>
            <param name="width">The width of the rectangle to crop.</param>
            <param name="height">The height of the rectangle to crop.</param>
            <returns>
            A cropped version of this object.
            </returns>
        </member>
        <member name="M:ZXing.PlanarYUVLuminanceSource.renderThumbnail">
            <summary>
            Renders the cropped greyscale bitmap.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ZXing.PlanarYUVLuminanceSource.ThumbnailWidth">
            <summary>
            width of image from {@link #renderThumbnail()}
            </summary>
        </member>
        <member name="P:ZXing.PlanarYUVLuminanceSource.ThumbnailHeight">
            <summary>
            height of image from {@link #renderThumbnail()}
            </summary>
        </member>
        <member name="M:ZXing.PlanarYUVLuminanceSource.CreateLuminanceSource(System.Byte[],System.Int32,System.Int32)">
            <summary>
            creates a new instance
            </summary>
            <param name="newLuminances"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.BitMatrixParser">
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.QrCode.Internal.BitMatrixParser.createBitMatrixParser(ZXing.Common.BitMatrix)">
            <param name="bitMatrix">{@link BitMatrix} to parse</param>
            <throws>ReaderException if dimension is not >= 21 and 1 mod 4</throws>
        </member>
        <member name="M:ZXing.QrCode.Internal.BitMatrixParser.readFormatInformation">
            <summary> <p>Reads format information from one of its two locations within the QR Code.</p>
            
            </summary>
            <returns> {@link FormatInformation} encapsulating the QR Code's format info
            </returns>
            <throws>  ReaderException if both format information locations cannot be parsed as </throws>
            <summary> the valid encoding of format information
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.BitMatrixParser.readVersion">
            <summary> <p>Reads version information from one of its two locations within the QR Code.</p>
            
            </summary>
            <returns> {@link Version} encapsulating the QR Code's version
            </returns>
            <throws>  ReaderException if both version information locations cannot be parsed as </throws>
            <summary> the valid encoding of version information
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.BitMatrixParser.readCodewords">
            <summary> <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
            correct order in order to reconstruct the codewords bytes contained within the
            QR Code.</p>
            
            </summary>
            <returns> bytes encoded within the QR Code
            </returns>
            <throws>  ReaderException if the exact number of bytes expected is not read </throws>
        </member>
        <member name="M:ZXing.QrCode.Internal.BitMatrixParser.remask">
            Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
        </member>
        <member name="M:ZXing.QrCode.Internal.BitMatrixParser.setMirror(System.Boolean)">
            Prepare the parser for a mirrored operation.
            This flag has effect only on the {@link #readFormatInformation()} and the
            {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the
            {@link #mirror()} method should be called.
            
            @param mirror Whether to read version and format information mirrored.
        </member>
        <member name="M:ZXing.QrCode.Internal.BitMatrixParser.mirror">
            Mirror the bit matrix in order to attempt a second reading. 
        </member>
        <member name="T:ZXing.QrCode.Internal.DataBlock">
            <summary> <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into
            multiple blocks, each of which is a unit of data and error-correction codewords. Each
            is represented by an instance of this class.</p>
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="M:ZXing.QrCode.Internal.DataBlock.getDataBlocks(System.Byte[],ZXing.QrCode.Internal.Version,ZXing.QrCode.Internal.ErrorCorrectionLevel)">
            <summary> <p>When QR Codes use multiple data blocks, they are actually interleaved.
            That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
            method will separate the data into original blocks.</p>
            
            </summary>
            <param name="rawCodewords">bytes as read directly from the QR Code
            </param>
            <param name="version">version of the QR Code
            </param>
            <param name="ecLevel">error-correction level of the QR Code
            </param>
            <returns> {@link DataBlock}s containing original bytes, "de-interleaved" from representation in the
            QR Code
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.DataMask">
            <summary> <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations
            of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,
            including areas used for finder patterns, timing patterns, etc. These areas should be unused
            after the point they are unmasked anyway.</p>
            
            <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position
            and j is row position. In fact, as the text says, i is row position and j is column position.</p>
            
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.QrCode.Internal.DataMask.DATA_MASKS">
            <summary> See ISO 18004:2006 6.8.1</summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.DataMask.unmaskBitMatrix(System.Int32,ZXing.Common.BitMatrix,System.Int32)">
            <summary> <p>Implementations of this method reverse the data masking process applied to a QR Code and
            make its bits ready to read.</p>
            </summary>
            <param name="reference"></param>
            <param name="bits">representation of QR Code bits</param>
            <param name="dimension">dimension of QR Code, represented by bits, being unmasked</param>
        </member>
        <member name="T:ZXing.QrCode.Internal.DecodedBitStreamParser">
            <summary> <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes
            in one QR Code. This class decodes the bits back into text.</p>
            
            <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>
            <author>Sean Owen</author>
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.DecodedBitStreamParser.ALPHANUMERIC_CHARS">
            <summary>
            See ISO 18004:2006, 6.4.4 Table 5
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.DecodedBitStreamParser.decodeHanziSegment(ZXing.Common.BitSource,System.Text.StringBuilder,System.Int32)">
            <summary>
            See specification GBT 18284-2000
            </summary>
            <param name="bits">The bits.</param>
            <param name="result">The result.</param>
            <param name="count">The count.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.Decoder">
            <summary>
              <p>The main class which implements QR Code decoding -- as opposed to locating and extracting
            the QR Code from an image.</p>
            </summary>
            <author>
            Sean Owen
            </author>
        </member>
        <member name="M:ZXing.QrCode.Internal.Decoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.QrCode.Internal.Decoder"/> class.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Decoder.decode(System.Boolean[][],System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
            "true" is taken to mean a black module.</p>
            </summary>
            <param name="image">booleans representing white/black QR Code modules</param>
            <param name="hints">decoding hints that should be used to influence decoding</param>
            <returns>
            text and bytes encoded within the QR Code
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Decoder.decode(ZXing.Common.BitMatrix,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
            </summary>
            <param name="bits">booleans representing white/black QR Code modules</param>
            <param name="hints">decoding hints that should be used to influence decoding</param>
            <returns>
            text and bytes encoded within the QR Code
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Decoder.correctErrors(System.Byte[],System.Int32)">
            <summary>
              <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
            correct the errors in-place using Reed-Solomon error correction.</p>
            </summary>
            <param name="codewordBytes">data and error correction codewords</param>
            <param name="numDataCodewords">number of codewords that are data bytes</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.ErrorCorrectionLevel">
            <summary>
            <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels
            defined by the QR code standard.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.QrCode.Internal.ErrorCorrectionLevel.L">
            <summary> L = ~7% correction</summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.ErrorCorrectionLevel.M">
            <summary> M = ~15% correction</summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.ErrorCorrectionLevel.Q">
            <summary> Q = ~25% correction</summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.ErrorCorrectionLevel.H">
            <summary> H = ~30% correction</summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.ErrorCorrectionLevel.Bits">
            <summary>
            Gets the bits.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.ErrorCorrectionLevel.Name">
            <summary>
            Gets the name.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.ErrorCorrectionLevel.ordinal">
            <summary>
            Ordinals this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.ErrorCorrectionLevel.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.ErrorCorrectionLevel.forBits(System.Int32)">
            <summary>
            Fors the bits.
            </summary>
            <param name="bits">int containing the two bits encoding a QR Code's error correction level</param>
            <returns>
              <see cref="T:ZXing.QrCode.Internal.ErrorCorrectionLevel"/> representing the encoded error correction level
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.FormatInformation">
            <summary> <p>Encapsulates a QR Code's format information, including the data mask used and
            error correction level.</p>
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
            <seealso cref="P:ZXing.QrCode.Internal.FormatInformation.DataMask">
            </seealso>
            <seealso cref="P:ZXing.QrCode.Internal.FormatInformation.ErrorCorrectionLevel">
            </seealso>
        </member>
        <member name="F:ZXing.QrCode.Internal.FormatInformation.FORMAT_INFO_DECODE_LOOKUP">
            <summary> See ISO 18004:2006, Annex C, Table C.1</summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.FormatInformation.BITS_SET_IN_HALF_BYTE">
            <summary> Offset i holds the number of 1 bits in the binary representation of i</summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.FormatInformation.decodeFormatInformation(System.Int32,System.Int32)">
            <summary>
            Decodes the format information.
            </summary>
            <param name="maskedFormatInfo1">format info indicator, with mask still applied</param>
            <param name="maskedFormatInfo2">The masked format info2.</param>
            <returns>
            information about the format it specifies, or <code>null</code>
            if doesn't seem to match any known pattern
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.Mode">
            <summary>
            <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which
            data can be encoded to bits in the QR code standard.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.QrCode.Internal.Mode.Name">
            <summary>
            Gets the name.
            </summary>
        </member>
        <member name="T:ZXing.QrCode.Internal.Mode.Names">
            <summary>
            enumeration for encoding modes
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.TERMINATOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.NUMERIC">
            <summary>
            numeric encoding
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.ALPHANUMERIC">
            <summary>
            alpha-numeric encoding
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.STRUCTURED_APPEND">
            <summary>
            structured append
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.BYTE">
            <summary>
            byte mode encoding
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.ECI">
            <summary>
            ECI segment
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.KANJI">
            <summary>
            Kanji mode
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.FNC1_FIRST_POSITION">
            <summary>
            FNC1 char, first position
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.FNC1_SECOND_POSITION">
            <summary>
            FNC1 char, second position
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.Names.HANZI">
            <summary>
            Hanzi mode
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.TERMINATOR">
            <summary>
            Not really a mode...
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.NUMERIC">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.ALPHANUMERIC">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.STRUCTURED_APPEND">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.BYTE">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.ECI">
            <summary>
            character counts don't apply
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.KANJI">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.FNC1_FIRST_POSITION">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.FNC1_SECOND_POSITION">
            <summary>
            
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.Mode.HANZI">
            <summary>
            See GBT 18284-2000; "Hanzi" is a transliteration of this mode name.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Mode.forBits(System.Int32)">
            <summary>
            Fors the bits.
            </summary>
            <param name="bits">four bits encoding a QR Code data mode</param>
            <returns>
              <see cref="T:ZXing.QrCode.Internal.Mode"/> encoded by these bits
            </returns>
            <exception cref="T:System.ArgumentException">if bits do not correspond to a known mode</exception>
        </member>
        <member name="M:ZXing.QrCode.Internal.Mode.getCharacterCountBits(ZXing.QrCode.Internal.Version)">
            <param name="version">version in question
            </param>
            <returns> number of bits used, in this QR Code symbol {@link Version}, to encode the
            count of characters that will follow encoded in this {@link Mode}
            </returns>
        </member>
        <member name="P:ZXing.QrCode.Internal.Mode.Bits">
            <summary>
            Gets the bits.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Mode.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.QRCodeDecoderMetaData">
            <summary>
            Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the
            decoding caller. Callers are expected to process this.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.QRCodeDecoderMetaData.#ctor(System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.QrCode.Internal.QRCodeDecoderMetaData"/> class.
            </summary>
            <param name="mirrored">if set to <c>true</c> [mirrored].</param>
            <param name="dataMask">The mask applied to the bit matrix</param>
        </member>
        <member name="P:ZXing.QrCode.Internal.QRCodeDecoderMetaData.IsMirrored">
            <summary>
            true if the QR Code was mirrored. 
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.QRCodeDecoderMetaData.DataMask">
            <summary>
            The mask applied to the QR code
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.QRCodeDecoderMetaData.applyMirroredCorrection(ZXing.ResultPoint[])">
            <summary>
            Apply the result points' order correction due to mirroring.
            </summary>
            <param name="points">Array of points to apply mirror correction to.</param>
        </member>
        <member name="T:ZXing.QrCode.Internal.Version">
            <summary>
            See ISO 18004:2006 Annex D
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.QrCode.Internal.Version.VERSION_DECODE_INFO">
            <summary> See ISO 18004:2006 Annex D.
            Element i represents the raw version bits that specify version i + 7
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.VersionNumber">
            <summary>
            Gets the version number.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.AlignmentPatternCenters">
            <summary>
            Gets the alignment pattern centers.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.TotalCodewords">
            <summary>
            Gets the total codewords.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.DimensionForVersion">
            <summary>
            Gets the dimension for version.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Version.getECBlocksForLevel(ZXing.QrCode.Internal.ErrorCorrectionLevel)">
            <summary>
            Gets the EC blocks for level.
            </summary>
            <param name="ecLevel">The ec level.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Version.getProvisionalVersionForDimension(System.Int32)">
            <summary> <p>Deduces version information purely from QR Code dimensions.</p>
            
            </summary>
            <param name="dimension">dimension in modules
            </param>
            <returns><see cref="T:ZXing.QrCode.Internal.Version" /> for a QR Code of that dimension or null</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Version.getVersionForNumber(System.Int32)">
            <summary>
            Gets the version for number.
            </summary>
            <param name="versionNumber">The version number.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Version.buildFunctionPattern">
            <summary> See ISO 18004:2006 Annex E</summary>
        </member>
        <member name="T:ZXing.QrCode.Internal.Version.ECBlocks">
            <summary> <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
            use blocks of differing sizes within one version, so, this encapsulates the parameters for
            each set of blocks. It also holds the number of error-correction codewords per block since it
            will be the same across all blocks within one version.</p>
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.ECBlocks.ECCodewordsPerBlock">
            <summary>
            Gets the EC codewords per block.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.ECBlocks.NumBlocks">
            <summary>
            Gets the num blocks.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.ECBlocks.TotalECCodewords">
            <summary>
            Gets the total EC codewords.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Version.ECBlocks.getECBlocks">
            <summary>
            Gets the EC blocks.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.Version.ECB">
            <summary> <p>Encapsulates the parameters for one error-correction block in one symbol version.
            This includes the number of data codewords, and the number of times a block with these
            parameters is used consecutively in the QR code version's format.</p>
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.ECB.Count">
            <summary>
            Gets the count.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Version.ECB.DataCodewords">
            <summary>
            Gets the data codewords.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Version.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Version.buildVersions">
            <summary> See ISO 18004:2006 6.5.1 Table 9</summary>
        </member>
        <member name="T:ZXing.QrCode.Internal.AlignmentPattern">
            <summary> <p>Encapsulates an alignment pattern, which are the smaller square patterns found in
            all but the simplest QR Codes.</p>
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPattern.aboutEquals(System.Single,System.Single,System.Single)">
            <summary> <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
            position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPattern.combineEstimate(System.Single,System.Single,System.Single)">
            <summary>
            Combines this object's current estimate of a finder pattern position and module size
            with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
            </summary>
            <param name="i">The i.</param>
            <param name="j">The j.</param>
            <param name="newModuleSize">New size of the module.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.AlignmentPatternFinder">
            <summary> <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder
            patterns but are smaller and appear at regular intervals throughout the image.</p>
            
            <p>At the moment this only looks for the bottom-right alignment pattern.</p>
            
            <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,
            pasted and stripped down here for maximum performance but does unfortunately duplicate
            some code.</p>
            
            <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>
            
            </summary>
            <author>  Sean Owen
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPatternFinder.#ctor(ZXing.Common.BitMatrix,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,ZXing.ResultPointCallback)">
            <summary> <p>Creates a finder that will look in a portion of the whole image.</p>
            
            </summary>
            <param name="image">image to search
            </param>
            <param name="startX">left column from which to start searching
            </param>
            <param name="startY">top row from which to start searching
            </param>
            <param name="width">width of region to search
            </param>
            <param name="height">height of region to search
            </param>
            <param name="moduleSize">estimated module size so far
            </param>
            <param name="resultPointCallback">callback function which is called, when a result point is found</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPatternFinder.find">
            <summary> <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
            it's pretty performance-critical and so is written to be fast foremost.</p>
            
            </summary>
            <returns><see cref="T:ZXing.QrCode.Internal.AlignmentPattern"/> if found</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPatternFinder.centerFromEnd(System.Int32[],System.Int32)">
            <summary> Given a count of black/white/black pixels just seen and an end position,
            figures the location of the center of this black/white/black run.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPatternFinder.foundPatternCross(System.Int32[])">
            <param name="stateCount">count of black/white/black pixels just read
            </param>
            <returns> true iff the proportions of the counts is close enough to the 1/1/1 ratios
            used by alignment patterns to be considered a match
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPatternFinder.crossCheckVertical(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              <p>After a horizontal scan finds a potential alignment pattern, this method
            "cross-checks" by scanning down vertically through the center of the possible
            alignment pattern to see if the same proportion is detected.</p>
            </summary>
            <param name="startI">row where an alignment pattern was detected</param>
            <param name="centerJ">center of the section that appears to cross an alignment pattern</param>
            <param name="maxCount">maximum reasonable number of modules that should be
            observed in any reading state, based on the results of the horizontal scan</param>
            <param name="originalStateCountTotal">The original state count total.</param>
            <returns>
            vertical center of alignment pattern, or null if not found
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.AlignmentPatternFinder.handlePossibleCenter(System.Int32[],System.Int32,System.Int32)">
            <summary> <p>This is called when a horizontal scan finds a possible alignment pattern. It will
            cross check with a vertical scan, and if successful, will see if this pattern had been
            found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
            found the alignment pattern.</p>
            
            </summary>
            <param name="stateCount">reading state module counts from horizontal scan
            </param>
            <param name="i">row where alignment pattern may be found
            </param>
            <param name="j">end of possible alignment pattern in row
            </param>
            <returns> {@link AlignmentPattern} if we have found the same pattern twice, or null if not
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.Detector">
            <summary>
            <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code
            is rotated or skewed, or partially obscured.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.QrCode.Internal.Detector"/> class.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="P:ZXing.QrCode.Internal.Detector.Image">
            <summary>
            Gets the image.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.Detector.ResultPointCallback">
            <summary>
            Gets the result point callback.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.detect">
            <summary>
              <p>Detects a QR Code in an image.</p>
            </summary>
            <returns>
              <see cref="T:ZXing.Common.DetectorResult"/> encapsulating results of detecting a QR Code
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.detect(System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
              <p>Detects a QR Code in an image.</p>
            </summary>
            <param name="hints">optional hints to detector</param>
            <returns>
              <see cref="T:ZXing.Common.DetectorResult"/> encapsulating results of detecting a QR Code
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.processFinderPatternInfo(ZXing.QrCode.Internal.FinderPatternInfo)">
            <summary>
            Processes the finder pattern info.
            </summary>
            <param name="info">The info.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.computeDimension(ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint,System.Single,System.Int32@)">
            <summary> <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
            of the finder patterns and estimated module size.</p>
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.calculateModuleSize(ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
              <p>Computes an average estimated module size based on estimated derived from the positions
            of the three finder patterns.</p>
            </summary>
            <param name="topLeft">detected top-left finder pattern center</param>
            <param name="topRight">detected top-right finder pattern center</param>
            <param name="bottomLeft">detected bottom-left finder pattern center</param>
            <returns>estimated module size</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.calculateModuleSizeOneWay(ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary> <p>Estimates module size based on two finder patterns -- it uses
            {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
            width of each, measuring along the axis between their centers.</p>
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.sizeOfBlackWhiteBlackRunBothWays(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
            a finder pattern by looking for a black-white-black run from the center in the direction
            of another point (another finder pattern center), and in the opposite direction too.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.sizeOfBlackWhiteBlackRun(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> <p>This method traces a line from a point in the image, in the direction towards another point.
            It begins in a black region, and keeps going until it finds white, then black, then white again.
            It reports the distance from the start to this point.</p>
            
            <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
            may be skewed or rotated.</p>
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.Detector.findAlignmentInRegion(System.Single,System.Int32,System.Int32,System.Single)">
            <summary>
              <p>Attempts to locate an alignment pattern in a limited region of the image, which is
            guessed to contain it. This method uses {@link AlignmentPattern}.</p>
            </summary>
            <param name="overallEstModuleSize">estimated module size so far</param>
            <param name="estAlignmentX">x coordinate of center of area probably containing alignment pattern</param>
            <param name="estAlignmentY">y coordinate of above</param>
            <param name="allowanceFactor">number of pixels in all directions to search from the center</param>
            <returns>
              <see cref="T:ZXing.QrCode.Internal.AlignmentPattern"/> if found, or null otherwise
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.FinderPattern">
            <summary>
            <p>Encapsulates a finder pattern, which are the three square patterns found in
            the corners of QR Codes. It also encapsulates a count of similar finder patterns,
            as a convenience to the finder's bookkeeping.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="P:ZXing.QrCode.Internal.FinderPattern.EstimatedModuleSize">
            <summary>
            Gets the size of the estimated module.
            </summary>
            <value>
            The size of the estimated module.
            </value>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPattern.aboutEquals(System.Single,System.Single,System.Single)">
            <summary> <p>Determines if this finder pattern "about equals" a finder pattern at the stated
            position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPattern.combineEstimate(System.Single,System.Single,System.Single)">
            <summary>
            Combines this object's current estimate of a finder pattern position and module size
            with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
            based on count.
            </summary>
            <param name="i">The i.</param>
            <param name="j">The j.</param>
            <param name="newModuleSize">New size of the module.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.FinderPatternFinder">
            <summary>
            <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square
            markers at three corners of a QR Code.</p>
            
            <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.QrCode.Internal.FinderPatternFinder.MIN_SKIP">
            <summary>
            1 pixel/module times 3 modules/center
            </summary>
        </member>
        <member name="F:ZXing.QrCode.Internal.FinderPatternFinder.MAX_MODULES">
            <summary>
            support up to version 20 for mobile clients
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.#ctor(ZXing.Common.BitMatrix)">
            <summary>
            <p>Creates a finder that will search the image for three finder patterns.</p>
            </summary>
            <param name="image">image to search</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.#ctor(ZXing.Common.BitMatrix,ZXing.ResultPointCallback)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.QrCode.Internal.FinderPatternFinder"/> class.
            </summary>
            <param name="image">The image.</param>
            <param name="resultPointCallback">The result point callback.</param>
        </member>
        <member name="P:ZXing.QrCode.Internal.FinderPatternFinder.Image">
            <summary>
            Gets the image.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.FinderPatternFinder.PossibleCenters">
            <summary>
            Gets the possible centers.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.centerFromEnd(System.Int32[],System.Int32)">
            <summary> Given a count of black/white/black/white/black pixels just seen and an end position,
            figures the location of the center of this run.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.foundPatternCross(System.Int32[])">
            <param name="stateCount">count of black/white/black/white/black pixels just read
            </param>
            <returns> true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios
            used by finder patterns to be considered a match
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.foundPatternDiagonal(System.Int32[])">
            <summary>
            </summary>
            <param name="stateCount">count of black/white/black/white/black pixels just read</param>
            <returns>true if the proportions of the counts is close enough to the 1/1/3/1/1 ratios
            by finder patterns to be considered a match</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.clearCounts(System.Int32[])">
            <summary>
            sets everything to 0
            </summary>
            <param name="counts"></param>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.shiftCounts2(System.Int32[])">
            <summary>
            shifts left by 2 index
            </summary>
            <param name="stateCount"></param>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.doClearCounts(System.Int32[])">
            <summary>
            sets everything to 0
            </summary>
            <param name="counts"></param>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.doShiftCounts2(System.Int32[])">
            <summary>
            shifts left by 2 index
            </summary>
            <param name="stateCount"></param>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.crossCheckDiagonal(System.Int32,System.Int32)">
            <summary>
            After a vertical and horizontal scan finds a potential finder pattern, this method
            "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
            finder pattern to see if the same proportion is detected.
            </summary>
            <param name="centerI">row where a finder pattern was detected</param>
            <param name="centerJ">center of the section that appears to cross a finder pattern</param>
            <returns>true if proportions are withing expected limits</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.crossCheckVertical(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              <p>After a horizontal scan finds a potential finder pattern, this method
            "cross-checks" by scanning down vertically through the center of the possible
            finder pattern to see if the same proportion is detected.</p>
            </summary>
            <param name="startI">row where a finder pattern was detected</param>
            <param name="centerJ">center of the section that appears to cross a finder pattern</param>
            <param name="maxCount">maximum reasonable number of modules that should be
            observed in any reading state, based on the results of the horizontal scan</param>
            <param name="originalStateCountTotal">The original state count total.</param>
            <returns>
            vertical center of finder pattern, or null if not found
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.crossCheckHorizontal(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
            except it reads horizontally instead of vertically. This is used to cross-cross
            check a vertical cross check and locate the real center of the alignment pattern.</p>
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.handlePossibleCenter(System.Int32[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            @see #handlePossibleCenter(int[], int, int)
            </summary>
            <param name="stateCount">reading state module counts from horizontal scan</param>
            <param name="i">row where finder pattern may be found</param>
            <param name="j">end of possible finder pattern in row</param>
            <param name="pureBarcode">ignored</param>
            <returns>true if a finder pattern candidate was found this time</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.handlePossibleCenter(System.Int32[],System.Int32,System.Int32)">
            <summary>
              <p>This is called when a horizontal scan finds a possible alignment pattern. It will
            cross check with a vertical scan, and if successful, will, ah, cross-cross-check
            with another horizontal scan. This is needed primarily to locate the real horizontal
            center of the pattern in cases of extreme skew.
            And then we cross-cross-cross check with another diagonal scan.</p>
            If that succeeds the finder pattern location is added to a list that tracks
            the number of times each location has been nearly-matched as a finder pattern.
            Each additional find is more evidence that the location is in fact a finder
            pattern center
            </summary>
            <param name="stateCount">reading state module counts from horizontal scan</param>
            <param name="i">row where finder pattern may be found</param>
            <param name="j">end of possible finder pattern in row</param>
            <returns>
            true if a finder pattern candidate was found this time
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.findRowSkip">
            <returns> number of rows we could safely skip during scanning, based on the first
            two finder patterns that have been located. In some cases their position will
            allow us to infer that the third pattern must lie below a certain point farther
            down in the image.
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.haveMultiplyConfirmedCenters">
            <returns> true iff we have found at least 3 finder patterns that have been detected
            at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the
            candidates is "pretty similar"
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.squaredDistance(ZXing.QrCode.Internal.FinderPattern,ZXing.QrCode.Internal.FinderPattern)">
            <summary>
            Get square of distance between a and b.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternFinder.selectBestPatterns">
            <returns> the 3 best {@link FinderPattern}s from our list of candidates. The "best" are
            those have similar module size and form a shape closer to a isosceles right triangle.
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.FinderPatternFinder.EstimatedModuleComparator">
            <summary>
            Orders by {@link FinderPatternFinder#getEstimatedModuleSize()}
            </summary>
        </member>
        <member name="T:ZXing.QrCode.Internal.FinderPatternInfo">
            <summary>
            <p>Encapsulates information about finder patterns in an image, including the location of
            the three finder patterns, and their estimated module size.</p>
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.QrCode.Internal.FinderPatternInfo.#ctor(ZXing.QrCode.Internal.FinderPattern[])">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.QrCode.Internal.FinderPatternInfo"/> class.
            </summary>
            <param name="patternCenters">The pattern centers.</param>
        </member>
        <member name="P:ZXing.QrCode.Internal.FinderPatternInfo.BottomLeft">
            <summary>
            Gets the bottom left.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.FinderPatternInfo.TopLeft">
            <summary>
            Gets the top left.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.FinderPatternInfo.TopRight">
            <summary>
            Gets the top right.
            </summary>
        </member>
        <member name="T:ZXing.QrCode.Internal.ByteMatrix">
            <summary>
            JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned
            0, 1 and 2 I'm going to use less memory and go with bytes.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="M:ZXing.QrCode.Internal.ByteMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.QrCode.Internal.ByteMatrix"/> class.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="P:ZXing.QrCode.Internal.ByteMatrix.Height">
            <summary>
            Gets the height.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.ByteMatrix.Width">
            <summary>
            Gets the width.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.ByteMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the <see cref="T:System.Int32"/> with the specified x.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.ByteMatrix.Array">
            <summary>
            an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.ByteMatrix.set(System.Int32,System.Int32,System.Byte)">
            <summary>
            Sets the specified x.
            </summary>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.ByteMatrix.set(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the specified x.
            </summary>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
            <param name="value">if set to <c>true</c> [value].</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.ByteMatrix.clear(System.Byte)">
            <summary>
            Clears the specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.ByteMatrix.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.Encoder">
            <summary>
            </summary>
            <author>satorux@google.com (Satoru Takabayashi) - creator</author>
            <author>dswitkin@google.com (Daniel Switkin) - ported from C++</author>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.encode(System.String,ZXing.QrCode.Internal.ErrorCorrectionLevel)">
            <summary>
            Encode "bytes" with the error correction level "ecLevel". The encoding mode will be chosen
            internally by chooseMode(). On success, store the result in "qrCode".
            We recommend you to use QRCode.EC_LEVEL_L (the lowest level) for
            "getECLevel" since our primary use is to show QR code on desktop screens. We don't need very
            strong error correction for this purpose.
            Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode()
            with which clients can specify the encoding mode. For now, we don't need the functionality.
            </summary>
            <param name="content">text to encode</param>
            <param name="ecLevel">error correction level to use</param>
            <returns><see cref="T:ZXing.QrCode.Internal.QRCode"/> representing the encoded QR code</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.encode(System.String,ZXing.QrCode.Internal.ErrorCorrectionLevel,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            Encodes the specified content.
            </summary>
            <param name="content">The content.</param>
            <param name="ecLevel">The ec level.</param>
            <param name="hints">The hints.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.recommendVersion(ZXing.QrCode.Internal.ErrorCorrectionLevel,ZXing.QrCode.Internal.Mode,ZXing.Common.BitArray,ZXing.Common.BitArray)">
            <summary>
            Decides the smallest version of QR code that will contain all of the provided data.
            </summary>
            <exception cref="T:ZXing.WriterException">if the data cannot fit in any version</exception>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.getAlphanumericCode(System.Int32)">
            <summary>
            Gets the alphanumeric code.
            </summary>
            <param name="code">The code.</param>
            <returns>the code point of the table used in alphanumeric mode or
            -1 if there is no corresponding code in the table.</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.chooseMode(System.String)">
            <summary>
            Chooses the mode.
            </summary>
            <param name="content">The content.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.chooseMode(System.String,System.Text.Encoding)">
            <summary>
            Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
            if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
            </summary>
            <param name="content">The content.</param>
            <param name="encoding">The encoding.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.willFit(System.Int32,ZXing.QrCode.Internal.Version,ZXing.QrCode.Internal.ErrorCorrectionLevel)">
            <summary></summary>
            <returns>true if the number of input bits will fit in a code with the specified version and error correction level.</returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.terminateBits(System.Int32,ZXing.Common.BitArray)">
            <summary>
            Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
            </summary>
            <param name="numDataBytes">The num data bytes.</param>
            <param name="bits">The bits.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.getNumDataBytesAndNumECBytesForBlockID(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Get number of data bytes and number of error correction bytes for block id "blockID". Store
            the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
            JISX0510:2004 (p.30)
            </summary>
            <param name="numTotalBytes">The num total bytes.</param>
            <param name="numDataBytes">The num data bytes.</param>
            <param name="numRSBlocks">The num RS blocks.</param>
            <param name="blockID">The block ID.</param>
            <param name="numDataBytesInBlock">The num data bytes in block.</param>
            <param name="numECBytesInBlock">The num EC bytes in block.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.interleaveWithECBytes(ZXing.Common.BitArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            Interleave "bits" with corresponding error correction bytes. On success, store the result in
            "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
            </summary>
            <param name="bits">The bits.</param>
            <param name="numTotalBytes">The num total bytes.</param>
            <param name="numDataBytes">The num data bytes.</param>
            <param name="numRSBlocks">The num RS blocks.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.appendModeInfo(ZXing.QrCode.Internal.Mode,ZXing.Common.BitArray)">
            <summary>
            Append mode info. On success, store the result in "bits".
            </summary>
            <param name="mode">The mode.</param>
            <param name="bits">The bits.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.appendLengthInfo(System.Int32,ZXing.QrCode.Internal.Version,ZXing.QrCode.Internal.Mode,ZXing.Common.BitArray)">
            <summary>
            Append length info. On success, store the result in "bits".
            </summary>
            <param name="numLetters">The num letters.</param>
            <param name="version">The version.</param>
            <param name="mode">The mode.</param>
            <param name="bits">The bits.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.Encoder.appendBytes(System.String,ZXing.QrCode.Internal.Mode,ZXing.Common.BitArray,System.Text.Encoding)">
            <summary>
            Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
            </summary>
            <param name="content">The content.</param>
            <param name="mode">The mode.</param>
            <param name="bits">The bits.</param>
            <param name="encoding">The encoding.</param>
        </member>
        <member name="T:ZXing.QrCode.Internal.MaskUtil">
            <summary>
            
            </summary>
            <author>Satoru Takabayashi</author>
            <author>Daniel Switkin</author>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.QrCode.Internal.MaskUtil.applyMaskPenaltyRule1(ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
            give penalty to them. Example: 00000 or 11111.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MaskUtil.applyMaskPenaltyRule2(ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
            penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
            penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MaskUtil.applyMaskPenaltyRule3(ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Apply mask penalty rule 3 and return the penalty. Find consecutive cells of 00001011101 or
            10111010000, and give penalty to them.  If we find patterns like 000010111010000, we give
            penalties twice (i.e. 40 * 2).
            </summary>
            <param name="matrix">The matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MaskUtil.applyMaskPenaltyRule4(ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
            penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MaskUtil.getDataMaskBit(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask
            pattern conditions.
            </summary>
            <param name="maskPattern">The mask pattern.</param>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MaskUtil.applyMaskPenaltyRule1Internal(ZXing.QrCode.Internal.ByteMatrix,System.Boolean)">
            <summary>
            Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
            vertical and horizontal orders respectively.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="isHorizontal">if set to <c>true</c> [is horizontal].</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.QrCode.Internal.MatrixUtil">
            <summary>
            
            </summary>
            <author>
            satorux@google.com (Satoru Takabayashi) - creator
            </author>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.clearMatrix(ZXing.QrCode.Internal.ByteMatrix)">
             <summary>
             Set all cells to 2.  2 means that the cell is empty (not set yet).
            
             JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding
             with the ByteMatrix initialized all to zero.
             </summary>
             <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.buildMatrix(ZXing.Common.BitArray,ZXing.QrCode.Internal.ErrorCorrectionLevel,ZXing.QrCode.Internal.Version,System.Int32,ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On
            success, store the result in "matrix" and return true.
            </summary>
            <param name="dataBits">The data bits.</param>
            <param name="ecLevel">The ec level.</param>
            <param name="version">The version.</param>
            <param name="maskPattern">The mask pattern.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.embedBasicPatterns(ZXing.QrCode.Internal.Version,ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Embed basic patterns. On success, modify the matrix and return true.
            The basic patterns are:
            - Position detection patterns
            - Timing patterns
            - Dark dot at the left bottom corner
            - Position adjustment patterns, if need be
            </summary>
            <param name="version">The version.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.embedTypeInfo(ZXing.QrCode.Internal.ErrorCorrectionLevel,System.Int32,ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Embed type information. On success, modify the matrix.
            </summary>
            <param name="ecLevel">The ec level.</param>
            <param name="maskPattern">The mask pattern.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.maybeEmbedVersionInfo(ZXing.QrCode.Internal.Version,ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Embed version information if need be. On success, modify the matrix and return true.
            See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
            </summary>
            <param name="version">The version.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.embedDataBits(ZXing.Common.BitArray,System.Int32,ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.
            For debugging purposes, it skips masking process if "getMaskPattern" is -1.
            See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
            </summary>
            <param name="dataBits">The data bits.</param>
            <param name="maskPattern">The mask pattern.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.findMSBSet(System.Int32)">
            <summary>
            Return the position of the most significant bit set (to one) in the "value". The most
            significant bit is position 32. If there is no bit set, return 0. Examples:
            - findMSBSet(0) => 0
            - findMSBSet(1) => 1
            - findMSBSet(255) => 8
            </summary>
            <param name="value_Renamed">The value_ renamed.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.calculateBCHCode(System.Int32,System.Int32)">
             <summary>
             Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH
             code is used for encoding type information and version information.
             Example: Calculation of version information of 7.
             f(x) is created from 7.
               - 7 = 000111 in 6 bits
               - f(x) = x^2 + x^2 + x^1
             g(x) is given by the standard (p. 67)
               - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
             Multiply f(x) by x^(18 - 6)
               - f'(x) = f(x) * x^(18 - 6)
               - f'(x) = x^14 + x^13 + x^12
             Calculate the remainder of f'(x) / g(x)
                     x^2
                     __________________________________________________
               g(x) )x^14 + x^13 + x^12
                     x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
                     --------------------------------------------------
                                          x^11 + x^10 + x^7 + x^4 + x^2
            
             The remainder is x^11 + x^10 + x^7 + x^4 + x^2
             Encode it in binary: 110010010100
             The return value is 0xc94 (1100 1001 0100)
            
             Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
             operations. We don't care if coefficients are positive or negative.
             </summary>
             <param name="value">The value.</param>
             <param name="poly">The poly.</param>
             <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.makeTypeInfoBits(ZXing.QrCode.Internal.ErrorCorrectionLevel,System.Int32,ZXing.Common.BitArray)">
            <summary>
            Make bit vector of type information. On success, store the result in "bits" and return true.
            Encode error correction level and mask pattern. See 8.9 of
            JISX0510:2004 (p.45) for details.
            </summary>
            <param name="ecLevel">The ec level.</param>
            <param name="maskPattern">The mask pattern.</param>
            <param name="bits">The bits.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.makeVersionInfoBits(ZXing.QrCode.Internal.Version,ZXing.Common.BitArray)">
            <summary>
            Make bit vector of version information. On success, store the result in "bits" and return true.
            See 8.10 of JISX0510:2004 (p.45) for details.
            </summary>
            <param name="version">The version.</param>
            <param name="bits">The bits.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.isEmpty(System.Int32)">
            <summary>
            Check if "value" is empty.
            </summary>
            <param name="value">The value.</param>
            <returns>
              <c>true</c> if the specified value is empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.embedDarkDotAtLeftBottomCorner(ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
            </summary>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.embedPositionAdjustmentPattern(System.Int32,System.Int32,ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            
            </summary>
            <param name="xStart">The x start.</param>
            <param name="yStart">The y start.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.embedPositionDetectionPatternsAndSeparators(ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Embed position detection patterns and surrounding vertical/horizontal separators.
            </summary>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MatrixUtil.maybeEmbedPositionAdjustmentPatterns(ZXing.QrCode.Internal.Version,ZXing.QrCode.Internal.ByteMatrix)">
            <summary>
            Embed position adjustment patterns if need be.
            </summary>
            <param name="version">The version.</param>
            <param name="matrix">The matrix.</param>
        </member>
        <member name="T:ZXing.QrCode.Internal.MinimalEncoder">
            <summary>
            * Encoder that encodes minimally
            *
            * Algorithm:
            *
            * The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which(Alan Perilis).
            *
            * This implementation computes.As an alternative, the QR-Code specification suggests heuristics like this one:
            *
            * If initial input data is in the exclusive subset of the Alphanumeric character set AND if there are less than
            * [6,7,8] characters followed by data from the remainder of the 8-bit byte character set, THEN select the 8-
            * bit byte mode ELSE select Alphanumeric mode;
            *
            * This is probably right for 99.99% of cases but there is at least this one counter example: The string "AAAAAAa"
            * encodes 2 bits smaller as ALPHANUMERIC(AAAAAA), BYTE(a) than by encoding it as BYTE(AAAAAAa).
            * Perhaps that is the only counter example but without having proof, it remains unclear.
            *
            * ECI switching:
            *
            * In multi language content the algorithm selects the most compact representation using ECI modes.
            * For example the most compact representation of the string "\u0150\u015C" (O-double-acute, S-circumflex) is
            * ECI(UTF-8), BYTE(\u0150\u015C) while prepending one or more times the same leading character as in
            * "\u0150\u0150\u015C", the most compact representation  uses two ECIs so that the string is encoded as
            * ECI(ISO-8859-2), BYTE(\u0150\u0150), ECI(ISO-8859-3), BYTE(\u015C).
            *
            * @author Alex Geller
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.MinimalEncoder.#ctor(System.String,System.Text.Encoding,System.Boolean,ZXing.QrCode.Internal.ErrorCorrectionLevel)">
            <summary>
            Creates a MinimalEncoder
            </summary>
            <param name="stringToEncode">The string to encode</param>
            <param name="priorityCharset">The preferred <see cref="T:System.Text.Encoding"/>. When the value of the argument is null, the algorithm
            *   chooses charsets that leads to a minimal representation.Otherwise the algorithm will use the priority
            *   charset to encode any character in the input that can be encoded by it if the charset is among the
            *   supported charsets.</param>
            <param name="isGS1"> {@code true} if a FNC1 is to be prepended; {@code false} otherwise</param>
            <param name="ecLevel">The error correction level.</param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MinimalEncoder.encode(System.String,ZXing.QrCode.Internal.Version,System.Text.Encoding,System.Boolean,ZXing.QrCode.Internal.ErrorCorrectionLevel)">
            <summary>
            Encodes the string minimally
            </summary>
            <param name="stringToEncode">The string to encode</param>
            <param name="version">The preferred <see cref="T:ZXing.QrCode.Internal.Version"/>. A minimal version is computed(see
             {@link ResultList#getVersion method} when the value of the argument is null</param>
            <param name="priorityCharset">The preferred { @link Charset}. When the value of the argument is null, the algorithm
             chooses charsets that leads to a minimal representation.Otherwise the algorithm will use the priority
            charset to encode any character in the input that can be encoded by it if the charset is among the
            supported charsets.</param>
            <param name="isGS1">{ @code true} if a FNC1 is to be prepended;{ @code false}otherwise</param>
            <param name="ecLevel">The error correction level.</param>
            <returns>An instance of { @code ResultList}
                   representing the minimal solution.
            @see ResultList#getBits
            @see ResultList#getVersion
            @see ResultList#getSize</returns>
        </member>
        <member name="P:ZXing.QrCode.Internal.MinimalEncoder.ResultList.Size">
            <summary>
            returns the size in bits
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.MinimalEncoder.ResultList.getBits(ZXing.Common.BitArray)">
            <summary>
            appends the bits
            </summary>
            <param name="bits"></param>
        </member>
        <member name="M:ZXing.QrCode.Internal.MinimalEncoder.ResultList.ResultNode.getSize(ZXing.QrCode.Internal.Version)">
            <summary>
            returns the size in bits
            </summary>
            <returns></returns>
        </member>
        <member name="P:ZXing.QrCode.Internal.MinimalEncoder.ResultList.ResultNode.CharacterCountIndicator">
            <summary>
            returns the length in characters according to the specification (differs from getCharacterLength() in BYTE mode
            for multi byte encoded characters)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.MinimalEncoder.ResultList.ResultNode.getBits(ZXing.Common.BitArray)">
            <summary>
            appends the bits
            </summary>
            <param name="bits"></param>
        </member>
        <member name="T:ZXing.QrCode.Internal.QRCode">
            <author>satorux@google.com (Satoru Takabayashi) - creator</author>
            <author>dswitkin@google.com (Daniel Switkin) - ported from C++</author>
        </member>
        <member name="F:ZXing.QrCode.Internal.QRCode.NUM_MASK_PATTERNS">
            <summary>
            
            </summary>
        </member>
        <member name="M:ZXing.QrCode.Internal.QRCode.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.QrCode.Internal.QRCode"/> class.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.Internal.QRCode.Mode">
            <summary>
            Gets or sets the mode, not relevant if <see cref="F:ZXing.EncodeHintType.QR_COMPACT"/> is selected.
            </summary>
            <value>
            The mode.
            </value>
        </member>
        <member name="P:ZXing.QrCode.Internal.QRCode.ECLevel">
            <summary>
            Gets or sets the EC level.
            </summary>
            <value>
            The EC level.
            </value>
        </member>
        <member name="P:ZXing.QrCode.Internal.QRCode.Version">
            <summary>
            Gets or sets the version.
            </summary>
            <value>
            The version.
            </value>
        </member>
        <member name="P:ZXing.QrCode.Internal.QRCode.MaskPattern">
            <summary>
            Gets or sets the mask pattern.
            </summary>
            <value>
            The mask pattern.
            </value>
        </member>
        <member name="P:ZXing.QrCode.Internal.QRCode.Matrix">
            <summary>
            Gets or sets the matrix.
            </summary>
            <value>
            The matrix.
            </value>
        </member>
        <member name="M:ZXing.QrCode.Internal.QRCode.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.QrCode.Internal.QRCode.isValidMaskPattern(System.Int32)">
            <summary>
            Check if "mask_pattern" is valid.
            </summary>
            <param name="maskPattern">The mask pattern.</param>
            <returns>
              <c>true</c> if [is valid mask pattern] [the specified mask pattern]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:ZXing.QrCode.QrCodeEncodingOptions">
            <summary>
            The class holds the available options for the QrCodeWriter
            </summary>
        </member>
        <member name="P:ZXing.QrCode.QrCodeEncodingOptions.ErrorCorrection">
            <summary>
            Specifies what degree of error correction to use, for example in QR Codes.
            Type depends on the encoder. For example for QR codes it's type
            <see cref="T:ZXing.QrCode.Internal.ErrorCorrectionLevel"/>.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.QrCodeEncodingOptions.CharacterSet">
            <summary>
            Specifies what character encoding to use where applicable (type <see cref="T:System.String"/>)
            </summary>
        </member>
        <member name="P:ZXing.QrCode.QrCodeEncodingOptions.DisableECI">
            <summary>
            Explicitly disables ECI segment when generating QR Code
            That is against the specification of QR Code but some
            readers have problems if the charset is switched from
            ISO-8859-1 (default) to UTF-8 with the necessary ECI segment.
            If you set the property to true you can use UTF-8 encoding
            and the ECI segment is omitted.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.QrCodeEncodingOptions.QrVersion">
            <summary>
            Specifies the exact version of QR code to be encoded. An integer, range 1 to 40. If the data specified
            cannot fit within the required version, a WriterException will be thrown.
            </summary>
        </member>
        <member name="P:ZXing.QrCode.QrCodeEncodingOptions.QrCompact">
            <summary>
            Specifies whether to use compact mode for QR code (type <see cref="T:System.Boolean" />, or "true" or "false"
            Please note that when compaction is performed, the most compact character encoding is chosen
            for characters in the input that are not in the ISO-8859-1 character set. Based on experience,
            some scanners do not support encodings like cp-1256 (Arabic). In such cases the encoding can
            be forced to UTF-8 by means of the <see cref="P:ZXing.QrCode.QrCodeEncodingOptions.CharacterSet"/> encoding hint.
            </summary>
        </member>
        <member name="T:ZXing.QrCode.QRCodeReader">
            <summary>
            This implementation can detect and decode QR Codes in an image.
            <author>Sean Owen</author>
            </summary>
        </member>
        <member name="M:ZXing.QrCode.QRCodeReader.getDecoder">
            <summary>
            Gets the decoder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ZXing.QrCode.QRCodeReader.decode(ZXing.BinaryBitmap)">
             <summary>
             Locates and decodes a QR code in an image.
            
             <returns>a String representing the content encoded by the QR code</returns>
             </summary>
        </member>
        <member name="M:ZXing.QrCode.QRCodeReader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary>
            Locates and decodes a barcode in some format within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:ZXing.DecodeHintType"/>
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.</param>
            <returns>
            String which the barcode encodes
            </returns>
        </member>
        <member name="M:ZXing.QrCode.QRCodeReader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="M:ZXing.QrCode.QRCodeReader.extractPureBits(ZXing.Common.BitMatrix)">
            <summary>
            This method detects a code in a "pure" image -- that is, pure monochrome image
            which contains only an unrotated, unskewed, image of a code, with some white border
            around it. This is a specialized method that works exceptionally fast in this special
            case.
            
            <seealso cref="M:ZXing.Datamatrix.DataMatrixReader.extractPureBits(ZXing.Common.BitMatrix)" />
            </summary>
        </member>
        <member name="T:ZXing.QrCode.QRCodeWriter">
             <summary>
             This object renders a QR Code as a BitMatrix 2D array of greyscale values.
            
             <author>dswitkin@google.com (Daniel Switkin)</author>
             </summary>
        </member>
        <member name="M:ZXing.QrCode.QRCodeWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            Encode a barcode using the default settings.
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="M:ZXing.QrCode.QRCodeWriter.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary>
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <param name="hints">Additional parameters to supply to the encoder</param>
            <returns>
            The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)
            </returns>
        </member>
        <member name="T:ZXing.Reader">
            <summary>
            Implementations of this interface can decode an image of a barcode in some format into
            the String it encodes. For example, <see cref="T:ZXing.QrCode.QRCodeReader" /> can
            decode a QR code. The decoder may optionally receive hints from the caller which may help
            it decode more quickly or accurately.
            
            See <see cref="T:ZXing.MultiFormatReader" />, which attempts to determine what barcode
            format is present within the image as well, and then decodes it accordingly.
            </summary>
            <author>Sean Owen</author>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="M:ZXing.Reader.decode(ZXing.BinaryBitmap)">
            <summary>
            Locates and decodes a barcode in some format within an image.
            </summary>
            <param name="image">image of barcode to decode</param>
            <returns>String which the barcode encodes</returns>
        </member>
        <member name="M:ZXing.Reader.decode(ZXing.BinaryBitmap,System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object})">
            <summary> Locates and decodes a barcode in some format within an image. This method also accepts
            hints, each possibly associated to some data, which may help the implementation decode.
            </summary>
            <param name="image">image of barcode to decode</param>
            <param name="hints">passed as a <see cref="T:System.Collections.Generic.IDictionary`2" /> from <see cref="T:ZXing.DecodeHintType" />
            to arbitrary data. The
            meaning of the data depends upon the hint type. The implementation may or may not do
            anything with these hints.
            </param>
            <returns>String which the barcode encodes</returns>
        </member>
        <member name="M:ZXing.Reader.reset">
            <summary>
            Resets any internal state the implementation has after a decode, to prepare it
            for reuse.
            </summary>
        </member>
        <member name="T:ZXing.ReaderException">
            <summary>
            The general exception class throw when something goes wrong during decoding of a barcode.
            This includes, but is not limited to, failing checksums / error correction algorithms, being
            unable to locate finder timing patterns, and so on.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.ReaderException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.ReaderException"/> class.
            </summary>
        </member>
        <member name="M:ZXing.ReaderException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.ReaderException"/> class.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:ZXing.ReaderException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.ReaderException"/> class.
            </summary>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:ZXing.ReaderException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.ReaderException"/> class.
            </summary>
            <param name="innerException">The inner exception.</param>
            <param name="message"></param>
        </member>
        <member name="T:ZXing.Rendering.IBarcodeRenderer`1">
            <summary>
            Interface for a class to convert a BitMatrix to an output image format
            </summary>
        </member>
        <member name="M:ZXing.Rendering.IBarcodeRenderer`1.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String)">
            <summary>
            Renders the specified matrix to its graphically representation
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The encoded content of the barcode which should be included in the image.
            That can be the numbers below a 1D barcode or something other.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Rendering.IBarcodeRenderer`1.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String,ZXing.Common.EncodingOptions)">
            <summary>
            Renders the specified matrix to its graphically representation
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The encoded content of the barcode which should be included in the image.
            That can be the numbers below a 1D barcode or something other.</param>
            <param name="options">The options.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Rendering.PixelData">
            <summary>
            represents the generated code as a byte array with pixel data (4 byte per pixel, BGRA)
            </summary>
            <summary>
            represents the generated code as a byte array with pixel data (4 byte per pixel, BGRA)
            </summary>
        </member>
        <member name="M:ZXing.Rendering.PixelData.ToColor32">
            <summary>
            converts the pixel data to a bitmap object
            </summary>
            <returns></returns>
        </member>
        <member name="P:ZXing.Rendering.PixelData.Pixels">
            <summary>
            the generated code as byte array of BGRA pixels
            </summary>
        </member>
        <member name="P:ZXing.Rendering.PixelData.Width">
            <summary>
            the width of the image
            </summary>
        </member>
        <member name="P:ZXing.Rendering.PixelData.Height">
            <summary>
            the height of the image
            </summary>
        </member>
        <member name="T:ZXing.Rendering.PixelDataRenderer">
            <summary>
            Renders a <see cref="T:ZXing.Common.BitMatrix" /> to an byte array with pixel data (4 byte per pixel, BGRA)
            </summary>
        </member>
        <member name="P:ZXing.Rendering.PixelDataRenderer.Foreground">
            <summary>
            Gets or sets the foreground color.
            </summary>
            <value>
            The foreground color.
            </value>
        </member>
        <member name="P:ZXing.Rendering.PixelDataRenderer.Background">
            <summary>
            Gets or sets the background color.
            </summary>
            <value>
            The background color.
            </value>
        </member>
        <member name="M:ZXing.Rendering.PixelDataRenderer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Rendering.PixelDataRenderer"/> class.
            </summary>
        </member>
        <member name="M:ZXing.Rendering.PixelDataRenderer.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String)">
            <summary>
            Renders the specified matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The content.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Rendering.PixelDataRenderer.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String,ZXing.Common.EncodingOptions)">
            <summary>
            Renders the specified matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The content.</param>
            <param name="options">The options.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Rendering.StringRenderer">
            <summary> Renders a <see cref="T:ZXing.Common.BitMatrix" /> to a <see cref="T:System.String" /> </summary>
            <inheritdoc />
        </member>
        <member name="P:ZXing.Rendering.StringRenderer.Foreground">
            <summary> Foreground/filled Char. </summary>
        </member>
        <member name="P:ZXing.Rendering.StringRenderer.Background">
            <summary> Background/blank Char. </summary>
        </member>
        <member name="T:ZXing.Rendering.SvgRenderer">
            <summary>
            Renders a barcode into a Svg image
            </summary>
        </member>
        <member name="F:ZXing.Rendering.SvgRenderer.DefaultFontName">
            <summary>
            the default font name if nothing else is set (Arial)
            </summary>
        </member>
        <member name="F:ZXing.Rendering.SvgRenderer.DefaultFontSize">
            <summary>
            the default font size if nothing else is set (10)
            </summary>
        </member>
        <member name="P:ZXing.Rendering.SvgRenderer.Foreground">
            <summary>
            Gets or sets the foreground color.
            </summary>
            <value>The foreground color.</value>
        </member>
        <member name="P:ZXing.Rendering.SvgRenderer.Background">
            <summary>
            Gets or sets the background color.
            </summary>
            <value>The background color.</value>
        </member>
        <member name="P:ZXing.Rendering.SvgRenderer.FontName">
            <summary>
            Gets or sets the font family name
            </summary>
            <value>The font family name.</value>
        </member>
        <member name="P:ZXing.Rendering.SvgRenderer.FontSize">
            <summary>
            Gets or sets the font size in pixel
            </summary>
            <value>The font size in pixel.</value>
        </member>
        <member name="M:ZXing.Rendering.SvgRenderer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Rendering.SvgRenderer"/> class.
            </summary>
        </member>
        <member name="M:ZXing.Rendering.SvgRenderer.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String)">
            <summary>
            Renders the specified matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The content.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Rendering.SvgRenderer.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String,ZXing.Common.EncodingOptions)">
            <summary>
            Renders the specified matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The content.</param>
            <param name="options">The options.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Rendering.SvgRenderer.SvgImage">
            <summary>
            Represents a barcode as a Svg image
            </summary>
        </member>
        <member name="P:ZXing.Rendering.SvgRenderer.SvgImage.Content">
            <summary>
            Gets or sets the content.
            </summary>
            <value>
            The content.
            </value>
        </member>
        <member name="P:ZXing.Rendering.SvgRenderer.SvgImage.Height">
            <summary>
            The original height of the bitmatrix for the barcode
            </summary>
        </member>
        <member name="P:ZXing.Rendering.SvgRenderer.SvgImage.Width">
            <summary>
            The original width of the bitmatrix for the barcode
            </summary>
        </member>
        <member name="M:ZXing.Rendering.SvgRenderer.SvgImage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Rendering.SvgRenderer.SvgImage"/> class.
            </summary>
        </member>
        <member name="M:ZXing.Rendering.SvgRenderer.SvgImage.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Rendering.SvgRenderer.SvgImage"/> class.
            </summary>
        </member>
        <member name="M:ZXing.Rendering.SvgRenderer.SvgImage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Rendering.SvgRenderer.SvgImage"/> class.
            </summary>
            <param name="content">The content.</param>
        </member>
        <member name="M:ZXing.Rendering.SvgRenderer.SvgImage.ToString">
            <summary>
            Gives the XML representation of the SVG image
            </summary>
        </member>
        <member name="T:ZXing.Result">
            <summary>
            Encapsulates the result of decoding a barcode within an image.
            </summary>
        </member>
        <member name="P:ZXing.Result.Text">
            <returns>raw text encoded by the barcode, if applicable, otherwise <code>null</code></returns>
        </member>
        <member name="P:ZXing.Result.RawBytes">
            <returns>raw bytes encoded by the barcode, if applicable, otherwise <code>null</code></returns>
        </member>
        <member name="P:ZXing.Result.ResultPoints">
            <returns>
            points related to the barcode in the image. These are typically points
            identifying finder patterns or the corners of the barcode. The exact meaning is
            specific to the type of barcode that was decoded.
            </returns>
        </member>
        <member name="P:ZXing.Result.BarcodeFormat">
            <returns>{@link BarcodeFormat} representing the format of the barcode that was decoded</returns>
        </member>
        <member name="P:ZXing.Result.ResultMetadata">
            <returns>
            {@link Hashtable} mapping {@link ResultMetadataType} keys to values. May be
            <code>null</code>. This contains optional metadata about what was detected about the barcode,
            like orientation.
            </returns>
        </member>
        <member name="P:ZXing.Result.Timestamp">
            <summary>
            Gets the timestamp.
            </summary>
        </member>
        <member name="P:ZXing.Result.NumBits">
            <summary>
            how many bits of <see cref="P:ZXing.Result.RawBytes"/> are valid; typically 8 times its length
            </summary>
        </member>
        <member name="M:ZXing.Result.#ctor(System.String,System.Byte[],ZXing.ResultPoint[],ZXing.BarcodeFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Result"/> class.
            </summary>
            <param name="text">The text.</param>
            <param name="rawBytes">The raw bytes.</param>
            <param name="resultPoints">The result points.</param>
            <param name="format">The format.</param>
        </member>
        <member name="M:ZXing.Result.#ctor(System.String,System.Byte[],System.Int32,ZXing.ResultPoint[],ZXing.BarcodeFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Result"/> class.
            </summary>
            <param name="text">The text.</param>
            <param name="rawBytes">The raw bytes.</param>
            <param name="numBits"></param>
            <param name="resultPoints">The result points.</param>
            <param name="format">The format.</param>
        </member>
        <member name="M:ZXing.Result.#ctor(System.String,System.Byte[],ZXing.ResultPoint[],ZXing.BarcodeFormat,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Result"/> class.
            </summary>
            <param name="text">The text.</param>
            <param name="rawBytes">The raw bytes.</param>
            <param name="resultPoints">The result points.</param>
            <param name="format">The format.</param>
            <param name="timestamp">The timestamp.</param>
        </member>
        <member name="M:ZXing.Result.#ctor(System.String,System.Byte[],System.Int32,ZXing.ResultPoint[],ZXing.BarcodeFormat,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Result"/> class.
            </summary>
            <param name="text">The text.</param>
            <param name="rawBytes">The raw bytes.</param>
            <param name="numBits"></param>
            <param name="resultPoints">The result points.</param>
            <param name="format">The format.</param>
            <param name="timestamp">The timestamp.</param>
        </member>
        <member name="M:ZXing.Result.putMetadata(ZXing.ResultMetadataType,System.Object)">
            <summary>
            Adds one metadata to the result
            </summary>
            <param name="type">The type.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:ZXing.Result.putAllMetadata(System.Collections.Generic.IDictionary{ZXing.ResultMetadataType,System.Object})">
            <summary>
            Adds a list of metadata to the result
            </summary>
            <param name="metadata">The metadata.</param>
        </member>
        <member name="M:ZXing.Result.addResultPoints(ZXing.ResultPoint[])">
            <summary>
            Adds the result points.
            </summary>
            <param name="newPoints">The new points.</param>
        </member>
        <member name="M:ZXing.Result.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ZXing.ResultMetadataType">
            <summary>
            Represents some type of metadata about the result of the decoding that the decoder
            wishes to communicate back to the caller.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="F:ZXing.ResultMetadataType.OTHER">
            <summary>
            Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.ORIENTATION">
            <summary>
            Denotes the likely approximate orientation of the barcode in the image. This value
            is given as degrees rotated clockwise from the normal, upright orientation.
            For example a 1D barcode which was found by reading top-to-bottom would be
            said to have orientation "90". This key maps to an {@link Integer} whose
            value is in the range [0,360).
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.BYTE_SEGMENTS">
            <summary>
            <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'
            which is sometimes used to encode binary data. While {@link Result} makes available
            the complete raw bytes in the barcode for these formats, it does not offer the bytes
            from the byte segments alone.</p>
            <p>This maps to a {@link java.util.List} of byte arrays corresponding to the
            raw bytes in the byte segments in the barcode, in order.</p>
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.ERROR_CORRECTION_LEVEL">
            <summary>
            Error correction level used, if applicable. The value type depends on the
            format, but is typically a String.
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.ISSUE_NUMBER">
            <summary>
            For some periodicals, indicates the issue number as an {@link Integer}.
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.SUGGESTED_PRICE">
            <summary>
            For some products, indicates the suggested retail price in the barcode as a
            formatted {@link String}.
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.POSSIBLE_COUNTRY">
            <summary>
            For some products, the possible country of manufacture as a {@link String} denoting the
            ISO country code. Some map to multiple possible countries, like "US/CA".
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.UPC_EAN_EXTENSION">
            <summary>
            For some products, the extension text
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.STRUCTURED_APPEND_SEQUENCE">
            <summary>
            If the code format supports structured append and
            the current scanned code is part of one then the
            sequence number is given with it.
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.STRUCTURED_APPEND_PARITY">
            <summary>
            If the code format supports structured append and
            the current scanned code is part of one then the
            parity is given with it.
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.PDF417_EXTRA_METADATA">
            <summary>
            PDF417-specific metadata
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.AZTEC_EXTRA_METADATA">
            <summary>
            Aztec-specific metadata
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.SYMBOLOGY_IDENTIFIER">
            <summary>
            Barcode Symbology Identifier.
            Note: According to the GS1 specification the identifier may have to replace a leading FNC1/GS character when prepending to the barcode content.
            </summary>
        </member>
        <member name="F:ZXing.ResultMetadataType.QR_MASK_PATTERN">
            <summary>
            The bit mask applied to a QR code
            </summary>
        </member>
        <member name="T:ZXing.ResultPoint">
            <summary>
            Encapsulates a point of interest in an image containing a barcode. Typically, this
            would be the location of a finder pattern or the corner of the barcode, for example.
            </summary>
            <author>Sean Owen</author>
        </member>
        <member name="M:ZXing.ResultPoint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.ResultPoint"/> class.
            </summary>
        </member>
        <member name="M:ZXing.ResultPoint.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.ResultPoint"/> class.
            </summary>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
        </member>
        <member name="P:ZXing.ResultPoint.X">
            <summary>
            Gets the X.
            </summary>
        </member>
        <member name="P:ZXing.ResultPoint.Y">
            <summary>
            Gets the Y.
            </summary>
        </member>
        <member name="M:ZXing.ResultPoint.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ZXing.ResultPoint.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:ZXing.ResultPoint.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ZXing.ResultPoint.orderBestPatterns(ZXing.ResultPoint[])">
            <summary>
            Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC and
            BC is less than AC and the angle between BC and BA is less than 180 degrees.
            </summary>
            <param name="patterns">array of three <see cref="T:ZXing.ResultPoint" /> to order</param>
        </member>
        <member name="M:ZXing.ResultPoint.distance(ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            calculates the distance between two points
            </summary>
            <param name="pattern1">first pattern</param>
            <param name="pattern2">second pattern</param>
            <returns>
            distance between two points
            </returns>
        </member>
        <member name="M:ZXing.ResultPoint.crossProductZ(ZXing.ResultPoint,ZXing.ResultPoint,ZXing.ResultPoint)">
            <summary>
            Returns the z component of the cross product between vectors BC and BA.
            </summary>
        </member>
        <member name="T:ZXing.ResultPointCallback">
            <summary> Callback which is invoked when a possible result point (significant
            point in the barcode image such as a corner) is found.
            
            </summary>
            <seealso cref="F:ZXing.DecodeHintType.NEED_RESULT_POINT_CALLBACK">
            </seealso>
        </member>
        <member name="T:ZXing.RGBLuminanceSource">
            <summary>
            Luminance source class which support different formats of images.
            </summary>
        </member>
        <member name="T:ZXing.RGBLuminanceSource.BitmapFormat">
            <summary>
            enumeration of supported bitmap format which the RGBLuminanceSource can process
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.Unknown">
            <summary>
            format of the byte[] isn't known. RGBLuminanceSource tries to determine the best possible value
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.Gray8">
            <summary>
            grayscale array, the byte array is a luminance array with 1 byte per pixel
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.Gray16">
            <summary>
            grayscale array, the byte array is a luminance array with 2 bytes per pixel
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.RGB24">
            <summary>
            3 bytes per pixel with the channels red, green and blue
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.RGB32">
            <summary>
            4 bytes per pixel with the channels red, green and blue
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.ARGB32">
            <summary>
            4 bytes per pixel with the channels alpha, red, green and blue
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.BGR24">
            <summary>
            3 bytes per pixel with the channels blue, green and red
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.BGR32">
            <summary>
            4 bytes per pixel with the channels blue, green and red
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.BGRA32">
            <summary>
            4 bytes per pixel with the channels blue, green, red and alpha
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.RGB565">
            <summary>
            2 bytes per pixel, 5 bit red, 6 bits green and 5 bits blue
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.RGBA32">
            <summary>
            4 bytes per pixel with the channels red, green, blue and alpha
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.UYVY">
            <summary>
            4 bytes for two pixels, UYVY formatted
            </summary>
        </member>
        <member name="F:ZXing.RGBLuminanceSource.BitmapFormat.YUYV">
            <summary>
            4 bytes for two pixels, YUYV formatted
            </summary>
        </member>
        <member name="M:ZXing.RGBLuminanceSource.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.RGBLuminanceSource"/> class.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:ZXing.RGBLuminanceSource.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.RGBLuminanceSource"/> class.
            It supports a byte array with 3 bytes per pixel (RGB24).
            </summary>
            <param name="rgbRawBytes">The RGB raw bytes.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:ZXing.RGBLuminanceSource.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.RGBLuminanceSource"/> class.
            It supports a byte array with 1 byte per pixel (Gray8).
            That means the whole array consists of the luminance values (grayscale).
            </summary>
            <param name="luminanceArray">The luminance array.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="is8Bit">if set to <c>true</c> [is8 bit].</param>
        </member>
        <member name="M:ZXing.RGBLuminanceSource.#ctor(System.Byte[],System.Int32,System.Int32,ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.RGBLuminanceSource"/> class.
            It supports a byte array with 3 bytes per pixel (RGB24).
            </summary>
            <param name="rgbRawBytes">The RGB raw bytes.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="bitmapFormat">The bitmap format.</param>
        </member>
        <member name="M:ZXing.RGBLuminanceSource.CreateLuminanceSource(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Should create a new luminance source with the right class type.
            The method is used in methods crop and rotate.
            </summary>
            <param name="newLuminances">The new luminances.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.RGBLuminanceSource.CalculateLuminance(System.Byte[],ZXing.RGBLuminanceSource.BitmapFormat)">
            <summary>
            calculates the luminance values for the given byte array and bitmap format
            </summary>
            <param name="rgbRawBytes"></param>
            <param name="bitmapFormat"></param>
        </member>
        <member name="T:ZXing.SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="M:ZXing.SupportClass.GetCharsFromString(System.String,System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            Copies an array of chars obtained from a String into a specified array of chars
            </summary>
            <param name="sourceString">The String to get the chars from</param>
            <param name="sourceStart">Position of the String to start getting the chars</param>
            <param name="sourceEnd">Position of the String to end getting the chars</param>
            <param name="destinationArray">Array to return the chars</param>
            <param name="destinationStart">Position of the destination array of chars to start storing the chars</param>
            <returns>An array of chars</returns>
        </member>
        <member name="M:ZXing.SupportClass.SetCapacity``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Sets the capacity for the specified List
            </summary>
            <param name="vector">The List which capacity will be set</param>
            <param name="newCapacity">The new capacity value</param>
        </member>
        <member name="M:ZXing.SupportClass.toStringArray(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Converts a string-Collection to an array
            </summary>
            <param name="strings">The strings.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.SupportClass.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Joins all elements to one string.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="separator">The separator.</param>
            <param name="values">The values.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.SupportClass.Fill``1(``0[],``0)">
            <summary>
            Fills the specified array.
            (can't use extension method because of .Net 2.0 support)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array">The array.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:ZXing.SupportClass.Fill``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
            Fills the specified array.
            (can't use extension method because of .Net 2.0 support)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array">The array.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:ZXing.SupportClass.ToBinaryString(System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.SupportClass.bitCount(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:ZXing.SupportClass.GetValue``1(System.Collections.Generic.IDictionary{ZXing.DecodeHintType,System.Object},ZXing.DecodeHintType,``0)">
            <summary>
            Savely gets the value of a decoding hint
            if hints is null the default is returned
            </summary>
            <typeparam name="T"></typeparam>
            <param name="hints">The hints.</param>
            <param name="hintType">Type of the hint.</param>
            <param name="default">The @default.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Color32LuminanceSource">
            <summary>
            Calculates the luminance values based upon the Color32 structure
            </summary>
        </member>
        <member name="M:ZXing.Color32LuminanceSource.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Color32LuminanceSource"/> class.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:ZXing.Color32LuminanceSource.#ctor(UnityEngine.Color32[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Color32LuminanceSource"/> class.
            </summary>
            <param name="color32s">The color32s.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:ZXing.Color32LuminanceSource.SetPixels(UnityEngine.Color32[])">
            <summary>
            Sets the pixels.
            </summary>
            <param name="color32s">The color32s.</param>
        </member>
        <member name="M:ZXing.Color32LuminanceSource.CreateLuminanceSource(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Should create a new luminance source with the right class type.
            The method is used in methods crop and rotate.
            </summary>
            <param name="newLuminances">The new luminances.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Color32Renderer">
            <summary>
            a barcode renderer which returns a Color32 array
            </summary>
        </member>
        <member name="P:ZXing.Color32Renderer.Foreground">
            <summary>
            Gets or sets the foreground color.
            </summary>
            <value>
            The foreground color.
            </value>
        </member>
        <member name="P:ZXing.Color32Renderer.Background">
            <summary>
            Gets or sets the background color.
            </summary>
            <value>
            The background color.
            </value>
        </member>
        <member name="M:ZXing.Color32Renderer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.Color32Renderer"/> class.
            </summary>
        </member>
        <member name="M:ZXing.Color32Renderer.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String)">
            <summary>
            Renders the specified matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The content.</param>
            <returns></returns>
        </member>
        <member name="M:ZXing.Color32Renderer.Render(ZXing.Common.BitMatrix,ZXing.BarcodeFormat,System.String,ZXing.Common.EncodingOptions)">
            <summary>
            Renders the specified matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">The format.</param>
            <param name="content">The content.</param>
            <param name="options">The options.</param>
            <returns></returns>
        </member>
        <member name="T:ZXing.Writer">
            <summary> The base class for all objects which encode/generate a barcode image.
            
            </summary>
            <author>  dswitkin@google.com (Daniel Switkin)
            </author>
            <author>www.Redivivus.in (suraj.supekar@redivivus.in) - Ported from ZXING Java Source 
            </author>
        </member>
        <member name="M:ZXing.Writer.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32)">
            <summary>
            Encode a barcode using the default settings.
            </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <returns> The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)</returns>
        </member>
        <member name="M:ZXing.Writer.encode(System.String,ZXing.BarcodeFormat,System.Int32,System.Int32,System.Collections.Generic.IDictionary{ZXing.EncodeHintType,System.Object})">
            <summary> </summary>
            <param name="contents">The contents to encode in the barcode</param>
            <param name="format">The barcode format to generate</param>
            <param name="width">The preferred width in pixels</param>
            <param name="height">The preferred height in pixels</param>
            <param name="hints">Additional parameters to supply to the encoder</param>
            <returns> The generated barcode as a Matrix of unsigned bytes (0 == black, 255 == white)</returns>
        </member>
        <member name="T:ZXing.WriterException">
            <summary>
            A base class which covers the range of exceptions which may occur when encoding a barcode using
            the Writer framework.
            </summary>
            <author>dswitkin@google.com (Daniel Switkin)</author>
        </member>
        <member name="M:ZXing.WriterException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.WriterException"/> class.
            </summary>
        </member>
        <member name="M:ZXing.WriterException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.WriterException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:ZXing.WriterException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ZXing.WriterException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerExc">The inner exc.</param>
        </member>
        <member name="T:BigIntegerLibrary.Base10BigInteger">
            <summary>
            Integer inefficiently represented internally using base-10 digits, in order to allow a
            visual representation as a base-10 string. Only for internal use.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.Base10BigInteger.NumberBase">
            <summary>
            10 numeration base for string representation, very inefficient for computations.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.Base10BigInteger.MaxSize">
            <summary>
            Maximum size for numbers is up to 10240 binary digits or approximately (safe to use) 3000 decimal digits.
            The maximum size is, in fact, double the previously specified amount, in order to accommodate operations'
            overflow.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.Base10BigInteger.Zero">
            Integer constants
        </member>
        <member name="F:BigIntegerLibrary.Base10BigInteger.digits">
            <summary>
            The array of digits of the number.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.Base10BigInteger.size">
            <summary>
            The actual number of digits of the number.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.Base10BigInteger.sign">
            <summary>
            The number sign.
            </summary>
        </member>
        <member name="P:BigIntegerLibrary.Base10BigInteger.NumberSign">
            <summary>
            Sets the number sign.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.#ctor">
            <summary>
            Default constructor, intializing the Base10BigInteger with zero.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.#ctor(System.Int64)">
            <summary>
            Constructor creating a new Base10BigInteger as a conversion of a regular base-10 long.
            </summary>
            <param name="n">The base-10 long to be converted</param>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.#ctor(BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Constructor creating a new Base10BigInteger as a copy of an existing Base10BigInteger.
            </summary>
            <param name="n">The Base10BigInteger to be copied</param>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Equals(BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Determines whether the specified Base10BigInteger is equal to the current Base10BigInteger.
            </summary>
            <param name="other">The Base10BigInteger to compare with the current Base10BigInteger</param>
            <returns>True if the specified Base10BigInteger is equal to the current Base10BigInteger,
            false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current Base10BigInteger.
            </summary>
            <param name="o">The System.Object to compare with the current Base10BigInteger</param>
            <returns>True if the specified System.Object is equal to the current Base10BigInteger,
            false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.GetHashCode">
            <summary>
            Serves as a hash function for the Base10BigInteger type.
            </summary>
            <returns>A hash code for the current Base10BigInteger</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.ToString">
            <summary>
            String representation of the current Base10BigInteger, converted to its base-10 representation.
            </summary>
            <returns>The string representation of the current Base10BigInteger</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Opposite(BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Base10BigInteger inverse with respect to addition.
            </summary>
            <param name="n">The Base10BigInteger whose opposite is to be computed</param>
            <returns>The Base10BigInteger inverse with respect to addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Greater(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Greater test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &gt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.GreaterOrEqual(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Greater or equal test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &gt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Smaller(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Smaller test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &lt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.SmallerOrEqual(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Smaller or equal test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &lt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Abs(BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Computes the absolute value of a Base10BigInteger.
            </summary>
            <param name="n">The Base10BigInteger whose absolute value is to be computed</param>
            <returns>The absolute value of the given BigInteger</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Addition(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Addition operation of two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>The Base10BigInteger result of the addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Subtraction(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Subtraction operation of two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>The Base10BigInteger result of the subtraction</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Multiplication(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Multiplication operation of two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>The Base10BigInteger result of the multiplication</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Implicit(System.Int64)~BigIntegerLibrary.Base10BigInteger">
            <summary>
            Implicit conversion operator from long to Base10BigInteger.
            </summary>
            <param name="n">The long to be converted to a Base10BigInteger</param>
            <returns>The Base10BigInteger converted from the given long</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Equality(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Equality test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a == b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Inequality(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Inequality test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a != b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_GreaterThan(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Greater test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &gt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_LessThan(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Smaller test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &lt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_GreaterThanOrEqual(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Greater or equal test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &gt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_LessThanOrEqual(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Smaller or equal test between two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>True if a &lt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_UnaryNegation(BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Base10BigInteger inverse with respect to addition.
            </summary>
            <param name="n">The Base10BigInteger whose opposite is to be computed</param>
            <returns>The Base10BigInteger inverse with respect to addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Addition(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Addition operation of two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>The Base10BigInteger result of the addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Subtraction(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Subtraction operation of two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>The Base10BigInteger result of the subtraction</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Multiply(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Multiplication operation of two Base10BigIntegers.
            </summary>
            <param name="a">The 1st Base10BigInteger</param>
            <param name="b">The 2nd Base10BigInteger</param>
            <returns>The Base10BigInteger result of the multiplication</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Increment(BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Incremetation by one operation of a Base10BigInteger.
            </summary>
            <param name="n">The Base10BigInteger to be incremented by one</param>
            <returns>The Base10BigInteger result of incrementing by one</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.op_Decrement(BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Decremetation by one operation of a Base10BigInteger.
            </summary>
            <param name="n">The Base10BigInteger to be decremented by one</param>
            <returns>The Base10BigInteger result of decrementing by one</returns>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Add(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Adds two BigNumbers a and b, where a >= b, a, b non-negative.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Subtract(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Subtracts the Base10BigInteger b from the Base10BigInteger a, where a >= b, a, b non-negative.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.Base10BigInteger.Multiply(BigIntegerLibrary.Base10BigInteger,BigIntegerLibrary.Base10BigInteger)">
            <summary>
            Multiplies two Base10BigIntegers.
            </summary>
        </member>
        <member name="T:BigIntegerLibrary.BigInteger">
            <summary>
            .NET 2.0 class for handling of very large integers, up to 10240 binary digits or
            approximately (safe to use) 3000 decimal digits.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.BigInteger.NumberBase">
            <summary>
            2^16 numeration base for internal computations, in order to benefit the most from the
            32 bit (or 64 bit) integer processor registers.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.BigInteger.MaxSize">
            <summary>
            Maximum size for numbers is up to 10240 binary digits or approximately (safe to use) 3000 decimal digits.
            The maximum size is, in fact, double the previously specified amount, in order to accommodate operations's
            overflow.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.BigInteger.RatioToBinaryDigits">
            <summary>
            Ratio for the convertion of a BigInteger's size to a binary digits size.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.BigInteger.Zero">
            Integer constants
        </member>
        <member name="F:BigIntegerLibrary.BigInteger.digits">
            <summary>
            The array of digits of the number.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.BigInteger.size">
            <summary>
            The actual number of digits of the number.
            </summary>
        </member>
        <member name="F:BigIntegerLibrary.BigInteger.sign">
            <summary>
            The number sign.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.#ctor">
            <summary>
            Default constructor, intializing the BigInteger with zero.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.#ctor(System.Int64)">
            <summary>
            Constructor creating a new BigInteger as a conversion of a regular base-10 long.
            </summary>
            <param name="n">The base-10 long to be converted</param>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.#ctor(BigIntegerLibrary.BigInteger)">
            <summary>
            Constructor creating a new BigInteger as a copy of an existing BigInteger.
            </summary>
            <param name="n">The BigInteger to be copied</param>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.#ctor(System.String)">
            <summary>
            Constructor creating a BigInteger instance out of a base-10 formatted string.
            </summary>
            <param name="numberString">The base-10 formatted string.</param>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Invalid numeric string exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.#ctor(System.Byte[])">
            <summary>
            Constructor creating a positive BigInteger by extracting it's digits from a given byte array.
            </summary>
            <param name="byteArray">The byte array</param>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">The byte array's content exceeds the maximum size of a BigInteger
            exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Equals(BigIntegerLibrary.BigInteger)">
            <summary>
            Determines whether the specified BigInteger is equal to the current BigInteger.
            </summary>
            <param name="other">The BigInteger to compare with the current BigInteger</param>
            <returns>True if the specified BigInteger is equal to the current BigInteger,
            false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current BigInteger.
            </summary>
            <param name="o">The System.Object to compare with the current BigInteger</param>
            <returns>True if the specified System.Object is equal to the current BigInteger,
            false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.GetHashCode">
            <summary>
            Serves as a hash function for the BigInteger type.
            </summary>
            <returns>A hash code for the current BigInteger</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.ToString">
            <summary>
            String representation of the current BigInteger, converted to its base-10 representation.
            </summary>
            <returns>The string representation of the current BigInteger</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Parse(System.String)">
            <summary>
            Parses the number given by a string
            </summary>
            <param name="str">the number as a string</param>
            <returns></returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.CompareTo(BigIntegerLibrary.BigInteger)">
            <summary>
             Compares this instance to a specified BigInteger.
            </summary>
            <param name="other">The BigInteger to compare this instance with</param>
            <returns>-1 if the current instance is smaller than the given BigInteger,
            0 if the two are equal, 1 otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.CompareTo(System.Object)">
            <summary>
             Compares this instance to a specified object.
            </summary>
            <param name="obj">The object to compare this instance with</param>
            <returns>-1 if the current instance is smaller than the given object,
            0 if the two are equal, 1 otherwise</returns>
            <exception cref="T:System.ArgumentException">obj is not a BigInteger exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.SizeInBinaryDigits(BigIntegerLibrary.BigInteger)">
            <summary>
            Returns a BigInteger's size in binary digits.
            </summary>
            <param name="n">The BigInteger whose size in binary digits is to be determined</param>
            <returns>The BigInteger's size in binary digits</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Opposite(BigIntegerLibrary.BigInteger)">
            <summary>
            BigInteger inverse with respect to addition.
            </summary>
            <param name="n">The BigInteger whose opposite is to be computed</param>
            <returns>The BigInteger inverse with respect to addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Greater(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Greater test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &gt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.GreaterOrEqual(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Greater or equal test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &gt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Smaller(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Smaller test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &lt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.SmallerOrEqual(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Smaller or equal test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &lt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Abs(BigIntegerLibrary.BigInteger)">
            <summary>
            Computes the absolute value of a BigInteger.
            </summary>
            <param name="n">The BigInteger whose absolute value is to be computed</param>
            <returns>The absolute value of the given BigInteger</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Addition(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Addition operation of two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Subtraction(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Subtraction operation of two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the subtraction</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Multiplication(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Multiplication operation of two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the multiplication</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Division(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Division operation of two BigIntegers a and b, b != 0.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the division</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot divide by zero exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Modulo(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Modulo operation of two BigIntegers a and b, b != 0.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the modulo</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot divide by zero exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Power(BigIntegerLibrary.BigInteger,System.Int32)">
            <summary>
            Returns the power of a BigInteger base to a non-negative exponent by using the
            fast exponentiation algorithm (right to left binary exponentiation).
            </summary>
            <param name="a">The BigInteger base</param>
            <param name="exponent">The non-negative exponent</param>
            <returns>The power of the BigInteger base to the non-negative exponent</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot raise a BigInteger to a negative power exception.</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.IntegerSqrt(BigIntegerLibrary.BigInteger)">
            <summary>
            Integer square root of the given BigInteger using Newton's numeric method.
            </summary>
            <param name="n">The BigInteger whose integer square root is to be computed</param>
            <returns>The integer square root of the given BigInteger</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot compute the integer square root of a negative number exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Gcd(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Euclidean algorithm for computing the greatest common divisor of two non-negative BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The greatest common divisor of the two given BigIntegers</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot compute the Gcd of negative BigIntegers exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.ExtendedEuclidGcd(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger@,BigIntegerLibrary.BigInteger@)">
            <summary>
            Extended Euclidian Gcd algorithm, returning the greatest common divisor of two non-negative BigIntegers,
            while also providing u and v, where: a*u + b*v = gcd(a,b).
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <param name="u">Output BigInteger parameter, where a*u + b*v = gcd(a,b)</param>
            <param name="v">Output BigInteger parameter, where a*u + b*v = gcd(a,b)</param>
            <returns>The greatest common divisor of the two given BigIntegers</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot compute the Gcd of negative BigIntegers exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.ModularInverse(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Computes the modular inverse of a given BigInteger.
            </summary>
            <param name="a">The non-zero BigInteger whose inverse is to be computed</param>
            <param name="n">The BigInteger modulus, which must be greater than or equal to 2</param>
            <returns>The BigInteger equal to a^(-1) mod n</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Invalid number or modulus exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.ModularExponentiation(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Returns the power of a BigInteger to a non-negative exponent modulo n, by using the
            fast exponentiation algorithm (right to left binary exponentiation) and modulo optimizations.
            </summary>
            <param name="a">The BigInteger base</param>
            <param name="exponent">The non-negative exponent</param>
            <param name="n">The modulus, which must be greater than or equal to 2</param>
            <returns>The power of the BigInteger to the non-negative exponent</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Invalid exponent or modulus exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Implicit(System.Int64)~BigIntegerLibrary.BigInteger">
            <summary>
            Implicit conversion operator from long to BigInteger.
            </summary>
            <param name="n">The long to be converted to a BigInteger</param>
            <returns>The BigInteger converted from the given long</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Implicit(System.Int32)~BigIntegerLibrary.BigInteger">
            <summary>
            Implicit conversion operator from int to BigInteger.
            </summary>
            <param name="n">The int to be converted to a BigInteger</param>
            <returns>The BigInteger converted from the given int</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Equality(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Equality test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a == b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Inequality(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Inequality test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a != b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_GreaterThan(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Greater test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &gt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_LessThan(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Smaller test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &lt; b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_GreaterThanOrEqual(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Greater or equal test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &gt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_LessThanOrEqual(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Smaller or equal test between two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>True if a &lt;= b, false otherwise</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_UnaryNegation(BigIntegerLibrary.BigInteger)">
            <summary>
            BigInteger inverse with respect to addition.
            </summary>
            <param name="n">The BigInteger whose opposite is to be computed</param>
            <returns>The BigInteger inverse with respect to addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Addition(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Addition operation of two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the addition</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Subtraction(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Subtraction operation of two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the subtraction</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Multiply(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Multiplication operation of two BigIntegers.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the multiplication</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Division(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Division operation of two BigIntegers a and b, b != 0.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the division</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot divide by zero exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Modulus(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Modulo operation of two BigIntegers a and b, b != 0.
            </summary>
            <param name="a">The 1st BigInteger</param>
            <param name="b">The 2nd BigInteger</param>
            <returns>The BigInteger result of the modulo</returns>
            <exception cref="T:BigIntegerLibrary.BigIntegerException">Cannot divide by zero exception</exception>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Increment(BigIntegerLibrary.BigInteger)">
            <summary>
            Incremetation by one operation of a BigInteger.
            </summary>
            <param name="n">The BigInteger to be incremented by one</param>
            <returns>The BigInteger result of incrementing by one</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.op_Decrement(BigIntegerLibrary.BigInteger)">
            <summary>
            Decremetation by one operation of a BigInteger.
            </summary>
            <param name="n">The BigInteger to be decremented by one</param>
            <returns>The BigInteger result of decrementing by one</returns>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Add(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Adds two BigNumbers a and b, where a >= b, a, b non-negative.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Subtract(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Subtracts the BigInteger b from the BigInteger a, where a >= b, a, b non-negative.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Multiply(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Multiplies two BigIntegers.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.DivideByOneDigitNumber(BigIntegerLibrary.BigInteger,System.Int64)">
            <summary>
            Divides a BigInteger by a one-digit int.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.DivideByBigNumber(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger)">
            <summary>
            Divides a BigInteger by another BigInteger.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.DivideByBigNumberSmaller(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger,System.Int32,System.Int32)">
            <summary>
            DivideByBigNumber auxiliary method. 
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Difference(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger,System.Int32,System.Int32)">
            <summary>
            DivideByBigNumber auxilary method.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigInteger.Trial(BigIntegerLibrary.BigInteger,BigIntegerLibrary.BigInteger,System.Int32,System.Int32)">
            <summary>
            DivideByBigNumber auxilary method.
            </summary>
        </member>
        <member name="T:BigIntegerLibrary.BigIntegerException">
            <summary>
            BigInteger-related exception class.
            </summary>
        </member>
        <member name="M:BigIntegerLibrary.BigIntegerException.#ctor(System.String,System.Exception)">
            <summary>
            BigIntegerException constructor.
            </summary>
            <param name="message">The exception message</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:BigIntegerLibrary.Sign">
            <summary>
            The number's sign, where Positive also stands for the number zero.
            </summary>
        </member>
    </members>
</doc>
