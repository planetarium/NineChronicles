<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Libplanet</name>
    </assembly>
    <members>
        <member name="T:Libplanet.Action.AccountBalanceGetter">
            <summary>
            An delegate to provide read-only view of account balances.
            <para>Gets <paramref name="address"/>' balance of the given <paramref name="currency"/>.
            </para>
            </summary>
            <param name="address">An address of the account to query its balance of
            the <paramref name="currency"/>.</param>
            <param name="currency">The currency type to query <paramref name="address"/>' balance.
            </param>
            <returns>
            The <paramref name="address"/>'s balance of the <paramref name="currency"/>.
            </returns>
        </member>
        <member name="T:Libplanet.Action.AccountStateDeltaImpl">
            <summary>
            An internal implementation of <see cref="T:Libplanet.Action.IAccountStateDelta"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.#ctor(Libplanet.Action.AccountStateGetter,Libplanet.Action.AccountBalanceGetter,Libplanet.Address)">
            <summary>
            Creates a null delta from the given <paramref name="accountStateGetter"/>.
            </summary>
            <param name="accountStateGetter">A view to the &#x201c;epoch&#x201d; states.</param>
            <param name="accountBalanceGetter">A view to the &#x201c;epoch&#x201d; asset balances.
            </param>
            <param name="signer">A signer address. Used for authenticating if a signer is allowed
            to mint a currency.</param>
        </member>
        <member name="P:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#UpdatedAddresses">
            <inheritdoc/>
        </member>
        <member name="P:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#StateUpdatedAddresses">
            <inheritdoc/>
        </member>
        <member name="P:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#UpdatedFungibleAssets">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#GetState(Libplanet.Address)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#SetState(Libplanet.Address,Bencodex.Types.IValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.GetBalance(Libplanet.Address,Libplanet.Assets.Currency)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Action.AccountStateDeltaImplV0">
            <summary>
            Equivalent to <see cref="T:Libplanet.Action.AccountStateDeltaImpl"/> except that it maintains its old (v0)
            incorrect behavior of <see cref="M:Libplanet.Action.AccountStateDeltaImplV0.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImplV0.GetBalance(Libplanet.Address,Libplanet.Assets.Currency)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImplV0.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Action.AccountStateGetter">
            <summary>
            An delegate to provide read-only view of account states.
            <para>Gets an account state of the given
            <paramref name="address"/>.</para>
            <para>If the given <paramref name="address"/> has never been set
            its account status, returns <c>null</c> instead of throwing
            any exception.</para>
            </summary>
            <param name="address">An address of the account to read
            its state.</param>
            <returns>The account state if exists.  Otherwise <c>null</c>.
            </returns>
        </member>
        <member name="T:Libplanet.Action.ActionEvaluation">
            <summary>
            A record type to represent an evaluation plan and result of
            a single action.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluation.#ctor(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta,System.Exception)">
            <summary>
            Creates an <see cref="T:Libplanet.Action.ActionEvaluation"/> instance
            with filling properties.
            </summary>
            <param name="action">An action to evaluate.</param>
            <param name="inputContext">An input <see cref="T:Libplanet.Action.IActionContext"/> to
            evaluate <paramref name="action"/>.</param>
            <param name="outputStates">The result states that
            <paramref name="action"/> makes.</param>
            <param name="exception">An exception that has risen during evaluating a given
            <paramref name="action"/>.</param>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.Action">
            <summary>
            An action to evaluate.
            </summary>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.InputContext">
            <summary>
            An input <see cref="T:Libplanet.Action.IActionContext"/> to evaluate
            <see cref="P:Libplanet.Action.ActionEvaluation.Action"/>.
            </summary>
            <remarks>Its <see cref="P:Libplanet.Action.IActionContext.Random"/> property
            is not consumed yet.</remarks>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.OutputStates">
            <summary>
            The result states that <see cref="P:Libplanet.Action.ActionEvaluation.Action"/> makes.
            </summary>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.Exception">
            <summary>
            An exception that had risen during evaluation.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluation.EvaluateActionsGradually(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Int64,System.Nullable{Libplanet.Tx.TxId},Libplanet.Action.IAccountStateDelta,Libplanet.Address,Libplanet.Address,System.Byte[],System.Collections.Immutable.IImmutableList{Libplanet.Action.IAction},System.Boolean,Libplanet.Store.Trie.ITrie,System.Boolean)">
            <summary>
            Executes the <paramref name="actions"/> step by step, and emits
            <see cref="T:Libplanet.Action.ActionEvaluation"/> for each step.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of <see cref="T:Libplanet.Blocks.Block`1"/> that
            <paramref name="actions"/> belongs to.</param>
            <param name="blockIndex">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of <see cref="T:Libplanet.Blocks.Block`1"/> that
            <paramref name="actions"/> belongs to.</param>
            <param name="txid">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of <see cref="T:Libplanet.Tx.Transaction`1"/>
            that <paramref name="actions"/> belongs to.  This can be <c>null</c> on rehearsal mode
            or if an action is a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.</param>
            <param name="previousStates">The states immediately before <paramref name="actions"/>
            being executed.  Note that its <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/> are
            remained to the returned next states.</param>
            <param name="minerAddress">An address of block miner.</param>
            <param name="signer">Signer of the <paramref name="actions"/>.</param>
            <param name="signature"><see cref="T:Libplanet.Tx.Transaction`1"/> signature used to generate random
            seeds.</param>
            <param name="actions">Actions to evaluate.</param>
            <param name="rehearsal">Pass <c>true</c> if it is intended
            to be dry-run (i.e., the returned result will be never used).
            The default value is <c>false</c>.</param>
            <param name="previousBlockStatesTrie">The trie to contain states at previous block.
            </param>
            <param name="blockAction">Pass <c>true</c> if it is
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.</param>
            <returns>Enumerates <see cref="T:Libplanet.Action.ActionEvaluation"/>s for each one in
            <paramref name="actions"/>.  The order is the same to the <paramref name="actions"/>.
            Note that each <see cref="P:Libplanet.Action.IActionContext.Random"/> object
            has a unconsumed state.
            </returns>
        </member>
        <member name="T:Libplanet.Action.ActionTypeAttribute">
            <summary>
            Indicates that an action class (i.e., a class implementing
            <see cref="T:Libplanet.Action.IAction"/>) can be held by transactions and blocks.
            It also gives an action class a <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> for
            serialization and deserialization.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ActionTypeAttribute.#ctor(System.String)">
            <summary>
            Creates an <see cref="T:Libplanet.Action.ActionTypeAttribute"/> with a given
            <paramref name="typeIdentifier"/>.
            </summary>
            <param name="typeIdentifier">An action class's unique
            identifier for serialization and deserialization.</param>
        </member>
        <member name="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier">
            <summary>
            An action class's unique identifier for serialization and
            deserialization.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ActionTypeAttribute.ValueOf(System.Type)">
            <summary>
            Gets the <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> for a given action class.
            </summary>
            <param name="actionType">A <see cref="T:System.Type"/> object of an action
            class to know its annotated <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/>.</param>
            <returns>The <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> of the given
            <paramref name="actionType"/> if it's annotated with
            <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.  If it's not annotated returns
            <c>null</c>.</returns>
        </member>
        <member name="T:Libplanet.Action.CurrencyPermissionException">
            <summary>
            The exception that is thrown when a <see cref="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner"/> has no rights
            to mint a <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/> or burn assets of a <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/>.
            </summary>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
        </member>
        <member name="M:Libplanet.Action.CurrencyPermissionException.#ctor(Libplanet.Address,Libplanet.Assets.Currency,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.CurrencyPermissionException"/> object.
            </summary>
            <param name="transactionSigner"> The address of the account who tried to mint or burn
            assets of a <paramref name="currency"/>.  Corresponds to
            the <see cref="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner"/> property.</param>
            <param name="currency"> The <see cref="T:Libplanet.Assets.Currency"/> to be tried to be minted
            or burned by the <paramref name="transactionSigner"/>.  Corresponds to
            the <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/> property.</param>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
        </member>
        <member name="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner">
            <summary>
            The address of the account who tried to mint or burn assets of a <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.CurrencyPermissionException.Currency">
            <summary>
            The <see cref="T:Libplanet.Assets.Currency"/> to be tried to be minted or burned by
            the <see cref="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Action.IAccountStateDelta">
            <summary>
            An interface to manipulate account states with
            maintaining the set of <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/>.
            <para>It is like a map which is virtually initialized such
            that every possible <see cref="T:Libplanet.Address"/> exists and
            is mapped to <c>null</c>.  That means that:</para>
            <list type="bullet">
            <item>
            <description>it does not have length,</description>
            </item>
            <item>
            <description>its index getter never throws
            <see cref="T:System.Collections.Generic.KeyNotFoundException"/>,
            but returns <c>null</c> instead, and</description>
            </item>
            <item>
            <description>filling an <see cref="T:Libplanet.Address"/> with
            <c>null</c> state cannot be distinguished from
            the <see cref="T:Libplanet.Address"/> having never been set to
            any state.</description>
            </item>
            </list>
            </summary>
            <remarks>
            This interface is immutable.  <see cref="M:Libplanet.Action.IAccountStateDelta.SetState(Libplanet.Address,Bencodex.Types.IValue)"/>
            method does not manipulate the instance, but returns a new
            <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance with updated states.
            </remarks>
        </member>
        <member name="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses">
            <summary>
            <seealso cref="T:Libplanet.Address"/>es of the accounts that have
            been updated since then.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IAccountStateDelta.StateUpdatedAddresses">
            <summary>
            <see cref="T:Libplanet.Address"/>es of the accounts whose states have been updated since then.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IAccountStateDelta.UpdatedFungibleAssets">
            <summary>
            <see cref="T:Libplanet.Address"/>es and sets of <see cref="T:Libplanet.Assets.Currency"/> whose fungible assets have
            been updated since then.
            <para>For example, if A transfers 10 FOO to B and B transfers 20 BAR to C,
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedFungibleAssets"/> become likes
            <c>{ [A] = { FOO }, [B] = { FOO, BAR }, [C] = { BAR } }</c>.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.GetState(Libplanet.Address)">
            <summary>
            Gets the account state of the given <paramref name="address"/>.
            </summary>
            <param name="address">The <see cref="T:Libplanet.Address"/> referring
            the account to get its state.</param>
            <returns>The account state of the given <paramref name="address"/>.
            If it has never been set to any state it returns <c>null</c>
            instead.</returns>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.SetState(Libplanet.Address,Bencodex.Types.IValue)">
            <summary>
            Gets a new instance that the account state of the given
            <paramref name="address"/> is set to the given
            <paramref name="state"/>.
            </summary>
            <param name="address">The <see cref="T:Libplanet.Address"/> referring
            the account to set its state.</param>
            <param name="state">The new state to fill the account with.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that
            the account state of the given <paramref name="address"/>
            is set to the given <paramref name="state"/>.</returns>
            <remarks>
            This method method does not manipulate the instance,
            but returns a new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance
            with updated states instead.
            </remarks>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.GetBalance(Libplanet.Address,Libplanet.Assets.Currency)">
            <summary>
            Queries <paramref name="address"/>'s balance of the <paramref name="currency"/>.
            </summary>
            <param name="address">The owner address to query.</param>
            <param name="currency">The currency type to query.</param>
            <returns>
            The <paramref name="address"/>'s balance of the <paramref name="currency"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Mints the fungible asset <paramref name="value"/> (i.e., in-game monetary),
            and give it to the <paramref name="recipient"/>.
            </summary>
            <param name="recipient">The address who receives the minted asset.</param>
            <param name="value">The asset value to mint.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that the given <paramref
            name="value"/> is added to <paramref name="recipient"/>'s balance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="value"/>
            is less than or equal to 0.</exception>
            <exception cref="T:Libplanet.Action.CurrencyPermissionException">Thrown when a transaction signer
            (or a miner in case of block actions) is not a member of the <see
            cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>'s <see cref="F:Libplanet.Assets.Currency.Minters"/>.</exception>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)">
            <summary>
            Transfers the fungible asset <paramref name="value"/> (i.e., in-game monetary)
            from the <paramref name="sender"/> to the <paramref name="recipient"/>.
            </summary>
            <param name="sender">The address who sends the fungible asset to
            the <paramref name="recipient"/>.</param>
            <param name="recipient">The address who receives the fungible asset from
            the <paramref name="sender"/>.</param>
            <param name="value">The asset value to transfer.</param>
            <param name="allowNegativeBalance">Turn on to allow <paramref name="sender"/>'s balance
            less than zero.  Turned off by default.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that the given <paramref
            name="value"/>  is subtracted from <paramref name="sender"/>'s balance and added to
            <paramref name="recipient"/>'s balance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="value"/>
            is less than or equal to zero.</exception>
            <exception cref="T:Libplanet.Action.InsufficientBalanceException">Thrown when the <paramref name="sender"/>
            has insufficient balance than <paramref name="value"/> to transfer and
            the <paramref name="allowNegativeBalance"/> option is turned off.</exception>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Burns the fungible asset <paramref name="value"/> (i.e., in-game monetary) from
            <paramref name="owner"/>'s balance.
            </summary>
            <param name="owner">The address who owns the fungible asset to burn.</param>
            <param name="value">The fungible asset <paramref name="value"/> to burn.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that the given <paramref
            name="value"/> is subtracted from <paramref name="owner"/>'s balance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="value"/>
            is less than or equal to zero.</exception>
            <exception cref="T:Libplanet.Action.CurrencyPermissionException">Thrown when a transaction signer
            (or a miner in case of block actions) is not a member of the <see
            cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>'s <see cref="F:Libplanet.Assets.Currency.Minters"/>.</exception>
            <exception cref="T:Libplanet.Action.InsufficientBalanceException">Thrown when the <paramref name="owner"/>
            has insufficient balance than <paramref name="value"/> to burn.</exception>
        </member>
        <member name="T:Libplanet.Action.IAction">
            <summary>
            An in-game action.  Every action should be replayable, because
            multiple nodes in a network should execute an action and get the same
            result.
            <para>A &#x201c;class&#x201d; which implements this interface is
            analogous to a function, and its instance is analogous to a
            <a href="https://en.wikipedia.org/wiki/Partial_application">partial
            function application</a>, in other words, a function with some bound
            arguments.  Those parameters that will be bound at runtime should be
            represented as fields or properties in an action class, and bound
            argument values to these parameters should be received through
            a constructor parameters of that class.</para>
            <para>From a perspective of security, an action class belongs to
            the network protocol, and property values in an action belong to
            a node's will (i.e., a user/player's choice).
            That means if you define an action class it also defines what every
            honest node can do in the network.  Even if a malicious node changes
            their own action code it won't affect other honest nodes in
            the network.</para>
            <para>For example, where honest nodes share the common action
            <c>Heal(Target) => PreviousStates[Target] + 1</c>, suppose a malicious
            node <c>m</c> changes their own <c>Heal</c> action code to
            <c>Heal(Target) => PreviousStates[Target] + 2</c> (2 instead of 1),
            and then send an action <c>Heal(m)</c>.
            Fortunately, this action does not work as <c>m</c>'s intention,
            because the changed code in itself is not used by other honest nodes,
            so they still increase only 1, not 2.  The effect of that double healing
            is a sort of &#x201c;illusion&#x201d; only visible to the malicious node
            alone.</para>
            <para>In conclusion, action code is a part of the protocol and it works with
            consensus in the network, so only things each node can affect the network
            in general is property values of each action they sign and send,
            not code of an action.</para>
            </summary>
            <example>
            The following example shows how to implement an action of three types
            of in-game logic:
            <code><![CDATA[
            using System;
            using System.Collections.Generic;
            using System.Collections.Immutable;
            using Bencodex.Types;
            using Libplanet;
            using Libplanet.Action;
            public class MyAction : IAction
            {
                // Declare an enum type to distinguish types of in-game logic.
                public enum ActType { CreateCharacter, Attack, Heal }
                // Declare properties (or fields) to store "bound" argument values.
                public ActType Type { get; private set; }
                public Address TargetAddress { get; private set; }
                // Action must has a public parameterless constructor.
                // Usually this is used only by Libplanet's internals.
                public MyAction() {}
                // Take argument values to "bind" through constructor parameters.
                public MyAction(ActType type, Address targetAddress)
                {
                    Type = type;
                    TargetAddress = targetAddress;
                }
                // The main game logic belongs to here.  It takes the
                // previous states through its parameter named context,
                // and is offered "bound" argument values through
                // its own properties (or fields).
                IAccountStateDelta IAction.Execute(IActionContext context)
                {
                    // Gets the state immediately before this action is executed.
                    // ImmutableDictionary<string, uint> is just for example,
                    // As far as it is serializable, you can store any types.
                    // (We recommend to use immutable types though.)
                    var state =
                        context.PreviousStates.GetState(TargetAddress);
                    Dictionary dictionary;
                    // This variable purposes to store the state
                    // right after this action finishes.
                    IImmutableDictionary<IKey, IValue> nextState;
                    // Does different things depending on the action's type.
                    // This way is against the common principals of programming
                    // as it is just an example.  You could compare this with
                    // a better example of PolymorphicAction<T> class.
                    switch (Type)
                    {
                        case ActType.CreateCharacter:
                            if (!TargetAddress.Equals(context.Signer))
                                throw new Exception(
                                    "TargetAddress of CreateCharacter action " +
                                    "only can be the same address to the " +
                                    "Transaction<T>.Signer.");
                            else if (!(state is null))
                                throw new Exception(
                                    "Character was already created.");
                            nextState = ImmutableDictionary<IKey, IValue>.Empty
                                .Add((Text)"hp", (Integer)20);
                            break;
                        case ActType.Attack:
                            dictionary = (Bencodex.Types.Dictionary)state;
                            nextState =
                                dictionary.SetItem(
                                    (Text)"hp",
                                    (Integer)Math.Max(
                                        dictionary.GetValue<Integer>("hp") - 5,
                                        0)
                                );
                            break;
                        case ActType.Heal:
                            dictionary = (Bencodex.Types.Dictionary)state;
                            nextState =
                                dictionary.SetItem(
                                    (Text)"hp",
                                    (Integer)Math.Min(
                                        dictionary.GetValue<Integer>("hp") + 5,
                                        20)
                                );
                            break;
                        default:
                            throw new Exception(
                                "Properties are not properly initialized.");
                    }
                    // Builds a delta (dirty) from previous to next states, and
                    // returns it.
                    return context.PreviousStates.SetState(TargetAddress,
                        (Dictionary)nextState);
                }
                // Serializes its "bound arguments" so that they are transmitted
                // over network or stored to the persistent storage.
                IValue IAction.PlainValue =>
                    new Bencodex.Types.Dictionary(new Dictionary<IKey, IValue>
                    {
                        [(Text)"type"] = (Integer)(int)Type,
                        [(Text)"target_address"] = (Binary)TargetAddress.ToByteArray(),
                    });
                // Deserializes "bound arguments".  That is, it is inverse
                // of PlainValue property.
                void IAction.LoadPlainValue(
                    IValue plainValue)
                {
                    var dictionary = (Bencodex.Types.Dictionary)plainValue;
                    Type = (ActType)(int)dictionary.GetValue<Integer>("type");
                    TargetAddress =
                        new Address(dictionary.GetValue<Binary>("target_address").Value);
                }
            }
            ]]></code>
            <para>Note that the above example has several bad practices.
            Compare this example with <see cref="T:Libplanet.Action.PolymorphicAction`1"/>'s
            example.</para>
            </example>
        </member>
        <member name="P:Libplanet.Action.IAction.PlainValue">
            <summary>
            Serializes values bound to an action, which is held by properties
            (or fields) of an action, so that they can be transmitted over
            network or saved to persistent storage.
            <para>Serialized values are deserialized by
            <see cref="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)"/> method later.</para>
            </summary>
            <returns>A Bencodex value which encodes this action's bound values (held
            by properties or fields).
            </returns>
            <seealso cref="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)"/>
        </member>
        <member name="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)">
            <summary>
            Deserializes serialized data (i.e., data <see cref="P:Libplanet.Action.IAction.PlainValue"/>
            property made), and then fills this action's properties (or fields)
            with the deserialized values.
            </summary>
            <param name="plainValue">Data (made by <see cref="P:Libplanet.Action.IAction.PlainValue"/>
            property) to be deserialized and assigned to this action's
            properties (or fields).</param>
            <seealso cref="P:Libplanet.Action.IAction.PlainValue"/>
        </member>
        <member name="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)">
            <summary>
            Executes the main game logic of an action.  This should be
            <em>deterministic</em>.
            <para>Through the <paramref name="context"/> object,
            it receives information such as a transaction signer,
            its states immediately before the execution,
            and a deterministic random seed.</para>
            <para>Other &#x201c;bound&#x201d; information resides in the action
            object in itself, as its properties (or fields).</para>
            <para>A returned <see cref="T:Libplanet.Action.IAccountStateDelta"/> object functions as
            a delta which shifts from previous states to next states.</para>
            </summary>
            <param name="context">A context object containing addresses that
            signed the transaction, states immediately before the execution,
            and a PRNG object which produces deterministic random numbers.
            See <see cref="T:Libplanet.Action.IActionContext"/> for details.</param>
            <returns>A map of changed states (so-called "dirty").</returns>
            <remarks>This method should be deterministic:
            for structurally (member-wise) equal actions and <see
            cref="T:Libplanet.Action.IActionContext"/>s, the same result should be returned.
            Side effects should be avoided, because an action's
            <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method can be called more
            than once, the time it's called is difficult to predict.
            <para>For changing in-memory game states or drawing graphics,
            implement the <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> interface separately and
            attach it to a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance.</para>
            <para>For randomness, <em>never</em> use <see cref="T:System.Random"/>
            nor any other PRNGs provided by other than Libplanet.
            Use <see cref="P:Libplanet.Action.IActionContext.Random"/> instead.
            <see cref="P:Libplanet.Action.IActionContext.Random"/> guarantees the same action
            has the consistent result for every node in the network.</para>
            <para>Also do not perform I/O operations such as file system access
            or networking.  These bring an action indeterministic.  You maybe
            fine to log messages for debugging purpose, but equivalent messages
            could be logged multiple times.</para>
            <para>Although it might be surprising, <a
            href="https://wp.me/p1fTCO-kT">floating-point arithmetics are
            underspecified so that it can make different results on different
            machines, platforms, runtimes, compilers, and builds</a>.</para>
            <para>Lastly, you need to be aware and keep in mind that there
            is a global state named <see
            cref="P:System.Globalization.CultureInfo.CurrentCulture"/> on .NET;
            if you format numbers, dates and times, currencies, or other such
            things into strings and parse these strings back these can rely on
            <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>,
            so that the same action make different results on two differently
            configured systems like Thai language and French language.
            In order to make these types of conversions deterministic,
            you have to explicitly pass <see
            cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.</para>
            <para>For more on determinism in general, please read also <a
            href="https://tendermint.com/docs/spec/abci/abci.html#determinism"
            >Tendermint ABCI's docs on determinism</a>.</para>
            <para>Lastly, you can conduct static analysis on your code
            using <a href="https://git.io/JTmby">Libplanet.Analyzers</a>.
            The analyzer can be enabled by adding its NuGet package into
            your project as a dependency.</para>
            </remarks>
            <seealso cref="T:Libplanet.Action.IActionContext"/>
        </member>
        <member name="T:Libplanet.Action.IActionContext">
            <summary>
            Contextual data determined by a transaction and a block.
            Passed to <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Signer">
            <summary>
            <see cref="T:Libplanet.Address"/> of an account who made and signed
            a transaction that an executed <see cref="T:Libplanet.Action.IAction"/> belongs to.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Miner">
            <summary>
            <see cref="T:Libplanet.Address"/> of a block miner account.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.BlockIndex">
            <summary>
            Block index of a transaction that an executed <see cref="T:Libplanet.Action.IAction"/>
            belongs to.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Rehearsal">
            <summary>
            Whether an <see cref="T:Libplanet.Action.IAction"/> is being executed during
            &#x201c;rehearsal mode&#x201d;, that there is nothing
            in <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/>.
            </summary>
            <seealso cref="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})"/>
        </member>
        <member name="P:Libplanet.Action.IActionContext.PreviousStates">
            <summary>
            A null delta of states, which means it represents the states
            before <see cref="T:Libplanet.Action.IAction"/> executes.
            <para>Although a <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance is
            immutable, it has several manipulative methods that returns
            new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instances with some "dirty"
            states.  These kinds of dirty <see cref="T:Libplanet.Action.IAccountStateDelta"/>
            instances can be returned by <see
            cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.</para>
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Random">
            <summary>
            An initialized pseudorandom number generator.  Its seed (state)
            is determined by a block and a transaction, which is
            deterministic so that every node can replay the same action and
            then reproduce the same result, while neither a single block miner
            nor a single transaction signer can predict the result and cheat.
            </summary>
            <returns>A random object that shares interface mostly equivalent
            to <see cref="T:System.Random"/>.</returns>
        </member>
        <member name="P:Libplanet.Action.IActionContext.PreviousStateRootHash">
            <summary>
            A state root hash at the <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/>.  It can cause file I/O interrupt.
            It will be return null if the implementation or your chain didn't support
            the state root hash feature.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.BlockAction">
            <summary>
            Whether this action is executed as a block action.
            <c>false</c> if it belongs to a transaction.
            </summary>
        </member>
        <member name="M:Libplanet.Action.IActionContext.GetUnconsumedContext">
            <summary>
            Returns a clone of this context, except that its <see cref="P:Libplanet.Action.IActionContext.Random"/> has the unconsumed
            state (with the same seed).  The clone and its original are a distinct instance
            each other, in other words, one's state transfer must not affect the other one
            (i.e., consuming <see cref="P:Libplanet.Action.IActionContext.Random"/> source should be local to a context instance).
            </summary>
            <returns>A clone instance, which is distinct from its original.  Its internal state
            is entirely equivalent to the original's unconsumed initial state.</returns>
        </member>
        <member name="T:Libplanet.Action.InsufficientBalanceException">
            <summary>
            The exception that is thrown when a sender has less <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/> than amount to
            transfer or an owner has less <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/> than amount to burn.
            </summary>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)"/>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
        </member>
        <member name="M:Libplanet.Action.InsufficientBalanceException.#ctor(Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.InsufficientBalanceException"/> object.
            </summary>
            <param name="address">The owner of the insufficient <paramref name="balance"/>.
            Corresponds to the <see cref="P:Libplanet.Action.InsufficientBalanceException.Address"/> property.</param>
            <param name="balance">The account's current balance.
            Corresponds to the <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/> property.</param>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
        </member>
        <member name="P:Libplanet.Action.InsufficientBalanceException.Address">
            <summary>
            The owner of the insufficient <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.InsufficientBalanceException.Balance">
            <summary>
            The account's current balance.
            </summary>
        </member>
        <member name="T:Libplanet.Action.IRandom">
            <summary>
            An pseudorandom number generator interface equivalent to
            <see cref="T:System.Random"/>.
            <para>Although these two types have similar shapes, they are not
            compatible (i.e., disallowed to be casted to each other).</para>
            </summary>
        </member>
        <member name="M:Libplanet.Action.IRandom.Next">
            <summary>
            Gets a non-negative random integer.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to
            0 and less than <see cref="F:System.Int32.MaxValue"/>.</returns>
            <seealso cref="M:System.Random.Next"/>
        </member>
        <member name="M:Libplanet.Action.IRandom.Next(System.Int32)">
            <summary>
            Gets a non-negative random integer that is less than the specified
            <paramref name="upperBound"/>.
            </summary>
            <param name="upperBound">The exclusive upper bound of the random
            number to be generated.  It must be greater than or equal to 0.
            </param>
            <returns>A 32-bit signed integer that is greater than or equal to
            0 and less than <paramref name="upperBound"/>; that is, the range of
            return values ordinarily includes 0 but not <paramref
            name="upperBound"/>.  However, if <paramref name="upperBound"/> equals
            to 0, <paramref name="upperBound"/> is returned.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when
            <paramref name="upperBound"/> is less than 0.</exception>
            <seealso cref="M:System.Random.Next(System.Int32)"/>
        </member>
        <member name="M:Libplanet.Action.IRandom.Next(System.Int32,System.Int32)">
            <summary>
            Gets a random integer that is within a specified range.
            </summary>
            <param name="lowerBound">The inclusive lower bound of the random
            number to be generated.</param>
            <param name="upperBound">The exclusive upper bound of the random
            number to be generated.  It must be greater than or equal to
            <paramref name="lowerBound"/>.
            </param>
            <returns>A 32-bit signed integer that is greater than or equal to
            <paramref name="lowerBound"/> and less than <paramref
            name="upperBound"/>; that is, the range of return values ordinarily
            includes <paramref name="lowerBound"/> but not <paramref
            name="upperBound"/>.  If <paramref name="upperBound"/> equals to
            <paramref name="lowerBound"/>, <paramref name="lowerBound"/> is
            returned.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when
            <paramref name="upperBound"/> is less than <paramref
            name="lowerBound"/>.</exception>
            <seealso cref="M:System.Random.Next(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Libplanet.Action.IRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified <see cref="T:System.Byte"/>s <paramref
            name="buffer"/> with random numbers.
            </summary>
            <param name="buffer">A <see cref="T:System.Byte"/> array to contain random
            numbers.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref
            name="buffer"/> is <c>null</c>.</exception>
            <seealso cref="M:System.Random.NextBytes(System.Byte[])"/>
        </member>
        <member name="T:Libplanet.Action.MissingActionTypeException">
            <summary>
            The exception that is thrown when an action class without
            <see cref="T:Libplanet.Action.ActionTypeAttribute"/> is tried to used with
            <see cref="T:Libplanet.Action.PolymorphicAction`1"/>.
            </summary>
            <seealso cref="T:Libplanet.Action.PolymorphicAction`1"/>
        </member>
        <member name="M:Libplanet.Action.MissingActionTypeException.#ctor(System.Type,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.MissingActionTypeException"/> object.
            </summary>
            <param name="actionType">The action type that lacks
            <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="P:Libplanet.Action.MissingActionTypeException.ActionType">
            <summary>
            The action type that lacks <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Action.PolymorphicAction`1">
            <summary>
            A decorator to enable subtype polymorphism for action classes.
            <para>By convention, concrete action subclasses are named with verb
            phrases, e.g., <c>Heal</c>, <c>Sell</c>.</para>
            <para>One downside of this compared to the vanilla <see cref="T:Libplanet.Action.IAction"/>
            is the fact that it uses reflection under the hood.  This may cause
            compatibility issues on certain platforms, and is slightly slower.
            </para>
            </summary>
            <typeparam name="T">An action base class which implements
            <see cref="T:Libplanet.Action.IAction"/> and has subclasses.  Usually an abstract
            class.</typeparam>
            <example>
            The following example shows how polymorphic actions look like
            (compare this with an <see cref="T:Libplanet.Action.IAction"/> example without
            subtype polymorphism):
            <code><![CDATA[
            using System;
            using System.Collections.Generic;
            using Bencodex.Types;
            using Libplanet;
            using Libplanet.Action;
            // Instead of having multiple in-game actions in a class,
            // in this example, we declare one abstract base class
            // and its three concrete subclasses.
            public abstract class ActionBase : IAction
            {
                public ActionBase() { }
                public ActionBase(Address targetAddress)
                {
                    TargetAddress = targetAddress;
                }
                public Address TargetAddress { get; private set; }
                // Leaves Execute() abstract so that concrete subclasses
                // implement their own logic.
                public abstract IAccountStateDelta Execute(IActionContext context);
                IValue IAction.PlainValue =>
                    new Bencodex.Types.Dictionary(new Dictionary<IKey, IValue>
                    {
                        [(Text)"target_address"] = (Binary)TargetAddress.ToByteArray(),
                    });
                void IAction.LoadPlainValue(
                    IValue plainValue)
                {
                    var dictionary = (Bencodex.Types.Dictionary)plainValue;
                    TargetAddress =
                        new Address(dictionary.GetValue<Binary>("target_address"));
                }
            }
            // PolymorphicAction<T> requires concrete action classes marked with
            // ActionTypeAttribute.
            // There is only one required parameter to ActionTypeAttribute,
            // which takes a unique identifier of the action type.
            // This is used for serialization and deserialization under the hood.
            [ActionType("create_character")]
            public sealed class CreateCharacter : ActionBase
            {
                public override IAccountStateDelta Execute(IActionContext context)
                {
                    var state =
                        context.PreviousStates.GetState(TargetAddress);
                    if (!TargetAddress.Equals(context.Signer))
                        throw new Exception(
                            "TargetAddress of CreateCharacter action only can be " +
                            "the same address to the Transaction<T>.Signer."
                        );
                    else if (!(state is null))
                        throw new Exception("Character was already created.");
                    return context.PreviousStates.SetState(
                        TargetAddress,
                        new Bencodex.Types.Dictionary(new Dictionary<IKey, IValue>
                        {
                            [(Text)"hp"] = (Integer)20,
                        })
                    );
                }
            }
            [ActionType("attack")]
            public sealed class Attack : ActionBase
            {
                public override IAccountStateDelta Execute(IActionContext context)
                {
                    var state =
                        (Bencodex.Types.Dictionary)context.PreviousStates.GetState(TargetAddress);
                    return context.PreviousStates.SetState(
                        TargetAddress,
                        (Bencodex.Types.Dictionary)state
                            .SetItem(
                                (Text)"hp",
                                (Integer)Math.Max(state.GetValue<Integer>("hp") - 5, 0))
                    );
                }
            }
            [ActionType("heal")]
            public sealed class Heal : ActionBase
            {
                public override IAccountStateDelta Execute(IActionContext context)
                {
                    var state =
                        (Bencodex.Types.Dictionary)context.PreviousStates.GetState(TargetAddress);
                    return context.PreviousStates.SetState(
                        TargetAddress,
                        (Bencodex.Types.Dictionary)state
                            .SetItem(
                                (Text)"hp",
                                (Integer)Math.Min(state.GetValue<Integer>("hp") + 5, 20))
                    );
                }
            }
            ]]></code>
            Note that when it's rendered through <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            an instance of <see cref="T:Libplanet.Action.PolymorphicAction`1"/> is passed instead of its
            <see cref="P:Libplanet.Action.PolymorphicAction`1.InnerAction"/>:
            <code>
            public class Renderer : IActionRenderer&lt;PolymorphicAction&lt;ActionBase&gt;&gt;
            {
                public void RenderAction(IAction action,
                                         IActionContext context,
                                         IAccountStateDelta nextStates)
                {
                    if (action is PolymorphicAction&lt;ActionBase&gt; polymorphicAction)
                    {
                        switch (polymorphicAction.InnerAction)
                        {
                            // render things here
                        }
                    }
                }
                // ... other method implementations
            }
            </code>
            </example>
            <remarks>Every concrete action subclass of <typeparamref name="T"/>
            has to be marked with the <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.
            Even if a superclass is marked with
            the <see cref="T:Libplanet.Action.ActionTypeAttribute"/> its subclass also should be
            marked with the <see cref="T:Libplanet.Action.ActionTypeAttribute"/> if it is concrete.
            </remarks>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.#ctor">
            <summary>
            Do not use this constructor.
            Use <see cref="M:Libplanet.Action.PolymorphicAction`1.#ctor(`0)"/> instead.
            </summary>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.#ctor(`0)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.PolymorphicAction`1"/> instance wrapping
            an <paramref name="innerAction"/>.
            </summary>
            <param name="innerAction">An instance of <typeparamref name="T"/>
            (or one of its subtypes) to wrap.</param>
            <exception cref="T:Libplanet.Action.MissingActionTypeException">Thrown
            when the class of the given <paramref name="innerAction"/>
            is not annotated with <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.</exception>
        </member>
        <member name="P:Libplanet.Action.PolymorphicAction`1.InnerAction">
            <summary>
            The wrapped action object of <typeparamref name="T"/>
            (or one of its subtypes).
            </summary>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.op_Implicit(`0)~Libplanet.Action.PolymorphicAction{`0}">
            <summary>
            For convenience, an inner action <typeparamref name="T"/> can be
            implicitly casted to <see cref="T:Libplanet.Action.PolymorphicAction`1"/>.
            </summary>
            <param name="innerAction">An instance of <typeparamref name="T"/>
            (or one of its subtypes) to wrap.</param>
            <returns>A <see cref="T:Libplanet.Action.PolymorphicAction`1"/> wrapping the given
            <paramref name="innerAction"/>.</returns>
            <exception cref="T:Libplanet.Action.MissingActionTypeException">Thrown
            when the class of the given <paramref name="innerAction"/>
            is not annotated with <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.</exception>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.LoadPlainValue(Bencodex.Types.IValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.Execute(Libplanet.Action.IActionContext)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Action.RandomExtensions">
            <summary>
            This extension class provides some convenient methods
            to deal with <see cref="T:Libplanet.Action.IRandom"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Action.RandomExtensions.GenerateRandomGuid(Libplanet.Action.IRandom)">
            <summary>
            Generates a UUID version 4, i.e., a random <see cref="T:System.Guid"/>.
            Please refer to <a href="https://tools.ietf.org/html/rfc4122#section-4.4">RFC 4122</a>.
            </summary>
            <param name="random"> <see cref="T:Libplanet.Action.IRandom"/> to generate
            a random <see cref="T:System.Guid"/>.</param>
            <returns> Generated random <see cref="T:System.Guid"/>.
            </returns>
            <seealso cref="T:Libplanet.Action.IRandom"/>
        </member>
        <member name="T:Libplanet.Action.UnexpectedlyTerminatedActionException">
            <summary>
            The exception that is thrown during an <see cref="T:Libplanet.Action.IAction"/> is being evaluated.
            <para>The actual exception that the <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> threw
            is stored in the <see cref="P:System.Exception.InnerException"/> property.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Action.UnexpectedlyTerminatedActionException.#ctor(System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Nullable{System.Int64},System.Nullable{Libplanet.Tx.TxId},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Action.IAction,System.String,System.Exception)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.UnexpectedlyTerminatedActionException"/> object.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that <paramref name="action"/> belongs to.  This can be <c>null</c> on rehearsal mode.
            </param>
            <param name="blockIndex">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that <paramref name="action"/> belongs to.  This can be <c>null</c> on rehearsal mode.
            </param>
            <param name="txid">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of
            the <see cref="T:Libplanet.Tx.Transaction`1"/> that <paramref name="action"/> belongs to.
            This can be <c>null</c> on rehearsal mode or if <paramref name="action"/> is
            a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.
            </param>
            <param name="action">The <see cref="T:Libplanet.Action.IAction"/> object which threw an exception.</param>
            <param name="previousStateRootHash">The <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of states until
            previous action execution.  This can be null on rehearsal mode or if the chain which
            executed the action, was not using <see cref="T:Libplanet.Store.TrieStateStore"/>.</param>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
            <param name="innerException">The actual exception that the <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> threw.
            </param>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.BlockHash">
            <summary>
            The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> that <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/>
            belongs to.  This can be <c>null</c> on rehearsal mode.
            </summary>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.BlockIndex">
            <summary>
            The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> that <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/>
            belongs to.  This can be <c>null</c> on rehearsal mode.
            </summary>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.TxId">
            <summary>
            The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/> that
            <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> belongs to.  This can be <c>null</c> on rehearsal mode or
            if <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> is a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action">
            <summary>
            The <see cref="T:Libplanet.Action.IAction"/> object which threw an exception.
            </summary>
        </member>
        <member name="T:Libplanet.Address">
            <summary>
            An identifier of 20 bytes (or 40 letters in hexadecimal, commonly with
            a prefix <c>0x</c>) that refers to a unique account.
            <para>It is derived from the corresponding <see cref="T:Libplanet.Crypto.PublicKey"/>
            of an account, but as a derivation loses information, it is always
            unidirectional.</para>
            <para>The address derivation from a public key is as follows:</para>
            <list type="number">
            <item><description>Calculates the Keccak-256, which is a previous form
            of SHA-3 before NIST standardized it and does not follow
            <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf"
            >FIPS-202</a>, of the corresponding <see cref="T:Libplanet.Crypto.PublicKey"/>.
            </description></item>
            <item><description>Takes only the last 20 bytes of the calculated
            Keccak-256 hash.</description></item>
            <item><description>When the address needs to be shown to end users,
            displays these 20 bytes in hexadecimal, with a prefix <c>0x</c>.
            </description></item>
            </list>
            <para>Since the scheme of the address derivation and the <see
            cref="T:Libplanet.Crypto.PrivateKey"/>/<see cref="T:Libplanet.Crypto.PublicKey"/> is the same to
            <a href="https://www.ethereum.org/">Ethereum</a>, Ethereum addresses
            can be used by Libplanet-backed games/apps too.</para>
            </summary>
            <remarks>Every <see cref="T:Libplanet.Address"/> value is immutable.</remarks>
            <seealso cref="T:Libplanet.Crypto.PublicKey"/>
        </member>
        <member name="F:Libplanet.Address.Size">
            <summary>
            The <see cref="T:System.Byte"/>s size that each <see cref="T:Libplanet.Address"/> takes.
            <para>It is 20 <see cref="T:System.Byte"/>s.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Address.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Creates an <see cref="T:Libplanet.Address"/> instance from the given immutable <see
            cref="T:System.Byte"/> array (i.e., <paramref name="address"/>).
            </summary>
            <param name="address">An immutable array of 20 <see cref="T:System.Byte"/>s which
            represents an <see cref="T:Libplanet.Address"/>.</param>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref
            name="address"/> array did not lengthen 20 bytes.</exception>
            <remarks>A valid <see cref="T:System.Byte"/> array which represents an
            <see cref="T:Libplanet.Address"/> can be gotten using <see cref="M:Libplanet.Address.ToByteArray"
            /> method.</remarks>
            <seealso cref="P:Libplanet.Address.ByteArray"/>
        </member>
        <member name="M:Libplanet.Address.#ctor(System.Byte[])">
            <summary>
            Creates an <see cref="T:Libplanet.Address"/> instance from the given <see
            cref="T:System.Byte"/> array (i.e., <paramref name="address"/>).
            </summary>
            <param name="address">An array of 20 <see cref="T:System.Byte"/>s which
            represents an <see cref="T:Libplanet.Address"/>.  This must not be <c>null</c>.
            </param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>null</c> was
            passed to <paramref name="address"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref
            name="address"/> array did not lengthen 20 bytes.</exception>
            <remarks>A valid <see cref="T:System.Byte"/> array which represents an
            <see cref="T:Libplanet.Address"/> can be gotten using <see cref="M:Libplanet.Address.ToByteArray"
            /> method.</remarks>
            <seealso cref="M:Libplanet.Address.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Address.#ctor(Libplanet.Crypto.PublicKey)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a <see
            cref="T:Libplanet.Crypto.PublicKey"/>.
            <para>Note that there is an equivalent extension method
            <see cref="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PublicKey)"/>, which enables
            a code like <c>publicKey.ToAddress()</c> instead of
            <c>new Address(publicKey)</c>, for convenience.</para>
            </summary>
            <param name="publicKey">A <see cref="T:Libplanet.Crypto.PublicKey"/> to derive
            the corresponding <see cref="T:Libplanet.Address"/> from.</param>
            <seealso cref="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PublicKey)"/>
        </member>
        <member name="M:Libplanet.Address.#ctor(System.String)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a hexadecimal
            address string.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>null</c> was
            passed to <paramref name="hex"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref
            name="hex"/> did not lengthen 40 characters.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref
            name="hex"/> is mixed-case and the checksum is invalid.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref
            name="hex"/> does not consist of ASCII characters.</exception>
            <param name="hex">A 40 characters hexadecimal address string to
            derive the corresponding <see cref="T:Libplanet.Address"/> from. The string
            should be all lower-case or mixed-case which follows <a
            href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md"
            >EIP 55</a>.</param>
        </member>
        <member name="P:Libplanet.Address.ByteArray">
            <summary>
            An immutable array of 20 <see cref="T:System.Byte"/>s that represent this
            <see cref="T:Libplanet.Address"/>.
            </summary>
            <remarks>This is immutable.  For a mutable array, call <see
            cref="M:Libplanet.Address.ToByteArray"/> method.</remarks>
            <seealso cref="M:Libplanet.Address.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Address.ToByteArray">
            <summary>
            Gets a mutable array of 20 <see cref="T:System.Byte"/>s that represent
            this <see cref="T:Libplanet.Address"/>.
            </summary>
            <returns>A new mutable array which represents this
            <see cref="T:Libplanet.Address"/>.  Since it is created every time the method
            is called, any mutation on that does not affect internal states of
            this <see cref="T:Libplanet.Address"/>.</returns>
            <seealso cref="P:Libplanet.Address.ByteArray"/>
            <seealso cref="M:Libplanet.Address.#ctor(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Address.ToHex">
            <summary>
            Gets a mixed-case hexadecimal string of 40 letters that represent
            this <see cref="T:Libplanet.Address"/>. The returned hexadecimal string follows
            <a
            href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md"
            >EIP 55</a>.
            </summary>
            <example>A returned string looks like
            <c>87Ae4774E20963fd6caC967CF47aDCF880C3e89B</c>.</example>
            <returns>A hexadecimal string of 40 letters that represent
            this <see cref="T:Libplanet.Address"/>.  Note that it does not start with
            a prefix.</returns>
            <remarks>As the returned string has no prefix, for
            <c>0x</c>-prefixed hexadecimal, call <see cref="M:Libplanet.Address.ToString"/>
            method instead.</remarks>
            <seealso cref="M:Libplanet.Address.ToString"/>
        </member>
        <member name="M:Libplanet.Address.ToString">
            <summary>
            Gets a <c>0x</c>-prefixed mixed-case hexadecimal string of
            42 letters that represent this <see cref="T:Libplanet.Address"/>. The returned
            hexadecimal string follows
            <a
            href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md"
            >EIP 55</a>.
            </summary>
            <example>A returned string looks like
            <c>0x87Ae4774E20963fd6caC967CF47aDCF880C3e89B</c>.</example>
            <returns>A <c>0x</c>-hexadecimal string of 42 letters that represent
            this <see cref="T:Libplanet.Address"/>.</returns>
            <remarks>As the returned string is <c>0x</c>-prefixed, for
            hexadecimal without prefix, call <see cref="M:Libplanet.Address.ToHex"/> method
            instead.</remarks>
            <seealso cref="M:Libplanet.Address.ToHex"/>
        </member>
        <member name="M:Libplanet.Address.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.AddressExtensions">
            <summary>
            This extension class enables some convenient methods (sugar for
            the most part) to deal with <see cref="T:Libplanet.Address"/>.
            </summary>
            <seealso cref="T:Libplanet.Address"/>
        </member>
        <member name="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PublicKey)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a <see
            cref="T:Libplanet.Crypto.PublicKey"/>.
            <para>This enables a code like <c>publicKey.ToAddress()</c> instead
            of <c>new Address(publicKey)</c>.</para>
            </summary>
            <param name="publicKey">A <see cref="T:Libplanet.Crypto.PublicKey"/> to derive
            the corresponding <see cref="T:Libplanet.Address"/> from.</param>
            <returns>The corresponding <see cref="T:Libplanet.Address"/> derived from
            <paramref name="publicKey"/>.</returns>
            <seealso cref="M:Libplanet.Address.#ctor(Libplanet.Crypto.PublicKey)"/>
        </member>
        <member name="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PrivateKey)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a <see
            cref="T:Libplanet.Crypto.PrivateKey"/>.
            <para>This enables a code like <c>privateKey.ToAddress()</c> instead
            of <c>new Address(privateKey.PublicKey)</c>.</para>
            </summary>
            <param name="privateKey">A <see cref="T:Libplanet.Crypto.PrivateKey"/> to derive
            the corresponding <see cref="T:Libplanet.Address"/> from.</param>
            <returns>The corresponding <see cref="T:Libplanet.Address"/> derived from
            <paramref name="privateKey"/>.</returns>
        </member>
        <member name="T:Libplanet.Assets.Currency">
            <summary>
            Represents a currency type.  Every single value of <see cref="T:Libplanet.Assets.Currency"/> defines
            a distinct currency type.  To draw a parallel with real world monetary,
            each <see cref="T:Libplanet.Assets.Currency"/> value represents such currencies as USD (US Dollar) or
            EUR (Euro), <em>not values</em> like $100 or €100.
            </summary>
            <example>
            Here is how US Dollar can be represented using <see cref="T:Libplanet.Assets.Currency"/>:
            <code>
            var USMint = new PrivateKey();
            var USD = new Currency(ticker: "USD", decimalPlace: 2, minter: USMint.ToAddress());
            var twentyThreeBucks = 23 * USD;
            // Or alternatively: USD * 23;
            // Or explicitly: new FungibleAssetValue(USD, 23, 0)
            </code>
            </example>
            <seealso cref="T:Libplanet.Assets.FungibleAssetValue"/>
        </member>
        <member name="F:Libplanet.Assets.Currency.Ticker">
            <summary>
            The ticker symbol, e.g., <c>&quot;USD&quot;</c>.
            </summary>
        </member>
        <member name="F:Libplanet.Assets.Currency.DecimalPlaces">
            <summary>
            The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.
            </summary>
        </member>
        <member name="F:Libplanet.Assets.Currency.Minters">
            <summary>
            The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            If this is <c>null</c> <em>anyone</em> can mint the currency.
            </summary>
            <remarks>
            Unlike <c>null</c>, an empty set means <em>no one</em> can mint the currency.
            </remarks>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
        </member>
        <member name="F:Libplanet.Assets.Currency.Hash">
            <summary>
            The deterministic hash derived from other fields.
            </summary>
        </member>
        <member name="M:Libplanet.Assets.Currency.#ctor(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})">
            <summary>
            Defines a <see cref="T:Libplanet.Assets.Currency"/> type.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="minters">The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.#ctor(System.String,System.Byte,System.Nullable{Libplanet.Address})">
            <summary>
            Defines a <see cref="T:Libplanet.Assets.Currency"/> type.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="minter">The address who can mint the currency.  To specify multiple
            minters, use the <see cref="M:Libplanet.Assets.Currency.#ctor(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/> constructor
            instead.  See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <seealso cref="M:Libplanet.Assets.Currency.#ctor(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.op_Multiply(Libplanet.Assets.Currency,System.Numerics.BigInteger)">
            <summary>
            Gets a fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.
            </summary>
            <param name="currency">The currency to get a value.</param>
            <param name="quantity">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.</param>
            <returns>A fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.</returns>
            <remarks>This cannot specify <see cref="P:Libplanet.Assets.FungibleAssetValue.MinorUnit"/> but only
            <see cref="P:Libplanet.Assets.FungibleAssetValue.MajorUnit"/>.  For more precision, directly use <see
            cref="T:Libplanet.Assets.FungibleAssetValue"/>'s constructors instead.</remarks>
        </member>
        <member name="M:Libplanet.Assets.Currency.op_Multiply(System.Numerics.BigInteger,Libplanet.Assets.Currency)">
            <summary>
            Gets a fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.
            </summary>
            <param name="quantity">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.</param>
            <param name="currency">The currency to get a value.</param>
            <returns>A fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.</returns>
            <remarks>This cannot specify <see cref="P:Libplanet.Assets.FungibleAssetValue.MinorUnit"/> but only
            <see cref="P:Libplanet.Assets.FungibleAssetValue.MajorUnit"/>.  For more precision, directly use <see
            cref="T:Libplanet.Assets.FungibleAssetValue"/>'s constructors instead.</remarks>
        </member>
        <member name="M:Libplanet.Assets.Currency.AllowsToMint(Libplanet.Address)">
            <summary>
            Returns <c>true</c> if and only if the given <paramref name="address"/> is allowed
            to mint or burn assets of this currency.
            </summary>
            <param name="address">The account address to test.</param>
            <returns><c>true</c> if and only if the given <paramref name="address"/> is allowed to
            mint or burn assets of this currency.</returns>
        </member>
        <member name="M:Libplanet.Assets.Currency.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.Equals(Libplanet.Assets.Currency)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="T:Libplanet.Assets.FungibleAssetValue">
            <summary>
            Holds a fungible asset value which holds its <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/> together.
            </summary>
            <remarks>
            It behaves like numbers except for division operator (<c>/</c>) to prevent to forget
            to handle its remainder; use <see cref="M:Libplanet.Assets.FungibleAssetValue.DivRem(Libplanet.Assets.FungibleAssetValue)"/> and <see
            cref="M:Libplanet.Assets.FungibleAssetValue.DivRem(System.Numerics.BigInteger)"/> methods instead.
            </remarks>
        </member>
        <member name="F:Libplanet.Assets.FungibleAssetValue.Currency">
            <summary>
            The currency of the fungible asset.
            </summary>
        </member>
        <member name="F:Libplanet.Assets.FungibleAssetValue.RawValue">
            <summary>
            The internal representation of the fungible asset.
            </summary>
            <remarks>
            Since this is an internal representation, this does not guarantee forward compatibility.
            Therefore, do not depend on this value for permanent uses but only for volatile data.
            </remarks>
            <seealso cref="M:Libplanet.Assets.FungibleAssetValue.FromRawValue(Libplanet.Assets.Currency,System.Numerics.BigInteger)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency)">
            <summary>
            Creates a zero value of the <paramref name="currency"/>.
            </summary>
            <param name="currency">The currency to create a zero value.</param>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency,System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Creates a value of the <paramref name="currency"/> from the given
            <paramref name="majorUnit"/> and <paramref name="minorUnit"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="majorUnit">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.</param>
            <param name="minorUnit">The minor unit of the fungible asset value,
            i.e., digits <em>after</em> the decimal separator.</param>
            <exception cref="T:System.ArgumentException">Thrown when the negativity sign is ambiguous
            (e.g., both units have signs) or too big for the <paramref name="currency"/>.
            </exception>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency,System.Int32,System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Creates a value of the <paramref name="currency"/> from the given <paramref
            name="sign"/>, <paramref name="majorUnit"/> and <paramref name="minorUnit"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="sign">Indicates the sign (negative, positive, or zero) of the value.
            <c>-1</c> indicates negative, <c>1</c> indicates positive, and <c>0</c> indicates
            zero.</param>
            <param name="majorUnit">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.  Must not be negative.</param>
            <param name="minorUnit">The minor unit of the fungible asset value,
            i.e., digits <em>after</em> the decimal separator.  Must not be negative.</param>
            <exception cref="T:System.ArgumentException">Thrown when the the <paramref name="sign"/> is not
            one of <c>1</c>, <c>0</c>, and <c>-1</c>, or <paramref name="majorUnit"/> or
            <paramref name="minorUnit"/> is negative.
            </exception>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency,System.Numerics.BigInteger)">
            <summary>
            Creates a value of the <paramref name="currency"/> with the specified <paramref
            name="rawValue"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="rawValue">The raw quantity of the value to create.</param>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes a fungible asset value.
            </summary>
            <param name="info">A serialization information.</param>
            <param name="context">A streaming context.</param>
        </member>
        <member name="P:Libplanet.Assets.FungibleAssetValue.Sign">
            <summary>
            Gets a number that indicates the sign (negative, positive, or zero) of the value.
            </summary>
            <value>
            A number that indicates the sign of the fungible asset value, as shown in the following
            table:
            <list type="table">
            <listheader><term>Number</term><description>Description</description></listheader>
            <item><term>-1</term><description>The value is negative.</description></item>
            <item><term>0</term><description>The value is zero.</description></item>
            <item><term>1</term><description>The value is positive.</description></item>
            </list>
            </value>
        </member>
        <member name="P:Libplanet.Assets.FungibleAssetValue.MajorUnit">
            <summary>
            The major unit of the fungible asset value, i.e., digits <em>before</em> the decimal
            separator, in absolute value.
            </summary>
            <remarks>It is absolute value, which lacks <see cref="P:Libplanet.Assets.FungibleAssetValue.Sign"/>.</remarks>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="P:Libplanet.Assets.FungibleAssetValue.MinorUnit">
            <summary>
            The minor unit of the fungible asset value, i.e., digits <em>after</em> the decimal
            separator, in absolute value.
            </summary>
            <remarks>It is absolute value, which lacks <see cref="P:Libplanet.Assets.FungibleAssetValue.Sign"/>.</remarks>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Equality(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if two values are equal.
            </summary>
            <param name="obj">A value.</param>
            <param name="other">Another value.</param>
            <returns><c>true</c> if two values are equal.  Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Inequality(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if two values are unequal.
            </summary>
            <param name="obj">A value.</param>
            <param name="other">Another value.</param>
            <returns><c>false</c> if two values are equal.  Otherwise <c>true</c>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_LessThan(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is less than the right operand
            (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><c>true</c> if the left operand (<paramref name="obj"/>) is less than the right
            operand (<paramref name="other"/>).  Otherwise (even if two operands are equal)
            <c>false</c>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_LessThanOrEqual(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is less than or equal to the right
            operand (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><c>true</c> if the left operand (<paramref name="obj"/>) is less than or equal
            to the right operand (<paramref name="other"/>).  Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_GreaterThan(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is greater than the right operand
            (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><c>true</c> if the left operand (<paramref name="obj"/>) is greater than
            the right operand (<paramref name="other"/>).  Otherwise (even if two operands are
            equal) <c>false</c>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_GreaterThanOrEqual(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is greater than or equal to the right
            operand (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><c>true</c> if the left operand (<paramref name="obj"/>) is greater than or
            equal to the right operand (<paramref name="other"/>). Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_UnaryNegation(Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Negates a <paramref name="value"/>.
            <para>Adds a negative sign to the <paramref name="value"/> if it's positive.
            Removes a negative sign from the <paramref name="value"/> if it's already negative.
            Does nothing if the <paramref name="value"/> is zero.</para>
            </summary>
            <param name="value">A value to negate.</param>
            <returns>A negated <paramref name="value"/>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Addition(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Adds two values and returns the result.
            </summary>
            <param name="left">The first value to add.</param>
            <param name="right">The second value to add.</param>
            <returns>The sum of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Subtraction(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Subtracts the <paramref name="right"/> value from the <paramref name="left"/> value.
            </summary>
            <param name="left">The value to subtract from (the minuend).</param>
            <param name="right">The value to subtract (the subtrahend).</param>
            <returns>The result of subtracting <paramref name="right"/> from
            <paramref name="left"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Multiply(Libplanet.Assets.FungibleAssetValue,System.Numerics.BigInteger)">
            <summary>
            Multiplies <paramref name="right"/> times the <paramref name="left"/> value.
            </summary>
            <param name="left">The value to multiply.</param>
            <param name="right">The times to multiply.</param>
            <returns>The multiplied value.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Multiply(System.Numerics.BigInteger,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Multiplies <paramref name="left"/> times the <paramref name="right"/> value.
            </summary>
            <param name="left">The times to multiply.</param>
            <param name="right">The value to multiply.</param>
            <returns>The multiplied value.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Modulus(Libplanet.Assets.FungibleAssetValue,System.Numerics.BigInteger)">
            <summary>
            Divides the value (<paramref name="dividend"/>) by <paramref name="divisor"/>,
            and returns the remainder.
            </summary>
            <param name="dividend">The value to be divided.</param>
            <param name="divisor">The number to divide by.</param>
            <returns>The remainder after dividing <paramref name="dividend"/>
            by <paramref name="divisor"/>.</returns>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            <c>0</c> (zero).</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Modulus(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Divides the value (<paramref name="dividend"/>) by <paramref name="divisor"/>,
            and returns the remainder.
            </summary>
            <param name="dividend">The value to be divided.</param>
            <param name="divisor">The value to divide by.</param>
            <returns>The remainder after dividing <paramref name="dividend"/>
            by <paramref name="divisor"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            zero.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Parse(Libplanet.Assets.Currency,System.String)">
            <summary>
            Parses a numeric string and returns a corresponding <see cref="T:Libplanet.Assets.FungibleAssetValue"/>.
            </summary>
            <param name="currency">The currency of the value to parse.</param>
            <param name="value">A numeric string to parse.  Can consist of digits, plus (+),
            minus (-), and decimal separator (.).</param>
            <returns>The parsed asset value.</returns>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="value"/> is not
            a valid numeric string.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.FromRawValue(Libplanet.Assets.Currency,System.Numerics.BigInteger)">
            <summary>
            Restores a value from a <paramref name="rawValue"/> of a <paramref name="currency"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="rawValue">The <see cref="F:Libplanet.Assets.FungibleAssetValue.RawValue"/> to restore.</param>
            <returns>The value restored from the given <paramref name="rawValue"/>.</returns>
            <seealso cref="F:Libplanet.Assets.FungibleAssetValue.RawValue"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(System.Numerics.BigInteger,Libplanet.Assets.FungibleAssetValue@)">
            <summary>
            Divides the value by <paramref name="divisor"/>, returns the quotient, and returns
            the <paramref name="remainder"/> in an output parameter.
            </summary>
            <param name="divisor">The number to divide by.</param>
            <param name="remainder">When this method returns (without any exception), the remainder
            after dividing the value by <paramref name="divisor"/>.  This parameter is passed
            uninitialized.</param>
            <returns>The quotient of the division.</returns>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            <c>0</c> (zero).</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue@)">
            <summary>
            Divides the value by <paramref name="divisor"/>, returns the quotient, and returns
            the <paramref name="remainder"/> in an output parameter.
            </summary>
            <param name="divisor">The value to divide by.</param>
            <param name="remainder">When this method returns (without any exception), the remainder
            after dividing the value by <paramref name="divisor"/>.  This parameter is passed
            uninitialized.</param>
            <returns>The quotient of the division.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            zero.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(System.Numerics.BigInteger)">
            <summary>
            Divides the value by <paramref name="divisor"/>, and returns a pair of the quotient
            and the remainder.
            </summary>
            <param name="divisor">The number to divide by.</param>
            <returns>A tuple of the <c>Quotient</c> and <c>Remainder</c> of the division.</returns>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            <c>0</c> (zero).</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Divides the value by <paramref name="divisor"/>, and returns a pair of the quotient
            and the remainder.
            </summary>
            <param name="divisor">The value to divide by.</param>
            <returns>A tuple of the <c>Quotient</c> and <c>Remainder</c> of the division.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            zero.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Abs">
            <summary>
            Gets the absolute value.
            <para>Removes the negative sign if it's negative.  Otherwise does nothing.</para>
            </summary>
            <returns>Its absolute value.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.GetQuantityString(System.Boolean)">
            <summary>
            Gets the value quantity without its <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/> in <see cref="T:System.String"/>.
            </summary>
            <param name="minorUnit">Whether to show all possible decimal places even
            if they are zeros.</param>
            <returns>A quantity string in decimal system.  Consists of an optional sign (minus),
            digits and an optional decimal separator (period).</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Equals(Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.CompareTo(System.Object)">
            <inheritdoc cref="M:System.IComparable.CompareTo(System.Object)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.CompareTo(Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.BlockChain`1">
            <summary>
            A class have <see cref="T:Libplanet.Blocks.Block`1"/>s, <see cref="T:Libplanet.Tx.Transaction`1"/>s, and the chain
            information.
            <para>In order to watch its state changes, implement <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>
            interface and pass it to the <see cref="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}})"/> constructor.</para>
            </summary>
            <remarks>This object is guaranteed that it has at least one block, since it takes a genesis
            block when it's instantiated.</remarks>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.BlockChain`1._blocks">
            <summary>
            All <see cref="T:Libplanet.Blocks.Block`1"/>s in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>
            storage, including orphan <see cref="T:Libplanet.Blocks.Block`1"/>s.
            Keys are <see cref="P:Libplanet.Blocks.Block`1.Hash"/>es and values are
            their corresponding <see cref="T:Libplanet.Blocks.Block`1"/>s.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.BlockChain`1._genesis">
            <summary>
            Cached genesis block.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> class.
            </summary>
            <param name="policy"><see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/> to use in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</param>
            <param name="stagePolicy">The staging policy to follow.</param>
            <param name="store"><see cref="T:Libplanet.Store.IStore"/> to store <see cref="T:Libplanet.Blocks.Block`1"/>s,
            <see cref="T:Libplanet.Tx.Transaction`1"/>s, and <see cref="T:Libplanet.Blockchain.BlockChain`1"/> information.</param>
            <param name="genesisBlock">The genesis <see cref="T:Libplanet.Blocks.Block`1"/> of
            the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>, which is a part of the consensus.
            If the given <paramref name="store"/> already contains the genesis block
            it checks if the existing genesis block and this argument is the same.
            If the <paramref name="store"/> has no genesis block yet this argument will
            be used for that.</param>
            <param name="renderers">Listens state changes on the created chain.  Listens nothing
            by default or if it is <c>null</c>.</param>
            <param name="stateStore"><see cref="T:Libplanet.Store.IStateStore"/> to store states.</param>
            <exception cref="T:Libplanet.Blocks.InvalidGenesisBlockException">Thrown when the <paramref name="store"/>
            has a genesis block and it does not match to what the network expects
            (i.e., <paramref name="genesisBlock"/>).</exception>
        </member>
        <member name="E:Libplanet.Blockchain.BlockChain`1.TipChanged">
            <summary>
            An event which is invoked when <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> is changed.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Renderers">
            <summary>
            The list of registered renderers listening the state changes.
            </summary>
            <remarks>
            Since this value is immutable, renderers cannot be registered after once a <see
            cref="T:Libplanet.Blockchain.BlockChain`1"/> object is instantiated; use <c>renderers</c> option of <see cref=
            "M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}})"/>
            constructor instead.
            </remarks>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.ActionRenderers">
            <summary>
            A filtered list, from <see cref="P:Libplanet.Blockchain.BlockChain`1.Renderers"/>, which contains only <see
            cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instances.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Policy">
            <summary>
            The block and blockchain policy.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.StagePolicy">
            <summary>
            The staging policy.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Tip">
            <summary>
            The topmost <see cref="T:Libplanet.Blocks.Block`1"/> of the current blockchain.
            Can be <c>null</c> if the blockchain is empty.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Genesis">
            <summary>
            The first <see cref="T:Libplanet.Blocks.Block`1"/> in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.BlockHashes">
            <summary>
            All <see cref="P:Libplanet.Blocks.Block`1.Hash"/>es in the current index.  The genesis block's hash goes
            first, and the tip goes last.
            Returns a <see cref="T:System.Int64"/> integer that represents the number of elements in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Count">
            <summary>
            Returns a <see cref="T:System.Int64"/> integer that represents the number of elements in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <returns>A number that represents how many elements in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </returns>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Item(System.Int32)">
            <summary>
            Gets the block corresponding to the <paramref name="index"/>.
            </summary>
            <param name="index">A number of index of <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given index of
            <see cref="T:Libplanet.Blocks.Block`1"/> does not exist.</exception>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Item(System.Int64)">
            <summary>
            Gets the block corresponding to the <paramref name="index"/>.
            </summary>
            <param name="index">A number of index of <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given index of
            <see cref="T:Libplanet.Blocks.Block`1"/> does not exist.</exception>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Item(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Gets the block corresponding to the <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">A <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> to
            get. </param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when there is no <see cref="T:Libplanet.Blocks.Block`1"/>
            with a given <paramref name="blockHash"/>.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MakeGenesisBlock(System.Collections.Generic.IEnumerable{`0},Libplanet.Crypto.PrivateKey,System.Nullable{System.DateTimeOffset},Libplanet.Action.IAction)">
            <summary>
            Mine the genesis block of the blockchain.
            </summary>
            <param name="actions">List of actions will be included in the genesis block.
            If it's null, it will be replaced with <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>
            as default.</param>
            <param name="privateKey">A private key to sign the transaction in the genesis block.
            If it's null, it will use new private key as default.</param>
            <param name="timestamp">The timestamp of the genesis block. If it's null, it will
            use <see cref="P:System.DateTimeOffset.UtcNow"/> as default.</param>
            <param name="blockAction">A block action to execute and be rendered for every block.
            It must match to <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockAction"/> of <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.
            </param>
            <returns>The genesis block mined with parameters.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ContainsBlock(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Determines whether the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> contains <see cref="T:Libplanet.Blocks.Block`1"/>
            the specified <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">The <see cref="T:Libplanet.HashDigest`1"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> to
            check if it is in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</param>
            <returns>
            <c>true</c> if the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> contains <see cref="T:Libplanet.Blocks.Block`1"/> with
            the specified <paramref name="blockHash"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetTransaction(Libplanet.Tx.TxId)">
            <summary>
            Gets the transaction corresponding to the <paramref name="txId"/>.
            </summary>
            <param name="txId">A <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/> to get.
            </param>
            <returns><see cref="T:Libplanet.Tx.Transaction`1"/> with <paramref name="txId"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when there is no
            <see cref="T:Libplanet.Tx.Transaction`1"/> with a given <paramref name="txId"/>.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetState(Libplanet.Address,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Blockchain.StateCompleter{`0})">
            <summary>
            Gets the state of the given <paramref name="address"/> in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> from <paramref name="offset"/>.
            </summary>
            <param name="address">An <see cref="T:Libplanet.Address"/> to get the states of.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to start finding
            the state.  It will be The tip of the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> if it is <c>null</c>.
            </param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states dirty of the block which lastly updated states of a requested address,
            this delegate is called and its return value is used instead.
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Recalculate"/> makes the incomplete states
            recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Reject"/> (which is default) makes the incomplete
            states (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> instead.</para>
            </param>
            <returns>The current state of given <paramref name="address"/>.  This can be <c>null</c>
            if <paramref name="address"/> has no value.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Blockchain.FungibleAssetStateCompleter{`0})">
            <summary>
            Queries <paramref name="address"/>'s balance of the <paramref name="currency"/> in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> from <paramref name="offset"/>.
            </summary>
            <param name="address">The owner <see cref="T:Libplanet.Address"/> to query.</param>
            <param name="currency">The currency type to query.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to
            start finding the state. It will be the tip of the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> if it is <c>null</c>.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states dirty of the block which lastly updated states of a requested address,
            this delegate is called and its return value is used instead.
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Recalculate"/> makes the incomplete
            states recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Reject"/> (which is default) makes
            the incomplete states (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>
            instead.</para></param>
            <returns>The <paramref name="address"/>'s current balance (or balance as of the given
            <paramref name="offset"/>) of the <paramref name="currency"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.Append(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})">
            <summary>
            Adds a <paramref name="block"/> to the end of this chain.
            <para>Note that <see cref="P:Libplanet.Blockchain.BlockChain`1.Renderers"/> receive events right after the <paramref
            name="block"/> is confirmed (and thus all states reflect changes in the <paramref
            name="block"/>).</para>
            </summary>
            <param name="block">A next <see cref="T:Libplanet.Blocks.Block`1"/>, which is mined,
            to add.</param>
            <param name="stateCompleters">The strategy to complement incomplete block states which
            are required for action execution and rendering.
            <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.
            </param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockBytesLengthException">Thrown when the given <paramref
            name="block"/> is too long in bytes (according to <see
            cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxBlockBytes(System.Int64)"/>).</exception>
            <exception cref="T:Libplanet.Blocks.BlockExceedingTransactionsException">Thrown when the given <paramref
            name="block"/> has too many transactions (according to <see
            cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>).</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockException">Thrown when the given <paramref name="block"/>
            is invalid, in itself or according to the <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxNonceException">Thrown when the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> is different from
            <see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/> result of the
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.Append(Libplanet.Blocks.Block{`0},System.DateTimeOffset,System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})">
            <summary>
            Adds a <paramref name="block"/> to the end of this chain.
            <para>Note that <see cref="P:Libplanet.Blockchain.BlockChain`1.Renderers"/> receive events right after the <paramref
            name="block"/> is confirmed (and thus all states reflect changes in the <paramref
            name="block"/>).</para>
            </summary>
            <param name="block">A next <see cref="T:Libplanet.Blocks.Block`1"/>, which is mined,
            to add.</param>
            <param name="currentTime">The current time.</param>
            <param name="stateCompleters">The strategy to complement incomplete block states which
            are required for action execution and rendering.
            <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.
            </param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockBytesLengthException">Thrown when the given <paramref
            name="block"/> is too long in bytes (according to <see
            cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxBlockBytes(System.Int64)"/>).</exception>
            <exception cref="T:Libplanet.Blocks.BlockExceedingTransactionsException">Thrown when the given <paramref
            name="block"/> has too many transactions (according to <see
            cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>).</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockException">Thrown when the given <paramref name="block"/>
            is invalid, in itself or according to the <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxNonceException">Thrown when the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> is different from
            <see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/> result of the
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.StageTransaction(Libplanet.Tx.Transaction{`0})">
            <summary>
            Adds a <paramref name="transaction"/> to the pending list so that
            a next <see cref="T:Libplanet.Blocks.Block`1"/> to be mined contains the given
            <paramref name="transaction"/>.
            </summary>
            <param name="transaction"><see cref="T:Libplanet.Tx.Transaction`1"/> to add to the pending list.
            </param>
            <exception cref="T:Libplanet.Tx.InvalidTxException">Thrown when the given
            <paramref name="transaction"/> is invalid.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.UnstageTransaction(Libplanet.Tx.Transaction{`0})">
            <summary>
            Removes a <paramref name="transaction"/> from the pending list.
            </summary>
            <param name="transaction">A <see cref="T:Libplanet.Tx.Transaction`1"/>
            to remove from the pending list.</param>
            <seealso cref="M:Libplanet.Blockchain.BlockChain`1.StageTransaction(Libplanet.Tx.Transaction{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)">
            <summary>
            Gets next <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> of the address.
            </summary>
            <param name="address">The <see cref="T:Libplanet.Address"/> from which to obtain the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> value.</param>
            <returns>The next <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> value of the
            <paramref name="address"/>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.PerceiveBlock(Libplanet.Blocks.IBlockExcerpt,System.Nullable{System.DateTimeOffset})">
            <summary>
            Records and queries the <paramref name="perceivedTime"/> of the given
            <paramref name="blockExcerpt"/>.
            <para>Although blocks have their own <see cref="P:Libplanet.Blocks.Block`1.Timestamp"/>, but these values
            are untrustworthy as they are arbitrarily determined by their miners.</para>
            <para>On the other hand, this method returns the subjective time according to the local
            node's perception.</para>
            <para>If the local node has never perceived the <paramref name="blockExcerpt"/> yet,
            it is perceived at that moment and the current time is returned instead. (However, you
            can replace the current time with the <paramref name="perceivedTime"/> option.)
            In other words, this method is idempotent.</para>
            </summary>
            <param name="blockExcerpt">The perceived block.</param>
            <param name="perceivedTime">The time the local node perceived the given <paramref
            name="blockExcerpt"/>.  The current time by default.</param>
            <returns>A pair of a block and the time it was perceived.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MineBlock(Libplanet.Address,System.DateTimeOffset,System.Boolean,System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Mines a next <see cref="T:Libplanet.Blocks.Block`1"/> using staged <see cref="T:Libplanet.Tx.Transaction`1"/>s,
            and then <see cref="M:Libplanet.Blockchain.BlockChain`1.Append(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})"/> it to the chain
            (unless the <paramref name="append"/> option is turned off).
            </summary>
            <param name="miner">The <see cref="T:Libplanet.Address"/> of miner that mined the block.</param>
            <param name="currentTime">The <see cref="T:System.DateTimeOffset"/> when mining started.</param>
            <param name="append">Whether to <see cref="M:Libplanet.Blockchain.BlockChain`1.Append(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})"/>
            the mined block.  Turned on by default.</param>
            <param name="maxTransactions">The maximum number of transactions that a block can
            accept.  This value must be greater than 0, and less than or equal to
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>.
            Zero and negative values are treated as 1. If it is omitted or more than
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>, it will be
            treated as <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>.
            </param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns>An awaitable task with a <see cref="T:Libplanet.Blocks.Block`1"/> that is mined.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> is changed while mining.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MineBlock(Libplanet.Address,System.Boolean,System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Mines a next <see cref="T:Libplanet.Blocks.Block`1"/> using staged <see cref="T:Libplanet.Tx.Transaction`1"/>s,
            and then <see cref="M:Libplanet.Blockchain.BlockChain`1.Append(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})"/> it to the chain
            (unless the <paramref name="append"/> option is turned off).
            </summary>
            <param name="miner">The <see cref="T:Libplanet.Address"/> of miner that mined the block.</param>
            <param name="append">Whether to <see cref="M:Libplanet.Blockchain.BlockChain`1.Append(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})"/>
            the mined block.  Turned on by default.</param>
            <param name="maxTransactions">The maximum number of transactions that a block can
            accept.  This value must be greater than 0, and less than or equal to
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>.
            Zero and negative values are treated as 1. If it is omitted or more than
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>, it will be
            treated as <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>.
            </param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns>An awaitable task with a <see cref="T:Libplanet.Blocks.Block`1"/> that is mined.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> is changed while mining.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MakeTransaction(Libplanet.Crypto.PrivateKey,System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.Transaction`1"/> and stage the transaction.
            Cannot create new transaction if the genesis block does not exist.
            </summary>
            <param name="privateKey">A <see cref="T:Libplanet.Crypto.PrivateKey"/> of the account who creates and
            signs a new transaction.</param>
            <param name="actions">A list of <see cref="T:Libplanet.Action.IAction"/>s to include to a new transaction.
            </param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose states affected by
            <paramref name="actions"/>.</param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/> is created and
            signed.</param>
            <returns>A created new <see cref="T:Libplanet.Tx.Transaction`1"/> signed by the given
            <paramref name="privateKey"/>.</returns>
            <seealso cref="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})" />
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetStagedTransactionIds">
            <summary>
            Lists all staged <see cref="T:Libplanet.Tx.TxId"/>s.
            </summary>
            <returns><see cref="T:System.Collections.Immutable.IImmutableSet`1"/> of staged transactions.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.RenderActionsInBlocks(System.Int64,Libplanet.Blockchain.Renderers.IActionRenderer{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})">
            <summary>
            Render actions from block index of <paramref name="offset"/>.
            </summary>
            <param name="offset">Index of the block to start rendering from.</param>
            <param name="renderer">The renderer to render actions.</param>
            <param name="stateCompleters">The strategy to complement incomplete block states.
            <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.</param>
            <returns>The number of actions rendered.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.RenderActions(System.Collections.Generic.IReadOnlyList{Libplanet.Action.ActionEvaluation},Libplanet.Blocks.Block{`0},Libplanet.Blockchain.Renderers.IActionRenderer{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})">
            <summary>
            Render actions of the given <paramref name="block"/>.
            </summary>
            <param name="evaluations"><see cref="T:Libplanet.Action.ActionEvaluation"/>s of the block.  If it is
            <c>null</c>, evaluate actions of the <paramref name="block"/> again.</param>
            <param name="block"><see cref="T:Libplanet.Blocks.Block`1"/> to render actions.</param>
            <param name="renderer">The renderer to render actions.</param>
            <param name="stateCompleters">The strategy to complement incomplete block states.
            <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.</param>
            <returns>The number of actions rendered.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ExecuteActions(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})">
            <summary>
            Evaluates actions in the given <paramref name="block"/> and fills states with the
            results.
            </summary>
            <param name="block">A block to execute.</param>
            <param name="stateCompleters">The strategy to complement incomplete previous block
            states.  <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.
            </param>
            <returns>The result of action evaluations of the given <paramref name="block"/>.
            </returns>
            <remarks>This method is idempotent (except for rendering).  If the given
            <paramref name="block"/> has executed before, it does not execute it nor mutate states.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.FindBranchPoint(Libplanet.Blockchain.BlockLocator)">
            <summary>
            Find an approximate to the topmost common ancestor between this
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> and a given <see cref="T:Libplanet.Blockchain.BlockLocator"/>.
            </summary>
            <param name="locator">A block locator that contains candidate common ancestors.</param>
            <returns>An approximate to the topmost common ancestor.  If it failed to find anything
            returns <c>null</c>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ComplementBlockStates(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Calculates and complements a block's incomplete states on the fly.
            </summary>
            <param name="blockHash">The hash of a block which has incomplete states.</param>
        </member>
        <member name="T:Libplanet.Blockchain.BlockPerception">
            <summary>
            Pair of a block and the time the local node perceived it.
            <para>Purposes to be compared when the canonical chain is determined.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.BlockPerception.#ctor(Libplanet.Blocks.IBlockExcerpt,System.DateTimeOffset)">
            <summary>
            Creates a pair.
            </summary>
            <param name="blockExcerpt">The block perceived by the local node.</param>
            <param name="perceivedTime">The time the local node perceived the
            <paramref name="blockExcerpt"/>.</param>
        </member>
        <member name="M:Libplanet.Blockchain.BlockPerception.#ctor(Libplanet.Blocks.IBlockExcerpt)">
            <summary>
            Creates a pair with setting <see cref="P:Libplanet.Blockchain.BlockPerception.PerceivedTime"/> to the current time.
            </summary>
            <param name="blockExcerpt">The block perceived by the local node.</param>
        </member>
        <member name="P:Libplanet.Blockchain.BlockPerception.BlockExcerpt">
            <summary>
            The block perceived by the local node.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockPerception.PerceivedTime">
            <summary>
            The time the local node perceived the <see cref="P:Libplanet.Blockchain.BlockPerception.BlockExcerpt"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.FungibleAssetStateCompleter`1">
            <summary>
            A delegate to be called when <see cref="M:Libplanet.Blockchain.BlockChain`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Blockchain.FungibleAssetStateCompleter{`0})"/> method encounters
            a block having incomplete dirty states. <see cref="M:Libplanet.Blockchain.BlockChain`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Blockchain.FungibleAssetStateCompleter{`0})"/> method
            returns this delegate's return value instead for such case.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <param name="blockChain">The blockchain to query.</param>
            <param name="blockHash">The hash of a block to lacks its dirty states.</param>
            <param name="address">The account to query its balance.</param>
            <param name="currency">The currency to query.</param>
            <returns>A complement balance value.  <em>Its <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>
            must match to the given <paramref name="currency"/>.</em></returns>
            <seealso cref="T:Libplanet.Blockchain.FungibleAssetStateCompleters`1"/>
        </member>
        <member name="T:Libplanet.Blockchain.FungibleAssetStateCompleters`1">
            <summary>
            Predefined built-in state completers that satisfy
            <see cref="T:Libplanet.Blockchain.FungibleAssetStateCompleter`1"/> delegate.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Recalculate">
            <summary>
            Recalculates and complements a block's incomplete states on the fly.
            Incomplete states are filled with the recalculated states and the states are
            permanently remained in the store.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Reject">
            <summary>
            Rejects to complement incomplete state and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.IncompleteBlockStatesException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> have
            not calculated the complete states for all blocks, but an operation
            that needs some lacked states is requested.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.IncompleteBlockStatesException.#ctor(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> object.
            </summary>
            <param name="blockHash">Specifies <see cref="P:Libplanet.Blockchain.IncompleteBlockStatesException.BlockHash"/>.
            It is automatically included to the <see cref="P:System.Exception.Message"/>
            string.</param>
            <param name="message">Specifies the <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="P:Libplanet.Blockchain.IncompleteBlockStatesException.BlockHash">
            <summary>
            The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of <see cref="T:Libplanet.Blocks.Block`1"/> that
            a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> lacks the states.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.Policies.BlockPolicy`1">
            <summary>
            A default implementation of <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/> interface.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.#ctor(Libplanet.Action.IAction,System.Int32,System.Int64,System.Int32,System.Int32,System.Int32,System.Int32,System.Func{Libplanet.Tx.Transaction{`0},Libplanet.Blockchain.BlockChain{`0},System.Boolean},System.Collections.Generic.IComparer{Libplanet.Blockchain.BlockPerception})">
            <summary>
            Creates a <see cref="T:Libplanet.Blockchain.Policies.BlockPolicy`1"/> with configuring
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockInterval"/> in milliseconds,
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MinimumDifficulty"/> and
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.DifficultyBoundDivisor"/>.
            </summary>
            <param name="blockAction">A block action to execute and be rendered for every block.
            </param>
            <param name="blockIntervalMilliseconds">Configures
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockInterval"/> in milliseconds.
            5000 milliseconds by default.
            </param>
            <param name="minimumDifficulty">Configures
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MinimumDifficulty"/>. 1024 by default.</param>
            <param name="difficultyBoundDivisor">Configures
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.DifficultyBoundDivisor"/>. 128 by default.</param>
            <param name="maxTransactionsPerBlock">Configures <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MaxTransactionsPerBlock"/>.
            100 by default.</param>
            <param name="maxBlockBytes">Configures <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxBlockBytes(System.Int64)"/> where
            the block is not a genesis.  100 KiB by default.</param>
            <param name="maxGenesisBytes">Configures <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxBlockBytes(System.Int64)"/> where
            the block is a genesis.  1 MiB by default.</param>
            <param name="doesTransactionFollowPolicy">
            A predicate that determines if the transaction follows the block policy.
            </param>
            <param name="canonicalChainComparer">The custom rule to determine which is the canonical
            chain.  If omitted, <see cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/> is used by default.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.#ctor(Libplanet.Action.IAction,System.TimeSpan,System.Int64,System.Int32,System.Int32,System.Int32,System.Int32,System.Func{Libplanet.Tx.Transaction{`0},Libplanet.Blockchain.BlockChain{`0},System.Boolean},System.Collections.Generic.IComparer{Libplanet.Blockchain.BlockPerception})">
            <summary>
            Creates a <see cref="T:Libplanet.Blockchain.Policies.BlockPolicy`1"/> with configuring
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockInterval"/>, <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MinimumDifficulty"/> and
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.DifficultyBoundDivisor"/>.
            </summary>
            <param name="blockAction">A block action to execute and be rendered for every block.
            </param>
            <param name="blockInterval">Configures <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockInterval"/>.
            </param>
            <param name="minimumDifficulty">Configures
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MinimumDifficulty"/>.</param>
            <param name="difficultyBoundDivisor">Configures
            <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.DifficultyBoundDivisor"/>.</param>
            <param name="maxTransactionsPerBlock">Configures <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MaxTransactionsPerBlock"/>.
            </param>
            <param name="maxBlockBytes">Configures <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxBlockBytes(System.Int64)"/> where
            the block is not a genesis.</param>
            <param name="maxGenesisBytes">Configures <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxBlockBytes(System.Int64)"/> where
            the block is a genesis.</param>
            <param name="doesTransactionFollowPolicy">
            A predicate that determines if the transaction follows the block policy.
            </param>
            <param name="canonicalChainComparer">The custom rule to determine which is the canonical
            chain.  If omitted, <see cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/> (having
            <see cref="P:Libplanet.Blockchain.TotalDifficultyComparer.OutdateAfter"/> configured to triple of
            <paramref name="blockInterval"/>) is used by default.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockAction">
            <inheritdoc/>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MaxTransactionsPerBlock">
            <inheritdoc cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockInterval">
            <summary>
            An appropriate interval between consecutive <see cref="T:Libplanet.Blocks.Block`1"/>s.
            It is usually from 20 to 30 seconds.
            <para>If a previous interval took longer than this
            <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetNextBlockDifficulty(Libplanet.Blockchain.BlockChain{`0})"/> method
            raises the <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/>.  If it took shorter
            than this <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/> is dropped.</para>
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.CanonicalChainComparer">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.DoesTransactionFollowsPolicy(Libplanet.Tx.Transaction{`0},Libplanet.Blockchain.BlockChain{`0})">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.DoesTransactionFollowsPolicy(Libplanet.Tx.Transaction{`0},Libplanet.Blockchain.BlockChain{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.ValidateNextBlock(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetNextBlockDifficulty(Libplanet.Blockchain.BlockChain{`0})">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxBlockBytes(System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Blockchain.Policies.IBlockPolicy`1">
            <summary>
            An interface to determine if consecutive <see cref="T:Libplanet.Blocks.Block`1"/>s are
            valid, and to suggest how difficult a <see cref="P:Libplanet.Blocks.Block`1.Nonce"/>
            for a <see cref="T:Libplanet.Blocks.Block`1"/> to be mined.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer">
            <summary>
            A comparer to determine which branch is the canonical chain (i.e., best chain).
            The most greater one according to this comparer is considered to be the canon.
            </summary>
            <seealso cref="T:Libplanet.Blocks.IBlockExcerpt"/>
            <seealso cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction">
            <summary>
            A block action to execute and be rendered for every block.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock">
            <summary>
            The maximum number of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> that a <see cref="T:Libplanet.Blocks.Block`1"/>
            can accept.  This value must not be negative and must be deterministic (i.e., must not
            change after an object is once instantiated).
            </summary>
            <remarks>If the value is less then 1, it's treated as 1.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.DoesTransactionFollowsPolicy(Libplanet.Tx.Transaction{`0},Libplanet.Blockchain.BlockChain{`0})">
            <summary>
            A predicate that determines if the transaction follows the block policy.
            </summary>
            <param name="transaction">A <see cref="T:Libplanet.Tx.Transaction`1"/> to determine.</param>
            <param name="blockChain">A <see cref="T:Libplanet.Blockchain.BlockChain`1" /> for given
            <paramref name="transaction" />.</param>
            <returns><c>true</c> if <paramref name="transaction"/>is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.ValidateNextBlock(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Checks if <paramref name="nextBlock"/> is invalid, and if that
            returns the reason.
            <para>Note that it returns <c>null</c> when
            <paramref name="nextBlock"/> is <em>valid</em>.</para>
            </summary>
            <param name="blocks">Consecutive <see cref="T:Libplanet.Blocks.Block`1"/>s to
            append <paramref name="nextBlock"/>.</param>
            <param name="nextBlock">The next block to append to
            <paramref name="blocks"/>.</param>
            <returns>The reason why the given <paramref name="blocks"/> are
            <em>invalid</em>, or <c>null</c> if <paramref name="blocks"/> are
            <em>valid</em>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetNextBlockDifficulty(Libplanet.Blockchain.BlockChain{`0})">
            <summary>
            Determines a right <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/>
            for a new <see cref="T:Libplanet.Blocks.Block`1"/> to be mined
            right after the given <paramref name="blocks"/>.
            </summary>
            <param name="blocks">Consecutive <see cref="T:Libplanet.Blocks.Block`1"/>s to be
            followed by a new <see cref="T:Libplanet.Blocks.Block`1"/> to be mined.</param>
            <returns>A right <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/>
            for a new <see cref="T:Libplanet.Blocks.Block`1"/> to be mined.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxBlockBytes(System.Int64)">
            <summary>
            Gets the maximum length of a <see cref="T:Libplanet.Blocks.Block`1"/> in bytes.  It can vary depending on
            a given <paramref name="index"/>, but should be deterministic; for the same
            <paramref name="index"/>, the same value must be returned.
            </summary>
            <param name="index">An <see cref="P:Libplanet.Blocks.Block`1.Index"/> of a block to mine or receive.
            </param>
            <returns>The maximum length of a <see cref="T:Libplanet.Blocks.Block`1"/> in bytes to accept.</returns>
            <remarks>If it returns less then 1, it is treated as 1, because there is no block
            taking 0 bytes or negative length of bytes.</remarks>
        </member>
        <member name="T:Libplanet.Blockchain.Policies.IStagePolicy`1">
            <summary>
            The interface to configure a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s strategy to deal with staged
            transactions.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <remarks>Every operation on an object implementing this must be thread-safe.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Stage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})">
            <summary>
            Stages a <paramref name="transaction"/>.
            </summary>
            <param name="blockChain">The chain to stage the <paramref name="transaction"/>.
            </param>
            <param name="transaction">The <seealso cref="T:Libplanet.Tx.Transaction`1"/> to be staged.</param>
            <remarks>It does not throw any exception even if the <paramref name="transaction"/> has
            already been staged.  It does nothing either if the <paramref name="transaction"/> has
            marked as ignored (using <see cref="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Ignore(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)"/> method).</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Unstage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <summary>
            Removes a transaction <paramref name="id"/> from the stage.
            </summary>
            <param name="blockChain">The chain to unstage the <paramref name="id"/>.</param>
            <param name="id">The <seealso cref="P:Libplanet.Tx.Transaction`1.Id"/> to remove.</param>
            <remarks>It does not throw any exception even if the <paramref name="id"/> has never
            been staged.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Ignore(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <summary>
            Marks a transaction as ignored, so that it will be never staged.
            </summary>
            <param name="blockChain">The chain that the stage belongs to.</param>
            <param name="id">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> to ignore.</param>
            <remarks>If the transaction is already in the stage, this method does nothing.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Ignores(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <summary>
            Checks if a transaction should be ignored for any reasons (for example, it is already
            staged or marked as ignored).
            </summary>
            <param name="blockChain">The chain that the stage belongs to.</param>
            <param name="id">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> to check.</param>
            <returns><c>true</c> if a transaction should be ignored.
            Otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Get(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId,System.Boolean)">
            <summary>
            Gets a staged <see cref="T:Libplanet.Tx.Transaction`1"/> by its <paramref name="id"/>.
            </summary>
            <param name="blockChain">The chain that the stage belongs to.</param>
            <param name="id">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> to get.</param>
            <param name="includeUnstaged">Whether to include transactions that had once staged but
            unstaged then.</param>
            <returns>A staged transaction if found.  If it had never staged <c>null</c> is
            returned.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Iterate(Libplanet.Blockchain.BlockChain{`0})">
            <summary>
            Enumerates all staged transaction IDs.
            </summary>
            <param name="blockChain">The chain of the stage to enumerate.</param>
            <returns>Staged transactions.  The earliest staged transaction goes first,
            and the latest staged transaction goes last.</returns>
        </member>
        <member name="T:Libplanet.Blockchain.Policies.VolatileStagePolicy`1">
            <summary>
            In-memory staged transactions.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.#ctor">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Policies.VolatileStagePolicy`1"/> instance.
            <para><see cref="P:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Lifetime"/> is configured to 3 hours.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.#ctor(System.TimeSpan)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Policies.VolatileStagePolicy`1"/> instance.
            </summary>
            <param name="lifetime">Volatilizes staged transactions older than this <paramref
            name="lifetime"/>.  See also the <see cref="P:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Lifetime"/> property.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Lifetime">
            <summary>
            Volatilizes staged transactions older than this <see cref="P:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Lifetime"/>.
            <para>Note that transactions older than the lifetime never cannot be staged.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Stage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Stage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Unstage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <inheritdoc cref="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Unstage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Ignore(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <inheritdoc cref="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Ignore(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Ignores(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <inheritdoc cref="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Ignores(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Get(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId,System.Boolean)">
            <inheritdoc cref="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Get(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId,System.Boolean)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Iterate(Libplanet.Blockchain.BlockChain{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Iterate(Libplanet.Blockchain.BlockChain{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1">
            <summary>
            An <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> that invokes its callbacks.
            In other words, this is an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> version of
            <see cref="T:Libplanet.Blockchain.Renderers.AnonymousRenderer`1"/>.
            <para>This class is useful when you want an one-use ad-hoc implementation (i.e., Java-style
            anonymous class) of <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> interface.</para>
            </summary>
            <example>
            With object initializers, you can easily make an one-use action renderer:
            <code><![CDATA[
            var actionRenderer = new AnonymousActionRenderer<ExampleAction>
            {
                ActionRenderer = (action, context, nextStates) =>
                {
                    // Implement RenderAction() here.
                };
            };
            ]]></code>
            </example>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionUnrenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionErrorRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionErrorUnrenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.BlockEndRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.AnonymousRenderer`1">
            <summary>
            A renderer that invokes its callbacks.
            <para>This class is useful when you want an one-use ad-hoc implementation (i.e., Java-style
            anonymous class) of <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> interface.</para>
            </summary>
            <example>
            With object initializers, you can easily make an one-use renderer:
            <code>
            var renderer = new AnonymousRenderer&lt;ExampleAction&gt;
            {
                BlockRenderer = (oldTip, newTip) =>
                {
                    // Implement RenderBlock() here.
                };
            };
            </code>
            </example>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.BlockRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.ReorgRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.ReorgEndRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1">
            <summary>
            Exception thrown by <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/>.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1.#ctor(System.Collections.Generic.IReadOnlyList{Libplanet.Blockchain.Renderers.Debug.RenderRecord{`0}},System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/> instance.
            </summary>
            <param name="records">Recorded render events.</param>
            <param name="message">The exception message string.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1.Records">
            <summary>
            Recorded render events.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1.Message">
            <inheritdoc cref="P:System.Exception.Message"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1">
            <summary>
            Records every render events.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.#ctor">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1"/> instance.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.Records">
            <summary>
            The list of recorded render events.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.ResetRecords">
            <summary>
            Empties the render event <see cref="P:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.Records"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1">
            <summary>
            A render event represented by <see cref="T:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1"/>.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Index">
            <summary>
            The ordinal number of the render event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.StackTrace">
            <summary>
            The stack trace of the render event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase">
            <summary>
            Represents an action render/unrender event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Action">
            <summary>
            The rendered action.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Context">
            <summary>
            The action evaluation context.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Render">
            <summary>
            Whether it is not an unrender event, but a render event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Unrender">
            <summary>
            Whether it is a render event, but an unrender event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess">
            <summary>
            Represents a succeeded action render/unrender event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess.#ctor(System.Int64,System.String,Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta,System.Boolean)">
            <summary>
            Creates a succeeded action render/unrender event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="action">The rendered action.</param>
            <param name="context">The action evaluation context.</param>
            <param name="nextStates">The resulting states after the action is evaluated.</param>
            <param name="unrender">Whether it is an unrender event.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess.NextStates">
            <summary>
            The resulting states after the action is evaluated.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError">
            <summary>
            Represents a failed action render/unrender event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError.#ctor(System.Int64,System.String,Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception,System.Boolean)">
            <summary>
            Creates a failed action render/unrender event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="action">The rendered action.</param>
            <param name="context">The action evaluation context.</param>
            <param name="exception">The exception thrown by the action.</param>
            <param name="unrender">Whether it is an unrender event.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError.Exception">
            <summary>
            The exception thrown by the action.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase">
            <summary>
            Represents a block/reorg event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.OldTip">
            <summary>
            The tip before update.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.NewTip">
            <summary>
            The tip after update.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.Begin">
            <summary>
            Whether it is not an <c>End</c> event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.End">
            <summary>
            Whether it is an <c>End</c> event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Block">
            <summary>
            Represents a block event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Block.#ctor(System.Int64,System.String,Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},System.Boolean)">
            <summary>
            Creates a block event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="oldTip">The tip before update.</param>
            <param name="newTip">The tip after update.</param>
            <param name="end">Whether it is an <c>End</c> event.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Block.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg">
            <summary>
            Represents a reorg event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg.#ctor(System.Int64,System.String,Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},System.Boolean)">
            <summary>
            Creates a reorg event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="oldTip">The tip before update.</param>
            <param name="newTip">The tip after update.</param>
            <param name="branchpoint">The topmost common ancestor between
            <paramref name="oldTip"/> and <paramref name="newTip"/>.</param>
            <param name="end">Whether it is an <c>End</c> event.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg.Branchpoint">
            <summary>
            The topmost common ancestor between <see cref="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.OldTip"/>
            and <see cref="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.NewTip"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1">
            <summary>
            Validates if rendering events are in the correct order according to the documented automata
            (see also the docs for <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> and <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/>)
            using profiling-guided analysis.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.#ctor(System.Action{Libplanet.Blockchain.Renderers.Debug.InvalidRenderException{`0}})">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/> instance.
            </summary>
            <param name="onError">An optional event handler which is triggered when invalid
            render events occur.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.BlockChain">
            <summary>
            The chain that publishes the render events.  More stricter validations are conducted
            if it's configured.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1">
            <summary>
            An <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> version of <see cref="T:Libplanet.Blockchain.Renderers.DelayedRenderer`1"/>.
            <para>Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance and delays the events until
            blocks are <em>confirmed</em> the certain number of blocks.  When blocks are recognized
            the delayed events relevant to these blocks are relayed to the decorated
            <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/>.</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IStore store = GetStore();
            IBlockPolicy<ExampleAction> policy = GetPolicy();
            IActionRenderer<ExampleAction> actionRenderer = new SomeActionRenderer();
            // Wraps the actionRenderer with DelayedActionRenderer; the SomeActionRenderer instance
            // becomes to receive event messages only after the relevent blocks are confirmed
            // by 3+ blocks.
            actionRenderer = new DelayedActionRenderer<ExampleAction>(
               actionRenderer,
               policy,
               store,
               confirmations: 3);
            // You must pass the same policy & store to the BlockChain<T>() constructor:
            var chain = new BlockChain<ExampleAction>(
               ...,
               policy: policy,
               store: store,
               renderers: new[] { actionRenderer });
            ]]></code>
            </example>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IActionRenderer{`0},System.Collections.Generic.IComparer{Libplanet.Blockchain.BlockPerception},Libplanet.Store.IStore,System.Int32,System.Int64)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.DelayedRenderer`1"/> instance decorating the given
            <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives delayed events.</param>
            <param name="canonicalChainComparer">The same canonical chain comparer to
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.</param>
            <param name="store">The same store to what <see cref="T:Libplanet.Blockchain.BlockChain`1"/> uses.</param>
            <param name="confirmations">The required number of confirmations to recognize a block.
            See also the <see cref="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Confirmations"/> property.</param>
            <param name="reorgResistantHeight">Configures the height of blocks to maintain the
            <see cref="T:Libplanet.Action.ActionEvaluation"/> buffer. Buffered <see cref="T:Libplanet.Action.ActionEvaluation"/>s
            that belong to blocks older than this height from the tip are gone.
            If zero, which is a default value, is passed the buffer is not cleared.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.ActionRenderer">
            <summary>
            The inner action renderer which has the <em>actual</em> implementations and receives
            delayed events.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.LocateBlockPath(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Lists all descendants from <paramref name="lower"/> (exclusive) to
            <paramref name="upper"/> (inclusive).
            </summary>
            <param name="lower">The block to get its descendants (excluding it).</param>
            <param name="upper">The block to get its ancestors (including it).</param>
            <returns>Block hashes from <paramref name="lower"/> to <paramref name="upper"/>.
            Lower block hashes go first, and upper block hashes go last.
            Does not contain <paramref name="lower"/>'s hash but <paramref name="upper"/>'s one.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="upper"/> block's index
            is not greater than <paramref name="lower"/> block's index.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.OnTipChanged(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.OnTipChanged(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.DelayedRenderer`1">
            <summary>
            Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> instance and delays the events until blocks
            are <em>confirmed</em> the certain number of blocks.  When blocks are recognized
            the delayed events relevant to these blocks are relayed to the decorated
            <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IStore store = GetStore();
            IBlockPolicy<ExampleAction> policy = GetPolicy();
            IRenderer<ExampleAction> renderer = new SomeRenderer();
            // Wraps the renderer with DelayedRenderer; the SomeRenderer instance becomes to receive
            // event messages only after the relevent blocks are confirmed by 3+ blocks.
            renderer = new DelayedRenderer<ExampleAction>(renderer, policy, store, confirmations: 3);
            // You must pass the same policy & store to the BlockChain<T>() constructor:
            var chain = new BlockChain<ExampleAction>(
                ...,
                policy: policy,
                store: store,
                renderers: new[] { renderer });
            ]]></code>
            </example>
            <remarks>Since <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> is a subtype of <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            <see cref="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},System.Collections.Generic.IComparer{Libplanet.Blockchain.BlockPerception},Libplanet.Store.IStore,System.Int32)"/>
            constructor can take an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance as well.
            However, even it takes an action renderer, action-level fine-grained events won't hear.
            For action renderers, please use <see cref="T:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1"/> instead.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},System.Collections.Generic.IComparer{Libplanet.Blockchain.BlockPerception},Libplanet.Store.IStore,System.Int32)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.DelayedRenderer`1"/> instance decorating the given
            <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives delayed events.</param>
            <param name="canonicalChainComparer">The same canonical chain comparer to
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.</param>
            <param name="store">The same store to what <see cref="T:Libplanet.Blockchain.BlockChain`1"/> uses.</param>
            <param name="confirmations">The required number of confirmations to recognize a block.
            It must be greater than zero (note that zero <paramref name="confirmations"/> mean
            nothing is delayed so that it is equivalent to the bare <paramref name="renderer"/>).
            See also the <see cref="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Confirmations"/> property.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the argument
            <paramref name="confirmations"/> is not greater than zero.</exception>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Renderer">
            <summary>
            The inner renderer which has the <em>actual</em> implementations and receives delayed
            events.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.CanonicalChainComparer">
            <summary>
            The same canonical chain comparer to <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.
            </summary>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Store">
            <summary>
            The same store to what <see cref="T:Libplanet.Blockchain.BlockChain`1"/> uses.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Confirmations">
            <summary>
            The required number of confirmations to recognize a block.
            <para>For example, the required confirmations are 2, the block #N is recognized after
            the block #N+1 and the block #N+2 are discovered.</para>
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Tip">
            <summary>
            The <em>recognized</em> topmost block.  If not enough blocks are discovered yet,
            this property can be <c>null</c>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Logger">
            <summary>
            The logger to record internal state changes.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.OnTipChanged(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            The callback method which is invoked when the new <see cref="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Tip"/> is recognized and
            changed.
            </summary>
            <param name="oldTip">The previously recognized topmost block.</param>
            <param name="newTip">The topmost block recognized this time.</param>
            <param name="branchpoint">A branchpoint between <paramref name="oldTip"/> and
            <paramref name="newTip"/> if the tip change is a reorg.  Otherwise <c>null</c>.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.IActionRenderer`1">
            <summary>
            Listens state changes of every step of actions, besides blocks,
            on a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            If you need more fine-grained events than <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            implement this interface instead.
            <para>The invocation order of methods for each <see cref="T:Libplanet.Blocks.Block`1"/> are:</para>
            <list type="number">
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
            (one time)</description></item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
            &amp; <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> (zero or more
            times)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)
            </description></item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
            &amp; <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> (zero or more
            times)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
            (one time)</description></item>
            </list>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <summary>
            Does things that should be done right after an <paramref name="action"/>
            is executed and applied to the blockchain.
            </summary>
            <param name="action">An executed action.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.  For the states after this action executed,
            use the <paramref name="nextStates"/> argument instead.</param>
            <param name="nextStates">The states right <em>after</em> this action executed,
            which means it is equivalent to the states <paramref name="action"/>'s
            <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method returned.</param>
            <remarks>
            It is guaranteed to be called only once for an <paramref name="action"/>,
            and only after applied to the blockchain, unless an exception is thrown during executing
            the <paramref name="action"/> (in that case <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> is called instead) or
            once the <paramref name="action"/> has been unrendered.
            <para>Also note that this method is invoked after <see
            cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> method is called
            (where its second parameter <c>newTip</c> contains a transaction the <paramref
            name="action"/> belongs to).</para>
            <para>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</para>
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <summary>
            Does things that should be undone right after the given <paramref name="action"/> is
            invalidated (mostly due to reorg, i.e., a block which the action has belonged to becomes
            considered stale).
            <para>This method takes the equivalent arguments to <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/> method.</para>
            </summary>
            <param name="action">A stale action.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.  For the states after this action executed,
            use the <paramref name="nextStates"/> argument instead.</param>
            <param name="nextStates">The states right <em>after</em> this action executed,
            which means it is equivalent to the states <paramref name="action"/>'s
            <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method returned.</param>
            <remarks>As a rule of thumb, this should be the inverse of
            <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/> method
            with redrawing the graphics on the display at the finish.</remarks>
            <remarks>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <summary>
            Does the similar things to <see cref=
            "M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>, except that this method
            is invoked when <paramref name="action"/> has terminated with an exception.
            </summary>
            <param name="action">An action which threw an exception during execution.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.</param>
            <param name="exception">The exception thrown during executing the <paramref
            name="action"/>.</param>
            <remarks>
            Also note that this method is invoked after <see
            cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> method is called
            (where its second parameter <c>newTip</c> contains a transaction the <paramref
            name="action"/> belongs to).
            <para>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</para>
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <summary>
            Does the similar things to <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>, except that
            this method is invoked when <paramref name="action"/> has terminated with an exception.
            <para>This method takes the equivalent arguments to <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> method.</para>
            </summary>
            <param name="action">An action which threw an exception during execution.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.</param>
            <param name="exception">The exception thrown during executing the <paramref
            name="action"/>.</param>
            <remarks>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right all actions in a new <see cref="T:Libplanet.Blocks.Block`1"/> are
            rendered.
            </summary>
            <remarks>It is guaranteed to be called only once for a block.</remarks>
            <param name="oldTip">The previous <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
            <param name="newTip">The current <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.IRenderer`1">
            <summary>
            Listens state changes on a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            <para>Usually, implementations of this interface purpose to update the in-memory game states
            (if exist), or send a signal to the UI thread (usually the main thread) so that the graphics
            on the display is redrawn.</para>
            <para>The invocation order of methods for each <see cref="T:Libplanet.Blocks.Block`1"/> are:</para>
            <list type="number">
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)
            </description></item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)
            </description></item>
            </list>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right after a new <see cref="T:Libplanet.Blocks.Block`1"/> is appended to
            a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> (so that its <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> has changed).
            </summary>
            <remarks>It is guaranteed to be called only once for a block, and only after applied to
            the blockchain, unless it has been stale due to reorg (for that case, <see
            cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> is called in advance).</remarks>
            <param name="oldTip">The previous <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
            <param name="newTip">The current <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right before reorg happens to a <see
            cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <remarks>For every call to this method, calls to
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> and
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})" /> methods with the same
            <paramref name="newTip"/> is made too.  Note that this method is guaranteed to be called
            before <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> method for the same
            <paramref name="newTip"/>.</remarks>
            <param name="oldTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> right before reorg.</param>
            <param name="newTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> after reorg.</param>
            <param name="branchpoint">The highest common <see cref="T:Libplanet.Blocks.Block`1"/> between
            <paramref name="oldTip"/> and <paramref name="newTip"/>.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right after reorg happens to a <see
            cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <remarks>Note that this method is guaranteed to be called after
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> and
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> methods for the same
            <paramref name="newTip"/>.</remarks>
            <param name="oldTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> right before reorg.</param>
            <param name="newTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> after reorg.</param>
            <param name="branchpoint">The highest common <see cref="T:Libplanet.Blocks.Block`1"/> between
            <paramref name="oldTip"/> and <paramref name="newTip"/>.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1">
            <summary>
            Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> so that all event messages are logged.
            In other words, this is an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> version of
            <see cref="T:Libplanet.Blockchain.Renderers.LoggedRenderer`1"/>.
            <para>Every single event message causes two log messages: one is logged <em>before</em>
            rendering, and other one is logged <em>after</em> rendering.  If any exception is thrown
            it is also logged with the log level <see cref="F:Serilog.Events.LogEventLevel.Error"/> (regardless of
            <see cref="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Level"/> configuration).</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IActionRenderer<ExampleAction> actionRenderer = new SomeActionRenderer();
            // Wraps the action renderer with LoggedActionRenderer:
            actionRenderer = new LoggedActionRenderer<ExampleAction>(
                actionRenderer,
                Log.Logger,
                LogEventLevel.Information,
            );
            ]]></code>
            </example>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IActionRenderer{`0},Serilog.ILogger,Serilog.Events.LogEventLevel)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1"/> instance which decorates the given
            action <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The actual action renderer to forward all event messages to and
            actually render things.</param>
            <param name="logger">The logger to write log messages to.  Note that all log messages
            this decorator writes become in the context of the <paramref name="renderer"/>'s
            type (with the context property <c>SourceContext</c>).</param>
            <param name="level">The log event level.  All log messages become this level.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.ActionRenderer">
            <summary>
            The inner action renderer to forward all event messages to and actually render things.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.LoggedRenderer`1">
            <summary>
            Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> so that all event messages are logged.
            <para>Every single event message causes two log messages: one is logged <em>before</em>
            rendering, and other one is logged <em>after</em> rendering.  If any exception is thrown
            it is also logged with the log level <see cref="F:Serilog.Events.LogEventLevel.Error"/> (regardless of
            <see cref="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Level"/> configuration).</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code>
            IRenderer&lt;ExampleAction&gt; renderer = new SomeRenderer();
            // Wraps the renderer with LoggedRenderer:
            renderer = new LoggedRenderer&lt;ExampleAction&gt;(
                renderer,
                Log.Logger,
                LogEventLevel.Information,
            );
            </code>
            </example>
            <remarks>Since <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> is a subtype of <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            <see cref="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},Serilog.ILogger,Serilog.Events.LogEventLevel)"/> constructor can take
            an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance as well.  However, even it takes an action
            renderer, action-level fine-grained events will not be logged.  For action renderers,
            please use <see cref="T:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1"/> instead.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},Serilog.ILogger,Serilog.Events.LogEventLevel)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.LoggedRenderer`1"/> instance which decorates the given
            <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The actual renderer to forward all event messages to and actually
            render things.</param>
            <param name="logger">The logger to write log messages to.  Note that all log messages
            this decorator writes become in the context of the <paramref name="renderer"/>'s
            type (with the context property <c>SourceContext</c>).</param>
            <param name="level">The log event level.  All log messages become this level.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Renderer">
            <summary>
            The inner renderer to forward all event messages to and actually render things.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Level">
            <summary>
            The log event level.  All log messages become this level.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Logger">
            <summary>
            The logger to write log messages to.  Note that all log messages this decorator writes
            become in the context of the <see cref="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Renderer"/>'s type (with the context
            property <c>SourceContext</c>).
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.StateCompleter`1">
            <summary>
            A delegate to be called when <see cref="M:Libplanet.Blockchain.BlockChain`1.GetState(Libplanet.Address,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Blockchain.StateCompleter{`0})"/> method encounters a block
            having incomplete dirty states. <see cref="M:Libplanet.Blockchain.BlockChain`1.GetState(Libplanet.Address,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Blockchain.StateCompleter{`0})"/> method returns this
            delegate's return value instead for such case.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <param name="blockChain">The blockchain to query.</param>
            <param name="blockHash">The hash of a block to lacks its dirty states.</param>
            <param name="address">The address to query its state value.</param>
            <returns>A complement state.  This can be <c>null</c>.</returns>
            <seealso cref="T:Libplanet.Blockchain.StateCompleters`1"/>
        </member>
        <member name="T:Libplanet.Blockchain.StateCompleters`1">
            <summary>
            Predefined built-in state completers that satisfy <see cref="T:Libplanet.Blockchain.StateCompleter`1"/> delegate.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleters`1.Recalculate">
            <summary>
            Recalculates and complements a block's incomplete states on the fly.
            Incomplete states are filled with the recalculated states and the states are
            permanently remained in the store.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleters`1.Reject">
            <summary>
            Rejects to complement incomplete state and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.StateCompleterSet`1">
            <summary>
            Groups two kinds of state completers.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate">
            <summary>
            Recalculates and complements a block's incomplete states on the fly.
            Incomplete states are filled with the recalculated states and the states are
            permanently remained in the store.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleterSet`1.Reject">
            <summary>
            Rejects to complement incomplete state and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.StateCompleterSet`1.StateCompleter">
            <summary>
            Holds a <see cref="T:Libplanet.Blockchain.StateCompleter`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.StateCompleterSet`1.FungibleAssetStateCompleter">
            <summary>
            Holds a <see cref="T:Libplanet.Blockchain.FungibleAssetStateCompleter`1"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.TotalDifficultyComparer">
            <summary>
            The default canonical chain comparer (which purpose to be a <see
            cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>).
            <para>The chain which has the most <see cref="P:Libplanet.Blocks.Block`1.TotalDifficulty"/> is considered
            the greatest, i.e., canonical chain.</para>
            </summary>
            <remarks>Although this compares blocks' total difficulty, if two blocks have different
            protocol version, it always consider the higher version greater.</remarks>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>
            <seealso cref="T:Libplanet.Blocks.IBlockExcerpt"/>
        </member>
        <member name="M:Libplanet.Blockchain.TotalDifficultyComparer.#ctor(System.TimeSpan)">
            <summary>
            Creates a <see cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/> instance.
            </summary>
            <param name="outdateAfter">Blocks taken this time since they are perceived are
            considered outdated, so that chains having these blocks as their tips become stale.
            </param>
        </member>
        <member name="M:Libplanet.Blockchain.TotalDifficultyComparer.#ctor(System.TimeSpan,System.Func{System.DateTimeOffset})">
            <summary>
            Creates a <see cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/> instance.
            </summary>
            <param name="outdateAfter">Blocks taken this time since they are perceived are
            considered outdated, so that chains having these blocks as their tips become stale.
            </param>
            <param name="currentTimeGetter">Configures the way to get the current time instead of
            <see cref="P:System.DateTimeOffset.UtcNow"/> property.</param>
        </member>
        <member name="P:Libplanet.Blockchain.TotalDifficultyComparer.OutdateAfter">
            <summary>
            Blocks taken this time since they are perceived are considered outdated, so that
            chains having these blocks as their tips become stale.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.TotalDifficultyComparer.Compare(Libplanet.Blockchain.BlockPerception,Libplanet.Blockchain.BlockPerception)">
            <inheritdoc cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>
        </member>
        <member name="F:Libplanet.Blocks.Block`1.CurrentProtocolVersion">
            <summary>
            The most latest protocol version.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.#ctor(System.Int64,System.Int64,System.Numerics.BigInteger,Libplanet.Nonce,System.Nullable{Libplanet.Address},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.DateTimeOffset,System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Int32)">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.Block`1"/> instance by manually filling all field values.
            For a more automated way, see also <see cref="M:Libplanet.Blocks.Block`1.Mine(System.Int64,System.Int64,System.Numerics.BigInteger,Libplanet.Address,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.DateTimeOffset,System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}},System.Int32,System.Threading.CancellationToken)"/> method.
            </summary>
            <param name="index">The height of the block to create.  Goes to the <see cref="P:Libplanet.Blocks.Block`1.Index"/>.
            </param>
            <param name="difficulty">The mining difficulty that <paramref name="nonce"/> has to
            satisfy.  Goes to the <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/>.</param>
            <param name="totalDifficulty">The total mining difficulty until this block.
            See also <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/>.</param>
            <param name="nonce">The nonce which satisfy the given <paramref name="difficulty"/> with
            any other field values.  Goes to the <see cref="P:Libplanet.Blocks.Block`1.Nonce"/>.</param>
            <param name="miner">An optional address refers to who mines this block.
            Goes to the <see cref="P:Libplanet.Blocks.Block`1.Miner"/>.</param>
            <param name="previousHash">The previous block's <see cref="P:Libplanet.Blocks.Block`1.Hash"/>.  If it's a genesis
            block (i.e., <paramref name="index"/> is 0) this should be <c>null</c>.
            Goes to the <see cref="P:Libplanet.Blocks.Block`1.PreviousHash"/>.</param>
            <param name="timestamp">The time this block is created.  Goes to
            the <see cref="P:Libplanet.Blocks.Block`1.Timestamp"/>.</param>
            <param name="transactions">The transactions to be mined together with this block.
            Transactions become sorted in an unpredicted-before-mined order and then go to
            the <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> property.
            </param>
            <param name="preEvaluationHash">The hash derived from the block <em>except of</em>
            <paramref name="stateRootHash"/> (i.e., without action evaluation).
            Automatically determined if <c>null</c> is passed (which is default).</param>
            <param name="stateRootHash">The <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of the states on the block.
            </param>
            <param name="protocolVersion">The protocol version. <see cref="F:Libplanet.Blocks.Block`1.CurrentProtocolVersion"/>
            by default.</param>
            <seealso cref="M:Libplanet.Blocks.Block`1.Mine(System.Int64,System.Int64,System.Numerics.BigInteger,Libplanet.Address,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.DateTimeOffset,System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}},System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.#ctor(Bencodex.Types.Dictionary)">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.Block`1"/> instance from its serialization.
            </summary>
            <param name="dict">The <see cref="T:Bencodex.Types.Dictionary"/>
            representation of <see cref="T:Libplanet.Blocks.Block`1"/> instance.
            </param>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.ProtocolVersion">
            <summary>
            The protocol version number.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Hash">
            <summary>
            <see cref="P:Libplanet.Blocks.Block`1.Hash"/> is derived from a serialized <see cref="T:Libplanet.Blocks.Block`1"/>
            after <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> are evaluated.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/>
            <seealso cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.PreEvaluationHash">
            <summary>
            The hash derived from the block <em>except of</em>
            <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/> (i.e., without action evaluation).
            Used for <see cref="M:Libplanet.Blocks.BlockHeader.Validate(System.DateTimeOffset)"/> checking <see cref="P:Libplanet.Blocks.Block`1.Nonce"/>.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.Nonce"/>
            <seealso cref="M:Libplanet.Blocks.BlockHeader.Validate(System.DateTimeOffset)"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.StateRootHash">
            <summary>
            The <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of the states on the block.
            </summary>
            <seealso cref="P:Libplanet.Store.Trie.ITrie.Hash"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.BytesLength">
            <summary>
            The bytes length in its serialized format.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Header">
            <summary>
            The <see cref="T:Libplanet.Blocks.BlockHeader"/> of the block.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.Mine(System.Int64,System.Int64,System.Numerics.BigInteger,Libplanet.Address,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.DateTimeOffset,System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Generate a block with given <paramref name="transactions"/>.
            </summary>
            <param name="index">Index of the block.</param>
            <param name="difficulty">Difficulty to find the <see cref="T:Libplanet.Blocks.Block`1"/>
            <see cref="P:Libplanet.Blocks.Block`1.Nonce"/>.</param>
            <param name="previousTotalDifficulty">The total difficulty until the previous
            <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <param name="miner">The <see cref="T:Libplanet.Address"/> of miner that mined the block.</param>
            <param name="previousHash">
            The <see cref="T:Libplanet.HashDigest`1"/> of previous block.
            </param>
            <param name="timestamp">The <see cref="T:System.DateTimeOffset"/> when mining started.</param>
            <param name="transactions"><see cref="T:Libplanet.Tx.Transaction`1"/>s that are going to be included
            in the block.</param>
            <param name="protocolVersion">The protocol version.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>A <see cref="T:Libplanet.Blocks.Block`1"/> that mined.</returns>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.Deserialize(System.Byte[])">
            <summary>
            Decodes a <see cref="T:Libplanet.Blocks.Block`1"/>'s
            <a href="https://bencodex.org/">Bencodex</a> representation.
            </summary>
            <param name="bytes">A <a href="https://bencodex.org/">Bencodex</a>
            representation of a <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <returns>A decoded <see cref="T:Libplanet.Blocks.Block`1"/> object.</returns>
            <seealso cref="M:Libplanet.Blocks.Block`1.Serialize"/>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.EvaluateActionsPerTx(Libplanet.Action.AccountStateGetter,Libplanet.Action.AccountBalanceGetter,Libplanet.Store.Trie.ITrie)">
            <summary>
            Executes every <see cref="T:Libplanet.Action.IAction"/> in the
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> step by step, and emits a pair of
            a transaction, and an <see cref="T:Libplanet.Action.ActionEvaluation"/>
            for each step.
            </summary>
            <param name="accountStateGetter">An <see cref="T:Libplanet.Action.AccountStateGetter"/>
            delegate to get a previous state.
            A <c>null</c> value, which is default, means a constant function
            that returns <c>null</c>.</param>
            <param name="accountBalanceGetter">An <see cref="T:Libplanet.Action.AccountBalanceGetter"/> delegate to
            get previous account balance.
            A <c>null</c> value, which is default, means a constant function that returns zero.
            </param>
            <param name="previousBlockStatesTrie">The trie to contain states at previous block.
            </param>
            <returns>Enumerates pair of a transaction, and
            <see cref="T:Libplanet.Action.ActionEvaluation"/> for each action.
            The order of pairs are the same to
            the <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> and their
            <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> (e.g., tx&#xb9;-act&#xb9;,
            tx&#xb9;-act&#xb2;, tx&#xb2;-act&#xb9;, tx&#xb2;-act&#xb2;,
            &#x2026;).
            Note that each <see cref="P:Libplanet.Action.IActionContext.Random"/> object has
            a unconsumed state.
            </returns>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.Evaluate(System.DateTimeOffset,Libplanet.Action.AccountStateGetter,Libplanet.Action.AccountBalanceGetter,Libplanet.Store.Trie.ITrie)">
            <summary>
            Executes every <see cref="T:Libplanet.Action.IAction"/> in the
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> and gets result states of each step of
            every <see cref="T:Libplanet.Tx.Transaction`1"/>.
            <para>It throws an <see cref="T:Libplanet.Blocks.InvalidBlockException"/> or
            an <see cref="T:Libplanet.Tx.InvalidTxException"/> if there is any
            integrity error.</para>
            <para>Otherwise it enumerates an <see cref="T:Libplanet.Action.ActionEvaluation"/>
            for each <see cref="T:Libplanet.Action.IAction"/>.</para>
            </summary>
            <param name="currentTime">The current time to validate
            time-wise conditions.</param>
            <param name="accountStateGetter">An <see cref="T:Libplanet.Action.AccountStateGetter"/> delegate to get
            a previous state.  A <c>null</c> value, which is default, means a constant function
            that returns <c>null</c>.
            This affects the execution of <see cref="P:Libplanet.Tx.Transaction`1.Actions"/>.
            </param>
            <param name="accountBalanceGetter">An <see cref="T:Libplanet.Action.AccountBalanceGetter"/> delegate to
            get previous account balance.
            A <c>null</c> value, which is default, means a constant function that returns zero.
            This affects the execution of <see cref="P:Libplanet.Tx.Transaction`1.Actions"/>.
            </param>
            <param name="previousBlockStatesTrie">The trie to contain states at previous block.
            </param>
            <returns>An <see cref="T:Libplanet.Action.ActionEvaluation"/> for each
            <see cref="T:Libplanet.Action.IAction"/>.</returns>
            <exception cref="T:Libplanet.Blocks.InvalidBlockHashException">Thrown when
            the <see cref="P:Libplanet.Blocks.Block`1.Hash"/> is invalid.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTimestampException">Thrown when
            the <see cref="P:Libplanet.Blocks.Block`1.Timestamp"/> is invalid, for example, it is the far
            future than the given <paramref name="currentTime"/>.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockIndexException">Thrown when
            the <see cref="P:Libplanet.Blocks.Block`1.Index"/>is invalid, for example, it is a negative
            integer.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockDifficultyException">Thrown when
            the <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/> is not properly configured,
            for example, it is too easy.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPreviousHashException">Thrown when
            <see cref="P:Libplanet.Blocks.Block`1.PreviousHash"/> is invalid so that
            the <see cref="T:Libplanet.Blocks.Block`1"/>s are not continuous.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockNonceException">Thrown when
            the <see cref="P:Libplanet.Blocks.Block`1.Nonce"/> does not satisfy its
            <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/> level.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTxHashException">Thrown when
            the <see cref="P:Libplanet.Blocks.Block`1.TxHash" /> does not match with its
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxUpdatedAddressesException">Thrown when
            any <see cref="T:Libplanet.Action.IAction"/> of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> tries
            to update the states of <see cref="T:Libplanet.Address"/>es not included
            in <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> is invalid or not signed by
            the account who corresponds to its <see cref="T:Libplanet.Crypto.PublicKey"/>.
            </exception>
            <exception cref="T:Libplanet.Tx.InvalidTxPublicKeyException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> is not derived from its
            <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.</exception>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.ToBlockDigest">
            <summary>
            Gets <see cref="T:Libplanet.Blocks.BlockDigest"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <returns><see cref="T:Libplanet.Blocks.BlockDigest"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </returns>
        </member>
        <member name="T:Libplanet.Blocks.BlockDigest">
            <summary>
            Class that store uses to save blocks. This contains:
            <see cref="T:Libplanet.Blocks.BlockHeader"/>, and list of <see cref="T:Libplanet.Tx.TxId"/>s.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockDigest.#ctor(Libplanet.Blocks.BlockHeader,System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{System.Byte}})">
            <summary>
            Creates <see cref="T:Libplanet.Blocks.BlockDigest"/> instance from <see cref="T:Libplanet.Blocks.BlockHeader"/> and
            <see cref="T:Libplanet.Tx.Transaction`1"/> ids the <see cref="T:Libplanet.Blocks.Block`1"/> has.
            </summary>
            <param name="header"><see cref="T:Libplanet.Blocks.BlockHeader"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <param name="txIds"><see cref="T:Libplanet.Tx.Transaction`1"/> ids the <see cref="T:Libplanet.Blocks.Block`1"/> has.
            </param>
        </member>
        <member name="M:Libplanet.Blocks.BlockDigest.#ctor(Bencodex.Types.Dictionary)">
            <summary>
            Creates <see cref="T:Libplanet.Blocks.BlockDigest"/> instance from
            <see cref="T:Bencodex.Types.Dictionary"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="dict">
            <see cref="T:Bencodex.Types.Dictionary"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </param>
        </member>
        <member name="M:Libplanet.Blocks.BlockDigest.Deserialize(System.Byte[])">
            <summary>
            Gets <see cref="T:Libplanet.Blocks.BlockDigest"/> instance from serialized <paramref name="bytes"/>.
            </summary>
            <param name="bytes">Serialized <see cref="T:Libplanet.Blocks.BlockDigest"/>.</param>
            <returns>Deserialized <see cref="T:Libplanet.Blocks.BlockDigest"/>.</returns>
            <exception cref="T:Bencodex.DecodingException">Thrown when decoded value is not
            <see cref="T:Bencodex.Types.Dictionary"/> type.</exception>
        </member>
        <member name="M:Libplanet.Blocks.BlockDigest.Serialize">
            <summary>
            Gets serialized byte array of the <see cref="T:Libplanet.Blocks.BlockDigest"/>.
            </summary>
            <returns>Serialized byte array of <see cref="T:Libplanet.Blocks.BlockDigest"/>.</returns>
        </member>
        <member name="M:Libplanet.Blocks.BlockDigest.ToBencodex">
            <summary>
            Gets <see cref="T:Bencodex.Types.Dictionary"/> representation of
            <see cref="T:Libplanet.Blocks.BlockDigest"/>.
            </summary>
            <returns><see cref="T:Bencodex.Types.Dictionary"/> representation of
            <see cref="T:Libplanet.Blocks.BlockDigest"/>.</returns>
        </member>
        <member name="T:Libplanet.Blocks.BlockExceedingTransactionsException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Blocks.Block`1"/> has too many
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> (i.e., more than the number specified by
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>).
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.BlockExceedingTransactionsException.ActualTransactions">
            <summary>
            The actual number of transactions in the block.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.BlockExceedingTransactionsException.MaxTransactionsPerBlock">
            <summary>
            The maximum allowed number of transactions per block.
            </summary>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.MaxTransactionsPerBlock"/>
        </member>
        <member name="T:Libplanet.Blocks.BlockExcerpt">
            <summary>
            The extension methods for <see cref="T:Libplanet.Blocks.IBlockExcerpt"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockExcerpt.ToExcerptString(Libplanet.Blocks.IBlockExcerpt)">
            <summary>
            Shows <see cref="T:Libplanet.Blocks.IBlockExcerpt"/> instance's members as a string.
            </summary>
            <param name="excerpt">An excerpt object to show.</param>
            <returns>Extracted members as a string.</returns>
        </member>
        <member name="T:Libplanet.Blocks.BlockHeader">
            <summary>
            Block header containing information about <see cref="T:Libplanet.Blocks.Block`1"/>s except transactions.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockHeader.#ctor(System.Int32,System.Int64,System.String,System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte},System.Int64,System.Numerics.BigInteger,System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.BlockHeader"/> instance.
            </summary>
            <param name="protocolVersion">The protocol version.  Goes to the <see
            cref="P:Libplanet.Blocks.BlockHeader.ProtocolVersion"/>.</param>
            <param name="index">The height of the block.  Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.Index"/>.
            </param>
            <param name="timestamp">The time this block is created.
            Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.Timestamp"/>.</param>
            <param name="nonce">The nonce which satisfy the given <paramref name="difficulty"/>
            with any other field values.  Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.Nonce"/>.</param>
            <param name="miner">An optional address refers to who mines this block.
            Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.Miner"/>.</param>
            <param name="difficulty">The mining difficulty that <paramref name="nonce"/>
            has to satisfy.  Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.Difficulty"/>.</param>
            <param name="totalDifficulty">The total mining difficulty until this block.
            See also <see cref="P:Libplanet.Blocks.BlockHeader.Difficulty"/>.</param>
            <param name="previousHash">The previous block's <see cref="P:Libplanet.Blocks.BlockHeader.Hash"/>.  If it's a genesis
            block (i.e., <paramref name="index"/> is 0) this should be <c>null</c>.
            Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.PreviousHash"/>.</param>
            <param name="txHash">The result of hashing the transactions the block has.
            Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.TxHash"/>.</param>
            <param name="hash">The hash of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            Goes to the <see cref="P:Libplanet.Blocks.BlockHeader.Hash"/>.</param>
            <param name="preEvaluationHash">The hash derived from the block <em>except of</em>
            <paramref name="stateRootHash"/> (i.e., without action evaluation).
            Used for <see cref="M:Libplanet.Blocks.BlockHeader.Validate(System.DateTimeOffset)"/> checking <paramref name="nonce"/>.
            </param>
            <param name="stateRootHash">The <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of the states on the block.
            </param>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.ProtocolVersion">
            <summary>
            The protocol version number.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockHeader.Deserialize(System.Byte[])">
            <summary>
            Gets <see cref="T:Libplanet.Blocks.BlockHeader"/> instance from serialized <paramref name="bytes"/>.
            </summary>
            <param name="bytes">Serialized <see cref="T:Libplanet.Blocks.BlockHeader"/>.</param>
            <returns>Deserialized <see cref="T:Libplanet.Blocks.BlockHeader"/>.</returns>
            <exception cref="T:Bencodex.DecodingException">Thrown when decoded value is not
            <see cref="T:Bencodex.Types.Dictionary"/> type.</exception>
        </member>
        <member name="M:Libplanet.Blocks.BlockHeader.Serialize">
            <summary>
            Gets serialized byte array of the <see cref="T:Libplanet.Blocks.BlockHeader"/>.
            </summary>
            <returns>Serialized byte array of <see cref="T:Libplanet.Blocks.BlockHeader"/>.</returns>
        </member>
        <member name="M:Libplanet.Blocks.BlockHeader.ToBencodex">
            <summary>
            Gets <see cref="T:Bencodex.Types.Dictionary"/> representation of
            <see cref="T:Libplanet.Blocks.BlockHeader"/>.
            </summary>
            <returns><see cref="T:Bencodex.Types.Dictionary"/> representation of
            <see cref="T:Libplanet.Blocks.BlockHeader"/>.</returns>
        </member>
        <member name="T:Libplanet.Blocks.IBlockExcerpt">
            <summary>
            The very essential metadata extracted from a block.  This purposes to determine
            the canonical chain.
            </summary>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>
            <seealso cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.ProtocolVersion">
            <summary>
            A block's protocol version.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.Index">
            <summary>
            A block's index (height).
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.Hash">
            <summary>
            A block's hash.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.Hash"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.TotalDifficulty">
            <summary>
            The sum of a block and its all ancestors' difficulties.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.TotalDifficulty"/>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockBytesLengthException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Blocks.Block`1"/>'s
            <see cref="P:Libplanet.Blocks.Block`1.BytesLength"/> (i.e., the length of bytes in its serialized format)
            is too long.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockBytesLengthException.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockBytesLengthException"/> class.
            </summary>
            <param name="blockBytesLength">The invalid <see cref="T:Libplanet.Blocks.Block`1"/>'s
            <see cref="P:Libplanet.Blocks.Block`1.BytesLength"/>.  It is automatically included to the
            <see cref="P:System.Exception.Message"/> string.</param>
            <param name="maxBlockBytesLength">The maximum allowed length of bytes.  It is
            automatically included to the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockBytesLengthException.BlockBytesLength">
            <summary>
            The bytes length of the actual block.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockBytesLengthException.MaxBlockBytesLength">
            <summary>
            The maximum allowed length of a block in bytes.
            </summary>
            <seealso cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxBlockBytes(System.Int64)"/>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockException">
            <summary>
            Serves as the base class for exceptions related <see cref="T:Libplanet.Blocks.Block`1"/>s' integrity and
            validity.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockException.#ctor(System.String)">
            <inheritdoc cref="M:System.Exception.#ctor(System.String)"/>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException">
            <summary>
            The exception that is thrown when the a <see cref="T:Libplanet.Blocks.Block`1"/>'s
            <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/> is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockPreEvaluationHashException.#ctor(Libplanet.HashDigest{System.Security.Cryptography.SHA256},Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException"/> class.
            </summary>
            <param name="actualPreEvaluationHash">The hash recorded as
            <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/>.</param>
            <param name="expectedPreEvaluationHash">The hash calculated from the block except
            <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockPreEvaluationHashException.ActualPreEvaluationHash">
            <summary>
            The hash calculated from the block except <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockPreEvaluationHashException.ExpectedPreEvaluationHash">
            <summary>
            The hash recorded as <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockProtocolVersionException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Blocks.Block`1"/>'s
            <see cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/> (or a <see cref="T:Libplanet.Blocks.BlockHeader"/>'s
            <see cref="P:Libplanet.Blocks.BlockHeader.ProtocolVersion"/>) is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockProtocolVersionException.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockProtocolVersionException"/> class.
            </summary>
            <param name="actualProtocolVersion">The actual block protocol version which is invalid.
            </param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockProtocolVersionException.ActualProtocolVersion">
            <summary>
            The actual block protocol version which is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockProtocolVersionException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockStateRootHashException">
            <summary>
            The exception that is thrown when the state root hash in the block has
            mismatches to the state root hash of the trie on the block executed in local.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockStateRootHashException.#ctor(System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Blocks.InvalidBlockStateRootHashException"/> class.
            </summary>
            <param name="expectedStateRootHash">The hash recorded as
            <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>>.</param>
            <param name="actualStateRootHash">The hash of state trie on the block executed.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockStateRootHashException.ActualStateRootHash">
            <summary>
            The hash of state trie on the block executed.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockStateRootHashException.ExpectedStateRootHash">
            <summary>
            The hash recorded as <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockTxHashException.#ctor(System.String,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockTxHashException"/> class.
            </summary>
            <param name="blockTxHash">The hash digest of <see cref="P:Libplanet.Blocks.Block`1.TxHash"/>.</param>
            <param name="calculatedTxHash">The calculated hash digest from
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/>.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockTxHashException.BlockTxHash">
            <summary>
            The hash digest from actual block.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockTxHashException.CalculatedTxHash">
            <summary>
            The calculated hash digest from transactions in the block.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.InvalidGenesisBlockException">
            <summary>
            The exception that is thrown when the genesis block the <see cref="T:Libplanet.Store.IStore"/> contains
            mismatches to the genesis block the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> constructor (i.e., network)
            expects or the first block of <see cref="T:Libplanet.Blockchain.BlockLocator"/> which the <see cref="T:Libplanet.Store.IStore"/>
            doesn't contain, because the block which <see cref="T:Libplanet.Store.IStore"/> doesn't means
            the genesis block in other network.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidGenesisBlockException.#ctor(Libplanet.HashDigest{System.Security.Cryptography.SHA256},Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Blocks.InvalidGenesisBlockException"/> class.
            </summary>
            <param name="networkExpected">The genesis block that the network expects.</param>
            <param name="stored">The genesis block that a local <see cref="T:Libplanet.Store.IStore"/> contains.
            </param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidGenesisBlockException.NetworkExpected">
            <summary>
            The genesis block that the network expects.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidGenesisBlockException.Stored">
            <summary>
            The genesis block that a local <see cref="T:Libplanet.Store.IStore"/> contains.
            </summary>
        </member>
        <member name="T:Libplanet.ByteArrayExtensions">
            <summary>
            This extension class enables some convenient methods to deal with byte array.
            </summary>
            <seealso cref="T:Libplanet.Address"/>
        </member>
        <member name="M:Libplanet.ByteArrayExtensions.StartsWith(System.Byte[],System.Byte[])">
            <summary>
            Determines whether the beginning of this byte array instance matches a specified string.
            </summary>
            <param name="bytes">A byte array to check.</param>
            <param name="prefix">The prefix byte array to compare.</param>
            <returns>
            true if <paramref name="prefix"/> matches the beginning of <paramref name="bytes"/>;
            otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="bytes"/> or <paramref name="prefix"/> is null.
            </exception>
        </member>
        <member name="T:Libplanet.ByteUtil">
            <summary>
            Utility methods to deal with <see cref="T:System.Byte"/> arrays.
            </summary>
        </member>
        <member name="M:Libplanet.ByteUtil.ParseHex(System.String)">
            <summary>
            Converts a hexadecimal string to a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="hex">A <see cref="T:System.String"/> which encodes
            <see cref="T:System.Byte"/>s in hexadecimal.  Its length must be zero or
            an even number.  It must not be <c>null</c>.</param>
            <returns>A <see cref="T:System.Byte"/> array that the given
            <paramref name="hex"/> string represented in hexadecimal.
            It lengthens the half of the given <paramref name="hex"/> string.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hex"/> string is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length
            of the given <paramref name="hex"/> string is an odd number.
            </exception>
            <exception cref="T:System.FormatException">Thrown when the given
            <paramref name="hex"/> string is not a valid hexadecimal string.
            </exception>
        </member>
        <member name="M:Libplanet.ByteUtil.Hex(System.Byte[])">
            <summary>
            Renders a hexadecimal string from a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">A <see cref="T:System.Byte"/> array to renders
            the corresponding hexadecimal string.  It must not be <c>null</c>.
            </param>
            <returns>A hexadecimal string which encodes the given
            <paramref name="bytes"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="bytes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Libplanet.ByteUtil.Hex(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Renders a hexadecimal string from a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">A <see cref="T:System.Byte"/> array to renders
            the corresponding hexadecimal string.  It must not be <c>null</c>.
            </param>
            <returns>A hexadecimal string which encodes the given
            <paramref name="bytes"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="bytes"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Libplanet.ByteUtil.CalculateHashCode(System.Byte[])">
            <summary>
            Calculates a deterministic hash code from a given
            <paramref name="bytes"/>.  It is mostly used to implement
            <see cref="M:System.Object.GetHashCode"/> method.
            </summary>
            <param name="bytes">A <see cref="T:System.Byte"/> array, which completely
            determines (or encodes) an object, to calculate a hash code.</param>
            <returns>A hash code determined from the given
            <paramref name="bytes"/>.  For equivalent <paramref name="bytes"/>,
            the same hash code is returned.  It must not be <c>null</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="bytes"/> is <c>null</c>.</exception>
        </member>
        <member name="T:Libplanet.Crypto.CryptoConfig">
            <summary>
            Libplanet cryptography configuration information.
            </summary>
        </member>
        <member name="P:Libplanet.Crypto.CryptoConfig.CryptoBackend">
            <summary>
            Global cryptography backend to sign and verify messages.
            </summary>
        </member>
        <member name="T:Libplanet.Crypto.ICryptoBackend`1">
            <summary>
            Cryptography backend interface.
            </summary>
            <typeparam name="T">A <see cref="T:System.Security.Cryptography.HashAlgorithm"/> which corresponds to a digest.</typeparam>
            <seealso cref="T:System.Security.Cryptography.HashAlgorithm"/>
        </member>
        <member name="M:Libplanet.Crypto.ICryptoBackend`1.Sign(Libplanet.HashDigest{`0},Libplanet.Crypto.PrivateKey)">
            <summary>
            Creates a signature from <paramref name="messageHash"/> with the corresponding
            <paramref name="privateKey"/>.
            </summary>
            <param name="messageHash">A 32 bytes message hash digest hashed with SHA256 to sign.
            </param>
            <param name="privateKey"><see cref="T:Libplanet.Crypto.PrivateKey"/> to sign
            <paramref name="messageHash"/>.
            </param>
            <returns> Created a signature from <paramref name="messageHash"/> with the corresponding
            <paramref name="privateKey"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Crypto.ICryptoBackend`1.Verify(Libplanet.HashDigest{`0},System.Byte[],Libplanet.Crypto.PublicKey)">
            <summary>
            Verifies whether a <paramref name="signature"/> was created from
            a <paramref name="messageHash"/> with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
            <param name="messageHash">A 32 bytes message hash digest hashed with SHA256.</param>
            <param name="signature">A signature that was created from the
            <paramref name="messageHash"/>.</param>
            <param name="publicKey"><see cref="T:Libplanet.Crypto.PublicKey"/> used for verification.</param>
            <returns><c>true</c> if the <paramref name="signature"/> was created
            from the <paramref name="messageHash"/> with the corresponding
            <see cref="T:Libplanet.Crypto.PrivateKey"/>. Otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Libplanet.Crypto.PrivateKey">
            <summary>
            A secret part of a key pair involved in
            <a href="https://en.wikipedia.org/wiki/ECDSA">ECDSA</a>, the digital
            signature algorithm on which the Libplanet is based.  It can be used to
            create signatures, which can be verified with the corresponding
            <see cref="T:Libplanet.Crypto.PublicKey"/>, as well as to decrypt
            messages which were encrypted with the corresponding
            <see cref="T:Libplanet.Crypto.PublicKey"/>.
            <para>Note that it uses <a href="https://en.bitcoin.it/wiki/Secp256k1"
            >secp256k1</a> as the parameters of the elliptic curve, which is
            the same to <a href="https://bitcoin.org/">Bitcoin</a> and
            <a href="https://www.ethereum.org/">Ethereum</a>.
            It means private keys generated for Bitcoin/Ethereum can be used by
            Libplanet-backed games/apps too.</para>
            </summary>
            <remarks>
            These (and any derived representations, e.g., <see cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>)
            must be kept secret, if they are exposed, an attacker will be able to
            forge signatures.
            <para>Every <see cref="T:Libplanet.Crypto.PrivateKey"/> object is immutable.</para>
            </remarks>
            <seealso cref="T:Libplanet.Crypto.PublicKey"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.#ctor">
            <summary>
            Generates a new unique <see cref="T:Libplanet.Crypto.PrivateKey"/> instance.
            It can be analogous to creating a new account in a degree.
            </summary>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.#ctor(System.Byte[])">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.PrivateKey"/> instance from the given
            <see cref="T:System.Byte"/> array (i.e., <paramref name="privateKey"/>),
            which encodes a valid <a href="https://en.wikipedia.org/wiki/ECDSA">
            ECDSA</a> private key.
            </summary>
            <param name="privateKey">A valid <see cref="T:System.Byte"/> array that
            encodes an ECDSA private key.
            </param>
            <remarks>A valid <see cref="T:System.Byte"/> array for a <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            Can be encoded using <see cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/> property.
            </remarks>
            <seealso cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>
        </member>
        <member name="P:Libplanet.Crypto.PrivateKey.PublicKey">
            <summary>
            The corresponding <see cref="T:Libplanet.Crypto.PublicKey"/> of
            this private key.
            </summary>
        </member>
        <member name="P:Libplanet.Crypto.PrivateKey.ByteArray">
            <summary>
            A <see cref="T:System.Byte"/> array encoding of this private key.
            </summary>
            <remarks>
            An encoded <see cref="T:System.Byte"/> array representation can recover
            a <see cref="T:Libplanet.Crypto.PrivateKey"/> object again using its constructor
            (i.e., <see cref="M:Libplanet.Crypto.PrivateKey.#ctor(System.Byte[])"/>.
            <para>As like <see cref="T:Libplanet.Crypto.PrivateKey"/> instances, this also must be
            kept secret.  In practice, this must not be sent over the network,
            and be securely stored in the file system.
            For the most part, modern operating systems, mobile ones
            in particular, provide their own API
            to store password and private keys in the secure manner, which
            means they encrypt things to store using their own hardware
            security unit if possible.  See also <a
            href="https://developer.android.com/training/articles/keystore"
            >Android keystore system</a> or <a href="https://apple.co/2JHjxAq"
            >iOS Secure Enclave</a>.</para>
            </remarks>
            <seealso cref="M:Libplanet.Crypto.PrivateKey.#ctor(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.Sign(System.Byte[])">
            <summary>
            Creates a signature from the given <paramref name="message"/>.
            <para>
            A created signature can be verified by the corresponding
            <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/>.
            </para>
            <para>
            Signatures can be created by only the <see cref="T:Libplanet.Crypto.PrivateKey"/>
            which corresponds a <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> to verify these
            signatures.
            </para>
            <para>
            To sum up, a signature is used to guarantee:
            </para>
            <list type="bullet">
            <item><description>that the <paramref name="message"/> was created
            by someone possessing the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>,
            </description></item>
            <item><description>that the possessor cannot deny having sent the
            <paramref name="message"/>, and</description></item>
            <item><description>that the <paramref name="message"/> was not
            forged in the middle of transit.</description></item>
            </list>
            </summary>
            <param name="message">A message to sign in <see cref="T:System.Byte"/> array
            representation.</param>
            <returns>A signature that verifies the <paramref name="message"/>.
            It can be verified using
            <see cref="M:Libplanet.Crypto.PublicKey.Verify(System.Byte[],System.Byte[])"/>
            method.</returns>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Verify(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.Decrypt(System.Byte[])">
            <summary>
            Converts a <paramref name="ciphertext"/> which was encrypted with
            the corresponding <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> to the plain message.
            </summary>
            <param name="ciphertext">The encrypted data.</param>
            <returns>The plain data the <paramref name="ciphertext"/> encrypted.
            </returns>
            <exception cref="T:Libplanet.Crypto.InvalidCiphertextException">Thrown when the given
            <paramref name="ciphertext"/> is invalid.</exception>
            <remarks>
            Although the parameter name <paramref name="ciphertext"/> has the
            word &#x201c;text&#x201d;, both a <paramref name="ciphertext"/>
            and a returned message are a <see cref="T:System.Byte"/> string,
            not a Unicode <see cref="T:System.String"/>.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Encrypt(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.ExchangeKey(Libplanet.Crypto.PublicKey)">
            <summary>
            Securely exchange a <see cref="T:Libplanet.Crypto.SymmetricKey"/> with a peer's
            <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/>.
            Two parties can agree on a (new, unique, and typically temporal)
            key without revealing to any eavesdropping party what key has been
            agreed upon.
            <para>Technically it is <a href="https://en.wikipedia.org/wiki/ECDH"
            >ECDH</a>, a <a
            href="https://en.wikipedia.org/wiki/DH_key_exchange"
            >Diffie&#x2013;Hellman key exchange</a> of elliptic-curve version.
            </para>
            </summary>
            <param name="publicKey">The <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> possessed by
            a peer to whom exchange a private key with.</param>
            <returns>An exchanged (agreed) <see cref="T:Libplanet.Crypto.SymmetricKey"/>.
            Note that it is not an elliptic-curve private key, but an <a
            href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
            >AES</a> key.</returns>
        </member>
        <member name="T:Libplanet.Crypto.PublicKey">
            <summary>
            A public part of a key pair involved in
            <a href="https://en.wikipedia.org/wiki/ECDSA">ECDSA</a>, the digital
            signature algorithm on which the Libplanet is based.
            It can be used to verify signatures created with the corresponding
            <see cref="T:Libplanet.Crypto.PrivateKey"/> and to encrypt messages for someone
            possessing the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            This can be distributed publicly, hence the name.
            <para>Note that it uses <a href="https://en.bitcoin.it/wiki/Secp256k1"
            >secp256k1</a> as the parameters of the elliptic curve, which is same to
            <a href="https://bitcoin.org/">Bitcoin</a> and
            <a href="https://www.ethereum.org/">Ethereum</a>.
            It means public keys generated for Bitcoin/Ethereum can be used by
            Libplanet-backed games/apps too.</para>
            </summary>
            <remarks>Every <see cref="T:Libplanet.Crypto.PublicKey"/> object is immutable.</remarks>
            <seealso cref="T:Libplanet.Crypto.PrivateKey"/>
            <seealso cref="T:Libplanet.Address"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.#ctor(System.Byte[])">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.PublicKey"/> instance from the given
            <see cref="T:System.Byte"/> array (i.e., <paramref name="publicKey"/>),
            which encodes a valid <a href="https://en.wikipedia.org/wiki/ECDSA">
            ECDSA</a> public key.
            </summary>
            <param name="publicKey">A valid <see cref="T:System.Byte"/> array that
            encodes an ECDSA public key.  It can be either compressed or
            not.</param>
            <remarks>A valid <see cref="T:System.Byte"/> array for
            a <see cref="T:Libplanet.Crypto.PublicKey"/> can be encoded using
            <see cref="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)"/> method.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)">
            <summary>
            Encodes this public key into a <see cref="T:System.Byte"/> array
            representation.
            </summary>
            <param name="compress">Returns a short length representation if
            it is <c>true</c>.  This option does not lose any information.
            </param>
            <returns>An encoded <see cref="T:System.Byte"/> array representation.
            It can recover a <see cref="T:Libplanet.Crypto.PublicKey"/> object again using
            its constructor (i.e., <see cref="M:Libplanet.Crypto.PublicKey.#ctor(System.Byte[])"/>)
            regardless of compression.</returns>
            <seealso cref="M:Libplanet.Crypto.PublicKey.#ctor(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.Encrypt(System.Byte[])">
            <summary>
            Converts a plain <paramref name="message"/> to a ciphertext
            which can be decrypted with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"
            />.
            </summary>
            <param name="message">A binary data to be encrypted.</param>
            <returns>
            A ciphertext that was encrypted from the <paramref name="message"/>
            and can be decrypted with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"
            />. (Although the word &#x201c;ciphertext&#x201d; has the word
            &#x201c;text&#x201d;, a returned ciphertext is not a Unicode
            <see cref="T:System.String"/>, but a <see cref="T:System.Byte"/> array.)
            </returns>
            <seealso cref="M:Libplanet.Crypto.PrivateKey.Decrypt(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.Verify(System.Byte[],System.Byte[])">
            <summary>
            Verifies whether a <paramref name="signature"/> was created from
            a <paramref name="message"/> with the corresponding
            <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
            <param name="message">A plain message that the
            <paramref name="signature"/> was created from.  That is, a data
            which was passed as an argument to
            <see cref="M:Libplanet.Crypto.PrivateKey.Sign(System.Byte[])"/>.</param>
            <param name="signature">A signature that was created from the
            <paramref name="message"/>.  That is, a data which was returned
            by <see cref="M:Libplanet.Crypto.PrivateKey.Sign(System.Byte[])"/>.</param>
            <returns><c>true</c> if the <paramref name="signature"/> was created
            from the <paramref name="message"/> with the corresponding
            <see cref="T:Libplanet.Crypto.PrivateKey"/>. Otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Libplanet.Crypto.SymmetricKey">
            <summary>
            An <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
            >AES</a>-<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"
            >GCM</a> <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm"
            >symmetric key</a>.  Unlike <see cref="T:Libplanet.Crypto.PrivateKey"/> and
            <see cref="T:Libplanet.Crypto.PublicKey"/> that are involved in an asymmetric key
            cryptography, it uses the same <see cref="T:Libplanet.Crypto.SymmetricKey"/> for both
            encrypting a plaintext and decrypting a ciphertext.
            </summary>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.#ctor(System.Byte[])">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.SymmetricKey"/> instance from the given
            <see cref="T:System.Byte"/> array (i.e., <paramref name="key"/>),
            which encodes a valid <a
            href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
            >AES</a>-<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"
            >GCM</a> <a
            href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm"
            >symmetric key</a>.
            </summary>
            <param name="key">A valid <see cref="T:System.Byte"/> array that
            encodes an AES-GCM symmetric key.
            </param>
            <remarks>A valid <see cref="T:System.Byte"/> array for
            a <see cref="T:Libplanet.Crypto.SymmetricKey"/> can be encoded using
            <see cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/> method.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/>
        </member>
        <member name="P:Libplanet.Crypto.SymmetricKey.ByteArray">
            <summary>
            An immutable <see cref="T:System.Byte"/> array encoding of this key.
            </summary>
            <remarks>This is immutable.  For a mutable array, call
            <see cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/> method.</remarks>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.Encrypt(System.Byte[],System.Byte[])">
            <summary>
            Converts a plain <paramref name="message"/> to a ciphertext
            which can be decrypted with the same key.
            </summary>
            <param name="message">A binary data to be encrypted.</param>
            <param name="nonSecret">An extra data not to be encrypted, but
            to be just transmitted as is.  The default value is <c>null</c>,
            which means empty.</param>
            <returns>
            A ciphertext that was encrypted from the <paramref name="message"/>
            and can be decrypted with the same key.
            (Although the word &#x201c;ciphertext&#x201d; has the word
            &#x201c;text&#x201d;, a returned ciphertext is not a Unicode
            <see cref="T:System.String"/>, but a <see cref="T:System.Byte"/> array.)
            </returns>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.Decrypt(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.Decrypt(System.Byte[],System.Int32)">
            <summary>
            Converts a <paramref name="ciphertext"/> which was encrypted with
            the same key to the plain message.
            </summary>
            <param name="ciphertext">The encrypted data.</param>
            <param name="nonSecretLength">The length of <c>nonSecret</c> data.
            (See also <see cref="M:Libplanet.Crypto.SymmetricKey.Encrypt(System.Byte[],System.Byte[])"/> method's the second
            parameter, which is optional.)  <c>0</c> by default.</param>
            <returns>The plain data the <paramref name="ciphertext"/> encrypted.
            It returns <c>null</c> if the <paramref name="ciphertext"/> is
            invalid (this behavior will be eventually changed in the future to
            throw an exception instead).</returns>
            <remarks>
            Although the parameter name <paramref name="ciphertext"/> has the
            word &#x201c;text&#x201d;, both a <paramref name="ciphertext"/>
            and a returned message are a <see cref="T:System.Byte"/> string,
            not a Unicode <see cref="T:System.String"/>.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.Encrypt(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.ToByteArray">
            <summary>
            Gets a mutable <see cref="T:System.Byte"/> array which encodes this key.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array which encodes this
            key.  Since it is created every time the method is called, any
            mutation on that does not affect this <see cref="T:Libplanet.Crypto.SymmetricKey"/>
            object.</returns>
            <seealso cref="P:Libplanet.Crypto.SymmetricKey.ByteArray"/>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.#ctor(System.Byte[])"/>
        </member>
        <member name="T:Libplanet.FixedSizedQueue`1">
            <summary>
            Equivalent to <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, except this does not accept more than
            the specified maximum size.
            </summary>
            <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
        </member>
        <member name="F:Libplanet.FixedSizedQueue`1._syncObject">
            <summary>
            Simple object for thread synchronization.
            </summary>
        </member>
        <member name="M:Libplanet.FixedSizedQueue`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Libplanet.FixedSizedQueue`1"/>
            with the specified <paramref name="size"/>.
            </summary>
            <param name="size">The maximum size of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.</param>
        </member>
        <member name="P:Libplanet.FixedSizedQueue`1.Size">
            <summary>
            Gets the fixed size of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.
            </summary>
        </member>
        <member name="M:Libplanet.FixedSizedQueue`1.Enqueue(`0)">
            <summary>
            Adds an object at the end of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.
            </summary>
            <param name="obj">The object to add at the
            end of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.</param>
        </member>
        <member name="T:Libplanet.Hashcash">
            <summary>
            This contains a set of functions that implements
            <a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a>,
            a <a href="https://en.wikipedia.org/wiki/Proof-of-work_system"
            >proof-of-work system</a>.
            </summary>
        </member>
        <member name="T:Libplanet.Hashcash.Stamp">
            <summary>
            A delegate to determine a consistent <see cref="T:System.Byte"/>s
            representation derived from a given <paramref name="nonce"/>.
            <para>Since it is called multiple times with different
            <paramref name="nonce"/>s for
            <a href="https://en.wikipedia.org/wiki/Proof-of-work_system"
            >proof-of-work system</a>, the total time an implementation elapses
            should not vary for different <paramref name="nonce"/>s.</para>
            </summary>
            <param name="nonce">An arbitrary nonce for an attempt, provided
            by <see cref="M:Libplanet.Hashcash.Answer(Libplanet.Hashcash.Stamp,System.Int64,System.Threading.CancellationToken)"/> method.</param>
            <returns>A <see cref="T:System.Byte"/> array determined from the given
            <paramref name="nonce"/>.  It should return consistently
            an equivalent array for equivalent <paramref name="nonce"/>
            values.</returns>
            <seealso cref="M:Libplanet.Hashcash.Answer(Libplanet.Hashcash.Stamp,System.Int64,System.Threading.CancellationToken)"/>
            <seealso cref="T:Libplanet.Nonce"/>
        </member>
        <member name="M:Libplanet.Hashcash.Answer(Libplanet.Hashcash.Stamp,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Finds a <see cref="T:Libplanet.Nonce"/> that satisfies the given
            <paramref name="difficulty"/>.  This process is so-called
            &#x0201c;<a
            href="https://en.wikipedia.org/wiki/Cryptocurrency#Mining"
            >mining</a>&#x0201d;.
            </summary>
            <param name="stamp">A callback to get a &#x0201c;stamp&#x0201d;
            which is a <see cref="T:System.Byte"/> array determined from a given
            <see cref="T:Libplanet.Nonce"/> value.</param>
            <param name="difficulty">A number to calculate the target number
            for which the returned answer should be less than.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns>A <see cref="T:Libplanet.Nonce"/> value which satisfies the given
            <paramref name="difficulty"/>.</returns>
            <seealso cref="T:Libplanet.Hashcash.Stamp"/>
        </member>
        <member name="M:Libplanet.Hashcash.Hash(System.Byte[])">
            <summary>
            Calculates a SHA-256 digest from the given <paramref name="bytes"/>.
            </summary>
            <param name="bytes">A <see cref="T:System.Byte"/> array to calculate
            its hash digest.</param>
            <returns>A deterministic digest of the given
            <paramref name="bytes"/>.</returns>
        </member>
        <member name="T:Libplanet.HashDigest`1">
            <summary>
            A value type to represent digest bytes determined by a
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.  For more type safety, it takes
            a type parameter <typeparamref name="T"/> of
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.
            </summary>
            <typeparam name="T">A <see cref="T:System.Security.Cryptography.HashAlgorithm"/> which corresponds to
            a digest.  This determines <see cref="F:Libplanet.HashDigest`1.Size"/> of a digest.</typeparam>
            <seealso cref="T:System.Security.Cryptography.HashAlgorithm"/>
        </member>
        <member name="F:Libplanet.HashDigest`1.Size">
            <summary>
            The fixed, and valid <see cref="P:System.Array.Length"/> of
            a <see cref="T:System.Byte"/> array of every digest.
            <para>This varies depending upon what <see cref="T:System.Security.Cryptography.HashAlgorithm"/> is
            used for <typeparamref name="T"/>.  For example, if <typeparamref
            name="T"/> is <see cref="T:System.Security.Cryptography.SHA1"/> <see cref="F:Libplanet.HashDigest`1.Size"/> is <c>20</c>,
            and if <see cref="T:System.Security.Cryptography.SHA256"/> it is <c>32</c>.</para>
            </summary>
        </member>
        <member name="M:Libplanet.HashDigest`1.#ctor(System.Byte[])">
            <summary>
            Converts a <see cref="T:System.Byte"/> array into a
            <see cref="T:Libplanet.HashDigest`1"/>.
            </summary>
            <param name="hashDigest">A <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.HashDigest`1"/>.  It must not be <c>null</c>,
            and its <see cref="P:System.Array.Length"/> must be the same to
            <see cref="F:Libplanet.HashDigest`1.Size"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hashDigest"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hashDigest"/>'s <see cref="P:System.Array.Length"/> is not
            the same to the <see cref="F:Libplanet.HashDigest`1.Size"/> the hash algorithm
            (i.e., <typeparamref name="T"/> requires.</exception>
        </member>
        <member name="M:Libplanet.HashDigest`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Converts a <see cref="T:System.Collections.Immutable.ImmutableArray"/> of <see cref="T:System.Byte"/> array into a
            <see cref="T:Libplanet.HashDigest`1"/>.
            </summary>
            <param name="hashDigest">A <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.HashDigest`1"/>.  It must not be <c>null</c>,
            and its <see cref="P:System.Array.Length"/> must be the same to
            <see cref="F:Libplanet.HashDigest`1.Size"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hashDigest"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hashDigest"/>'s <see cref="P:System.Collections.Immutable.ImmutableArray`1.Length"/> is not
            the same to the <see cref="F:Libplanet.HashDigest`1.Size"/> the hash algorithm
            (i.e., <typeparamref name="T"/> requires.</exception>
        </member>
        <member name="P:Libplanet.HashDigest`1.ByteArray">
            <summary>
            A bare immutable <see cref="T:System.Byte"/> array of the digest.
            </summary>
            <remarks>It is immutable.  For a mutable array, use
            <see cref="M:Libplanet.HashDigest`1.ToByteArray"/> method instead.</remarks>
            <seealso cref="M:Libplanet.HashDigest`1.ToByteArray"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.FromString(System.String)">
            <summary>
            Converts a given hexadecimal representation of a digest into
            a <see cref="T:Libplanet.HashDigest`1"/> object.
            <para>This is an inverse function of <see cref="M:Libplanet.HashDigest`1.ToString"/>
            method.</para>
            </summary>
            <param name="hexDigest">A hexadecimal representation of
            a <see cref="T:Libplanet.HashDigest`1"/>.</param>
            <returns>A corresponding <see cref="T:Libplanet.HashDigest`1"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hexDigest"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hexDigest"/>'s length is not the double of
            the <see cref="F:Libplanet.HashDigest`1.Size"/>, the hash algorithm
            (i.e., <typeparamref name="T"/> requires.</exception>
            <seealso cref="M:Libplanet.HashDigest`1.ToString"/>
            <seealso cref="M:Libplanet.HashDigestExtensions.ToHashDigest``1(System.String)"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.Satisfies(System.Int64)">
            <summary>
            Tests if a digest is less than the target computed for the given
            <paramref name="difficulty"/>).
            </summary>
            <param name="difficulty">The difficulty to compute target number.
            </param>
            <returns><c>true</c> only if a digest is less than the target
            computed for the given <paramref name="difficulty"/>).
            If <paramref name="difficulty"/> is <c>0</c> it always returns
            <c>true</c>.
            </returns>
        </member>
        <member name="M:Libplanet.HashDigest`1.ToByteArray">
            <summary>
            Gets a bare mutable <see cref="T:System.Byte"/> array of the digest.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array of the digest.
            Since a returned array is created every time the method is called,
            any mutations on that array does not affect to the digest object.
            </returns>
            <seealso cref="P:Libplanet.HashDigest`1.ByteArray"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.ToString">
            <summary>
            Gets a hexadecimal representation of a digest.
            <para>This is an inverse function of <see cref="M:Libplanet.HashDigest`1.FromString(System.String)"/>.
            </para>
            </summary>
            <returns>A hexadecimal representation of a digest.</returns>
            <seealso cref="M:Libplanet.HashDigest`1.FromString(System.String)"/>
        </member>
        <member name="T:Libplanet.HashDigestExtensions">
            <summary>
            Augments types to have some shortcut methods dealing with
            <see cref="T:Libplanet.HashDigest`1"/> values.
            </summary>
        </member>
        <member name="M:Libplanet.HashDigestExtensions.ToHashDigest``1(System.String)">
            <summary>
            Converts a given hexadecimal representation of a digest into
            a <see cref="T:Libplanet.HashDigest`1"/> object.
            <para>This is a shortcut of
            <see cref="M:Libplanet.HashDigest`1.FromString(System.String)"/> method.</para>
            <para>This is an inverse function of
            <see cref="M:Libplanet.HashDigest`1.ToString"/> method.</para>
            </summary>
            <param name="hexDigest">A hexadecimal representation of
            a <see cref="T:Libplanet.HashDigest`1"/>.</param>
            <typeparam name="T">A <see cref="T:System.Security.Cryptography.HashAlgorithm"/> which corresponds
            to a digest.</typeparam>
            <returns>A corresponding <see cref="T:Libplanet.HashDigest`1"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hexDigest"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hexDigest"/>'s length is not the double of
            the <see cref="F:Libplanet.HashDigest`1.Size"/>, the hash algorithm
            (i.e., <typeparamref name="T"/> requires.</exception>
            <seealso cref="M:Libplanet.HashDigest`1.FromString(System.String)"/>
            <seealso cref="M:Libplanet.HashDigest`1.ToString"/>
        </member>
        <member name="T:Libplanet.KeyStore.Ciphers.Aes128Ctr">
            <summary>
            AES-128-CTR (AES 128-bit in counter moder).
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.#ctor(System.Byte[])">
            <summary>
            Creates an <see cref="T:Libplanet.KeyStore.Ciphers.Aes128Ctr"/> instance with the given <paramref name="iv"/>.
            </summary>
            <param name="iv">Initialization vector.</param>
            <exception cref="T:System.ArgumentException">Thrown when the length of <paramref name="iv"/> is
            invalid.</exception>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Creates an <see cref="T:Libplanet.KeyStore.Ciphers.Aes128Ctr"/> instance with the given <paramref name="iv"/>.
            </summary>
            <param name="iv">Initialization vector.</param>
            <exception cref="T:System.ArgumentException">Thrown when the length of <paramref name="iv"/> is
            invalid.</exception>
        </member>
        <member name="P:Libplanet.KeyStore.Ciphers.Aes128Ctr.Iv">
            <summary>
            Initialization vector.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.Encrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.Decrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.KeyStore.Ciphers.ICipher">
            <summary>
            An interface to define symmetric cipher algorithm.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.ICipher.Encrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Encrypts the given <paramref name="plaintext"/> using the given <paramref name="key"/>.
            </summary>
            <param name="key">A symmetric key.</param>
            <param name="plaintext">An immutable <see cref="T:System.Byte"/> array to encrypt.</param>
            <returns>The ciphertext made from the <paramref name="plaintext"/>
            using the <paramref name="key"/>.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.ICipher.Decrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Decrypts the given <paramref name="ciphertext"/> using the given <paramref name="key"/>.
            </summary>
            <param name="key">A symmetric key.</param>
            <param name="ciphertext">An immutable <see cref="T:System.Byte"/> array to decrypt.</param>
            <returns>The plain text decrypted from the <paramref name="ciphertext"/>
            using the <paramref name="key"/>.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.ICipher.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <summary>
            Dumps the cipher parameters as a JSON representation according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="writer">A JSON writer which has not begun object nor array.</param>
            <returns>A unique identifier of the cipher algorithm.  This is going to be the
            <c>crypto.cipher</c> field in the key JSON file.</returns>
        </member>
        <member name="T:Libplanet.KeyStore.IKeyStore">
            <summary>
            The interface to store <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>s.  An appropriate implementation
            should be used according to a running platform.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.ListIds">
            <summary>
            Lists all keys IDs in the key store.
            </summary>
            <returns>All keys IDs in the key store.  The order is undefined and not deterministic.
            </returns>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.List">
            <summary>
            Lists all keys in the key store.
            </summary>
            <returns>All keys in the key store.  The order is undefined and not deterministic.
            </returns>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.Get(System.Guid)">
            <summary>
            Looks for a key having the requested <paramref name="id"/> in the key store.
            </summary>
            <param name="id">The key ID to look for.</param>
            <returns>The found key.</returns>
            <exception cref="T:Libplanet.KeyStore.NoKeyException">Thrown when there are no key of the given
            <paramref name="id"/>.</exception>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.Add(Libplanet.KeyStore.ProtectedPrivateKey)">
            <summary>
            Adds a new <paramref name="key"/> into the key store.
            </summary>
            <param name="key">A key to add.</param>
            <returns>The id of the added <paramref name="key"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>null</c> is passed to
            <paramref name="key"/>.</exception>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.Remove(System.Guid)">
            <summary>
            Removes a key having the given <pramref name="id"/> from the key store.
            </summary>
            <param name="id">The key ID to remove.</param>
            <exception cref="T:Libplanet.KeyStore.NoKeyException">Thrown when there is no key having
            the given <paramref name="id"/>.</exception>
        </member>
        <member name="T:Libplanet.KeyStore.IncorrectPassphraseException">
            <summary>
            The exception that is thrown when a user input passphrase (i.e., password) is incorrect.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.IncorrectPassphraseException.#ctor(System.String,System.String,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.IncorrectPassphraseException"/> object.
            </summary>
            <param name="message">The error message that explains the reason for the exception.
            </param>
            <param name="paramName">The name of the parameter that caused the current exception.
            </param>
            <param name="expectedMac">The expected MAC of the correct passphrase.
            It is automatically included to the <paramref name="message"/> string.</param>
            <param name="inputMac">The actual MAC of the user input passphrase.
            It is automatically included to the <paramref name="message"/> string.</param>
        </member>
        <member name="P:Libplanet.KeyStore.IncorrectPassphraseException.ExpectedMac">
            <summary>
            The expected MAC of the correct passphrase.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.IncorrectPassphraseException.InputMac">
            <summary>
            The actual MAC of the user input passphrase.
            </summary>
        </member>
        <member name="T:Libplanet.KeyStore.InvalidKeyJsonException">
            <summary>
            The exception that is thrown when a key JSON is invalid, e.g., missing field.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.InvalidKeyJsonException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.InvalidKeyJsonException"/> instance.
            </summary>
            <param name="message">A detailed exception message.</param>
        </member>
        <member name="T:Libplanet.KeyStore.Kdfs.IKdf">
            <summary>
            An interface to form key derivation functions (KDF) that are used to derive a valid
            cryptographic key from a user input passphrase (i.e., password).
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.IKdf.Derive(System.String)">
            <summary>
            Derives a cryptographic key in <see cref="T:System.Byte"/>s from a user input
            <paramref name="passphrase"/>.
            </summary>
            <param name="passphrase">A user input passphrase.</param>
            <returns>A derived cryptographic key.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.IKdf.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <summary>
            Dumps the KDF parameters as a JSON representation.
            </summary>
            <param name="writer">A JSON writer which has not begun object nor array.</param>
            <returns>A unique identifier of the KDF.  This is going to be the
            <c>crypto.kdf</c> field in the key JSON file.</returns>
        </member>
        <member name="T:Libplanet.KeyStore.Kdfs.Pbkdf2`1">
            <summary>
            <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>.
            </summary>
            <typeparam name="T">PRF (pseudorandom function) to use, e.g.,
            <see cref="T:Org.BouncyCastle.Crypto.Digests.Sha256Digest"/>.</typeparam>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.#ctor(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>.
            </summary>
            <param name="iterations">The number of iterations desired.
            Corresponds to <c>c</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>.
            </summary>
            <param name="iterations">The number of iterations desired.
            Corresponds to <c>c</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Pbkdf2`1.Iterations">
            <summary>
            The number of iterations desired.  Corresponds to <c>c</c>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Pbkdf2`1.KeyLength">
            <summary>
            The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Pbkdf2`1.Salt">
            <summary>
            A cryptographic salt.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.Derive(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.KeyStore.Kdfs.Scrypt">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt</a>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.#ctor(System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt</a>.
            </summary>
            <param name="cost">The CPU/memory cost parameter. Corresponds to <c>n</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
            <param name="parallelization">The parallelization parameter.
            Corresponds to <c>p</c>.</param>
            <param name="blockSize">The blocksize parameter. Corresponds to <c>r</c>.</param>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt</a>.
            </summary>
            <param name="cost">The CPU/memory cost parameter. Corresponds to <c>n</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
            <param name="parallelization">The parallelization parameter.
            Corresponds to <c>p</c>.</param>
            <param name="blockSize">The blocksize parameter. Corresponds to <c>r</c>.</param>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.Cost">
            <summary>
            The CPU/memory cost parameter. Corresponds to <c>n</c>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.KeyLength">
            <summary>
            The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.Salt">
            <summary>
            A cryptographic salt.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.Parallelization">
            <summary>
            The parallelization parameter. Corresponds to <c>p</c>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.BlockSize">
            <summary>
            The blocksize parameter. Corresponds to <c>r</c>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.Derive(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.KeyStore.KeyJsonException">
            <summary>
            Serves as the base class for exceptions thrown by
            <see cref="M:Libplanet.KeyStore.ProtectedPrivateKey.FromJson(System.String)"/> method.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.KeyJsonException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.KeyJsonException"/> instance with a message.
            </summary>
            <param name="message">A detailed exception message.</param>
        </member>
        <member name="T:Libplanet.KeyStore.KeyStoreException">
            <summary>
            Serves as the base class for exceptions thrown by <see cref="T:Libplanet.KeyStore.IKeyStore"/>
            implementations.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.KeyStoreException.#ctor(System.String)">
            <summary>
            Initializes a new instance with the given <paramref name="message"/>.
            </summary>
            <param name="message">A descriptive error message for programmers.
            Goes to <see cref="P:System.Exception.Message"/>.</param>
        </member>
        <member name="T:Libplanet.KeyStore.MismatchedAddressException">
            <summary>
            The exception that is thrown when an unprotected private key's actual address does
            not match to the expected address.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.MismatchedAddressException.#ctor(System.String,Libplanet.Address@,Libplanet.Address@)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.MismatchedAddressException"/> object.
            </summary>
            <param name="message">The error message that explains the reason for the exception.
            </param>
            <param name="expectedAddress">The expected address of a protected private key.
            It is automatically included to the <paramref name="message"/> string.</param>
            <param name="actualAddress">The actual address of an unprotected private key.
            It is automatically included to the <paramref name="message"/> string.</param>
        </member>
        <member name="P:Libplanet.KeyStore.MismatchedAddressException.ExpectedAddress">
            <summary>
            The expected address of the protected private key.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.MismatchedAddressException.ActualAddress">
            <summary>
            The actual address of the unprotected private key.
            </summary>
        </member>
        <member name="T:Libplanet.KeyStore.NoKeyException">
            <summary>
            The exception that is thrown when there is no <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>
            with a given key ID in an <see cref="T:Libplanet.KeyStore.IKeyStore"/>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.NoKeyException.#ctor(System.Guid,System.String)">
            <summary>
            Instantiates a new exception object with proper metadata.
            </summary>
            <param name="keyId">The key ID tried to look for.
            It is automatically included to the <see cref="P:System.Exception.Message"/>
            string.
            </param>
            <param name="message">A descriptive error message for programmers.
            Goes to <see cref="P:System.Exception.Message"/>.</param>
        </member>
        <member name="P:Libplanet.KeyStore.NoKeyException.KeyId">
            <summary>
            The key ID tried to look for.
            </summary>
        </member>
        <member name="T:Libplanet.KeyStore.ProtectedPrivateKey">
            <summary>
            Protects a <see cref="T:Libplanet.Crypto.PrivateKey"/> with a passphrase (i.e., password).
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.#ctor(Libplanet.Address,Libplanet.KeyStore.Kdfs.IKdf,System.Byte[],Libplanet.KeyStore.Ciphers.ICipher,System.Byte[])">
            <summary>
            Loads a protected private key.
            </summary>
            <param name="address">The address of the protected private key.</param>
            <param name="kdf">A key derivation function to derive a symmetric key to decrypt
            a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="mac">MAC digest to check if a derived key is correct or not.</param>
            <param name="cipher">A symmetric cipher to decrypt a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="ciphertext">An encrypted <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.#ctor(Libplanet.Address,Libplanet.KeyStore.Kdfs.IKdf,System.Collections.Immutable.ImmutableArray{System.Byte},Libplanet.KeyStore.Ciphers.ICipher,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Loads a protected private key.
            </summary>
            <param name="address">The address of the protected private key.</param>
            <param name="kdf">A key derivation function to derive a symmetric key to decrypt
            a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="mac">MAC digest to check if a derived key is correct or not.</param>
            <param name="cipher">A symmetric cipher to decrypt a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="ciphertext">An encrypted <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Address">
            <summary>
            The address of the protected private key.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Kdf">
            <summary>
            A key derivation function to derive a symmetric key to decrypt
            a <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Cipher">
            <summary>
            A symmetric cipher to decrypt a <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Ciphertext">
            <summary>
            An encrypted <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.Protect(Libplanet.Crypto.PrivateKey,System.String)">
            <summary>
            Protects a bare <see cref="T:Libplanet.Crypto.PrivateKey"/> using a user input
            <paramref name="passphrase"/>.
            </summary>
            <param name="privateKey">A bare private key to protect.</param>
            <param name="passphrase">A user input passphrase (i.e., password).</param>
            <returns>A passphrase-protected private key.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.FromJson(System.String)">
            <summary>
            Loads a <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/> from a JSON, according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="json">A JSON string that encodes a <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>.
            </param>
            <returns>A protected private key loaded from the given <paramref name="json"/>.
            </returns>
            <exception cref="T:System.Text.Json.JsonException">Thrown when the given <paramref name="json"/> is not
            a valid JSON.</exception>
            <exception cref="T:Libplanet.KeyStore.InvalidKeyJsonException">Thrown when the given key data lacks some
            required fields or consists of wrong types.</exception>
            <exception cref="T:Libplanet.KeyStore.UnsupportedKeyJsonException">Thrown when the given key data depends on
            an unsupported features (e.g., KDF).</exception>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.Unprotect(System.String)">
            <summary>
            Gets the protected <see cref="T:Libplanet.Crypto.PrivateKey"/> using a user input
            <paramref name="passphrase"/>.
            </summary>
            <param name="passphrase">A user input passphrase (i.e., password).</param>
            <returns>A bare <see cref="T:Libplanet.Crypto.PrivateKey"/>.</returns>
            <exception cref="T:Libplanet.KeyStore.IncorrectPassphraseException">Thrown when the given
            <paramref name="passphrase"/> does not match to the <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>'s
            passphrase.</exception>
            <exception cref="T:Libplanet.KeyStore.MismatchedAddressException">Thrown when the unprotected
            <see cref="T:Libplanet.Crypto.PrivateKey"/> does not match to the expected <see cref="P:Libplanet.KeyStore.ProtectedPrivateKey.Address"/>.
            </exception>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.WriteJson(System.Text.Json.Utf8JsonWriter,System.Nullable{System.Guid}@)">
            <summary>
            Dumps the cipher parameters as a JSON representation according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="writer">A JSON writer which has not begun object nor array.</param>
            <param name="id">A unique identifier, which goes to the <c>id</c> field in the key JSON
            file.  If <c>null</c> (which is default) it is random-generated.</param>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.WriteJson(System.IO.Stream,System.Nullable{System.Guid}@)">
            <summary>
            Dumps the cipher parameters as a JSON representation according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="stream">The destination for writing JSON text.</param>
            <param name="id">A unique identifier, which goes to the <c>id</c> field in the key JSON
            file.  If <c>null</c> (which is default) it is random-generated.</param>
        </member>
        <member name="T:Libplanet.KeyStore.UnsupportedKeyJsonException">
            <summary>
            The exception that is thrown when a key JSON is valid but uses an unsupported feature,
            e.g., unsupported cipher algorithm.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.UnsupportedKeyJsonException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.UnsupportedKeyJsonException"/> instance with a message.
            </summary>
            <param name="message">A detailed exception message.</param>
        </member>
        <member name="T:Libplanet.KeyStore.Web3KeyStore">
            <summary>
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret
            Storage</a> (i.e., Ethereum-style key store) compliant <see cref="T:Libplanet.KeyStore.IKeyStore"/>
            implementation.  Key files are placed in a directory of the <see cref="P:Libplanet.KeyStore.Web3KeyStore.Path"/>.
            <para>Use <see cref="P:Libplanet.KeyStore.Web3KeyStore.DefaultKeyStore"/> property to get an instance.</para>
            <para>In order to get an instance with a customized directory,
            use the <see cref="M:Libplanet.KeyStore.Web3KeyStore.#ctor(System.String)"/> constructor.</para>
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.#ctor(System.String)">
            <summary>
            Creates a <see cref="T:Libplanet.KeyStore.Web3KeyStore"/> instance with a custom directory
            <paramref name="path"/>.
            </summary>
            <param name="path">A path of the directory to store key files.  A new directory is
            created if not exists.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>null</c> is passed to
            <paramref name="path"/>.</exception>
            <seealso cref="P:Libplanet.KeyStore.Web3KeyStore.DefaultKeyStore"/>
        </member>
        <member name="P:Libplanet.KeyStore.Web3KeyStore.DefaultKeyStore">
            <summary>
            A default <see cref="T:Libplanet.KeyStore.Web3KeyStore"/> instance which refers to a user-local directory.
            The <see cref="P:Libplanet.KeyStore.Web3KeyStore.Path"/> differs on the platform:
            <list type="table">
            <listheader>
            <term>OS</term>
            <description>Directory path</description>
            </listheader>
            <item>
            <term>Linux/macOS</term>
            <description><var>$HOME</var>/.config/planetarium/keystore</description>
            </item>
            <item>
            <term>Windows</term>
            <description><var>%AppData%</var>\planetarium\keystore</description>
            </item>
            </list>
            </summary>
            <seealso cref="M:Libplanet.KeyStore.Web3KeyStore.#ctor(System.String)"/>
        </member>
        <member name="P:Libplanet.KeyStore.Web3KeyStore.Path">
            <summary>
            The path of the directory key files are placed.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.List">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.ListIds">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.Get(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.Add(Libplanet.KeyStore.ProtectedPrivateKey)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.Remove(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Net.ActionExecutionState">
            <summary>
            Indicates a progress of executing block actions.
            </summary>
        </member>
        <member name="P:Libplanet.Net.ActionExecutionState.TotalBlockCount">
            <summary>
            Total number of blocks to execute in the current batch.
            </summary>
        </member>
        <member name="P:Libplanet.Net.ActionExecutionState.ExecutedBlockCount">
            <summary>
            The number of currently executed blocks.
            </summary>
        </member>
        <member name="P:Libplanet.Net.ActionExecutionState.ExecutedBlockHash">
            <summary>
            The hash digest of the block just executed.
            </summary>
        </member>
        <member name="P:Libplanet.Net.ActionExecutionState.CurrentPhase">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Net.AppProtocolVersion">
            <summary>
            A <em>claim</em> of a version.
            <para>Every peer in network shows others their <see cref="T:Libplanet.Net.AppProtocolVersion"/> information.
            As every peer can change its software by itself, this <see cref="T:Libplanet.Net.AppProtocolVersion"/>
            is theoretically arbitrary, hence a &#x201c;claim.&#x201d; (i.e., no authority).</para>
            <para>In order to verify who claimed a version, every <see cref="T:Libplanet.Net.AppProtocolVersion"/>
            has its <see cref="P:Libplanet.Net.AppProtocolVersion.Signature"/> which is made by its <see cref="F:Libplanet.Net.AppProtocolVersion.Signer"/>.
            <see cref="M:Libplanet.Net.AppProtocolVersion.Verify(Libplanet.Crypto.PublicKey)"/> method purposes to determine whether an information
            is claimed by its corresponding <see cref="F:Libplanet.Net.AppProtocolVersion.Signer"/> in fact.</para>
            </summary>
        </member>
        <member name="F:Libplanet.Net.AppProtocolVersion.Version">
            <summary>
            The version number.  This does not have to be increased by only 1, but can be more
            than that.
            </summary>
        </member>
        <member name="F:Libplanet.Net.AppProtocolVersion.Extra">
            <summary>
            Optional extra data about the version.  This can be used for any purpose
            by apps, such as a URL to download the software.
            </summary>
        </member>
        <member name="F:Libplanet.Net.AppProtocolVersion.Signer">
            <summary>
            A signer who claims presence of a version.
            </summary>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.#ctor(System.Int32,Bencodex.Types.IValue,System.Collections.Immutable.ImmutableArray{System.Byte},Libplanet.Address)">
            <summary>
            Initializes an <see cref="T:Libplanet.Net.AppProtocolVersion"/> value with field values.
            </summary>
            <param name="version">Sets the <see cref="F:Libplanet.Net.AppProtocolVersion.Version"/>.</param>
            <param name="extra">Sets the <see cref="F:Libplanet.Net.AppProtocolVersion.Extra"/>.</param>
            <param name="signature">Sets the <see cref="P:Libplanet.Net.AppProtocolVersion.Signature"/>.</param>
            <param name="signer">Gets the <see cref="F:Libplanet.Net.AppProtocolVersion.Signer"/>.</param>
        </member>
        <member name="P:Libplanet.Net.AppProtocolVersion.Signature">
            <summary>
            A signature which verifies <seealso cref="F:Libplanet.Net.AppProtocolVersion.Signer"/>'s claim of a version.
            </summary>
        </member>
        <member name="P:Libplanet.Net.AppProtocolVersion.Token">
            <summary>
            A token string which serializes an <see cref="T:Libplanet.Net.AppProtocolVersion"/>.
            <para>As this is designed to be easy to copy and paste, the format consists of only
            printable characters in the ASCII character set.</para>
            <para>A token can be deserialized into an <see cref="T:Libplanet.Net.AppProtocolVersion"/> through
            <see cref="M:Libplanet.Net.AppProtocolVersion.FromToken(System.String)"/> method.</para>
            </summary>
            <seealso cref="M:Libplanet.Net.AppProtocolVersion.FromToken(System.String)"/>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.Sign(Libplanet.Crypto.PrivateKey,System.Int32,Bencodex.Types.IValue)">
            <summary>
            Claim a <paramref name="version"/> with <paramref name="extra"/> data and sign it
            using the given private key.
            </summary>
            <param name="signer">A private key to sign the claim.</param>
            <param name="version">A version to claim.</param>
            <param name="extra">Extra data to claim.</param>
            <returns>A signed version claim.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="signer"/> is
            <c>null</c>.</exception>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.FromToken(System.String)">
            <summary>
            Deserializes a <see cref="P:Libplanet.Net.AppProtocolVersion.Token"/> into an <see cref="T:Libplanet.Net.AppProtocolVersion"/> object.
            </summary>
            <param name="token">A <see cref="P:Libplanet.Net.AppProtocolVersion.Token"/> string.</param>
            <returns>A deserialized <see cref="T:Libplanet.Net.AppProtocolVersion"/> object.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>null</c> is passed to
            <paramref name="token"/>.</exception>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="token"/>'s
            format is invalid.  The detailed reason is in the message.</exception>
            <seealso cref="P:Libplanet.Net.AppProtocolVersion.Token"/>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.Verify(Libplanet.Crypto.PublicKey)">
            <summary>
            Verifies whether the claim is certainly signed by the <see cref="F:Libplanet.Net.AppProtocolVersion.Signer"/>.
            </summary>
            <param name="publicKey">A public key of the <see cref="F:Libplanet.Net.AppProtocolVersion.Signer"/>.</param>
            <returns><c>true</c> if and only if the given <paramref name="publicKey"/> is
            <see cref="F:Libplanet.Net.AppProtocolVersion.Signer"/>'s and the <see cref="P:Libplanet.Net.AppProtocolVersion.Signature"/> is certainly signed by
            the <see cref="F:Libplanet.Net.AppProtocolVersion.Signer"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.Equals(Libplanet.Net.AppProtocolVersion)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Net.AppProtocolVersion.GetMessage(System.Int32,Bencodex.Types.IValue)">
            <summary>
            Gets a deterministic message to sign.
            </summary>
            <returns>A deterministic message to sign.</returns>
        </member>
        <member name="M:Libplanet.Net.BlockCompletion`2.Complete(System.Collections.Generic.IReadOnlyList{`0},Libplanet.Net.BlockCompletion{`0,`1}.BlockFetcher,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Downloads blocks from <paramref name="peers"/> in parallel,
            using the given <paramref name="blockFetcher"/> function.
            </summary>
            <param name="peers">A list of peers to download blocks.</param>
            <param name="blockFetcher">A function to take demands and a peer, and then
            download corresponding blocks.</param>
            <param name="singleSessionTimeout">A maximum time to wait each single call of
            <paramref name="blockFetcher"/>.  If a call is timed out unsatisfied demands
            are automatically retried to fetch from other peers.</param>
            <param name="cancellationToken">A cancellation token to observe while waiting
            for the task to complete.</param>
            <returns>An async enumerable that yields pairs of a fetched block and its source
            peer.  It terminates when all demands are satisfied.</returns>
        </member>
        <member name="M:Libplanet.Net.BlockCompletion`2.Complete(System.Collections.Generic.IReadOnlyList{`0},Libplanet.Net.BlockCompletion{`0,`1}.BlockFetcher,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Downloads blocks from <paramref name="peers"/> in parallel,
            using the given <paramref name="blockFetcher"/> function.
            </summary>
            <param name="peers">A list of peers to download blocks.</param>
            <param name="blockFetcher">A function to take demands and a peer, and then
            download corresponding blocks.</param>
            <param name="millisecondsSingleSessionTimeout">A maximum time in milliseconds to wait
            each single call of <paramref name="blockFetcher"/>.  If a call is timed out unsatisfied
            demands are automatically retried to fetch from other peers.  10 seconds by default.
            </param>
            <param name="cancellationToken">A cancellation token to observe while waiting
            for the task to complete.</param>
            <returns>An async enumerable that yields pairs of a fetched block and its source
            peer.  It terminates when all demands are satisfied.</returns>
        </member>
        <member name="T:Libplanet.Net.BlockDemand">
            <summary>
            Struct represents <see cref="T:Libplanet.Net.Swarm`1"/>'s block demand status.
            </summary>
        </member>
        <member name="F:Libplanet.Net.BlockDemand.Header">
            <summary>
            The <see cref="T:Libplanet.Blocks.BlockHeader"/> of the block to request.
            </summary>
        </member>
        <member name="F:Libplanet.Net.BlockDemand.Peer">
            <summary>
            The <see cref="T:Libplanet.Net.BoundPeer"/> to request block hash from.
            </summary>
        </member>
        <member name="F:Libplanet.Net.BlockDemand.Timestamp">
            <summary>
            The <see cref="T:System.DateTimeOffset"/> when
            the corresponding block information was received.
            </summary>
        </member>
        <member name="T:Libplanet.Net.BlockDownloadState">
            <summary>
            Indicates a progress of downloading blocks.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockDownloadState.TotalBlockCount">
            <summary>
            Total number of blocks to receive in the current batch.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockDownloadState.ReceivedBlockCount">
            <summary>
            The number of currently received blocks.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockDownloadState.ReceivedBlockHash">
            <summary>
            The hash digest of the block just received.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockDownloadState.CurrentPhase">
            <inheritdoc />
        </member>
        <member name="P:Libplanet.Net.BlockDownloadState.SourcePeer">
            <summary>
            The peer which sent the block.
            </summary>
        </member>
        <member name="T:Libplanet.Net.BlockHashDownloadState">
            <summary>
            Indicates a progress of downloading block hashes.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockHashDownloadState.EstimatedTotalBlockHashCount">
            <summary>
            The estimated number of block hashes to receive in the current batch.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockHashDownloadState.ReceivedBlockHashCount">
            <summary>
            The number of currently received block hashes.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockHashDownloadState.SourcePeer">
            <summary>
            The peer which sent the block hashes.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockHashDownloadState.CurrentPhase">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Net.BlockVerificationState">
            <summary>
            Indicates a progress of verifying blocks.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockVerificationState.TotalBlockCount">
            <summary>
            Total number of blocks to verify in the current batch.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockVerificationState.VerifiedBlockCount">
            <summary>
            The number of blocks that completed verification.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockVerificationState.VerifiedBlockHash">
            <summary>
            The hash digest of the block just verified.
            </summary>
        </member>
        <member name="P:Libplanet.Net.BlockVerificationState.CurrentPhase">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.BoundPeer.#ctor(Libplanet.Crypto.PublicKey,System.Net.DnsEndPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:Libplanet.Net.BoundPeer"/> class.
            </summary>
            <param name="publicKey">A <see cref="T:Libplanet.Crypto.PublicKey"/> of the
            <see cref="T:Libplanet.Net.Peer"/>.</param>
            <param name="endPoint">A <see cref="T:System.Net.DnsEndPoint"/> consisting of the
            host and port of the <see cref="T:Libplanet.Net.Peer"/>.</param>
        </member>
        <member name="P:Libplanet.Net.BoundPeer.EndPoint">
            <summary>
            The corresponding <see cref="T:System.Net.DnsEndPoint"/> of this peer.
            </summary>
        </member>
        <member name="M:Libplanet.Net.BoundPeer.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Net.BoundPeer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Net.DifferentAppProtocolVersionEncountered">
            <summary>
            A delegate called back when a <see cref="T:Libplanet.Net.Swarm`1"/> encounters
            a peer with different <see cref="T:Libplanet.Net.AppProtocolVersion"/> in the network.
            </summary>
            <param name="peer">An encountered peer with a different <see cref="T:Libplanet.Net.AppProtocolVersion"/>.
            </param>
            <param name="peerVersion">An encountered different <see cref="T:Libplanet.Net.AppProtocolVersion"/>.</param>
            <param name="localVersion">The currently running application's
            <see cref="T:Libplanet.Net.AppProtocolVersion"/>.</param>
            <returns>Whether to recognize the encountered <paramref name="peer"/> as a valid
            participant of the network or not.  The <paramref name="peer"/> is ignored if
            it returns <c>false</c>.</returns>
        </member>
        <member name="T:Libplanet.Net.DifferentAppProtocolVersionException">
            <summary>
            The exception that is thrown when the version of the
            <see cref="T:Libplanet.Net.Messages.Message" /> that <see cref="T:Libplanet.Net.Swarm`1" /> received
            is different.
            </summary>
        </member>
        <member name="M:Libplanet.Net.DifferentAppProtocolVersionException.#ctor(System.String,System.Byte[],Libplanet.Net.AppProtocolVersion,Libplanet.Net.AppProtocolVersion)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Net.DifferentAppProtocolVersionException"/> class.
            </summary>
            <param name="identity">The identity of the message received. Will have empty
            string if the message is a reply.</param>
            <param name="expectedVersion">The protocol version of the current
            <see cref="T:Libplanet.Net.Swarm`1"/>.</param>
            <param name="actualVersion">The protocol version of the
            <see cref="T:Libplanet.Net.Peer"/> that <see cref="T:Libplanet.Net.Swarm`1" /> is trying to connect
            to.</param>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="P:Libplanet.Net.DifferentAppProtocolVersionException.Identity">
            <summary>
            The identity of the message received.
            Will have <c>null</c> if the message is a reply.
            </summary>
        </member>
        <member name="P:Libplanet.Net.DifferentAppProtocolVersionException.ExpectedVersion">
            <summary>
            The protocol version of the current <see cref="T:Libplanet.Net.Swarm`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.DifferentAppProtocolVersionException.ActualVersion">
            <summary>
            The protocol version of the <see cref="T:Libplanet.Net.Peer"/> that the
            <see cref="T:Libplanet.Net.Swarm`1" /> is trying to connect to.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Messages.BlockHashes.StartIndex">
            <summary>
            The block index of the first hash in <see cref="P:Libplanet.Net.Messages.BlockHashes.Hashes"/>.
            It is <c>null</c> iff <see cref="P:Libplanet.Net.Messages.BlockHashes.Hashes"/> are empty.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Messages.BlockHashes.Hashes">
            <summary>
            The continuous block hashes, from the lowest index to the highest index.
            </summary>
        </member>
        <member name="T:Libplanet.Net.Messages.Message">
            <summary>
            Serves as the base class for messages used in <see cref="T:Libplanet.Net.Transports.ITransport"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.CommonFrames">
            <summary>
            The number of frames that all messages commonly contain.
            </summary>
        </member>
        <member name="T:Libplanet.Net.Messages.Message.MessageType">
            <summary>
            <c>Enum</c> represents the type of the <see cref="T:Libplanet.Net.Messages.Message"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.Ping">
            <summary>
            Check message to determine peer is alive.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.Pong">
            <summary>
            A reply to <see cref="F:Libplanet.Net.Messages.Message.MessageType.Ping"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.GetBlockHashes">
            <summary>
            Request to query block hashes.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.TxIds">
            <summary>
            Inventory to transfer transactions.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.GetBlocks">
            <summary>
            Request to query blocks.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.GetTxs">
            <summary>
            Request to query transactions.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.Blocks">
            <summary>
            Message containing serialized blocks.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.Tx">
            <summary>
            Message containing serialized transaction.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.FindNeighbors">
            <summary>
            Message containing request for nearby peers.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.Neighbors">
            <summary>
            Message containing nearby peers.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.BlockHeaderMessage">
            <summary>
            Message containing a single <see cref="T:Libplanet.Blocks.BlockHeader"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.BlockHashes">
            <summary>
            Message containing demand block hashes with their index numbers.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.GetChainStatus">
            <summary>
            Request current chain status of the peer.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.ChainStatus">
            <summary>
            A reply to <see cref="F:Libplanet.Net.Messages.Message.MessageType.GetChainStatus"/>.
            Contains the chain status of the peer at the moment.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageType.DifferentVersion">
            <summary>
            A reply to any messages with different <see cref="T:Libplanet.Net.AppProtocolVersion"/>.
            Contains the expected and actual <see cref="T:Libplanet.Net.AppProtocolVersion"/>
            value of the message.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageFrame.Version">
            <summary>
            Frame containing <see cref="T:Libplanet.Net.AppProtocolVersion"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageFrame.Type">
            <summary>
            Frame containing <see cref="T:Libplanet.Net.Messages.Message.MessageType"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageFrame.Peer">
            <summary>
            Frame containing the sender <see cref="F:Libplanet.Net.Messages.Message.MessageFrame.Peer"/> of the <see cref="T:Libplanet.Net.Messages.Message"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageFrame.Timestamp">
            <summary>
            Frame containing the datetime when the <see cref="T:Libplanet.Net.Messages.Message"/> is created.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Messages.Message.MessageFrame.Sign">
            <summary>
            Frame containing signature of the <see cref="T:Libplanet.Net.Messages.Message"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Messages.Message.Identity">
            <summary>
            <c>byte[]</c>-typed identity of the message.
            If a message B is the reply of the message A,
            B's identity must be set to A's identity.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Messages.Message.Version">
            <summary>
            <see cref="T:Libplanet.Net.AppProtocolVersion"/>-typed version of the
            <see cref="P:Libplanet.Net.Messages.Message.Remote"/>'s transport layer.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Messages.Message.Timestamp">
            <summary>
            The timestamp of the message is created.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Messages.Message.Remote">
            <summary>
            The sender <see cref="T:Libplanet.Net.Peer"/> of the message.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Messages.Message.Parse(NetMQ.NetMQMessage,System.Boolean,Libplanet.Net.AppProtocolVersion,System.Collections.Immutable.IImmutableSet{Libplanet.Crypto.PublicKey},Libplanet.Net.DifferentAppProtocolVersionEncountered,System.Nullable{System.TimeSpan})">
            <summary>
            Casts given <see cref="T:NetMQ.NetMQMessage"/>-typed <paramref name="raw"/> into
            <see cref="T:Libplanet.Net.Messages.Message"/> and checks its validity.
            <seealso cref="M:Libplanet.Net.Messages.Message.ToNetMQMessage(Libplanet.Crypto.PrivateKey,Libplanet.Net.Peer,System.DateTimeOffset,Libplanet.Net.AppProtocolVersion)"/>
            </summary>
            <param name="raw">A <see cref="T:NetMQ.NetMQMessage"/> to parse.</param>
            <param name="reply">A flag to express whether the target is a reply of other message.
            </param>
            <param name="localVersion">The <see cref="T:Libplanet.Net.AppProtocolVersion"/>-typed version of the
            local transport layer. <seealso cref="T:Libplanet.Net.Transports.ITransport"/></param>
            <param name="trustedAppProtocolVersionSigners"><see cref="T:Libplanet.Crypto.PublicKey"/>s of parties
            to trust <see cref="T:Libplanet.Net.AppProtocolVersion"/>s they signed.  To trust any party, pass
            <c>null</c>.</param>
            <param name="differentAppProtocolVersionEncountered">A delegate called back when a peer
            with one different from <paramref name="localVersion"/>, and their version is
            signed by a trusted party (i.e., <paramref name="trustedAppProtocolVersionSigners"/>).
            If this callback returns <c>false</c>, an encountered peer is ignored.  If this callback
            is omitted, all peers with different <see cref="T:Libplanet.Net.AppProtocolVersion"/>s are ignored.
            </param>
            <param name="lifetime">
            The lifetime of a message.
            Messages generated before this value from the current time are ignored.
            If <c>null</c> is given, messages will not be ignored by its timestamp.</param>
            <returns>A <see cref="T:Libplanet.Net.Messages.Message"/> parsed from <paramref name="raw"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when empty <paramref name="raw"/> is given.
            </exception>
            <exception cref="T:Libplanet.Net.DifferentAppProtocolVersionException">Thrown when
            <paramref name="localVersion"/> does not match with given <paramref name="raw"/>'s
            <see cref="P:Libplanet.Net.Messages.Message.Version"/>, and their version is signed by a trusted party
            (i.e., <paramref name="trustedAppProtocolVersionSigners"/>), and
            <paramref name="differentAppProtocolVersionEncountered"/> is <c>null</c> or its
            return value is <c>false</c>.</exception>
            <exception cref="T:Libplanet.Net.InvalidMessageException">Thrown when given <paramref name="raw"/>'s
            signer is invalid.</exception>
        </member>
        <member name="M:Libplanet.Net.Messages.Message.ToNetMQMessage(Libplanet.Crypto.PrivateKey,Libplanet.Net.Peer,System.DateTimeOffset,Libplanet.Net.AppProtocolVersion)">
            <summary>
            Casts the message to <see cref="T:NetMQ.NetMQMessage"/> with given <paramref name="key"/>,
            <paramref name="peer"/> and <paramref name="version"/>.
            </summary>
            <param name="key">A <see cref="T:Libplanet.Crypto.PrivateKey"/> to sign message.</param>
            <param name="peer"><see cref="T:Libplanet.Net.Peer"/>-typed representation of the
            sender's transport layer.
            <seealso cref="P:Libplanet.Net.Transports.ITransport.AsPeer"/></param>
            <param name="timestamp">The <see cref="T:System.DateTimeOffset"/> of the message is created.
            </param>
            <param name="version"><see cref="T:Libplanet.Net.AppProtocolVersion"/>-typed version of the
            transport layer.</param>
            <returns>A <see cref="T:NetMQ.NetMQMessage"/> containing the signed <see cref="T:Libplanet.Net.Messages.Message"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="peer"/> is
            <c>null</c>.</exception>
        </member>
        <member name="T:Libplanet.Net.Peer">
            <summary>
            A representation of peer node.
            </summary>
            <seealso cref="T:Libplanet.Net.Swarm`1"/>
        </member>
        <member name="P:Libplanet.Net.Peer.PublicKey">
            <summary>
            The corresponding <see cref="T:Libplanet.Crypto.PublicKey"/> of
            this peer.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Peer.Address">
            <summary>The peer's address which is derived from
            its <see cref="P:Libplanet.Net.Peer.PublicKey"/>.
            </summary>
            <seealso cref="P:Libplanet.Net.Peer.PublicKey"/>
        </member>
        <member name="M:Libplanet.Net.Peer.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Net.Peer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Net.PeerChainState">
            <summary>
            The blockchain state of <see cref="T:Libplanet.Net.BoundPeer"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PeerChainState.Peer">
            <summary>
            The peer with chain.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PeerChainState.TipIndex">
            <summary>
            The blockchain tip of the <see cref="P:Libplanet.Net.PeerChainState.Peer"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PeerChainState.TotalDifficulty">
            <summary>
            The total difficulty of the blockchain of the <see cref="P:Libplanet.Net.PeerChainState.Peer"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Net.PeerChainState.ToString">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Net.PeerState">
            <summary>
            Represents a <see cref="P:Libplanet.Net.PeerState.Peer"/>'s state in the routing table.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PeerState.Peer">
            <summary>
            <see cref="T:Libplanet.Net.BoundPeer"/> of the state.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PeerState.LastUpdated">
            <summary>
            Last time messages were exchanged.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PeerState.LastChecked">
            <summary>
            Last time the peer was verified.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PeerState.Latency">
            <summary>
            Delay of verification in milliseconds.
            </summary>
        </member>
        <member name="F:Libplanet.Net.PreloadState.TotalPhase">
            <summary>
            The number of total phases.
            </summary>
        </member>
        <member name="P:Libplanet.Net.PreloadState.CurrentPhase">
            <summary>
            The current phase.
            </summary>
        </member>
        <member name="T:Libplanet.Net.Protocols.IProtocol">
            <summary>
            An interface of protocol to discover peers from the distributed network.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Protocols.IProtocol.BootstrapAsync(System.Collections.Generic.IEnumerable{Libplanet.Net.BoundPeer},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Conducts peer discovery for given <paramref name="bootstrapPeers"/>.
            </summary>
            <param name="bootstrapPeers">A <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Libplanet.Net.Peer"/>s
            to bootstrap.</param>
            <param name="pingSeedTimeout">A timeout of waiting for the reply of <see cref="T:Libplanet.Net.Messages.Ping"/>
            message sent to seed <see cref="T:Libplanet.Net.Peer"/>.
            If <c>null</c> is given, the task never halts by itself
            even no any response was given from the the target seed.</param>
            <param name="findNeighborsTimeout">A timeout of waiting for the reply of
            <see cref="T:Libplanet.Net.Messages.FindNeighbors"/> message sent to seed <see cref="T:Libplanet.Net.Peer"/>.
            If <c>null</c> is given, task never halts by itself
            even the target seed gives no any response.</param>
            <param name="depth">Recursive operation depth to search peers from network.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.IProtocol.AddPeersAsync(System.Collections.Generic.IEnumerable{Libplanet.Net.Peer},System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Tries to add given <paramref name="peers"/> to routing table
            by sending <see cref="T:Libplanet.Net.Messages.Ping"/>.
            </summary>
            <param name="peers">The peers to add.</param>
            <param name="timeout">A timeout of waiting for the reply of <see cref="T:Libplanet.Net.Messages.Ping"/>
            message sent to <paramref name="peers"/>.
            If <c>null</c> is given, task never halts by itself
            even the target peer gives no any response.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.IProtocol.RefreshTableAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Checks whether <see cref="T:Libplanet.Net.Peer"/>s in <see cref="T:Libplanet.Net.Protocols.RoutingTable"/> is online by
            sending <see cref="T:Libplanet.Net.Messages.Ping"/>.
            </summary>
            <param name="maxAge">Maximum age of peer to validate.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.IProtocol.RebuildConnectionAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reconstructs network connection between peers on network.
            </summary>
            <param name="depth">Recursive operation depth to search peers from network.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.IProtocol.CheckReplacementCacheAsync(System.Threading.CancellationToken)">
            <summary>
            Checks the <see cref="T:Libplanet.Net.Protocols.KBucket"/> in the <see cref="T:Libplanet.Net.Protocols.RoutingTable"/> and if
            there is an empty <see cref="T:Libplanet.Net.Protocols.KBucket"/>, fill it with <see cref="T:Libplanet.Net.Peer"/>s
            in the <see cref="P:Libplanet.Net.Protocols.KBucket.ReplacementCache"/>.
            </summary>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="T:Libplanet.Net.Protocols.Kademlia">
            <summary>
            Commonly used constants and static functions for Kademlia distributed hash table.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Protocols.Kademlia.BucketSize">
            <summary>
            The size of a single bucket.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Protocols.Kademlia.TableSize">
            <summary>
            The number of buckets in the table.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Protocols.Kademlia.FindConcurrency">
            <summary>
            The number of concurrency in peer discovery.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Protocols.Kademlia.MaxDepth">
            <summary>
            Depth of the peer discovery operation.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Protocols.Kademlia.CalculateDistance(Libplanet.Address,Libplanet.Address)">
            <summary>
            Calculates xor distance between two address.
            </summary>
            <param name="left">First element to calculate distance.</param>
            <param name="right">Second element to calculate distance.</param>
            <returns>Distance between two addresses in <see cref="T:Libplanet.Address"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.Kademlia.CommonPrefixLength(Libplanet.Address,Libplanet.Address)">
            <summary>
            Calculates length of common prefix length
            by finding the index of first bit of xor value.
            </summary>
            <param name="left">First element to calculate common prefix length.</param>
            <param name="right">Second element to calculate common prefix length.</param>
            <returns>Length of the common prefix length.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.Kademlia.SortByDistance(System.Collections.Generic.IEnumerable{Libplanet.Net.BoundPeer},Libplanet.Address)">
            <summary>
            Sorts the element of the sequence from in ascending order of
            the distance with <paramref name="targetAddr"/>.
            </summary>
            <param name="peers">A sequence of values to order.</param>
            <param name="targetAddr">
            <see cref="T:Libplanet.Address"/> to calculate distance of element.</param>
            <returns>>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements are sorted
            according to the distance with <paramref name="targetAddr"/>.</returns>
        </member>
        <member name="T:Libplanet.Net.Protocols.KademliaProtocol">
            <summary>
            A Kademlia based peer discovery protocol.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.#ctor(Libplanet.Net.Protocols.RoutingTable,Libplanet.Net.Transports.ITransport,Libplanet.Address,System.Int32,System.Nullable{System.TimeSpan})">
            <summary>
            Creates a <see cref="T:Libplanet.Net.Protocols.KademliaProtocol"/> instance.
            </summary>
            <param name="table">
            The <see cref="T:Libplanet.Net.Protocols.RoutingTable"/> where <see cref="T:Libplanet.Net.Peer"/>s are stored.</param>
            <param name="transport"><see cref="T:Libplanet.Net.Transports.ITransport"/> to process messages.</param>
            <param name="address">The <see cref="T:Libplanet.Address"/> of the <see cref="T:Libplanet.Net.Peer"/>
            to be the reference point.</param>
            <param name="findConcurrency">The number of concurrency in peer discovery.</param>
            <param name="requestTimeout">
            A timeout of waiting for the reply of messages.
            If it's omitted or <c>null</c> is given, will automatically be set to 5 seconds.
            </param>
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.BootstrapAsync(System.Collections.Generic.IEnumerable{Libplanet.Net.BoundPeer},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.AddPeersAsync(System.Collections.Generic.IEnumerable{Libplanet.Net.Peer},System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.RefreshTableAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.CheckAllPeersAsync(System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Refreshes all peers in routing table.
            </summary>
            <param name="timeout">A timeout of waiting for the reply of messages.
            If <c>null</c> is given, the task never halts by itself
            even no any response was given from the the target peer.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.RebuildConnectionAsync(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.CheckReplacementCacheAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.FindSpecificPeerAsync(Libplanet.Address,System.Int32,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Use <see cref="T:Libplanet.Net.Messages.FindNeighbors"/> messages to to find a <see cref="T:Libplanet.Net.BoundPeer"/> with
            <see cref="T:Libplanet.Address"/> of <paramref name="target"/>.
            </summary>
            <param name="target">The <see cref="T:Libplanet.Address"/> to find.</param>
            <param name="depth">Target depth of recursive operation.</param>
            <param name="timeout"><see cref="T:System.TimeSpan"/> for waiting reply of
            <see cref="T:Libplanet.Net.Messages.FindNeighbors"/>.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>A <see cref="T:Libplanet.Net.BoundPeer"/> with <see cref="T:Libplanet.Address"/> of
            <paramref name="target"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.ValidateAsync(Libplanet.Net.BoundPeer,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Validate peer by send <see cref="T:Libplanet.Net.Messages.Ping"/> to <paramref name="peer"/>. If target peer
            does not responds, remove it from the table.
            </summary>
            <param name="peer">A <see cref="T:Libplanet.Net.BoundPeer"/> to validate.</param>
            <param name="timeout">Timeout for waiting reply of <see cref="T:Libplanet.Net.Messages.Ping"/>.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
            <exception cref="T:System.TimeoutException">
            Thrown when validation fails in given <paramref name="timeout"/>.
            </exception>
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.Update(Libplanet.Net.Peer)">
            <summary>
            Updates routing table when receiving a message. If corresponding bucket
            for remote peer is not full, just adds given <paramref name="rawPeer"/>.
            Otherwise, checks aliveness of the least recently used (LRU) peer
            and determine evict LRU peer or discard given <paramref name="rawPeer"/>.
            </summary>
            <param name="rawPeer"><see cref="T:Libplanet.Net.Peer"/> to update.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="rawPeer"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.FindPeerAsync(System.Collections.Concurrent.ConcurrentBag{Libplanet.Net.BoundPeer},System.Collections.Concurrent.ConcurrentBag{Libplanet.Net.BoundPeer},Libplanet.Address,Libplanet.Net.BoundPeer,System.Int32,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Send <see cref="T:Libplanet.Net.Messages.FindNeighbors"/> messages to <paramref name="viaPeer"/>
            to find <see cref="T:Libplanet.Net.Peer"/>s near <paramref name="target"/>.
            </summary>
            <param name="history">The <see cref="T:Libplanet.Net.Peer"/> that searched.</param>
            <param name="dialHistory">The <see cref="T:Libplanet.Net.Peer"/> that ping was sent.</param>
            <param name="target">The <see cref="T:Libplanet.Address"/> to find.</param>
            <param name="viaPeer">The target <see cref="T:Libplanet.Net.Peer"/> to send <see cref="T:Libplanet.Net.Messages.FindNeighbors"/>
            message. If null, selects 3 <see cref="T:Libplanet.Net.Peer"/>s from <see cref="T:Libplanet.Net.Protocols.RoutingTable"/> of
            self.</param>
            <param name="depth">Target depth of recursive operation.</param>
            <param name="timeout"><see cref="T:System.TimeSpan"/> for waiting reply of
            <see cref="T:Libplanet.Net.Messages.FindNeighbors"/>.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.KademliaProtocol.ProcessFoundAsync(System.Collections.Concurrent.ConcurrentBag{Libplanet.Net.BoundPeer},System.Collections.Concurrent.ConcurrentBag{Libplanet.Net.BoundPeer},System.Collections.Generic.IEnumerable{Libplanet.Net.BoundPeer},Libplanet.Address,System.Int32,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Process <see cref="T:Libplanet.Net.Peer"/>s that is replied by sending <see cref="T:Libplanet.Net.Messages.FindNeighbors"/>
            request.
            </summary>
            <param name="history"><see cref="T:Libplanet.Net.Peer"/>s that already searched.</param>
            <param name="dialHistory"><see cref="T:Libplanet.Net.Peer"/>s that ping sent.</param>
            <param name="found"><see cref="T:Libplanet.Net.Peer"/>s that found.</param>
            <param name="target">The target <see cref="T:Libplanet.Address"/> to search.</param>
            <param name="depth">Target depth of recursive operation. If -1 is given,
            it runs until the closest peer is found.</param>
            <param name="timeout"><see cref="T:System.TimeSpan"/> for next depth's
            <see cref="M:Libplanet.Net.Protocols.KademliaProtocol.FindPeerAsync(System.Collections.Concurrent.ConcurrentBag{Libplanet.Net.BoundPeer},System.Collections.Concurrent.ConcurrentBag{Libplanet.Net.BoundPeer},Libplanet.Address,Libplanet.Net.BoundPeer,System.Int32,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)"/> operation.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
            <exception cref="T:System.TimeoutException">Thrown when all peers that found are
            not online.</exception>
        </member>
        <member name="P:Libplanet.Net.Protocols.KBucket.Head">
            <summary>
            Most recently used peer.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Protocols.KBucket.Tail">
            <summary>
            Least recently used peer.
            </summary>
        </member>
        <member name="T:Libplanet.Net.Protocols.RoutingTable">
            <summary>
            Kademlia distributed hash table.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.#ctor(Libplanet.Address,System.Int32,System.Int32)">
            <summary>
            Creates a Kademlia distributed hash table instance.
            </summary>
            <param name="address"><see cref="T:Libplanet.Address"/> of this peer.</param>
            <param name="tableSize">The number of buckets in the table.</param>
            <param name="bucketSize">The size of a single bucket.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when <paramref name="tableSize"/> or <paramref name="bucketSize"/> is
            less then or equal to 0.</exception>
        </member>
        <member name="P:Libplanet.Net.Protocols.RoutingTable.TableSize">
            <summary>
            The number of buckets in the table.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Protocols.RoutingTable.BucketSize">
            <summary>
            The size of a single bucket.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Protocols.RoutingTable.Count">
            <summary>
            The number of peers in the table.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Protocols.RoutingTable.Peers">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of peers in the table.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Protocols.RoutingTable.PeerStates">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Libplanet.Net.PeerState"/> of peers in the table.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.AddPeer(Libplanet.Net.BoundPeer)">
            <summary>
            Adds the <paramref name="peer"/> to the table.
            </summary>
            <param name="peer">The <see cref="T:Libplanet.Net.BoundPeer"/> to add.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="peer"/> is
            <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="peer"/>'s
            <see cref="T:Libplanet.Address"/> is equal to the <see cref="T:Libplanet.Address"/> of self.</exception>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.Contains(Libplanet.Net.BoundPeer)">
            <summary>
            Determines whether the <see cref="T:Libplanet.Net.Protocols.RoutingTable"/> contains the specified key.
            </summary>
            <param name="peer">Key to locate in the <see cref="T:Libplanet.Net.Protocols.RoutingTable"/>.</param>
            <returns><see langword="true"/> if the <see cref="T:Libplanet.Net.Protocols.RoutingTable" /> contains
            an element with the specified key; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.GetPeer(Libplanet.Address)">
            <summary>
            Finds a <seealso cref="T:Libplanet.Net.BoundPeer"/> whose <see cref="T:Libplanet.Address"/> matches with
            the given <paramref name="addr"/> if it exits.
            </summary>
            <param name="addr">The <see cref="T:Libplanet.Address"/> to search.</param>
            <returns>A <see cref="T:Libplanet.Net.BoundPeer"/> whose <see cref="T:Libplanet.Address"/> matches
            the given <paramref name="addr"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.Clear">
            <summary>
            Removes all peers in the table.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.Neighbors(Libplanet.Net.Peer,System.Int32,System.Boolean)">
            <summary>
            Returns <paramref name="k"/> nearest peers to given parameter peer from routing table.
            Return value is already sorted with respect to target.
            </summary>
            <param name="target"><see cref="T:Libplanet.Net.Peer"/> to look up.</param>
            <param name="k">Number of peers to return.</param>
            <param name="includeTarget">A boolean value indicates to include a peer with
            <see cref="T:Libplanet.Address"/> of <paramref name="target"/> in return value or not.</param>
            <returns>An enumerable of <see cref="T:Libplanet.Net.BoundPeer"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.Neighbors(Libplanet.Address,System.Int32,System.Boolean)">
            <summary>
            Returns at most 2 * <paramref name="k"/> (2 * <paramref name="k"/> + 1 if
            <paramref name="includeTarget"/> is <c>true</c>) nearest peers to given parameter peer
            from routing table. Return value is sorted with respect to target.
            <seealso cref="M:Libplanet.Net.Protocols.Kademlia.SortByDistance(System.Collections.Generic.IEnumerable{Libplanet.Net.BoundPeer},Libplanet.Address)"/>
            </summary>
            <param name="target"><see cref="T:Libplanet.Address"/> to look up.</param>
            <param name="k">Number of peers to return.</param>
            <param name="includeTarget">A boolean value indicates to include a peer with
            <see cref="T:Libplanet.Address"/> of <paramref name="target"/> in return value or not.</param>
            <returns>An enumerable of <see cref="T:Libplanet.Net.BoundPeer"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Protocols.RoutingTable.Check(Libplanet.Net.BoundPeer,System.DateTimeOffset,System.DateTimeOffset)">
            <summary>
            Marks <paramref name="peer"/> checked and refreshes last checked time of the peer.
            </summary>
            <param name="peer">The <see cref="T:Libplanet.Net.Peer"/> to check.</param>
            <param name="start"><see cref="T:System.DateTimeOffset"/> at the beginning of the check.</param>
            <param name="end"><see cref="T:System.DateTimeOffset"/> at the end of the check.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="peer"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:Libplanet.Net.StateDownloadState">
            <summary>
            Indicates a progress of downloading states.
            </summary>
        </member>
        <member name="P:Libplanet.Net.StateDownloadState.TotalIterationCount">
            <summary>
            Total number of messages to receive in the current batch.
            </summary>
        </member>
        <member name="P:Libplanet.Net.StateDownloadState.ReceivedIterationCount">
            <summary>
            The number of received messages until now.
            </summary>
        </member>
        <member name="P:Libplanet.Net.StateDownloadState.CurrentPhase">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Swarm`1.#ctor(Libplanet.Blockchain.BlockChain{`0},Libplanet.Crypto.PrivateKey,Libplanet.Net.AppProtocolVersion,System.Int32,System.String,System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{Libplanet.Net.IceServer},Libplanet.Net.DifferentAppProtocolVersionEncountered,System.Collections.Generic.IEnumerable{Libplanet.Crypto.PublicKey},Libplanet.Net.SwarmOptions)">
            <summary>
            Creates a <see cref="T:Libplanet.Net.Swarm`1"/>.  This constructor in only itself does not start
            any communication with the network.
            </summary>
            <param name="blockChain">A blockchain to publicize on the network.</param>
            <param name="privateKey">A private key to sign messages.  The public part of
            this key become a part of its end address for being pointed by peers.</param>
            <param name="appProtocolVersion">An app protocol to comply.</param>
            <param name="workers">The number of background workers (i.e., threads).</param>
            <param name="host">A hostname to be a part of a public endpoint, that peers use when
            they connect to this node.  Note that this is not a hostname to listen to;
            <see cref="T:Libplanet.Net.Swarm`1"/> always listens to 0.0.0.0 &amp; ::/0.</param>
            <param name="listenPort">A port number to listen to.</param>
            <param name="iceServers">
            <a href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">ICE</a>
            servers to use for TURN/STUN.  Purposes to traverse NAT.</param>
            <param name="differentAppProtocolVersionEncountered">A delegate called back when a peer
            with one different from <paramref name="appProtocolVersion"/>, and their version is
            signed by a trusted party (i.e., <paramref name="trustedAppProtocolVersionSigners"/>).
            If this callback returns <c>false</c> an encountered peer is ignored.  If this callback
            is omitted all peers with different <see cref="P:Libplanet.Net.Swarm`1.AppProtocolVersion"/>s are ignored.
            </param>
            <param name="trustedAppProtocolVersionSigners"><see cref="T:Libplanet.Crypto.PublicKey"/>s of parties
            to trust <see cref="P:Libplanet.Net.Swarm`1.AppProtocolVersion"/>s they signed.  To trust any party, pass
            <c>null</c>, which is default.</param>
            <param name="options">Options for <see cref="T:Libplanet.Net.Swarm`1"/>.</param>
        </member>
        <member name="P:Libplanet.Net.Swarm`1.LastMessageTimestamp">
            <summary>
            The last time when any message was arrived.
            It can be <c>null</c> if no message has been arrived yet.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Swarm`1.BlockChain">
            <summary>
            The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance this <see cref="T:Libplanet.Net.Swarm`1"/> instance
            synchronizes with.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Swarm`1.BlockDemand">
            <summary>
            Information of <see cref="T:Libplanet.Net.Swarm`1"/>'s demand for new blocks.
            It is null when the <see cref="T:Libplanet.Net.Swarm`1"/> does not have any block to demand.
            <seealso cref="P:Libplanet.Net.Swarm`1.BlockDemand"/>
            </summary>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.WaitForRunningAsync">
            <summary>
            Waits until this <see cref="T:Libplanet.Net.Swarm`1"/> instance gets started to run.
            </summary>
            <seealso cref="M:Libplanet.Net.Transports.NetMQTransport.WaitForRunningAsync"/>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> completed when <see cref="P:Libplanet.Net.Transports.NetMQTransport.Running"/>
            property becomes <c>true</c>.</returns>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.StartAsync(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Starts to periodically synchronize the <see cref="P:Libplanet.Net.Swarm`1.BlockChain"/>.
            </summary>
            <param name="millisecondsDialTimeout">
            When the <see cref="T:Libplanet.Net.Swarm`1"/> tries to dial each peer in <see cref="P:Libplanet.Net.Swarm`1.Peers"/>,
            the dial-up is cancelled after this timeout, and it tries another peer.
            If <c>null</c> is given it never gives up dial-ups.
            </param>
            <param name="millisecondsBroadcastTxInterval">
            The time period of exchange of staged transactions.
            </param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns>An awaitable task without value.</returns>
            <exception cref="T:Libplanet.Net.SwarmException">Thrown when this <see cref="T:Libplanet.Net.Swarm`1"/> instance is
            already <see cref="P:Libplanet.Net.Swarm`1.Running"/>.</exception>
            <remarks>If the <see cref="P:Libplanet.Net.Swarm`1.BlockChain"/> has no blocks at all or there are long behind
            blocks to caught in the network this method could lead to unexpected behaviors, because
            this tries to render <em>all</em> actions in the behind blocks so that there are
            a lot of calls to methods of <see cref="P:Libplanet.Blockchain.BlockChain`1.Renderers"/> in a short
            period of time.  This can lead a game startup slow.  If you want to omit rendering of
            these actions in the behind blocks use <see cref=
            "M:Libplanet.Net.Swarm`1.PreloadAsync(System.Nullable{System.TimeSpan},System.IProgress{Libplanet.Net.PreloadState},System.Threading.CancellationToken)"
            /> method too.</remarks>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.StartAsync(System.TimeSpan,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Starts to periodically synchronize the <see cref="P:Libplanet.Net.Swarm`1.BlockChain"/>.
            </summary>
            <param name="dialTimeout">
            When the <see cref="T:Libplanet.Net.Swarm`1"/> tries to dial each peer in <see cref="P:Libplanet.Net.Swarm`1.Peers"/>,
            the dial-up is cancelled after this timeout, and it tries another peer.
            If <c>null</c> is given it never gives up dial-ups.
            </param>
            <param name="broadcastTxInterval">The time period of exchange of staged transactions.
            </param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns>An awaitable task without value.</returns>
            <exception cref="T:Libplanet.Net.SwarmException">Thrown when this <see cref="T:Libplanet.Net.Swarm`1"/> instance is
            already <see cref="P:Libplanet.Net.Swarm`1.Running"/>.</exception>
            <remarks>If the <see cref="P:Libplanet.Net.Swarm`1.BlockChain"/> has no blocks at all or there are long behind
            blocks to caught in the network this method could lead to unexpected behaviors, because
            this tries to render <em>all</em> actions in the behind blocks so that there are
            a lot of calls to methods of <see cref="P:Libplanet.Blockchain.BlockChain`1.Renderers"/> in a short
            period of time.  This can lead a game startup slow.  If you want to omit rendering of
            these actions in the behind blocks use <see cref=
            "M:Libplanet.Net.Swarm`1.PreloadAsync(System.Nullable{System.TimeSpan},System.IProgress{Libplanet.Net.PreloadState},System.Threading.CancellationToken)"
            /> method too.</remarks>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.BootstrapAsync(System.Collections.Generic.IEnumerable{Libplanet.Net.Peer},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Join to the peer-to-peer network using seed peers.
            </summary>
            <param name="seedPeers">List of seed peers.</param>
            <param name="pingSeedTimeout">Timeout for connecting to seed peers.</param>
            <param name="findNeighborsTimeout">Timeout for requesting neighbors.</param>
            <param name="depth">Depth to find neighbors of current <see cref="T:Libplanet.Net.Peer"/>
            from seed peers.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
            <exception cref="T:Libplanet.Net.SwarmException">Thrown when this <see cref="T:Libplanet.Net.Swarm`1"/> instance is
            not <see cref="P:Libplanet.Net.Swarm`1.Running"/>.</exception>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.GetPeerChainStateAsync(System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Libplanet.Net.PeerChainState"/> of the connected <see cref="P:Libplanet.Net.Swarm`1.Peers"/>.
            </summary>
            <param name="dialTimeout">
            When the <see cref="T:Libplanet.Net.Swarm`1"/> tries to dial each peer in <see cref="P:Libplanet.Net.Swarm`1.Peers"/>,
            the dial-up is cancelled after this timeout, and it tries another peer.
            If <c>null</c> is given it never gives up dial-ups.
            </param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns><see cref="T:Libplanet.Net.PeerChainState"/> of the connected <see cref="P:Libplanet.Net.Swarm`1.Peers"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.PreloadAsync(System.Nullable{System.TimeSpan},System.IProgress{Libplanet.Net.PreloadState},System.Threading.CancellationToken)">
            <summary>
            Preemptively downloads blocks from registered <see cref="T:Libplanet.Net.Peer"/>s.
            </summary>
            <param name="dialTimeout">
            When the <see cref="T:Libplanet.Net.Swarm`1"/> tries to dial each peer in <see cref="P:Libplanet.Net.Swarm`1.Peers"/>,
            the dial-up is cancelled after this timeout, and it tries another peer.
            If <c>null</c> is given it never gives up dial-ups.
            </param>
            <param name="progress">
            An instance that receives progress updates for block downloads.
            </param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns>
            A task without value.
            You only can <c>await</c> until the method is completed.
            </returns>
            <remarks>This does not render downloaded <see cref="T:Libplanet.Action.IAction"/>s, but fills states only.
            </remarks>
            <exception cref="T:System.AggregateException">Thrown when the given the block downloading is
            failed.</exception>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.FindSpecificPeerAsync(Libplanet.Address,System.Int32,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Use <see cref="T:Libplanet.Net.Messages.FindNeighbors"/> messages to to find a <see cref="T:Libplanet.Net.BoundPeer"/> with
            <see cref="P:Libplanet.Net.Swarm`1.Address"/> of <paramref name="target"/>.
            </summary>
            <param name="target">The <see cref="P:Libplanet.Net.Swarm`1.Address"/> to find.</param>
            <param name="depth">Target depth of recursive operation. If -1 is given,
            will recursive until the closest <see cref="T:Libplanet.Net.BoundPeer"/> to the
            <paramref name="target"/> is found.</param>
            <param name="timeout">
            <see cref="T:System.TimeSpan"/> for waiting reply of <see cref="T:Libplanet.Net.Messages.FindNeighbors"/>.
            If <c>null</c> is given, <see cref="T:System.TimeoutException"/> will not be thrown.
            </param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>
            A <see cref="T:Libplanet.Net.BoundPeer"/> with <see cref="P:Libplanet.Net.Swarm`1.Address"/> of <paramref name="target"/>.
            Returns <c>null</c> if the peer with address does not exist.
            </returns>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.CheckAllPeersAsync(System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Validates all <see cref="T:Libplanet.Net.Peer"/>s in the routing table by sending a simple message.
            </summary>
            <param name="timeout">Timeout for this operation. If it is set to <c>null</c>,
            wait infinitely until the requested operation is finished.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Swarm`1.AddPeersAsync(System.Collections.Generic.IEnumerable{Libplanet.Net.Peer},System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Adds <paramref name="peers"/> to routing table by sending a simple message.
            </summary>
            <param name="peers">A list of peers to add.</param>
            <param name="timeout">Timeout for this operation. If it is set to <c>null</c>,
            wait infinitely until the requested operation is finished.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.MaxTimeout">
            <summary>
            The maximum timeout used in <see cref="T:Libplanet.Net.Swarm`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.BlockHashRecvTimeout">
            <summary>
            The base timeout used to receive the block hashes from other peers.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.BlockRecvTimeout">
            <summary>
            The base timeout used to receive <see cref="T:Libplanet.Blocks.Block`1"/> from other peers.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.TxRecvTimeout">
            <summary>
            The base timeout used to receive <see cref="T:Libplanet.Tx.Transaction`1"/> from other peers.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.RecentStateRecvTimeout">
            <summary>
            The timeout used to receive recent states from other peers.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.BlockDownloadTimeout">
            <summary>
            The timeout used to block download in preloading.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.BlockDemandLifespan">
            <summary>
            The lifespan of block demand.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.MessageLifespan">
            <summary>
            The lifespan of <see cref="T:Libplanet.Net.Messages.Message"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.RefreshPeriod">
            <summary>
            The frequency of <see cref="M:Libplanet.Net.Protocols.IProtocol.RefreshTableAsync(System.TimeSpan,System.Threading.CancellationToken)" />.
            </summary>
        </member>
        <member name="P:Libplanet.Net.SwarmOptions.RefreshLifespan">
            <summary>
            The lifespan of <see cref="T:Libplanet.Net.Peer"/> in routing table.
            <seealso cref="M:Libplanet.Net.Protocols.IProtocol.RefreshTableAsync(System.TimeSpan,System.Threading.CancellationToken)" />
            </summary>
        </member>
        <member name="T:Libplanet.Net.Transports.BoundPeerExtensions">
            <summary>
            This extension class activates transport-oriented methods on <see cref="T:Libplanet.Net.BoundPeer"/>.
            </summary>
            <seealso cref="T:Libplanet.Net.BoundPeer"/>
        </member>
        <member name="M:Libplanet.Net.Transports.BoundPeerExtensions.QueryAppProtocolVersion(Libplanet.Net.BoundPeer,System.Nullable{System.TimeSpan})">
            <summary>
            Queries <see cref="T:Libplanet.Net.AppProtocolVersion"/> of given <see cref="T:Libplanet.Net.BoundPeer"/>.
            </summary>
            <param name="peer">The <see cref="T:Libplanet.Net.BoundPeer"/> to query
            <see cref="T:Libplanet.Net.AppProtocolVersion"/>.</param>
            <param name="timeout">Timeout value for request.</param>
            <returns><see cref="T:Libplanet.Net.AppProtocolVersion"/> of given peer. </returns>
        </member>
        <member name="T:Libplanet.Net.Transports.ITransport">
            <summary>
            An interface to handle peer-to-peer networking, including <see cref="T:Libplanet.Net.Messages.Message"/> exchanging
            and <see cref="T:Libplanet.Net.Peer"/> managing.
            </summary>
        </member>
        <member name="E:Libplanet.Net.Transports.ITransport.ProcessMessageHandler">
            <summary>
            The <see cref="T:System.EventHandler"/> invoked when a message that is not
            a reply is received. To handle reply, please use <see cref=
            "M:Libplanet.Net.Transports.ITransport.SendMessageWithReplyAsync(Libplanet.Net.BoundPeer,Libplanet.Net.Messages.Message,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Transports.ITransport.AsPeer">
            <summary>
            <see cref="T:Libplanet.Net.Peer"/> representation of <see cref="T:Libplanet.Net.Transports.ITransport"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Transports.ITransport.LastMessageTimestamp">
            <summary>
            The <see cref="T:System.DateTimeOffset"/> of the last message was received.
            </summary>
        </member>
        <member name="P:Libplanet.Net.Transports.ITransport.Running">
            <summary>
            Whether this <see cref="T:Libplanet.Net.Transports.ITransport"/> instance is running.
            </summary>
            <value>Gets the value indicates whether the instance is running.</value>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Initiates transport layer.
            </summary>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.RunAsync(System.Threading.CancellationToken)">
            <summary>
            Starts running transport layer. To <see cref="M:Libplanet.Net.Transports.ITransport.RunAsync(System.Threading.CancellationToken)"/>, you should call
            <see cref="M:Libplanet.Net.Transports.ITransport.StartAsync(System.Threading.CancellationToken)"/> first.
            </summary>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.StopAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Stops running transport layer.
            </summary>
            <param name="waitFor">The <see cref="T:System.TimeSpan"/> of delay
            before actual stopping.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.SendMessageAsync(Libplanet.Net.BoundPeer,Libplanet.Net.Messages.Message,System.Threading.CancellationToken)">
            <summary>
            Sends the <paramref name="message"/> to given <paramref name="peer"/>.
            </summary>
            <param name="peer">A <see cref="T:Libplanet.Net.Peer"/> to send message to.</param>
            <param name="message">A <see cref="T:Libplanet.Net.Messages.Message"/> to send.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>An awaitable task without value.</returns>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.SendMessageWithReplyAsync(Libplanet.Net.BoundPeer,Libplanet.Net.Messages.Message,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Sends the <paramref name="message"/>
            to given <paramref name="peer"/> and waits for its single reply.
            </summary>
            <param name="peer">A <see cref="T:Libplanet.Net.Peer"/> to send message to.</param>
            <param name="message">A <see cref="T:Libplanet.Net.Messages.Message"/> to send.</param>
            <param name="timeout">A timeout of waiting for the reply of the message.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>The replies of the <paramref name="message"/>
            sent by <paramref name="peer"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.SendMessageWithReplyAsync(Libplanet.Net.BoundPeer,Libplanet.Net.Messages.Message,System.Nullable{System.TimeSpan},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Sends the <paramref name="message"/>
            to given <paramref name="peer"/> and waits for its multiple replies.
            </summary>
            <param name="peer">A <see cref="T:Libplanet.Net.Peer"/> to send message to.</param>
            <param name="message">A <see cref="T:Libplanet.Net.Messages.Message"/> to send.</param>
            <param name="timeout">A timeout of waiting for the reply of the message.</param>
            <param name="expectedResponses">The number of expected replies for the message.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.</param>
            <returns>The replies of the <paramref name="message"/>
            sent by <paramref name="peer"/>.</returns>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.BroadcastMessage(System.Nullable{Libplanet.Address},Libplanet.Net.Messages.Message)">
            <summary>
            Broadcasts the <paramref name="message"/> to peers selected from the routing table.
            </summary>
            <param name="except">An <see cref="T:Libplanet.Address"/> to exclude from broadcasting.
            If <c>null</c> is given, no peers will be excluded.</param>
            <param name="message">A <see cref="T:Libplanet.Net.Messages.Message"/> to broadcast.</param>
        </member>
        <member name="M:Libplanet.Net.Transports.ITransport.ReplyMessage(Libplanet.Net.Messages.Message)">
            <summary>
            Replies message.
            </summary>
            <remarks>
            The <see cref="P:Libplanet.Net.Messages.Message.Identity"/> of the given <paramref name="message"/> must be
            matched to <see cref="P:Libplanet.Net.Messages.Message.Identity"/> of a message corresponding to the given
            <paramref name="message"/>.
            </remarks>
            <param name="message">A <see cref="T:Libplanet.Net.Messages.Message"/> to reply.</param>
        </member>
        <member name="T:Libplanet.Net.Transports.NetMQTransport">
            <summary>
            Implementation of <see cref="T:Libplanet.Net.Transports.ITransport"/> interface using NetMQ.
            </summary>
        </member>
        <member name="F:Libplanet.Net.Transports.NetMQTransport._differentAppProtocolVersionEncountered">
            <summary>
            The <see cref="T:System.EventHandler" /> triggered when the different version of
            <see cref="T:Libplanet.Net.Peer" /> is discovered.
            </summary>
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.#ctor(Libplanet.Net.Protocols.RoutingTable,Libplanet.Crypto.PrivateKey,Libplanet.Net.AppProtocolVersion,System.Collections.Immutable.IImmutableSet{Libplanet.Crypto.PublicKey},System.Int32,System.String,System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{Libplanet.Net.IceServer},Libplanet.Net.DifferentAppProtocolVersionEncountered,System.Nullable{System.TimeSpan})">
            <summary>
            Creates <see cref="T:Libplanet.Net.Transports.NetMQTransport"/> instance.
            </summary>
            <param name="table">
            The <see cref="T:Libplanet.Net.Protocols.RoutingTable"/> that manages <see cref="T:Libplanet.Net.Peer"/>s which are connected
            with this <see cref="T:Libplanet.Net.Peer"/>.
            </param>
            <param name="privateKey"><see cref="T:Libplanet.Crypto.PrivateKey"/> of the transport layer.</param>
            <param name="appProtocolVersion"><see cref="T:Libplanet.Net.AppProtocolVersion"/>-typed
            version of the transport layer.</param>
            <param name="trustedAppProtocolVersionSigners"><see cref="T:Libplanet.Crypto.PublicKey"/>s of parties
            to trust <see cref="T:Libplanet.Net.AppProtocolVersion"/>s they signed.  To trust any party, pass
            <c>null</c>.</param>
            <param name="workers">The number of background workers (i.e., threads).</param>
            <param name="host">A hostname to be a part of a public endpoint, that peers use when
            they connect to this node.  Note that this is not a hostname to listen to;
            <see cref="T:Libplanet.Net.Transports.NetMQTransport"/> always listens to 0.0.0.0 &amp; ::/0.</param>
            <param name="listenPort">A port number to listen to.</param>
            <param name="iceServers">
            <a href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">ICE</a>
            servers to use for TURN/STUN.  Purposes to traverse NAT.</param>
            <param name="differentAppProtocolVersionEncountered">A delegate called back when a peer
            with one different from <paramref name="appProtocolVersion"/>, and their version is
            signed by a trusted party (i.e., <paramref name="trustedAppProtocolVersionSigners"/>).
            If this callback returns <c>false</c>, an encountered peer is ignored.  If this callback
            is omitted, all peers with different <see cref="T:Libplanet.Net.AppProtocolVersion"/>s are ignored.
            </param>
            <param name="messageLifespan">
            The lifespan of a message.
            Messages generated before this value from the current time are ignored.
            If <c>null</c> is given, messages will not be ignored by its timestamp.</param>
            <exception cref="T:System.ArgumentException">Thrown when both <paramref name="host"/> and
            <paramref name="iceServers"/> are <c>null</c>.</exception>
        </member>
        <member name="E:Libplanet.Net.Transports.NetMQTransport.ProcessMessageHandler">
            <inheritdoc />
        </member>
        <member name="P:Libplanet.Net.Transports.NetMQTransport.AsPeer">
            <inheritdoc cref="P:Libplanet.Net.Transports.ITransport.AsPeer"/>
        </member>
        <member name="P:Libplanet.Net.Transports.NetMQTransport.LastMessageTimestamp">
            <inheritdoc cref="P:Libplanet.Net.Transports.ITransport.LastMessageTimestamp"/>
        </member>
        <member name="P:Libplanet.Net.Transports.NetMQTransport.Running">
            <inheritdoc cref="P:Libplanet.Net.Transports.ITransport.Running"/>
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.StartAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.RunAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.StopAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.WaitForRunningAsync">
            <summary>
            Waits until this <see cref="T:Libplanet.Net.Transports.NetMQTransport"/> instance gets started to run.
            </summary>
            <seealso cref="M:Libplanet.Net.Swarm`1.WaitForRunningAsync"/>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> completed when <see cref="P:Libplanet.Net.Transports.NetMQTransport.Running"/>
            property becomes <c>true</c>.</returns>
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.SendMessageAsync(Libplanet.Net.BoundPeer,Libplanet.Net.Messages.Message,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.SendMessageWithReplyAsync(Libplanet.Net.BoundPeer,Libplanet.Net.Messages.Message,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.SendMessageWithReplyAsync(Libplanet.Net.BoundPeer,Libplanet.Net.Messages.Message,System.Nullable{System.TimeSpan},System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.BroadcastMessage(System.Nullable{Libplanet.Address},Libplanet.Net.Messages.Message)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Net.Transports.NetMQTransport.ReplyMessage(Libplanet.Net.Messages.Message)">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Nonce">
            <summary>
            An arbitrary <see cref="T:System.Byte"/>s that determines a
            <see cref="T:Libplanet.Hashcash.Stamp"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Nonce.#ctor(System.Byte[])">
            <summary>
            Converts a <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Nonce"/>
            value.
            <para>This constructor is an inverse function of
            <see cref="M:Libplanet.Nonce.ToByteArray"/> method.</para>
            </summary>
            <param name="nonce">A <see cref="T:System.Byte"/> array to convert to
            a <see cref="T:Libplanet.Nonce"/> object.  It must not be <c>null</c>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="nonce"/> is a <c>null</c>.</exception>
            <seealso cref="M:Libplanet.Nonce.ToByteArray"/>
        </member>
        <member name="P:Libplanet.Nonce.ByteArray">
            <summary>
            A bare immutable <see cref="T:System.Byte"/> array of the nonce.
            </summary>
            <remarks>It is immutable.  For a mutable array, use
            <see cref="M:Libplanet.Nonce.ToByteArray"/> method instead.</remarks>
            <seealso cref="M:Libplanet.Nonce.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Nonce.ToByteArray">
            <summary>
            Gets a bare mutable <see cref="T:System.Byte"/> array of the nonce.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array of the nonce.
            Since a returned array is created every time the method is called,
            any mutations on that array does not affect to
            the <see cref="T:Libplanet.Nonce"/> object.
            </returns>
            <seealso cref="P:Libplanet.Nonce.ByteArray"/>
        </member>
        <member name="M:Libplanet.Nonce.ToString">
            <summary>
            Gets a hexadecimal representation of a <see cref="T:Libplanet.Nonce"/>.
            </summary>
            <returns>A hexadecimal representation of a <see cref="T:Libplanet.Nonce"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ListChainIds">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetCanonicalChainId">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.SetCanonicalChainId(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.ForkBlockIndexes(System.Guid,System.Guid,Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.StageTransactionIds(System.Collections.Immutable.IImmutableSet{Libplanet.Tx.TxId})">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.IterateStagedTransactionIds">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetBlock``1(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetBlockIndex(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetBlockDigest(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.PutBlock``1(Libplanet.Blocks.Block{``0})">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.ContainsBlock(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.SetBlockPerceivedTime(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.DateTimeOffset)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetBlockPerceivedTime(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ListTxNonces(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetTxNonce(System.Guid,Libplanet.Address)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ContainsTransaction(Libplanet.Tx.TxId)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.BaseStore.DeleteChainId(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ForkTxNonces(System.Guid,System.Guid)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.ChainIdNotFoundException">
            <summary>
            The exception that is thrown when a chain ID does not exist in
            an <see cref="T:Libplanet.Store.IStore"/> object.
            </summary>
        </member>
        <member name="M:Libplanet.Store.ChainIdNotFoundException.#ctor(System.Guid,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Libplanet.Store.ChainIdNotFoundException"/> class.
            </summary>
            <param name="chainId">The ID of the chain not found.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Store.ChainIdNotFoundException.ChainId">
            <summary>
            Gets the ID of the chain not found.
            </summary>
        </member>
        <member name="T:Libplanet.Store.DefaultStore">
            <summary>
            The default built-in <see cref="T:Libplanet.Store.IStore"/> implementation.  This stores data in
            the file system or in memory.  It also uses <a href="https://www.litedb.org/">LiteDB</a>
            for some complex indices.
            </summary>
            <seealso cref="T:Libplanet.Store.IStore"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <seealso cref="T:Libplanet.Store.DefaultStore"/>.
            </summary>
            <param name="path">The path of the directory where the storage files will be saved.
            If the path is <c>null</c>, the database is created in memory.</param>
            <param name="compress">Whether to compress data.  Does not compress by default.</param>
            <param name="journal">
            Enables or disables double write check to ensure durability.
            </param>
            <param name="indexCacheSize">Max number of pages in the index cache.</param>
            <param name="blockCacheSize">The capacity of the block cache.</param>
            <param name="txCacheSize">The capacity of the transaction cache.</param>
            <param name="statesCacheSize">The capacity of the states cache.</param>
            <param name="flush">Writes data direct to disk avoiding OS cache.  Turned on by default.
            </param>
            <param name="readOnly">Opens database readonly mode. Turned off by default.</param>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ListChainIds">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.DeleteChainId(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetCanonicalChainId">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.DefaultStore.SetCanonicalChainId(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.DefaultStore.CountIndex(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IndexBlockHash(System.Guid,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.AppendIndex(System.Guid,Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ForkBlockIndexes(System.Guid,System.Guid,Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.StageTransactionIds(System.Collections.Immutable.IImmutableSet{Libplanet.Tx.TxId})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.UnstageTransactionIds(System.Collections.Generic.ISet{Libplanet.Tx.TxId})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IterateStagedTransactionIds">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IterateTransactionIds">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetTransaction``1(Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PutTransaction``1(Libplanet.Tx.Transaction{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.DeleteTransaction(Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ContainsTransaction(Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IterateBlockHashes">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetBlockDigest(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PutBlock``1(Libplanet.Blocks.Block{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.DeleteBlock(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ContainsBlock(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.SetBlockPerceivedTime(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.DateTimeOffset)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetBlockPerceivedTime(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ListTxNonces(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetTxNonce(System.Guid,Libplanet.Address)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ForkTxNonces(System.Guid,System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.CountTransactions">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.CountBlocks">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.IStateStore">
            <summary>
            An interface to store states.
            </summary>
        </member>
        <member name="M:Libplanet.Store.IStateStore.SetStates``1(Libplanet.Blocks.Block{``0},System.Collections.Immutable.IImmutableDictionary{System.String,Bencodex.Types.IValue})">
            <summary>
            Sets states mapped as relation <see cref="P:Libplanet.Blocks.Block`1.Hash"/> → states.
            It guarantees <see cref="M:Libplanet.Store.IStateStore.GetState(System.String,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Nullable{System.Guid})"/> will return the same state if you passed same
            <paramref name="block"/> unless it has overwritten.
            </summary>
            <param name="block">The <see cref="T:Libplanet.Blocks.Block`1"/> to set states.</param>
            <param name="states">The dictionary of state keys to states.</param>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type. It should match to
            <paramref name="block"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStateStore.GetState(System.String,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Nullable{System.Guid})">
            <summary>
            Gets state queried by <paramref name="stateKey"/> in the point,
            <paramref name="blockHash"/>.
            </summary>
            <param name="stateKey">The key to query state.</param>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> which the point to query by
            <paramref name="stateKey"/> at.</param>
            <param name="chainId">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Id"/> of wanted got.</param>
            <returns>The state queried from <paramref name="blockHash"/> and
            <paramref name="stateKey"/>. If it couldn't find state, returns <c>null</c>.</returns>
        </member>
        <member name="M:Libplanet.Store.IStateStore.ContainsBlockStates(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Checks if the states corresponded to the block derived from <paramref name="blockHash"/>
            exist.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of <see cref="T:Libplanet.Blocks.Block`1"/>.
            </param>
            <returns>Whether it contains the block states corresponded to
            <paramref name="blockHash"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.IStateStore.ForkStates``1(System.Guid,System.Guid,Libplanet.Blocks.Block{``0})">
            <summary>
            Copies metadata related to states from <paramref name="sourceChainId"/> to
            <paramref name="destinationChainId"/>, with <paramref name="branchpoint"/>.
            </summary>
            <param name="sourceChainId">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Id"/> of the chain which
            copies from.</param>
            <param name="destinationChainId">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Id"/> of the chain which
            copies to.</param>
            <param name="branchpoint">The branchpoint to begin coping.</param>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <paramref name="branchpoint"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStore.ListChainIds">
            <summary>
            Lists existing chain IDs.
            </summary>
            <returns>Existing chain IDs.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.DeleteChainId(System.Guid)">
            <summary>
            Deletes an index, tx nonces, and state references in the given
            <paramref name="chainId"/>.
            It also deletes chain itself.  If there is no such <paramref name="chainId"/> it
            does nothing.
            </summary>
            <param name="chainId">The ID of chain to delete.</param>
            <remarks>This does not delete blocks or transactions that belong to the index of
            the <paramref name="chainId"/>, but only the index, tx nonces, and state references.
            </remarks>
        </member>
        <member name="M:Libplanet.Store.IStore.GetCanonicalChainId">
            <summary>
            Gets the ID of the current canonical chain.
            </summary>
            <returns>The ID of the current canonical chain.  Maybe <c>null</c>.</returns>
            <seealso cref="M:Libplanet.Store.IStore.SetCanonicalChainId(System.Guid)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.SetCanonicalChainId(System.Guid)">
            <summary>
            Sets the canonical chain.
            </summary>
            <param name="chainId">The ID of a new canonical chain.</param>
            <seealso cref="M:Libplanet.Store.IStore.GetCanonicalChainId"/>
        </member>
        <member name="M:Libplanet.Store.IStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Lists all block hashes in the <parmaref name="chainId"/>.
            </summary>
            <param name="chainId">The chain ID of the index that contains block hashes to
            iterate.</param>
            <param name="offset">The starting point to return block hashes.</param>
            <param name="limit">The maximum number of block hashes to get.</param>
            <returns>Block hashes in the index of the <paramref name="chainId"/>, in ascending
            order; the genesis block goes first, and the tip block goes last.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.ForkBlockIndexes(System.Guid,System.Guid,Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Forks block indexes from
            <paramref name="sourceChainId"/> to
            <paramref name="destinationChainId"/>.
            </summary>
            <param name="sourceChainId">The chain ID of block indexes to
            fork.</param>
            <param name="destinationChainId">The chain ID of destination
            block indexes.</param>
            <param name="branchPoint">The branch point <see cref="T:Libplanet.Blocks.Block`1"/>
            to fork.</param>
            <exception cref="T:Libplanet.Store.ChainIdNotFoundException">Thrown when the given
            <paramref name="sourceChainId"/> does not exist.</exception>
            <seealso cref="M:Libplanet.Store.IStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})"/>
            <seealso cref="M:Libplanet.Store.IStore.AppendIndex(System.Guid,Libplanet.HashDigest{System.Security.Cryptography.SHA256})"/>
        </member>
        <member name="M:Libplanet.Store.IStore.StageTransactionIds(System.Collections.Immutable.IImmutableSet{Libplanet.Tx.TxId})">
            <summary>
            Adds <see cref="T:Libplanet.Tx.TxId"/>s to the pending list so that
            a next <see cref="T:Libplanet.Blocks.Block`1"/> to be mined contains the corresponding
            <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </summary>
            <param name="txids"><see cref="T:Libplanet.Tx.TxId"/>s to add to pending list.</param>
        </member>
        <member name="M:Libplanet.Store.IStore.IterateStagedTransactionIds">
            <summary>
            Iterates staged <see cref="T:Libplanet.Tx.TxId"/>s.
            </summary>
            <returns>Staged <see cref="T:Libplanet.Tx.TxId"/>s.  The earliest staged <see cref="T:Libplanet.Tx.TxId"/> goes first,
            and the latest staged <see cref="T:Libplanet.Tx.TxId"/> goes last.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.PutTransaction``1(Libplanet.Tx.Transaction{``0})">
            <summary>
            Puts a given <see cref="T:Libplanet.Tx.Transaction`1"/> to the store.  If the same transaction
            already exists in the store it does nothing.
            </summary>
            <param name="tx">A transaction to put into the store.</param>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Tx.Transaction`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStore.GetBlock``1(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Gets the corresponding stored <see cref="T:Libplanet.Blocks.Block`1"/> to the given
            <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to find.</param>
            <returns>A found block, or <c>null</c> if no block having such
            <paramref name="blockHash"/> is stored.</returns>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStore.GetBlockIndex(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Gets a stored block's <see cref="P:Libplanet.Blocks.Block`1.Index"/> by its <see cref="P:Libplanet.Blocks.Block`1.Hash"/>.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to find.</param>
            <remarks>
            It provides only limited information, but can be called without any type parameter
            unlike <see cref="M:Libplanet.Store.IStore.GetBlock``1(Libplanet.HashDigest{System.Security.Cryptography.SHA256})"/>.
            </remarks>
            <returns>A found block's <see cref="P:Libplanet.Blocks.Block`1.Index"/>, or <c>null</c> if no block having
            such <paramref name="blockHash"/> is stored.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.GetBlockDigest(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Gets the corresponding stored <see cref="T:Libplanet.Blocks.BlockDigest"/> to the given
            <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to find.</param>
            <returns>A found <see cref="T:Libplanet.Blocks.BlockDigest"/>, or <c>null</c> if no block having such
            <paramref name="blockHash"/> is stored.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.PutBlock``1(Libplanet.Blocks.Block{``0})">
            <summary>
            Puts the given <paramref name="block"/> in to the store.
            If the same block already exists in the store it does nothing.
            </summary>
            <param name="block">A <see cref="T:Libplanet.Blocks.Block`1"/> to put into the store.
            </param>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> class used with
            <paramref name="block"/>.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStore.ContainsBlock(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Determines whether the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Blocks.Block`1"/>
            the specified <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">The <see cref="T:Libplanet.HashDigest`1"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> to
            check if it is in the <see cref="T:Libplanet.Store.IStore"/>.</param>
            <returns>
            <c>true</c> if the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Blocks.Block`1"/> with
            the specified <paramref name="blockHash"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.IStore.SetBlockPerceivedTime(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.DateTimeOffset)">
            <summary>
            Records the perceived time of a block.  If there is already a record, it is overwritten.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to record its perceived time.
            </param>
            <param name="perceivedTime">The perceived time to record.</param>
        </member>
        <member name="M:Libplanet.Store.IStore.GetBlockPerceivedTime(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Queries the perceived time of a block, if it has been recorded.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to query.</param>
            <returns>The perceived time of a block, if it exists.  Otherwise, <c>null</c>.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.ListTxNonces(System.Guid)">
            <summary>
            Lists all <see cref="T:Libplanet.Address"/>es that have ever signed <see cref="T:Libplanet.Tx.Transaction`1"/>,
            and their corresponding <see cref="T:Libplanet.Tx.Transaction`1"/> nonces.
            </summary>
            <param name="chainId">The ID of the chain to list <see cref="T:Libplanet.Address"/>es and their
            <see cref="T:Libplanet.Tx.Transaction`1"/> nonces.</param>
            <returns>Pairs of an <see cref="T:Libplanet.Address"/> and its tx nonce.  All nonces are greater
            than 0.  (If there are underlying entries having zero nonces these must be hidden.)
            </returns>
            <seealso cref="M:Libplanet.Store.IStore.GetTxNonce(System.Guid,Libplanet.Address)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.GetTxNonce(System.Guid,Libplanet.Address)">
            <summary>
            Gets <see cref="T:Libplanet.Tx.Transaction`1"/> nonce of the
            <paramref name="address"/>.
            </summary>
            <param name="chainId">The ID of the chain to get <see cref="T:Libplanet.Tx.Transaction`1"/> nonce.
            </param>
            <param name="address">The <see cref="T:Libplanet.Address"/> to get
            <see cref="T:Libplanet.Tx.Transaction`1"/> nonce.
            </param>
            <returns>A <see cref="T:Libplanet.Tx.Transaction`1"/> nonce. If there is no
            previous <see cref="T:Libplanet.Tx.Transaction`1"/>, return 0.</returns>
            <seealso cref="M:Libplanet.Store.IStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)">
            <summary>
            Increases (or decreases if a negative <paramref name="delta"/> is given)
            the tx nonce counter for <paramref name="signer"/>.
            </summary>
            <param name="chainId">The ID of the chain to increase
            <see cref="T:Libplanet.Tx.Transaction`1"/> nonce.</param>
            <param name="signer">The address of the account to increase tx nonce.</param>
            <param name="delta">How many to increase the counter.  A negative number decreases
            the counter.  1 by default.</param>
            <seealso cref="M:Libplanet.Store.IStore.GetTxNonce(System.Guid,Libplanet.Address)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.ContainsTransaction(Libplanet.Tx.TxId)">
            <summary>
            Determines whether the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Tx.Transaction`1"/>
            the specified <paramref name="txId"/>.
            </summary>
            <param name="txId">The <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/>
            to check if it is in the <see cref="T:Libplanet.Store.IStore"/>.</param>
            <returns>
            <c>true</c> if the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Tx.Transaction`1"/>
            with the specified <paramref name="txId"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.IStore.ForkTxNonces(System.Guid,System.Guid)">
            <summary>
            Forks <see cref="T:Libplanet.Tx.Transaction`1"/> <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>s from
            <paramref name="sourceChainId"/> to
            <paramref name="destinationChainId"/>.
            </summary>
            <param name="sourceChainId">The chain <see cref="P:Libplanet.Blockchain.BlockChain`1.Id"/> of
            <see cref="T:Libplanet.Tx.Transaction`1"/> <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>s to fork.</param>
            <param name="destinationChainId">The chain <see cref="P:Libplanet.Blockchain.BlockChain`1.Id"/> of destination
            <see cref="T:Libplanet.Tx.Transaction`1"/> <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>s.</param>
        </member>
        <member name="M:Libplanet.Store.StoreExtensions.Copy(Libplanet.Store.IStore,Libplanet.Store.IStore)">
            <summary>
            Makes a store, <paramref name="to"/>, logically (but not necessarily physically)
            identical to another store, <paramref name="from"/>.  As this copies the contents
            of the store, instead of its physicall data, this can be used for migrating
            between two different types of <see cref="T:Libplanet.Store.IStore"/> implementations.
            </summary>
            <param name="from">The store containing the source contents.</param>
            <param name="to">The store to contain the copied contents. Expected to be empty.</param>
            <exception cref="T:System.ArgumentException">Thrown when the store passed through
            <paramref name="to"/> is not empty.</exception>
        </member>
        <member name="T:Libplanet.Store.StoreExtensions.NullAction">
            <summary>
            An action implementation which does nothing for filling type parameter taking of
            <see cref="T:Libplanet.Action.IAction"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Store.StoreExtensions.NullAction.PlainValue">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.StoreExtensions.NullAction.Execute(Libplanet.Action.IActionContext)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.StoreExtensions.NullAction.LoadPlainValue(Bencodex.Types.IValue)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.TrieStateStore">
            <summary>
            An <see cref="T:Libplanet.Store.IStateStore"/> implementation. It stores states with <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.#ctor(Libplanet.Store.Trie.IKeyValueStore,Libplanet.Store.Trie.IKeyValueStore,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.TrieStateStore"/>.
            </summary>
            <param name="stateKeyValueStore">The storage to store states. It used by
            <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in internal.</param>
            <param name="stateHashKeyValueStore">The storage to store state hash corresponding to
            block hash.</param>
            <param name="secure">Whether to use <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in secure mode.
            <seealso cref="M:Libplanet.Store.Trie.MerkleTrie.#ctor(Libplanet.Store.Trie.IKeyValueStore,Libplanet.Store.Trie.Nodes.INode,System.Boolean)"/>.</param>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.SetStates``1(Libplanet.Blocks.Block{``0},System.Collections.Immutable.IImmutableDictionary{System.String,Bencodex.Types.IValue})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.GetState(System.String,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Nullable{System.Guid})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.ContainsBlockStates(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.ForkStates``1(System.Guid,System.Guid,Libplanet.Blocks.Block{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.GetRootHash(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Gets the state hash corresponds to <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> to get state hash.</param>
            <returns>If there is a state hash corresponds to <paramref name="blockHash"/>,
            it will return the state hash. If not, it will return null.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If there are no root hashes that correspond to
            <paramref name="blockHash"/>.</exception>
        </member>
        <member name="T:Libplanet.Store.Trie.CacheableKeyValueStore">
            <summary>
            The proxy class to cache <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> operations.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.#ctor(Libplanet.Store.Trie.IKeyValueStore,System.Int32)">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.Trie.CacheableKeyValueStore"/>.
            </summary>
            <param name="keyValueStore">An <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> implementation to do real
            operations via <see cref="T:Libplanet.Store.Trie.CacheableKeyValueStore"/>.</param>
            <param name="cacheSize">The capacity of the values cache.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Get(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Set(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Delete(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Exists(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.ListKeys">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.Trie.DefaultKeyValueStore">
            <summary>
            The default built-in <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> implementation. This stores data in
            the file system or in memory.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.Trie.DefaultKeyValueStore"/>.
            </summary>
            <param name="path">The path of the directory where the storage files will be saved.
            If the path is <c>null</c>, the database is created in memory.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Get(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Set(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Delete(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Exists(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.ListKeys">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.Trie.IKeyValueStore">
            <summary>
            An interface to access key-value store.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.ListKeys">
            <summary>
            Lists all keys that have been stored in the storage.
            </summary>
            <returns>All keys in an arbitrary order.  The order might be vary for each call.
            </returns>
        </member>
        <member name="T:Libplanet.Store.Trie.ITrie">
            <summary>
            An interface for <see href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</see>.
            </summary>
            <seealso cref="T:Libplanet.Store.Trie.MerkleTrie"/>
        </member>
        <member name="P:Libplanet.Store.Trie.ITrie.Hash">
            <summary>
            The state root hash of the trie.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.ITrie.Set(System.Byte[],Bencodex.Types.IValue)">
            <summary>
            Stores the <paramref name="value"/> to the
            node corresponding to given <paramref name="key"/>.
            </summary>
            <param name="key">An index to look with <see cref="M:Libplanet.Store.Trie.ITrie.TryGet(System.Byte[],Bencodex.Types.IValue@)"/> after.</param>
            <param name="value">The value to store.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="value"/> is <c>null</c>.</exception>
            <returns>Returns new updated <see cref="T:Libplanet.Store.Trie.ITrie"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.ITrie.TryGet(System.Byte[],Bencodex.Types.IValue@)">
            <summary>
            Gets the value stored with <paramref name="key"/> in <see cref="M:Libplanet.Store.Trie.ITrie.Set(System.Byte[],Bencodex.Types.IValue)"/>.
            </summary>
            <param name="key">The key used in <see cref="M:Libplanet.Store.Trie.ITrie.Set(System.Byte[],Bencodex.Types.IValue)"/> to store a value.</param>
            <param name="value">The reference pointer to be set the value stored.</param>
            <returns>If there is a value corresponded to <paramref name="key"/>,
            set <paramref name="value"/> to it and return true. If not, set <paramref name="value"/>
            to null and return false.</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.ITrie.Commit(System.Boolean)">
            <summary>
            Cleans up and stores the <see cref="T:Libplanet.Store.Trie.ITrie"/> in storage.
            </summary>
            <param name="rehearsal">Whether to store nodes.</param>
            <returns>Returns new committed <see cref="T:Libplanet.Store.Trie.ITrie"/>.</returns>
        </member>
        <member name="T:Libplanet.Store.Trie.MerkleTrie">
            <summary>
            An <see cref="T:Libplanet.Store.Trie.ITrie"/> implementation implemented
            <see href="https://eth.wiki/fundamentals/patricia-tree">Merkle Patricia Trie</see>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.#ctor(Libplanet.Store.Trie.IKeyValueStore,Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Boolean)">
            <summary>
            An <see cref="T:Libplanet.Store.Trie.ITrie"/> implementation.
            </summary>
            <param name="keyValueStore">The <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> storage to store
            nodes.</param>
            <param name="rootHash">The root <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of
            <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.</param>
            <param name="secure">Whether to use <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in
            secure mode.  If it is turned on, <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> internally stores hashed keys
            instead of bare keys.  <see cref="M:Libplanet.Hashcash.Hash(System.Byte[])" /> is used to hash them.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.#ctor(Libplanet.Store.Trie.IKeyValueStore,Libplanet.Store.Trie.Nodes.INode,System.Boolean)">
            <summary>
            An <see cref="T:Libplanet.Store.Trie.ITrie"/> implementation.
            </summary>
            <param name="keyValueStore">The <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> storage to store
            nodes.</param>
            <param name="root">The root node of <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>. If it is <c>null</c>,
            it will be treated like empty trie.</param>
            <param name="secure">Whether to use <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in secure
            mode. If it is true, <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> will stores the value with the hashed
            result from the given key as the key. It will hash with
            <see cref="M:Libplanet.Hashcash.Hash(System.Byte[])"/>.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.Set(System.Byte[],Bencodex.Types.IValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.TryGet(System.Byte[],Bencodex.Types.IValue@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.Commit(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.GetNode(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Gets the node corresponding to <paramref name="nodeHash"/> from storage,
            (i.e., <see cref="P:Libplanet.Store.Trie.MerkleTrie.KeyValueStore"/>).
            </summary>
            <param name="nodeHash">The hash of node to get.</param>
            <returns>The node corresponding to <paramref name="nodeHash"/>.</returns>
        </member>
        <member name="T:Libplanet.Store.Trie.MerkleTrieExtensions">
            <summary>
            An extension class to provide some convenient methods to deal with <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrieExtensions.DifferentNodes(Libplanet.Store.Trie.MerkleTrie,Libplanet.Store.Trie.MerkleTrie)">
            <summary>
            Compares two given tries and gets different value nodes (leaf node).
            </summary>
            <param name="origin">A trie to compare.</param>
            <param name="other">An other trie to compare.</param>
            <returns><see cref="T:System.Linq.IGrouping`2"/>s,
            mapping path to tuple having the hash of the value is contained and the value.</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrieExtensions.ListAllStates(Libplanet.Store.Trie.MerkleTrie)">
            <summary>
            Lists the all states key and the all states in the given <paramref name="merkleTrie"/>.
            </summary>
            <param name="merkleTrie">A trie to discover.</param>
            <returns>All state keys and the all states.</returns>
        </member>
        <member name="T:Libplanet.Store.Trie.Nodes.HashNode">
            <summary>
            <see cref="T:Libplanet.HashDigest`1"/>'s wrapper class, used in <see cref="T:Libplanet.Store.Trie.ITrie"/> interface.
            </summary>
        </member>
        <member name="T:Libplanet.Store.Trie.Nodes.INode">
            <summary>
            A constituent unit of <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.
            </summary>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.FullNode"/>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.ShortNode"/>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.ValueNode"/>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.HashNode"/>
        </member>
        <member name="T:Libplanet.Store.Trie.Nodes.ValueNode">
            <summary>
            Wrapper class.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxException">
            <summary>
            Serves as the base class for exceptions thrown by
            <see cref="M:Libplanet.Tx.Transaction`1.Validate"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxException.#ctor(Libplanet.Tx.TxId,System.String)">
            <summary>
            Instantiates a new exception object with proper metadata.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="message">A descriptive error message for programmers.
            </param>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxException.TxId">
            <summary>
            The <see cref="P:Libplanet.Tx.InvalidTxException.TxId"/> of the invalid <see cref="T:Libplanet.Tx.Transaction`1"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxGenesisHashException">
            <summary>
            The exception that is thrown when the <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>
            is different from the <see cref="T:Libplanet.HashDigest`1"/> of
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Genesis"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxGenesisHashException.#ctor(Libplanet.Tx.TxId,Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Tx.InvalidTxGenesisHashException"/> class.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="expectedGenesisHash">The <see cref="T:Libplanet.HashDigest`1"/>
            value of <see cref="P:Libplanet.Blockchain.BlockChain`1.Genesis"/>.</param>
            <param name="improperGenesisHash">The actual
            <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>.  This can be <c>null</c>.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxGenesisHashException.ExpectedGenesisHash">
            <summary>
            The <see cref="T:Libplanet.HashDigest`1"/> value of
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Genesis"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxGenesisHashException.ImproperGenesisHash">
            <summary>
            The actual <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>, which is improper.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxIdException">
            <summary>
            The exception that is thrown when a given <see cref="T:Libplanet.Tx.TxId"/> cannot be
            found.
            </summary>
            <remarks>This does <em>not</em> mean a given value is an invalid
            encoding of <see cref="T:Libplanet.Tx.TxId"/>, but there is no corresponding entry to
            a given <see cref="T:Libplanet.Tx.TxId"/>, which is <em>valid</em>.</remarks>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxIdException.#ctor(Libplanet.Tx.TxId,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.InvalidTxIdException"/> object.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.TxId"/>.
            It is automatically included to the <see cref="P:System.Exception.Message"/>
            string.</param>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxNonceException">
            <summary>
            The exception that is thrown when the <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>
            is different from <see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/> result of
            the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxNonceException.#ctor(Libplanet.Tx.TxId,System.Int64,System.Int64,System.String)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Tx.InvalidTxNonceException"/> class.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="expectedNonce"><see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/>
            result of the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.</param>
            <param name="improperNonce">The actual
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxNonceException.ExpectedNonce">
            <summary>
            <see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/> result of the
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxNonceException.ImproperNonce">
            <summary>
            The actual <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>, which is improper.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxPublicKeyException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> is not derived from its
            <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxPublicKeyException.#ctor(Libplanet.Tx.TxId,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.InvalidTxPublicKeyException"/> object.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxSignatureException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxSignatureException.#ctor(Libplanet.Tx.TxId,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.InvalidTxSignatureException"/> object.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxUpdatedAddressesException">
            <summary>
            The exception that is thrown when a given
            <see cref="P:Libplanet.Tx.InvalidTxException.TxId"/> cannot be found.
            The exception that is thrown when a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> try to update any
            <see cref="T:Libplanet.Address"/>es that are not included in
            <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> (i.e., <see
            cref="T:Libplanet.Address"/>es that <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> granted to update.)
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxUpdatedAddressesException.#ctor(Libplanet.Tx.TxId,System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.InvalidTxUpdatedAddressesException"/>
            object.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="updatableAddresses">Specifies the
            <see cref="P:Libplanet.Tx.InvalidTxUpdatedAddressesException.UpdatableAddresses"/>.</param>
            <param name="updatedAddresses">Specifies the
            <see cref="P:Libplanet.Tx.InvalidTxUpdatedAddressesException.UpdatedAddresses"/>.</param>
            <param name="message">Specifies the <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxUpdatedAddressesException.UpdatableAddresses">
            <summary>
            Expected <see cref="T:Libplanet.Address"/>es to be updated.  That means,
            <see cref="T:Libplanet.Address"/>es that <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> granted to update.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxUpdatedAddressesException.UpdatedAddresses">
            <summary>
            <see cref="T:Libplanet.Address"/>es that <see cref="P:Libplanet.Tx.Transaction`1.Actions"/>
            actually try to update.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.Transaction`1">
            <summary>
            Consists of <see cref="T:Libplanet.Action.IAction"/> and is signed to be included in
            a <see cref="T:Libplanet.Blocks.Block`1"/> and transmitted over the network.
            </summary>
            <typeparam name="T">A class implementing <see cref="T:Libplanet.Action.IAction"/> to
            include.
            Each game usually defines its own concrete class which implements
            <see cref="T:Libplanet.Action.IAction"/>, and uses it for this type parameter.
            This type parameter is aligned with <see cref="T:Libplanet.Blocks.Block`1"/>'s
            and <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameters.
            </typeparam>
            <seealso cref="T:Libplanet.Action.IAction"/>
            <seealso cref="T:Libplanet.Action.PolymorphicAction`1"/>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.#ctor(System.Int64,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.DateTimeOffset,System.Collections.Generic.IEnumerable{`0},System.Byte[])">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.Transaction`1"/>.
            <para>This constructor takes all required and only required values
            for a <see cref="T:Libplanet.Tx.Transaction`1"/>, so gives you full control of
            creating a <see cref="T:Libplanet.Tx.Transaction`1"/>, and in other words,
            this constructor is only useful when all details of
            a <see cref="T:Libplanet.Tx.Transaction`1"/> need to be manually adjusted.
            For the most cases, the fa&#xe7;ade factory <see
            cref="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})"/> is more useful.</para>
            </summary>
            <param name="nonce">The number of previous
            <see cref="T:Libplanet.Tx.Transaction`1"/>s committed by the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>
            of this transaction.  This goes to the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> property.</param>
            <param name="signer">An <see cref="T:Libplanet.Address"/> of the account
            who signs this transaction.  If this is not derived from <paramref
            name="publicKey"/> <see cref="T:Libplanet.Tx.InvalidTxPublicKeyException"/> is
            thrown.  This goes to the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> property.</param>
            <param name="publicKey">A <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/> of the account
            who signs this transaction.  If this does not match to <paramref
            name="signer"/> address <see cref="T:Libplanet.Tx.InvalidTxPublicKeyException"/>
            is thrown.  This cannot be <c>null</c>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/> property.</param>
            <param name="genesisHash">A <see cref="T:Libplanet.HashDigest`1"/> value
            of the genesis which this <see cref="T:Libplanet.Tx.Transaction`1"/> is made from.
            This can be <c>null</c> iff the transaction is contained
            in the genesis block.
            </param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose
            states affected by <paramref name="actions"/>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property.</param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/>
            is created and signed.  This goes to the <see cref="P:Libplanet.Tx.Transaction`1.Timestamp"/>
            property.</param>
            <param name="actions">A list of <see cref="T:Libplanet.Action.IAction"/>s.  This
            can be empty, but cannot be <c>null</c>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> property.</param>
            <param name="signature">A digital signature of the content of
            this <see cref="T:Libplanet.Tx.Transaction`1"/>.  This has to be signed by
            the account who corresponds to <paramref name="publicKey"/>,
            or it will throw <see cref="T:Libplanet.Tx.InvalidTxSignatureException"/>.
            This is copied and then assigned to the <see cref="P:Libplanet.Tx.Transaction`1.Signature"/>
            property.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>null</c>
            is passed to <paramref name="signature"/>,
            <paramref name="actions"/>, or <paramref name="publicKey"/>.
            </exception>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.#ctor(Bencodex.Types.Dictionary)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.Transaction`1"/> instance from its serialization.
            </summary>
            <param name="dict">The <see cref="T:Bencodex.Types.Dictionary"/>
            representation of <see cref="T:Libplanet.Tx.Transaction`1"/> instance.
            </param>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Id">
            <summary>
            A unique identifier derived from this <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            content.
            <para>For more characteristics, see <see cref="T:Libplanet.Tx.TxId"/> type.</para>
            </summary>
            <seealso cref="T:Libplanet.Tx.TxId"/>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Nonce">
            <summary>
            The number of previous <see cref="T:Libplanet.Tx.Transaction`1"/>s committed by
            the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> of this transaction.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Signer">
            <summary>
            A <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/> of the account who signs this transaction.
            This is derived from the <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.UpdatedAddresses">
            <summary>
            <see cref="T:Libplanet.Address"/>es whose states affected by
            <see cref="P:Libplanet.Tx.Transaction`1.Actions"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Signature">
            <summary>
            A digital signature of the content of this
            <see cref="T:Libplanet.Tx.Transaction`1"/>.  This is signed by the account
            who corresponds to <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            This cannot be <c>null</c>.
            </summary>
            <returns>A new <see cref="T:System.Byte"/> array of this transaction's
            signature.  Changing a returned array does not affect the internal
            state of this <see cref="T:Libplanet.Tx.Transaction`1"/> object.</returns>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Actions">
            <summary>
            A list of <see cref="T:Libplanet.Action.IAction"/>s.  These are executed in the order.
            This can be empty, but cannot be <c>null</c>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Timestamp">
            <summary>
            The time this <see cref="T:Libplanet.Tx.Transaction`1"/> is created and signed.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.PublicKey">
            <summary>
            A <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/> of the account who signs this
            <see cref="T:Libplanet.Tx.Transaction`1"/>.
            The <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> address is always corresponding to this
            for each transaction.  This cannot be <c>null</c>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.GenesisHash">
            <summary>
            A <see cref="T:Libplanet.HashDigest`1"/> value of the genesis which this
            <see cref="T:Libplanet.Tx.Transaction`1"/> is made from.
            This can be <c>null</c> iff the transaction is contained
            in the genesis block.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.BytesLength">
            <summary>
            The bytes length in its serialized format.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Deserialize(System.Byte[],System.Boolean)">
            <summary>
            Decodes a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <a href="https://bencodex.org/">Bencodex</a> representation.
            </summary>
            <param name="bytes">A <a href="https://bencodex.org/">Bencodex</a>
            representation of a <see cref="T:Libplanet.Tx.Transaction`1"/>.</param>
            <param name="validate">Whether to validate the transaction.</param>
            <returns>A decoded <see cref="T:Libplanet.Tx.Transaction`1"/> object.</returns>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> is invalid or not signed by
            the account who corresponds to <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            </exception>
            <exception cref="T:Libplanet.Tx.InvalidTxPublicKeyException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> is not derived from its
            <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.</exception>
            <seealso cref="M:Libplanet.Tx.Transaction`1.Serialize(System.Boolean)"/>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            A fa&#xe7;ade factory to create a new <see cref="T:Libplanet.Tx.Transaction`1"/>.
            Unlike the <see cref="M:Libplanet.Tx.Transaction`1.#ctor(System.Int64,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.DateTimeOffset,System.Collections.Generic.IEnumerable{`0},System.Byte[])"/>
            constructor, it automatically fills the following values from:
            <list type="table">
            <listheader>
            <term>Property</term>
            <description>Parameter the filled value derived from</description>
            </listheader>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.Signer"/></term>
            <description><paramref name="privateKey"/></description>
            </item>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/></term>
            <description><paramref name="privateKey"/></description>
            </item>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/></term>
            <description><paramref name="actions"/> and
            <paramref name="updatedAddresses"/></description>
            </item>
            </list>
            <para>Note that the <paramref name="privateKey"/> in itself is not
            included in the created <see cref="T:Libplanet.Tx.Transaction`1"/>.</para>
            </summary>
            <remarks>
            This factory method tries its best to fill the <see
            cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property by actually evaluating
            the given <paramref name="actions"/> (we call it &#x201c;rehearsal
            mode&#x201d;), but remember that its result
            is approximated in some degree, because the result of
            <paramref name="actions"/> are not deterministic until
            the <see cref="T:Libplanet.Tx.Transaction`1"/> belongs to a <see
            cref="T:Libplanet.Blocks.Block`1"/>.
            <para>If an <see cref="T:Libplanet.Action.IAction"/> depends on previous states or
            some randomness to determine what <see cref="T:Libplanet.Address"/> to update,
            the automatically filled <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> became
            mismatched from the <see cref="T:Libplanet.Address"/>es
            <paramref name="actions"/> actually update after
            a <see cref="T:Libplanet.Blocks.Block`1"/> is mined.
            Although such case would be rare, a programmer could manually give
            the <paramref name="updatedAddresses"/> parameter
            the <see cref="T:Libplanet.Address"/>es they predict to be updated.</para>
            <para>If an <see cref="T:Libplanet.Action.IAction"/> oversimplifies the assumption
            about the <see cref="T:Libplanet.Blocks.Block`1"/> it belongs to,
            runtime exceptions could be thrown from this factory method.
            The best solution to that is not to oversimplify things,
            there is an option to check <see cref="T:Libplanet.Action.IActionContext"/>'s
            <see cref="P:Libplanet.Action.IActionContext.Rehearsal"/> is <c>true</c> and
            a conditional logic for the case.</para>
            </remarks>
            <param name="nonce">The number of previous
            <see cref="T:Libplanet.Tx.Transaction`1"/>s committed by the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>
            of this transaction.  This goes to the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> property.</param>
            <param name="privateKey">A <see cref="T:Libplanet.Crypto.PrivateKey"/> of the account
            who creates and signs a new transaction.  This key is used to fill
            the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>, <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>, and
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> properties, but this in itself is not
            included in the transaction.</param>
            <param name="genesisHash">A <see cref="T:Libplanet.HashDigest`1"/> value
            of the genesis which this <see cref="T:Libplanet.Tx.Transaction`1"/> is made from.
            This can be <c>null</c> iff the transaction is contained
            in the genesis block.
            </param>
            <param name="actions">A list of <see cref="T:Libplanet.Action.IAction"/>s.  This
            can be empty, but cannot be <c>null</c>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> property, and <see cref="T:Libplanet.Action.IAction"/>s
            are evaluated before a <see cref="T:Libplanet.Tx.Transaction`1"/> is created
            in order to fill the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/>.  See also
            <em>Remarks</em> section.</param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose
            states affected by <paramref name="actions"/>.
            These <see cref="T:Libplanet.Address"/>es are also included in
            the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property, besides
            <see cref="T:Libplanet.Address"/>es projected by evaluating
            <paramref name="actions"/>.  See also <em>Remarks</em> section.
            </param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/>
            is created and signed.  This goes to the <see cref="P:Libplanet.Tx.Transaction`1.Timestamp"/>
            property.  If <c>null</c> (which is default) is passed this will
            be the current time.</param>
            <returns>A created new <see cref="T:Libplanet.Tx.Transaction`1"/> signed by
            the given <paramref name="privateKey"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <c>null</c>
            is passed to <paramref name="privateKey"/> or
            or <paramref name="actions"/>.
            </exception>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Serialize(System.Boolean)">
            <summary>
            Encodes this <see cref="T:Libplanet.Tx.Transaction`1"/> into a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="sign">Whether to include its <see cref="P:Libplanet.Tx.Transaction`1.Signature"/>.
            </param>
            <returns>A <a href="https://bencodex.org/">Bencodex</a>
            representation of this <see cref="T:Libplanet.Tx.Transaction`1"/>.</returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.ToBencodex(System.Boolean)">
            <summary>
            Encodes this <see cref="T:Libplanet.Tx.Transaction`1"/> into a <see cref="T:Bencodex.Types.IValue"/>.
            </summary>
            <param name="sign">Whether to include its <see cref="P:Libplanet.Tx.Transaction`1.Signature"/>.
            Note that an encoding without signature cannot be decoded.
            </param>
            <returns>A <see cref="T:Bencodex.Types.Dictionary"/> typed
            <a href="https://bencodex.org/">Bencodex</a>
            representation of this <see cref="T:Libplanet.Tx.Transaction`1"/>.</returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.EvaluateActionsGradually(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Int64,Libplanet.Action.IAccountStateDelta,Libplanet.Address,System.Boolean,Libplanet.Store.Trie.ITrie)">
            <summary>
            Executes the <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> step by step, and emits
            <see cref="T:Libplanet.Action.ActionEvaluation"/> for each step.
            <para>If the needed value is only the final states,
            use <see cref="M:Libplanet.Tx.Transaction`1.EvaluateActions(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Int64,Libplanet.Action.IAccountStateDelta,Libplanet.Address,System.Boolean)"/> method instead.</para>
            </summary>
            <param name="blockHash">The <see
            cref="P:Libplanet.Blocks.Block`1.Hash"/> of
            <see cref="T:Libplanet.Blocks.Block`1"/> that this
            <see cref="T:Libplanet.Tx.Transaction`1"/> will belong to.</param>
            <param name="blockIndex">The <see
            cref="P:Libplanet.Blocks.Block`1.Index"/> of
            <see cref="T:Libplanet.Blocks.Block`1"/> that this
            <see cref="T:Libplanet.Tx.Transaction`1"/> will belong to.</param>
            <param name="previousStates">The states immediately before
            <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> being executed.  Note that its
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/> are remained
            to the returned next states.</param>
            <param name="minerAddress">An address of block miner.</param>
            <param name="rehearsal">Pass <c>true</c> if it is intended
            to be dry-run (i.e., the returned result will be never used).
            The default value is <c>false</c>.</param>
            <param name="previousBlockStatesTrie">The trie to contain states at previous block.
            </param>
            <returns>Enumerates <see cref="T:Libplanet.Action.ActionEvaluation"/>s for each one in
            <see cref="P:Libplanet.Tx.Transaction`1.Actions"/>.
            The order is the same to the <see cref="P:Libplanet.Tx.Transaction`1.Actions"/>.
            Note that each <see cref="P:Libplanet.Action.IActionContext.Random"/> object has
            a unconsumed state.
            </returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.EvaluateActions(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Int64,Libplanet.Action.IAccountStateDelta,Libplanet.Address,System.Boolean)">
            <summary>
            Executes the <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> and gets the result states.
            </summary>
            <param name="blockHash">The <see
            cref="P:Libplanet.Blocks.Block`1.Hash"/> of
            <see cref="T:Libplanet.Blocks.Block`1"/> that this
            <see cref="T:Libplanet.Tx.Transaction`1"/> will belong to.</param>
            <param name="blockIndex">The <see
            cref="P:Libplanet.Blocks.Block`1.Index"/> of
            <see cref="T:Libplanet.Blocks.Block`1"/> that this
            <see cref="T:Libplanet.Tx.Transaction`1"/> will belong to.</param>
            <param name="previousStates">The states immediately before
            <see cref="P:Libplanet.Tx.Transaction`1.Actions"/> being executed.  Note that its
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/> are remained
            to the returned next states.</param>
            <param name="minerAddress">An address of block miner.</param>
            <param name="rehearsal">Pass <c>true</c> if it is intended
            to be dry-run (i.e., the returned result will be never used).
            The default value is <c>false</c>.</param>
            <returns>The states immediately after <see cref="P:Libplanet.Tx.Transaction`1.Actions"/>
            being executed.  Note that it maintains
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/> of the given
            <paramref name="previousStates"/> as well.</returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Validate">
            <summary>
            Validates this <see cref="T:Libplanet.Tx.Transaction`1"/>.  If there is something
            invalid it throws an exception.  If valid it does nothing.
            </summary>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> is invalid or not signed by
            the account who corresponds to its <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            </exception>
            <exception cref="T:Libplanet.Tx.InvalidTxPublicKeyException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> is not derived from its
            <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.</exception>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Equals(Libplanet.Tx.Transaction{`0})">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Tx.TxId">
            <summary>
            <see cref="T:Libplanet.Tx.TxId"/>, abbreviation of transaction identifier,
            is a SHA-256 digest derived from a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            content.
            <para>As it is a SHA-256 digest, it consists of 32 <see cref="T:System.Byte"/>s,
            and 64 characters in hexadecimal.
            (See also <see cref="F:Libplanet.Tx.TxId.Size"/> constant.)</para>
            </summary>
            <seealso cref="P:Libplanet.Tx.Transaction`1.Id"/>
        </member>
        <member name="F:Libplanet.Tx.TxId.Size">
            <summary>
            The <see cref="T:System.Byte"/>s size that each <see cref="T:Libplanet.Tx.TxId"/> takes.
            <para>As a txid is a SHA-256 digest, it is 32 <see cref="T:System.Byte"/>s.
            </para>
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxId.#ctor(System.Byte[])">
            <summary>
            Converts a <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <param name="txid">A <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.Tx.TxId"/>.  It must not be <c>null</c>,
            and its <see cref="P:System.Array.Length"/> must be the same to
            <see cref="F:Libplanet.Tx.TxId.Size"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="txid"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="txid"/>'s <see cref="P:System.Array.Length"/> is not
            the same to the required <see cref="F:Libplanet.Tx.TxId.Size"/>.</exception>
        </member>
        <member name="P:Libplanet.Tx.TxId.ByteArray">
            <summary>
            A bare immutable <see cref="T:System.Byte"/> array of
            this <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <remarks>It is immutable.  For a mutable array, use
            <see cref="M:Libplanet.Tx.TxId.ToByteArray"/> method instead.</remarks>
            <seealso cref="M:Libplanet.Tx.TxId.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Tx.TxId.ToByteArray">
            <summary>
            Gets a bare mutable <see cref="T:System.Byte"/> array of
            this <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array of
            this <see cref="T:Libplanet.Tx.TxId"/>.
            Since a returned array is created every time the method is called,
            any mutations on that array does not affect to
            the <see cref="T:Libplanet.Tx.TxId"/> object.
            </returns>
            <seealso cref="P:Libplanet.Tx.TxId.ByteArray"/>
        </member>
        <member name="M:Libplanet.Tx.TxId.ToHex">
            <summary>
            Gets a hexadecimal form of a <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <returns>64 hexadecimal characters.</returns>
        </member>
        <member name="M:Libplanet.Tx.TxId.ToString">
            <summary>
            Gets a <see cref="T:Libplanet.Tx.TxId"/>'s representative string.
            </summary>
            <returns>A string which represents this <see cref="T:Libplanet.Tx.TxId"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Tx.TxId.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Tx.TxViolatingBlockPolicyException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Tx.Transaction`1"/> does not follow the
            block policy.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxViolatingBlockPolicyException.#ctor(Libplanet.Tx.TxId,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.TxViolatingBlockPolicyException"/> object.
            </summary>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.TxId"/>.
            It is automatically included to the <see cref="P:System.Exception.Message"/>
            string.</param>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
    </members>
</doc>
