<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Libplanet</name>
    </assembly>
    <members>
        <member name="T:Libplanet.Action.AccountBalanceGetter">
            <summary>
            An delegate to provide read-only view of account balances.
            <para>Gets <paramref name="address"/>' balance of the given <paramref name="currency"/>.
            </para>
            </summary>
            <param name="address">An address of the account to query its balance of
            the <paramref name="currency"/>.</param>
            <param name="currency">The currency type to query <paramref name="address"/>' balance.
            </param>
            <returns>
            The <paramref name="address"/>'s balance of the <paramref name="currency"/>.
            </returns>
        </member>
        <member name="T:Libplanet.Action.AccountStateDeltaImpl">
            <summary>
            An internal implementation of <see cref="T:Libplanet.Action.IAccountStateDelta"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.#ctor(Libplanet.Action.AccountStateGetter,Libplanet.Action.AccountBalanceGetter,Libplanet.Action.TotalSupplyGetter,Libplanet.Action.ValidatorSetGetter,Libplanet.Address)">
            <summary>
            Creates a null delta from the given <paramref name="accountStateGetter"/>.
            </summary>
            <param name="accountStateGetter">A view to the &#x201c;epoch&#x201d; states.</param>
            <param name="accountBalanceGetter">A view to the &#x201c;epoch&#x201d; asset balances.
            </param>
            <param name="totalSupplyGetter">A view to the &#x201c;epoch&#x201d; total supplies of
            currencies.</param>
            <param name="validatorSetGetter">A view to the &#x201c;epoch&#x201d; validator
            set.</param>
            <param name="signer">A signer address. Used for authenticating if a signer is allowed
            to mint a currency.</param>
        </member>
        <member name="P:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#UpdatedAddresses">
            <inheritdoc/>
        </member>
        <member name="P:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#StateUpdatedAddresses">
            <inheritdoc/>
        </member>
        <member name="P:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#UpdatedFungibleAssets">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateView#GetState(Libplanet.Address)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateView#GetStates(System.Collections.Generic.IReadOnlyList{Libplanet.Address})">
            <inheritdoc cref="M:Libplanet.Action.IAccountStateView.GetStates(System.Collections.Generic.IReadOnlyList{Libplanet.Address})"/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.Libplanet#Action#IAccountStateDelta#SetState(Libplanet.Address,Bencodex.Types.IValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.GetBalance(Libplanet.Address,Libplanet.Assets.Currency)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.GetTotalSupply(Libplanet.Assets.Currency)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.GetValidatorSet">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.SetValidator(Libplanet.Consensus.Validator)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImpl.ChooseVersion(System.Int32,Libplanet.Action.AccountStateGetter,Libplanet.Action.AccountBalanceGetter,Libplanet.Action.TotalSupplyGetter,Libplanet.Action.ValidatorSetGetter,Libplanet.Address)">
            <summary>
            Creates a null delta from the given <paramref name="accountStateGetter"/>,
            <paramref name="accountBalanceGetter"/>, and <paramref name="totalSupplyGetter"/>,
            with a subtype of <see cref="T:Libplanet.Action.AccountStateDeltaImpl"/> that corresponds to the
            <paramref name="protocolVersion"/>.
            </summary>
            <param name="protocolVersion">The protocol version of which to create a delta.</param>
            <param name="accountStateGetter">A view to the &#x201c;epoch&#x201d; states.</param>
            <param name="accountBalanceGetter">A view to the &#x201c;epoch&#x201d; asset balances.
            </param>
            <param name="totalSupplyGetter">A view to the &#x201c;epoch&#x201d; total supplies of
            currencies.</param>
            <param name="validatorSetGetter">A view to the &#x201c;epoch&#x201d; validator
            set.</param>
            <param name="signer">A signer address. Used for authenticating if a signer is allowed
            to mint a currency.</param>
            <returns>A instance of a subtype of <see cref="T:Libplanet.Action.AccountStateDeltaImpl"/> which
            corresponds to the <paramref name="protocolVersion"/>.</returns>
        </member>
        <member name="T:Libplanet.Action.AccountStateDeltaImplV0">
            <summary>
            Equivalent to <see cref="T:Libplanet.Action.AccountStateDeltaImpl"/> except that it maintains its old (v0)
            incorrect behavior of <see cref="M:Libplanet.Action.AccountStateDeltaImplV0.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImplV0.GetBalance(Libplanet.Address,Libplanet.Assets.Currency)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.AccountStateDeltaImplV0.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Action.AccountStateGetter">
            <summary>
            An delegate to provide read-only view of account states.
            <para>Gets states associated with the specified account <paramref name="addresses"/>.</para>
            <para>If some states associated with the specified account <paramref name="addresses"/> have
            never been set these absent states are represented as <see langword="null"/>.</para>
            </summary>
            <param name="addresses">Account addresses associated with the states to get.</param>
            <returns>The states associated to the specified account <paramref name="addresses"/>.
            Associated values are ordered in the same way to the corresponding
            <paramref name="addresses"/>.  Absent states are represented as <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Action.ActionContext.PutLog(System.String)">
            <inheritdoc cref="M:Libplanet.Action.IActionContext.PutLog(System.String)"/>
        </member>
        <member name="T:Libplanet.Action.ActionEvaluation">
            <summary>
            A record type to represent an evaluation plan and result of
            a single action.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluation.#ctor(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta,System.Exception,System.Collections.Generic.List{System.String})">
            <summary>
            Creates an <see cref="T:Libplanet.Action.ActionEvaluation"/> instance
            with filling properties.
            </summary>
            <param name="action">An action to evaluate.</param>
            <param name="inputContext">An input <see cref="T:Libplanet.Action.IActionContext"/> to
            evaluate <paramref name="action"/>.</param>
            <param name="outputStates">The result states that
            <paramref name="action"/> makes.</param>
            <param name="logs">The logs recorded while executing action.</param>
            <param name="exception">An exception that has risen during evaluating a given
            <paramref name="action"/>.</param>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.Action">
            <summary>
            An action to evaluate.
            </summary>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.InputContext">
            <summary>
            An input <see cref="T:Libplanet.Action.IActionContext"/> to evaluate
            <see cref="P:Libplanet.Action.ActionEvaluation.Action"/>.
            </summary>
            <remarks>Its <see cref="P:Libplanet.Action.IActionContext.Random"/> property
            is not consumed yet.</remarks>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.OutputStates">
            <summary>
            The result states that <see cref="P:Libplanet.Action.ActionEvaluation.Action"/> makes.
            </summary>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.Exception">
            <summary>
            An exception that had risen during evaluation.
            </summary>
        </member>
        <member name="P:Libplanet.Action.ActionEvaluation.Logs">
            <summary>
            Logs recorded while executing an action through
            <see cref="M:Libplanet.Action.IActionContext.PutLog(System.String)"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Action.ActionEvaluator`1">
            <summary>
            Class responsible for handling of <see cref="T:Libplanet.Action.IAction"/> evaluations.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            the <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.#ctor(Libplanet.Action.PolicyBlockActionGetter,Libplanet.Blockchain.IBlockChainStates{`0},System.Func{Libplanet.Blocks.BlockHash,Libplanet.Store.Trie.ITrie},System.Nullable{Libplanet.Blocks.BlockHash},System.Predicate{Libplanet.Assets.Currency})">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.ActionEvaluator`1"/>.
            </summary>
            <param name="policyBlockActionGetter">A delegator to get policy block action to evaluate
            at the end for each <see cref="T:Libplanet.Blocks.IPreEvaluationBlock"/> that gets evaluated.</param>
            <param name="blockChainStates">The <see cref="T:Libplanet.Blockchain.IBlockChainStates`1"/> to use to retrieve
            the states for a provided <see cref="T:Libplanet.Address"/>.</param>
            <param name="trieGetter">The function to retrieve a trie for
            a provided <see cref="T:Libplanet.Blocks.BlockHash"/>.</param>
            <param name="genesisHash"> A <see cref="T:Libplanet.Blocks.BlockHash"/> value of the genesis block.
            </param>
            <param name="nativeTokenPredicate">A predicate function to determine whether
            the specified <see cref="T:Libplanet.Assets.Currency"/> is a native token defined by chain's
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/> or not.</param>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.#ctor(Libplanet.Action.PolicyBlockActionGetter,Libplanet.Blockchain.IBlockChainStates{`0},System.Func{Libplanet.Blocks.BlockHash,Libplanet.Store.Trie.ITrie},System.Nullable{Libplanet.Blocks.BlockHash},System.Predicate{Libplanet.Assets.Currency},Libplanet.Action.IActionTypeLoader)">
            <inheritdoc cref="M:Libplanet.Action.ActionEvaluator`1.#ctor(Libplanet.Action.PolicyBlockActionGetter,Libplanet.Blockchain.IBlockChainStates{`0},System.Func{Libplanet.Blocks.BlockHash,Libplanet.Store.Trie.ITrie},System.Nullable{Libplanet.Blocks.BlockHash},System.Predicate{Libplanet.Assets.Currency})" />
            <param name="actionTypeLoader"> A <see cref="T:Libplanet.Action.IActionTypeLoader"/> implementation using action type lookup.</param>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.GenerateRandomSeed(System.Byte[],System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Creates a random seed.
            </summary>
            <param name="preEvaluationHashBytes">The previous evaluation hash turned into bytes.
            </param>
            <param name="hashedSignature">The hashed signature.</param>
            <param name="signature">The signature.</param>
            <param name="actionOffset">The offset of the action.</param>
            <returns>An integer of the random seed.
            </returns>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.Evaluate(Libplanet.Blocks.IPreEvaluationBlock,Libplanet.Blockchain.StateCompleterSet{`0})">
            <summary>
            The main entry point for evaluating a <see cref="T:Libplanet.Blocks.IPreEvaluationBlock"/>.
            </summary>
            <param name="block">The block to evaluate.</param>
            <param name="stateCompleterSet">The <see cref="T:Libplanet.Blockchain.StateCompleterSet`1"/> to use.</param>
            <returns> The result of evaluating every <see cref="T:Libplanet.Action.IAction"/> related to
            <paramref name="block"/> as an <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> of
            <see cref="T:Libplanet.Action.ActionEvaluation"/>s.</returns>
            <remarks>
            <para>Publicly exposed for benchmarking.</para>
            <para>First evaluates all <see cref="T:Libplanet.Action.IAction"/>s in
            <see cref="P:Libplanet.Blocks.IBlockContent.Transactions"/> of <paramref name="block"/> and appends the
            evaluation of the <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/> held by the instance at
            the end.</para>
            </remarks>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.GetUpdatedAddresses(Libplanet.Tx.Transaction{`0})">
            <summary>
            Retrieves the set of <see cref="T:Libplanet.Address"/>es that will be updated when
            a given <see cref="T:Libplanet.Tx.Transaction`1"/> is evaluated.
            </summary>
            <param name="tx">The <see cref="T:Libplanet.Tx.Transaction`1"/> to evaluate.</param>
            <returns>An <see cref="T:System.Collections.Immutable.IImmutableSet`1"/> of updated <see cref="T:Libplanet.Address"/>es.
            </returns>
            <remarks>
            A mock evaluation is performed on <paramref name="tx"/> using a mock
            <see cref="T:Libplanet.Blocks.Block`1"/> for its evaluation context and a mock
            <see cref="T:Libplanet.Action.IAccountStateDelta"/> as its previous state to obtain the
            <see cref="T:System.Collections.Immutable.IImmutableSet`1"/> of updated <see cref="T:Libplanet.Address"/>es.
            </remarks>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.EvaluateActions(System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Immutable.ImmutableArray{System.Byte},System.Int64,System.Nullable{Libplanet.Tx.TxId},Libplanet.Action.IAccountStateDelta,Libplanet.Address,Libplanet.Address,System.Byte[],System.Collections.Immutable.IImmutableList{Libplanet.Action.IAction},System.Predicate{Libplanet.Assets.Currency},System.Boolean,Libplanet.Store.Trie.ITrie,System.Boolean,Serilog.ILogger)">
            <summary>
            Executes <see cref="T:Libplanet.Action.IAction"/>s in <paramref name="actions"/>.  All other evaluation
            calls resolve to this method.
            </summary>
            <param name="genesisHash"> A <see cref="T:Libplanet.Blocks.BlockHash"/> value of the genesis block.
            </param>
            <param name="preEvaluationHash">The
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/> of
            the <see cref="T:Libplanet.Blocks.IPreEvaluationBlock"/> that <paramref name="actions"/> belong to.</param>
            <param name="blockIndex">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that <paramref name="actions"/> belong to.</param>
            <param name="txid">The <see cref="P:Libplanet.Tx.ITxExcerpt.Id"/> of the
            <see cref="T:Libplanet.Tx.ITransaction"/> that <paramref name="actions"/> belong to.
            This can be <see langword="null"/> on rehearsal mode or if an <see cref="T:Libplanet.Action.IAction"/> is a
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.</param>
            <param name="previousStates">The states immediately before <paramref name="actions"/>
            being executed.</param>
            <param name="miner">An address of block miner.</param>
            <param name="signer">Signer of the <paramref name="actions"/>.</param>
            <param name="signature"><see cref="T:Libplanet.Tx.ITransaction"/> signature used to generate random
            seeds.</param>
            <param name="actions">Actions to evaluate.</param>
            <param name="nativeTokenPredicate">A predicate function to determine whether
            the specified <see cref="T:Libplanet.Assets.Currency"/> is a native token defined by chain's
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/> or not.</param>
            <param name="rehearsal">Pass <see langword="true"/> if it is intended
            to be dry-run (i.e., the returned result will be never used).
            The default value is <see langword="false"/>.</param>
            <param name="previousBlockStatesTrie">The trie to contain states at previous block.
            </param>
            <param name="blockAction">Pass <see langword="true"/> if it is
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.</param>
            <param name="logger">An optional logger.</param>
            <returns>An enumeration of <see cref="T:Libplanet.Action.ActionEvaluation"/>s for each
            <see cref="T:Libplanet.Action.IAction"/> in <paramref name="actions"/>.
            </returns>
            <remarks>
            <para>Each <see cref="P:Libplanet.Action.IActionContext.Random"/> object has an unconsumed state.</para>
            <para>
            The returned enumeration has the following properties:
            <list type="bullet">
            <item><description>The first <see cref="T:Libplanet.Action.ActionEvaluation"/> in the enumerated result,
            if any, has <see cref="P:Libplanet.Action.ActionEvaluation.OutputStates"/> with
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/> that is a
            superset of <paramref name="previousStates"/>'s
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/>.</description></item>
            <item><description>Each <see cref="T:Libplanet.Action.ActionEvaluation"/> in the enumerated result
            has <see cref="P:Libplanet.Action.ActionEvaluation.OutputStates"/> with
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/> that is a super set
            of the previous one, if any.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.OrderTxsForEvaluation(System.Int32,System.Collections.Generic.IEnumerable{Libplanet.Tx.ITransaction},System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Deterministically shuffles <paramref name="txs"/> for evaluation using
            <paramref name="preEvaluationHash"/> as a random seed.
            </summary>
            <param name="protocolVersion">The <see cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
            that <paramref name="txs"/> belong to.</param>
            <param name="txs">The list of <see cref="T:Libplanet.Tx.ITransaction"/>s to shuffle.</param>
            <param name="preEvaluationHash">The
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/> to use as a random seed when
            shuffling.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Libplanet.Tx.ITransaction"/>s in evaluation
            order with the following properties:
            <list type="bullet">
            <item><see cref="T:Libplanet.Tx.ITransaction"/>s with the same <see cref="P:Libplanet.Tx.ITxMetadata.Signer"/>
            value appear consecutive in the list.</item>
            <item><see cref="T:Libplanet.Tx.ITransaction"/>s with the same <see cref="P:Libplanet.Tx.ITxMetadata.Signer"/>
            value are ordered by <see cref="P:Libplanet.Tx.ITxMetadata.Nonce"/> value in ascending order.</item>
            </list>
            </returns>
            <remarks>
            This is to prevent an attempt to gain a first move advantage by participants.
            </remarks>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.EvaluateBlock(Libplanet.Blocks.IPreEvaluationBlock,Libplanet.Action.IAccountStateDelta,Libplanet.Store.Trie.ITrie)">
            <summary>
            Evaluates <see cref="T:Libplanet.Action.IAction"/>s in <see cref="P:Libplanet.Blocks.IBlockContent.Transactions"/>
            of a given <see cref="T:Libplanet.Blocks.IPreEvaluationBlock"/>.
            </summary>
            <param name="block">The block to evaluate.</param>
            <param name="previousStates">The states immediately before an execution of any
            <see cref="T:Libplanet.Action.IAction"/>s.</param>
            <param name="previousBlockStatesTrie">The <see cref="T:Libplanet.Store.Trie.ITrie"/> containing the states
            at the previous block of <paramref name="block"/>.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:Libplanet.Action.ActionEvaluation"/>s
            where each <see cref="T:Libplanet.Action.ActionEvaluation"/> is the evaluation of an <see cref="T:Libplanet.Action.IAction"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.EvaluatePolicyBlockAction(Libplanet.Blocks.IPreEvaluationBlockHeader,Libplanet.Action.IAccountStateDelta,Libplanet.Store.Trie.ITrie)">
            <summary>
            Evaluates the <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/> set by the policy when
            this <see cref="T:Libplanet.Action.ActionEvaluator`1"/> was instantiated for a given
            <see cref="T:Libplanet.Blocks.IPreEvaluationBlockHeader"/>.
            </summary>
            <param name="blockHeader">The header of the block to evaluate.</param>
            <param name="previousStates">The states immediately before the evaluation of
            the <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/> held by the instance.</param>
            <param name="previousBlockStatesTrie">The trie to contain states at previous block.
            </param>
            <returns>The <see cref="T:Libplanet.Action.ActionEvaluation"/> of evaluating
            the <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/> held by the instance
            for the <paramref name="blockHeader"/>.</returns>
        </member>
        <member name="M:Libplanet.Action.ActionEvaluator`1.GetPreviousBlockOutputStates(Libplanet.Blocks.IPreEvaluationBlockHeader,Libplanet.Blockchain.StateCompleterSet{`0})">
            <summary>
            Retrieves the last previous states for the previous block of
            <paramref name="blockHeader"/>.
            </summary>
            <param name="blockHeader">The header of block to reference.</param>
            <param name="stateCompleterSet">The <see cref="T:Libplanet.Blockchain.StateCompleterSet`1"/> to use.</param>
            <returns>The last previous <see cref="T:Libplanet.Action.IAccountStateDelta"/> for the previous
            <see cref="T:Libplanet.Blocks.Block`1"/>.
            </returns>
        </member>
        <member name="T:Libplanet.Action.ActionTypeAttribute">
            <summary>
            Indicates that an action class (i.e., a class implementing
            <see cref="T:Libplanet.Action.IAction"/>) can be held by transactions and blocks.
            It also gives an action class a <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> for
            serialization and deserialization.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ActionTypeAttribute.#ctor(System.String)">
            <summary>
            Creates an <see cref="T:Libplanet.Action.ActionTypeAttribute"/> with a given
            <paramref name="typeIdentifier"/>.
            </summary>
            <param name="typeIdentifier">An action class's unique
            identifier for serialization and deserialization.</param>
        </member>
        <member name="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier">
            <summary>
            An action class's unique identifier for serialization and
            deserialization.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ActionTypeAttribute.ValueOf(System.Type)">
            <summary>
            Gets the <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> for a given action class.
            </summary>
            <param name="actionType">A <see cref="T:System.Type"/> object of an action
            class to know its annotated <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/>.</param>
            <returns>The <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> of the given
            <paramref name="actionType"/> if it's annotated with
            <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.  If it's not annotated returns
            <see langword="null"/>.</returns>
        </member>
        <member name="T:Libplanet.Action.ActionTypeLoaderContext">
            <summary>
            An <see cref="T:Libplanet.Action.IActionTypeLoaderContext" /> implementation.
            </summary>
        </member>
        <member name="P:Libplanet.Action.ActionTypeLoaderContext.Index">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Action.CurrencyPermissionException">
            <summary>
            The exception that is thrown when a <see cref="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner"/> has no rights
            to mint a <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/> or burn assets of a <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/>.
            </summary>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
        </member>
        <member name="M:Libplanet.Action.CurrencyPermissionException.#ctor(System.String,Libplanet.Address,Libplanet.Assets.Currency)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.CurrencyPermissionException"/> object.
            </summary>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
            <param name="transactionSigner"> The address of the account who tried to mint or burn
            assets of a <paramref name="currency"/>.  Corresponds to
            the <see cref="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner"/> property.</param>
            <param name="currency"> The <see cref="T:Libplanet.Assets.Currency"/> to be tried to be minted
            or burned by the <paramref name="transactionSigner"/>.  Corresponds to
            the <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/> property.</param>
        </member>
        <member name="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner">
            <summary>
            The address of the account who tried to mint or burn assets of a <see cref="P:Libplanet.Action.CurrencyPermissionException.Currency"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.CurrencyPermissionException.Currency">
            <summary>
            The <see cref="T:Libplanet.Assets.Currency"/> to be tried to be minted or burned by
            the <see cref="P:Libplanet.Action.CurrencyPermissionException.TransactionSigner"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Action.DuplicateActionTypeIdentifierException">
            <summary>
            An exception that is thrown when multiple action types are associated with the same
            <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/>.
            </summary>
            <remarks>Note this cannot be serialized as it holds a set of <see cref="T:System.Type"/> objects
            which are not serializable either.</remarks>
        </member>
        <member name="M:Libplanet.Action.DuplicateActionTypeIdentifierException.#ctor(System.String,System.String,System.Collections.Immutable.IImmutableSet{System.Type})">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.DuplicateActionTypeIdentifierException"/> instance.
            </summary>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.  Note that extra
            informative text will be appended to this.</param>
            <param name="typeIdentifier">The <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> string
            that the <paramref name="duplicateActionTypes"/> are associated with.</param>
            <param name="duplicateActionTypes">The set of multiple action types that are associated
            with the same <paramref name="typeIdentifier"/>.</param>
        </member>
        <member name="P:Libplanet.Action.DuplicateActionTypeIdentifierException.TypeIdentifier">
            <summary>
            The <see cref="P:Libplanet.Action.ActionTypeAttribute.TypeIdentifier"/> string that
            the <see cref="P:Libplanet.Action.DuplicateActionTypeIdentifierException.DuplicateActionTypes"/> are associated with.
            </summary>
        </member>
        <member name="P:Libplanet.Action.DuplicateActionTypeIdentifierException.DuplicateActionTypes">
            <summary>
            The set of multiple action types that are associated with the same
            <see cref="P:Libplanet.Action.DuplicateActionTypeIdentifierException.TypeIdentifier"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Action.ExtractableException">
            <summary>
            Extension methods for <see cref="T:Libplanet.Action.IExtractableException"/> and other <see cref="T:System.Exception"/>s
            that do not implement <see cref="T:Libplanet.Action.IExtractableException"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Action.ExtractableException.ExtractMetadata(System.Exception)">
            <summary>
            Extracts metadata from any exception in a general way.
            </summary>
            <param name="exception">An exception to extract its metadata from.</param>
            <returns>Extracted metadata.  If there is not its metadata at all, or it does not
            support metadata extraction, it can return <see langword="null"/> instead.</returns>
        </member>
        <member name="T:Libplanet.Action.IAccountStateDelta">
            <summary>
            An interface to manipulate account states with
            maintaining the set of <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses"/>.
            <para>It is like a map which is virtually initialized such
            that every possible <see cref="T:Libplanet.Address"/> exists and
            is mapped to <see langword="null"/>.  That means that:</para>
            <list type="bullet">
            <item>
            <description>it does not have length,</description>
            </item>
            <item>
            <description>its index getter never throws
            <see cref="T:System.Collections.Generic.KeyNotFoundException"/>,
            but returns <see langword="null"/> instead, and</description>
            </item>
            <item>
            <description>filling an <see cref="T:Libplanet.Address"/> with
            <see langword="null"/> state cannot be distinguished from
            the <see cref="T:Libplanet.Address"/> having never been set to
            any state.</description>
            </item>
            </list>
            </summary>
            <remarks>
            This interface is immutable.  <see cref="M:Libplanet.Action.IAccountStateDelta.SetState(Libplanet.Address,Bencodex.Types.IValue)"/>
            method does not manipulate the instance, but returns a new
            <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance with updated states.
            </remarks>
        </member>
        <member name="P:Libplanet.Action.IAccountStateDelta.UpdatedAddresses">
            <summary>
            <seealso cref="T:Libplanet.Address"/>es of the accounts that have
            been updated since then.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IAccountStateDelta.StateUpdatedAddresses">
            <summary>
            <see cref="T:Libplanet.Address"/>es of the accounts whose states have been updated since then.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IAccountStateDelta.UpdatedFungibleAssets">
            <summary>
            <see cref="T:Libplanet.Address"/>es and sets of <see cref="T:Libplanet.Assets.Currency"/> whose fungible assets have
            been updated since then.
            <para>For example, if A transfers 10 FOO to B and B transfers 20 BAR to C,
            <see cref="P:Libplanet.Action.IAccountStateDelta.UpdatedFungibleAssets"/> become likes
            <c>{ [A] = { FOO }, [B] = { FOO, BAR }, [C] = { BAR } }</c>.</para>
            </summary>
        </member>
        <member name="P:Libplanet.Action.IAccountStateDelta.TotalSupplyUpdatedCurrencies">
            <summary>
            <seealso cref="T:Libplanet.Assets.Currency">Currencies</seealso> with their total supplies updated.
            </summary>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.SetState(Libplanet.Address,Bencodex.Types.IValue)">
            <summary>
            Gets a new instance that the account state of the given
            <paramref name="address"/> is set to the given
            <paramref name="state"/>.
            </summary>
            <param name="address">The <see cref="T:Libplanet.Address"/> referring
            the account to set its state.</param>
            <param name="state">The new state to fill the account with.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that
            the account state of the given <paramref name="address"/>
            is set to the given <paramref name="state"/>.</returns>
            <remarks>
            This method method does not manipulate the instance,
            but returns a new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance
            with updated states instead.
            </remarks>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Mints the fungible asset <paramref name="value"/> (i.e., in-game monetary),
            and give it to the <paramref name="recipient"/>.
            </summary>
            <param name="recipient">The address who receives the minted asset.</param>
            <param name="value">The asset value to mint.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that the given <paramref
            name="value"/> is added to <paramref name="recipient"/>'s balance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="value"/>
            is less than or equal to 0.</exception>
            <exception cref="T:Libplanet.Action.CurrencyPermissionException">Thrown when a transaction signer
            (or a miner in case of block actions) is not a member of the <see
            cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>'s <see cref="F:Libplanet.Assets.Currency.Minters"/>.</exception>
            <exception cref="T:Libplanet.Action.SupplyOverflowException">Thrown when the sum of the
            <paramref name="value"/> to be minted and the current total supply amount of the
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/> exceeds the
            <see cref="P:Libplanet.Assets.Currency.MaximumSupply"/>.</exception>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)">
            <summary>
            Transfers the fungible asset <paramref name="value"/> (i.e., in-game monetary)
            from the <paramref name="sender"/> to the <paramref name="recipient"/>.
            </summary>
            <param name="sender">The address who sends the fungible asset to
            the <paramref name="recipient"/>.</param>
            <param name="recipient">The address who receives the fungible asset from
            the <paramref name="sender"/>.</param>
            <param name="value">The asset value to transfer.</param>
            <param name="allowNegativeBalance">Turn on to allow <paramref name="sender"/>'s balance
            less than zero.  Turned off by default.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that the given <paramref
            name="value"/>  is subtracted from <paramref name="sender"/>'s balance and added to
            <paramref name="recipient"/>'s balance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="value"/>
            is less than or equal to zero.</exception>
            <exception cref="T:Libplanet.Action.InsufficientBalanceException">Thrown when the <paramref name="sender"/>
            has insufficient balance than <paramref name="value"/> to transfer and
            the <paramref name="allowNegativeBalance"/> option is turned off.</exception>
        </member>
        <member name="M:Libplanet.Action.IAccountStateDelta.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Burns the fungible asset <paramref name="value"/> (i.e., in-game monetary) from
            <paramref name="owner"/>'s balance.
            </summary>
            <param name="owner">The address who owns the fungible asset to burn.</param>
            <param name="value">The fungible asset <paramref name="value"/> to burn.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance that the given <paramref
            name="value"/> is subtracted from <paramref name="owner"/>'s balance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the <paramref name="value"/>
            is less than or equal to zero.</exception>
            <exception cref="T:Libplanet.Action.CurrencyPermissionException">Thrown when a transaction signer
            (or a miner in case of block actions) is not a member of the <see
            cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>'s <see cref="F:Libplanet.Assets.Currency.Minters"/>.</exception>
            <exception cref="T:Libplanet.Action.InsufficientBalanceException">Thrown when the <paramref name="owner"/>
            has insufficient balance than <paramref name="value"/> to burn.</exception>
        </member>
        <member name="T:Libplanet.Action.IAccountStateView">
            <summary>
            An interface to fetch account states.
            <para>It is like a readonly map which is virtually initialized such
            that every possible <see cref="T:Libplanet.Address"/> exists and
            is mapped to <see langword="null"/>.  That means that:</para>
            <list type="bullet">
            <item>
            <description>it does not have length,</description>
            </item>
            <item>
            <description>its index getter never throws
            <see cref="T:System.Collections.Generic.KeyNotFoundException"/>,
            but returns <see langword="null"/> instead, and</description>
            </item>
            <item>
            <description>filling an <see cref="T:Libplanet.Address"/> with
            <see langword="null"/> state cannot be distinguished from
            the <see cref="T:Libplanet.Address"/> having never been set to
            any state.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Libplanet.Action.IAccountStateView.GetState(Libplanet.Address)">
            <summary>
            Gets the account state of the given <paramref name="address"/>.
            </summary>
            <param name="address">The <see cref="T:Libplanet.Address"/> referring
            the account to get its state.</param>
            <returns>The account state of the given <paramref name="address"/>.
            If it has never been set to any state it returns <see langword="null"/>
            instead.</returns>
        </member>
        <member name="M:Libplanet.Action.IAccountStateView.GetStates(System.Collections.Generic.IReadOnlyList{Libplanet.Address})">
            <summary>
            Gets multiple account states associated with the specified <paramref name="addresses"/>
            at once.
            </summary>
            <param name="addresses">The <see cref="T:Libplanet.Address"/>es associated with states to get.
            </param>
            <returns>The states associated to the specified <paramref name="addresses"/>.
            Associated values are ordered in the same way to the corresponding
            <paramref name="addresses"/>.  Absent states are represented as <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Action.IAccountStateView.GetBalance(Libplanet.Address,Libplanet.Assets.Currency)">
            <summary>
            Queries <paramref name="address"/>'s balance of the <paramref name="currency"/>.
            </summary>
            <param name="address">The owner address to query.</param>
            <param name="currency">The currency type to query.</param>
            <returns>
            The <paramref name="address"/>'s balance of the <paramref name="currency"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Action.IAccountStateView.GetTotalSupply(Libplanet.Assets.Currency)">
            <summary>
            Returns the total supply of a <paramref name="currency"/>.
            </summary>
            <param name="currency">The currency type to query.</param>
            <returns>The total supply of the <paramref name="currency"/>.
            </returns>
            <exception cref="T:Libplanet.Action.TotalSupplyNotTrackableException">Thrown when the total supply of the
            given <paramref name="currency"/> is not trackable.</exception>
            <seealso cref="P:Libplanet.Assets.Currency.MaximumSupply"/>
        </member>
        <member name="T:Libplanet.Action.IAction">
            <summary>
            An in-game action.  Every action should be replayable, because
            multiple nodes in a network should execute an action and get the same
            result.
            <para>A &#x201c;class&#x201d; which implements this interface is
            analogous to a function, and its instance is analogous to a
            <a href="https://en.wikipedia.org/wiki/Partial_application">partial
            function application</a>, in other words, a function with some bound
            arguments.  Those parameters that will be bound at runtime should be
            represented as fields or properties in an action class, and bound
            argument values to these parameters should be received through
            a constructor parameters of that class.</para>
            <para>From a perspective of security, an action class belongs to
            the network protocol, and property values in an action belong to
            a node's will (i.e., a user/player's choice).
            That means if you define an action class it also defines what every
            honest node can do in the network.  Even if a malicious node changes
            their own action code it won't affect other honest nodes in
            the network.</para>
            <para>For example, where honest nodes share the common action
            <c>Heal(Target) => PreviousStates[Target] + 1</c>, suppose a malicious
            node <c>m</c> changes their own <c>Heal</c> action code to
            <c>Heal(Target) => PreviousStates[Target] + 2</c> (2 instead of 1),
            and then send an action <c>Heal(m)</c>.
            Fortunately, this action does not work as <c>m</c>'s intention,
            because the changed code in itself is not used by other honest nodes,
            so they still increase only 1, not 2.  The effect of that double healing
            is a sort of &#x201c;illusion&#x201d; only visible to the malicious node
            alone.</para>
            <para>In conclusion, action code is a part of the protocol and it works with
            consensus in the network, so only things each node can affect the network
            in general is property values of each action they sign and send,
            not code of an action.</para>
            </summary>
            <example>
            The following example shows how to implement an action of three types
            of in-game logic:
            <code><![CDATA[
            using System;
            using System.Collections.Generic;
            using System.Collections.Immutable;
            using Bencodex.Types;
            using Libplanet;
            using Libplanet.Action;
            public class MyAction : IAction
            {
                // Declare an enum type to distinguish types of in-game logic.
                public enum ActType { CreateCharacter, Attack, Heal }
                // Declare properties (or fields) to store "bound" argument values.
                public ActType Type { get; private set; }
                public Address TargetAddress { get; private set; }
                // Action must has a public parameterless constructor.
                // Usually this is used only by Libplanet's internals.
                public MyAction() {}
                // Take argument values to "bind" through constructor parameters.
                public MyAction(ActType type, Address targetAddress)
                {
                    Type = type;
                    TargetAddress = targetAddress;
                }
                // The main game logic belongs to here.  It takes the
                // previous states through its parameter named context,
                // and is offered "bound" argument values through
                // its own properties (or fields).
                IAccountStateDelta IAction.Execute(IActionContext context)
                {
                    // Gets the state immediately before this action is executed.
                    // ImmutableDictionary<string, uint> is just for example,
                    // As far as it is serializable, you can store any types.
                    // (We recommend to use immutable types though.)
                    var state =
                        context.PreviousStates.GetState(TargetAddress);
                    Dictionary dictionary;
                    // This variable purposes to store the state
                    // right after this action finishes.
                    IImmutableDictionary<IKey, IValue> nextState;
                    // Does different things depending on the action's type.
                    // This way is against the common principals of programming
                    // as it is just an example.  You could compare this with
                    // a better example of PolymorphicAction<T> class.
                    switch (Type)
                    {
                        case ActType.CreateCharacter:
                            if (!TargetAddress.Equals(context.Signer))
                                throw new Exception(
                                    "TargetAddress of CreateCharacter action " +
                                    "only can be the same address to the " +
                                    "Transaction<T>.Signer.");
                            else if (!(state is null))
                                throw new Exception(
                                    "Character was already created.");
                            nextState = ImmutableDictionary<IKey, IValue>.Empty
                                .Add((Text)"hp", (Integer)20);
                            break;
                        case ActType.Attack:
                            dictionary = (Bencodex.Types.Dictionary)state;
                            nextState =
                                dictionary.SetItem(
                                    (Text)"hp",
                                    (Integer)Math.Max(
                                        dictionary.GetValue<Integer>("hp") - 5,
                                        0)
                                );
                            break;
                        case ActType.Heal:
                            dictionary = (Bencodex.Types.Dictionary)state;
                            nextState =
                                dictionary.SetItem(
                                    (Text)"hp",
                                    (Integer)Math.Min(
                                        dictionary.GetValue<Integer>("hp") + 5,
                                        20)
                                );
                            break;
                        default:
                            throw new Exception(
                                "Properties are not properly initialized.");
                    }
                    // Builds a delta (dirty) from previous to next states, and
                    // returns it.
                    return context.PreviousStates.SetState(TargetAddress,
                        (Dictionary)nextState);
                }
                // Serializes its "bound arguments" so that they are transmitted
                // over network or stored to the persistent storage.
                IValue IAction.PlainValue =>
                    new Bencodex.Types.Dictionary(new Dictionary<IKey, IValue>
                    {
                        [(Text)"type"] = (Integer)(int)Type,
                        [(Text)"target_address"] = (Binary)TargetAddress.ToByteArray(),
                    });
                // Deserializes "bound arguments".  That is, it is inverse
                // of PlainValue property.
                void IAction.LoadPlainValue(
                    IValue plainValue)
                {
                    var dictionary = (Bencodex.Types.Dictionary)plainValue;
                    Type = (ActType)(int)dictionary.GetValue<Integer>("type");
                    TargetAddress =
                        new Address(dictionary.GetValue<Binary>("target_address"));
                }
            }
            ]]></code>
            <para>Note that the above example has several bad practices.
            Compare this example with <see cref="T:Libplanet.Action.PolymorphicAction`1"/>'s
            example.</para>
            </example>
        </member>
        <member name="P:Libplanet.Action.IAction.PlainValue">
            <summary>
            Serializes values bound to an action, which is held by properties
            (or fields) of an action, so that they can be transmitted over
            network or saved to persistent storage.
            <para>Serialized values are deserialized by
            <see cref="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)"/> method later.</para>
            </summary>
            <returns>A Bencodex value which encodes this action's bound values (held
            by properties or fields).
            </returns>
            <seealso cref="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)"/>
        </member>
        <member name="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)">
            <summary>
            Deserializes serialized data (i.e., data <see cref="P:Libplanet.Action.IAction.PlainValue"/>
            property made), and then fills this action's properties (or fields)
            with the deserialized values.
            </summary>
            <param name="plainValue">Data (made by <see cref="P:Libplanet.Action.IAction.PlainValue"/>
            property) to be deserialized and assigned to this action's
            properties (or fields).</param>
            <seealso cref="P:Libplanet.Action.IAction.PlainValue"/>
        </member>
        <member name="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)">
            <summary>
            Executes the main game logic of an action.  This should be
            <em>deterministic</em>.
            <para>Through the <paramref name="context"/> object,
            it receives information such as a transaction signer,
            its states immediately before the execution,
            and a deterministic random seed.</para>
            <para>Other &#x201c;bound&#x201d; information resides in the action
            object in itself, as its properties (or fields).</para>
            <para>A returned <see cref="T:Libplanet.Action.IAccountStateDelta"/> object functions as
            a delta which shifts from previous states to next states.</para>
            </summary>
            <param name="context">A context object containing addresses that
            signed the transaction, states immediately before the execution,
            and a PRNG object which produces deterministic random numbers.
            See <see cref="T:Libplanet.Action.IActionContext"/> for details.</param>
            <returns>A map of changed states (so-called "dirty").</returns>
            <remarks>This method should be deterministic:
            for structurally (member-wise) equal actions and <see
            cref="T:Libplanet.Action.IActionContext"/>s, the same result should be returned.
            Side effects should be avoided, because an action's
            <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method can be called more
            than once, the time it's called is difficult to predict.
            <para>For changing in-memory game states or drawing graphics,
            implement the <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> interface separately and
            attach it to a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance.</para>
            <para>For randomness, <em>never</em> use <see cref="T:System.Random"/>
            nor any other PRNGs provided by other than Libplanet.
            Use <see cref="P:Libplanet.Action.IActionContext.Random"/> instead.
            <see cref="P:Libplanet.Action.IActionContext.Random"/> guarantees the same action
            has the consistent result for every node in the network.</para>
            <para>Also do not perform I/O operations such as file system access
            or networking.  These bring an action indeterministic.  You maybe
            fine to log messages for debugging purpose, but equivalent messages
            could be logged multiple times.</para>
            <para>Although it might be surprising, <a
            href="https://wp.me/p1fTCO-kT">floating-point arithmetics are
            underspecified so that it can make different results on different
            machines, platforms, runtimes, compilers, and builds</a>.</para>
            <para>Lastly, you need to be aware and keep in mind that there
            is a global state named <see
            cref="P:System.Globalization.CultureInfo.CurrentCulture"/> on .NET;
            if you format numbers, dates and times, currencies, or other such
            things into strings and parse these strings back these can rely on
            <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>,
            so that the same action make different results on two differently
            configured systems like Thai language and French language.
            In order to make these types of conversions deterministic,
            you have to explicitly pass <see
            cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.</para>
            <para>For more on determinism in general, please read also <a
            href="https://tendermint.com/docs/spec/abci/abci.html#determinism"
            >Tendermint ABCI's docs on determinism</a>.</para>
            <para>Lastly, you can conduct static analysis on your code
            using <a href="https://git.io/JTmby">Libplanet.Analyzers</a>.
            The analyzer can be enabled by adding its NuGet package into
            your project as a dependency.</para>
            </remarks>
            <seealso cref="T:Libplanet.Action.IActionContext"/>
        </member>
        <member name="T:Libplanet.Action.IActionContext">
            <summary>
            Contextual data determined by a transaction and a block.
            Passed to <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.GenesisHash">
            <summary>
            The genesis block's hash.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Signer">
            <summary>
            <see cref="T:Libplanet.Address"/> of an account who made and signed
            a transaction that an executed <see cref="T:Libplanet.Action.IAction"/> belongs to.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.TxId">
            <summary>
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of a transaction that an executed <see cref="T:Libplanet.Action.IAction"/>
            belongs to.  This is <see langword="null"/>
            iff <see cref="P:Libplanet.Action.IActionContext.BlockAction"/> is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Miner">
            <summary>
            <see cref="T:Libplanet.Address"/> of a block miner account.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.BlockIndex">
            <summary>
            <see cref="T:Libplanet.Blocks.Block`1"/>.<see cref="P:Libplanet.Blocks.Block`1.Index"/> of a transaction that an executed
            <see cref="T:Libplanet.Action.IAction"/> belongs to.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Rehearsal">
            <summary>
            Whether an <see cref="T:Libplanet.Action.IAction"/> is being executed during
            &#x201c;rehearsal mode&#x201d;, that there is nothing
            in <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.PreviousStates">
            <summary>
            A null delta of states, which means it represents the states
            before <see cref="T:Libplanet.Action.IAction"/> executes.
            <para>Although a <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance is
            immutable, it has several manipulative methods that returns
            new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instances with some "dirty"
            states.  These kinds of dirty <see cref="T:Libplanet.Action.IAccountStateDelta"/>
            instances can be returned by <see
            cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.</para>
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.Random">
            <summary>
            An initialized pseudorandom number generator.  Its seed (state)
            is determined by a block and a transaction, which is
            deterministic so that every node can replay the same action and
            then reproduce the same result, while neither a single block miner
            nor a single transaction signer can predict the result and cheat.
            </summary>
            <returns>A random object that shares interface mostly equivalent
            to <see cref="T:System.Random"/>.</returns>
        </member>
        <member name="P:Libplanet.Action.IActionContext.PreviousStateRootHash">
            <summary>
            A state root hash at the <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/>.  It can cause file I/O interrupt.
            It will be return null if the implementation or your chain didn't support
            the state root hash feature.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionContext.BlockAction">
            <summary>
            Whether this action is executed as a block action.
            <see langword="false"/> if it belongs to a transaction.
            </summary>
        </member>
        <member name="M:Libplanet.Action.IActionContext.PutLog(System.String)">
            <summary>
            Record a log in <see cref="T:Libplanet.Tx.TxExecution"/>.
            </summary>
            <param name="log">A log to record in <see cref="T:Libplanet.Tx.TxExecution"/>.</param>
        </member>
        <member name="M:Libplanet.Action.IActionContext.IsNativeToken(Libplanet.Assets.Currency)">
            <summary>
            Checks whether the specified <paramref name="currency"/> is a native token defined by
            chain's <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/>.
            </summary>
            <param name="currency">A token currency to check.</param>
            <returns><see langword="true"/> if the specified <paramref name="currency"/> is a native
            token, otherwise <see langword="false"/>.</returns>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/>
        </member>
        <member name="M:Libplanet.Action.IActionContext.GetUnconsumedContext">
            <summary>
            Returns a clone of this context, except that its <see cref="P:Libplanet.Action.IActionContext.Random"/> has the unconsumed
            state (with the same seed).  The clone and its original are a distinct instance
            each other, in other words, one's state transfer must not affect the other one
            (i.e., consuming <see cref="P:Libplanet.Action.IActionContext.Random"/> source should be local to a context instance).
            </summary>
            <returns>A clone instance, which is distinct from its original.  Its internal state
            is entirely equivalent to the original's unconsumed initial state.</returns>
        </member>
        <member name="T:Libplanet.Action.IActionTypeLoader">
            <summary>
            An interface to load action types branched by block index.
            </summary>
        </member>
        <member name="M:Libplanet.Action.IActionTypeLoader.Load(Libplanet.Action.IActionTypeLoaderContext)">
            <summary>
            Load action types branched by <paramref name="context"/>.
            </summary>
            <param name="context">A <see cref="T:Libplanet.Action.IActionTypeLoaderContext"/> to determine
            what action types to use.</param>
            <returns>A dictionary made of action id to action type pairs.</returns>
        </member>
        <member name="M:Libplanet.Action.IActionTypeLoader.LoadAllActionTypes(Libplanet.Action.IActionTypeLoaderContext)">
            <summary>
            Load action types branched by <paramref name="context"/>.
            </summary>
            <param name="context">A <see cref="T:Libplanet.Action.IActionTypeLoader"/> to determine
            what action types to use.</param>
            <returns>Types of available actions. It also includes actions not having
            <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.</returns>
        </member>
        <member name="T:Libplanet.Action.IActionTypeLoaderContext">
            <summary>
            An interface to provide contextual variables to load action types.
            </summary>
        </member>
        <member name="P:Libplanet.Action.IActionTypeLoaderContext.Index">
            <summary>
            A block index.
            </summary>
        </member>
        <member name="T:Libplanet.Action.IExtractableException">
            <summary>
            Marks an exception type as able to extract its metadata, so that these metadata can be
            stored as a part of <see cref="T:Libplanet.Tx.TxFailure"/>.
            </summary>
            <seealso cref="P:Libplanet.Tx.TxFailure.ExceptionMetadata"/>
        </member>
        <member name="P:Libplanet.Action.IExtractableException.Metadata">
            <summary>
            Metadata of the exception.  It purposes to store these metadata as a part of
            <see cref="T:Libplanet.Tx.TxFailure"/>.
            </summary>
            <remarks>As every metadata becomes a part of blockchain, which is replicated database
            on the network, for the equivalent exception, the same metadata should be extracted.
            </remarks>
        </member>
        <member name="T:Libplanet.Action.InsufficientBalanceException">
            <summary>
            The exception that is thrown when a sender has less <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/> than amount to
            transfer or an owner has less <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/> than amount to burn.
            </summary>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.TransferAsset(Libplanet.Address,Libplanet.Address,Libplanet.Assets.FungibleAssetValue,System.Boolean)"/>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.BurnAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
        </member>
        <member name="M:Libplanet.Action.InsufficientBalanceException.#ctor(System.String,Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.InsufficientBalanceException"/> object.
            </summary>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
            <param name="address">The owner of the insufficient <paramref name="balance"/>.
            Corresponds to the <see cref="P:Libplanet.Action.InsufficientBalanceException.Address"/> property.</param>
            <param name="balance">The account's current balance.
            Corresponds to the <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/> property.</param>
        </member>
        <member name="P:Libplanet.Action.InsufficientBalanceException.Address">
            <summary>
            The owner of the insufficient <see cref="P:Libplanet.Action.InsufficientBalanceException.Balance"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.InsufficientBalanceException.Balance">
            <summary>
            The account's current balance.
            </summary>
        </member>
        <member name="T:Libplanet.Action.IRandom">
            <summary>
            An pseudorandom number generator interface equivalent to
            <see cref="T:System.Random"/>.
            <para>Although these two types have similar shapes, they are not
            compatible (i.e., disallowed to be casted to each other).</para>
            </summary>
        </member>
        <member name="P:Libplanet.Action.IRandom.Seed">
            <summary>
            A number used to calculate a starting value for the pseudo-random
            number sequence.
            </summary>
        </member>
        <member name="M:Libplanet.Action.IRandom.Next">
            <summary>
            Gets a non-negative random integer.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to
            0 and less than <see cref="F:System.Int32.MaxValue"/>.</returns>
            <seealso cref="M:System.Random.Next"/>
        </member>
        <member name="M:Libplanet.Action.IRandom.Next(System.Int32)">
            <summary>
            Gets a non-negative random integer that is less than the specified
            <paramref name="upperBound"/>.
            </summary>
            <param name="upperBound">The exclusive upper bound of the random
            number to be generated.  It must be greater than or equal to 0.
            </param>
            <returns>A 32-bit signed integer that is greater than or equal to
            0 and less than <paramref name="upperBound"/>; that is, the range of
            return values ordinarily includes 0 but not <paramref
            name="upperBound"/>.  However, if <paramref name="upperBound"/> equals
            to 0, <paramref name="upperBound"/> is returned.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when
            <paramref name="upperBound"/> is less than 0.</exception>
            <seealso cref="M:System.Random.Next(System.Int32)"/>
        </member>
        <member name="M:Libplanet.Action.IRandom.Next(System.Int32,System.Int32)">
            <summary>
            Gets a random integer that is within a specified range.
            </summary>
            <param name="lowerBound">The inclusive lower bound of the random
            number to be generated.</param>
            <param name="upperBound">The exclusive upper bound of the random
            number to be generated.  It must be greater than or equal to
            <paramref name="lowerBound"/>.
            </param>
            <returns>A 32-bit signed integer that is greater than or equal to
            <paramref name="lowerBound"/> and less than <paramref
            name="upperBound"/>; that is, the range of return values ordinarily
            includes <paramref name="lowerBound"/> but not <paramref
            name="upperBound"/>.  If <paramref name="upperBound"/> equals to
            <paramref name="lowerBound"/>, <paramref name="lowerBound"/> is
            returned.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when
            <paramref name="upperBound"/> is less than <paramref
            name="lowerBound"/>.</exception>
            <seealso cref="M:System.Random.Next(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Libplanet.Action.IRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified <see cref="T:System.Byte"/>s <paramref
            name="buffer"/> with random numbers.
            </summary>
            <param name="buffer">A <see cref="T:System.Byte"/> array to contain random
            numbers.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref
            name="buffer"/> is <see langword="null"/>.</exception>
            <seealso cref="M:System.Random.NextBytes(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Action.IValidatorSupportStateDelta.GetValidatorSet">
            <summary>
            Returns the validator set.
            </summary>
            <returns>The validator set of type <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Action.IValidatorSupportStateDelta.SetValidator(Libplanet.Consensus.Validator)">
            <summary>
            Sets <paramref name="validator"/> to the stored <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            If 0 is given as its power, removes the validator from the <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            </summary>
            <param name="validator">The <see cref="T:Libplanet.Consensus.Validator"/> instance to write.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance with
            <paramref name="validator"/> set.</returns>
        </member>
        <member name="T:Libplanet.Action.MissingActionTypeException">
            <summary>
            The exception that is thrown when an action class without
            <see cref="T:Libplanet.Action.ActionTypeAttribute"/> is tried to used with
            <see cref="T:Libplanet.Action.PolymorphicAction`1"/>.
            </summary>
            <seealso cref="T:Libplanet.Action.PolymorphicAction`1"/>
        </member>
        <member name="M:Libplanet.Action.MissingActionTypeException.#ctor(System.String,System.Type)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.MissingActionTypeException"/> object.
            </summary>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.</param>
            <param name="actionType">The action type that lacks
            <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
        </member>
        <member name="P:Libplanet.Action.MissingActionTypeException.ActionType">
            <summary>
            The action type that lacks <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Action.NullAction">
            <summary>
            An action implementation which does nothing for filling type parameter taking of
            <see cref="T:Libplanet.Action.IAction"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Action.PolymorphicAction`1">
            <summary>
            A decorator to enable subtype polymorphism for action classes.
            <para>By convention, concrete action subclasses are named with verb
            phrases, e.g., <c>Heal</c>, <c>Sell</c>.</para>
            <para>One downside of this compared to the vanilla <see cref="T:Libplanet.Action.IAction"/>
            is the fact that it uses reflection under the hood.  This may cause
            compatibility issues on certain platforms, and is slightly slower.
            </para>
            </summary>
            <typeparam name="T">An action base class which implements
            <see cref="T:Libplanet.Action.IAction"/> and has subclasses.  Usually an abstract
            class.</typeparam>
            <example>
            The following example shows how polymorphic actions look like
            (compare this with an <see cref="T:Libplanet.Action.IAction"/> example without
            subtype polymorphism):
            <code><![CDATA[
            using System;
            using System.Collections.Generic;
            using Bencodex.Types;
            using Libplanet;
            using Libplanet.Action;
            // Instead of having multiple in-game actions in a class,
            // in this example, we declare one abstract base class
            // and its three concrete subclasses.
            public abstract class ActionBase : IAction
            {
                public ActionBase() { }
                public ActionBase(Address targetAddress)
                {
                    TargetAddress = targetAddress;
                }
                public Address TargetAddress { get; private set; }
                // Leaves Execute() abstract so that concrete subclasses
                // implement their own logic.
                public abstract IAccountStateDelta Execute(IActionContext context);
                IValue IAction.PlainValue =>
                    new Bencodex.Types.Dictionary(new Dictionary<IKey, IValue>
                    {
                        [(Text)"target_address"] = (Binary)TargetAddress.ToByteArray(),
                    });
                void IAction.LoadPlainValue(
                    IValue plainValue)
                {
                    var dictionary = (Bencodex.Types.Dictionary)plainValue;
                    TargetAddress =
                        new Address(dictionary.GetValue<Binary>("target_address"));
                }
            }
            // PolymorphicAction<T> requires concrete action classes marked with
            // ActionTypeAttribute.
            // There is only one required parameter to ActionTypeAttribute,
            // which takes a unique identifier of the action type.
            // This is used for serialization and deserialization under the hood.
            [ActionType("create_character")]
            public sealed class CreateCharacter : ActionBase
            {
                public override IAccountStateDelta Execute(IActionContext context)
                {
                    var state =
                        context.PreviousStates.GetState(TargetAddress);
                    if (!TargetAddress.Equals(context.Signer))
                        throw new Exception(
                            "TargetAddress of CreateCharacter action only can be " +
                            "the same address to the Transaction<T>.Signer."
                        );
                    else if (!(state is null))
                        throw new Exception("Character was already created.");
                    return context.PreviousStates.SetState(
                        TargetAddress,
                        new Bencodex.Types.Dictionary(new Dictionary<IKey, IValue>
                        {
                            [(Text)"hp"] = (Integer)20,
                        })
                    );
                }
            }
            [ActionType("attack")]
            public sealed class Attack : ActionBase
            {
                public override IAccountStateDelta Execute(IActionContext context)
                {
                    var state =
                        (Bencodex.Types.Dictionary)context.PreviousStates.GetState(TargetAddress);
                    return context.PreviousStates.SetState(
                        TargetAddress,
                        (Bencodex.Types.Dictionary)state
                            .SetItem(
                                (Text)"hp",
                                (Integer)Math.Max(state.GetValue<Integer>("hp") - 5, 0))
                    );
                }
            }
            [ActionType("heal")]
            public sealed class Heal : ActionBase
            {
                public override IAccountStateDelta Execute(IActionContext context)
                {
                    var state =
                        (Bencodex.Types.Dictionary)context.PreviousStates.GetState(TargetAddress);
                    return context.PreviousStates.SetState(
                        TargetAddress,
                        (Bencodex.Types.Dictionary)state
                            .SetItem(
                                (Text)"hp",
                                (Integer)Math.Min(state.GetValue<Integer>("hp") + 5, 20))
                    );
                }
            }
            ]]></code>
            Note that when it's rendered through <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            an instance of <see cref="T:Libplanet.Action.PolymorphicAction`1"/> is passed instead of its
            <see cref="P:Libplanet.Action.PolymorphicAction`1.InnerAction"/>:
            <code>
            public class Renderer : IActionRenderer&lt;PolymorphicAction&lt;ActionBase&gt;&gt;
            {
                public void RenderAction(IAction action,
                                         IActionContext context,
                                         IAccountStateDelta nextStates)
                {
                    if (action is PolymorphicAction&lt;ActionBase&gt; polymorphicAction)
                    {
                        switch (polymorphicAction.InnerAction)
                        {
                            // render things here
                        }
                    }
                }
                // ... other method implementations
            }
            </code>
            </example>
            <remarks>Every concrete action subclass of <typeparamref name="T"/>
            has to be marked with the <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.
            Even if a superclass is marked with
            the <see cref="T:Libplanet.Action.ActionTypeAttribute"/> its subclass also should be
            marked with the <see cref="T:Libplanet.Action.ActionTypeAttribute"/> if it is concrete.
            <para>Also, every concrete action subclass of <typeparamref name="T"/>
            has to be declared in the same assembly as <typeparamref name="T"/>,
            or at least in the entry assembly of the application.</para>
            </remarks>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.#ctor">
            <summary>
            Do not use this constructor.
            Use <see cref="M:Libplanet.Action.PolymorphicAction`1.#ctor(`0)"/> instead.
            </summary>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.#ctor(`0)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.PolymorphicAction`1"/> instance wrapping
            an <paramref name="innerAction"/>.
            </summary>
            <param name="innerAction">An instance of <typeparamref name="T"/>
            (or one of its subtypes) to wrap.</param>
            <exception cref="T:Libplanet.Action.MissingActionTypeException">Thrown
            when the class of the given <paramref name="innerAction"/>
            is not annotated with <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.</exception>
        </member>
        <member name="P:Libplanet.Action.PolymorphicAction`1.InnerAction">
            <summary>
            The wrapped action object of <typeparamref name="T"/>
            (or one of its subtypes).
            </summary>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.op_Implicit(`0)~Libplanet.Action.PolymorphicAction{`0}">
            <summary>
            For convenience, an inner action <typeparamref name="T"/> can be
            implicitly casted to <see cref="T:Libplanet.Action.PolymorphicAction`1"/>.
            </summary>
            <param name="innerAction">An instance of <typeparamref name="T"/>
            (or one of its subtypes) to wrap.</param>
            <returns>A <see cref="T:Libplanet.Action.PolymorphicAction`1"/> wrapping the given
            <paramref name="innerAction"/>.</returns>
            <exception cref="T:Libplanet.Action.MissingActionTypeException">Thrown
            when the class of the given <paramref name="innerAction"/>
            is not annotated with <see cref="T:Libplanet.Action.ActionTypeAttribute"/>.</exception>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.LoadPlainValue(Bencodex.Types.IValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Action.PolymorphicAction`1.Execute(Libplanet.Action.IActionContext)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Action.RandomExtensions">
            <summary>
            This extension class provides some convenient methods
            to deal with <see cref="T:Libplanet.Action.IRandom"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Action.RandomExtensions.GenerateRandomGuid(Libplanet.Action.IRandom)">
            <summary>
            Generates a UUID version 4, i.e., a random <see cref="T:System.Guid"/>.
            Please refer to <a href="https://tools.ietf.org/html/rfc4122#section-4.4">RFC 4122</a>.
            </summary>
            <param name="random"> <see cref="T:Libplanet.Action.IRandom"/> to generate
            a random <see cref="T:System.Guid"/>.</param>
            <returns> Generated random <see cref="T:System.Guid"/>.
            </returns>
            <seealso cref="T:Libplanet.Action.IRandom"/>
        </member>
        <member name="T:Libplanet.Action.StaticActionTypeLoader">
            <summary>
            An <see cref="T:Libplanet.Action.IActionTypeLoader"/> implementation to load action types
            without branching by block index.
            </summary>
        </member>
        <member name="M:Libplanet.Action.StaticActionTypeLoader.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Type)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.StaticActionTypeLoader"/> instance.
            </summary>
            <param name="assemblies">The assemblies to load actions from.</param>
            <param name="baseType">The base type of actions to load.</param>
        </member>
        <member name="M:Libplanet.Action.StaticActionTypeLoader.Load(Libplanet.Action.IActionTypeLoaderContext)">
            <summary>
            Load action types inherited the base type given in the constructor from assemblies.
            </summary>
            <param name="context">A <see cref="T:Libplanet.Action.IActionTypeLoaderContext"/> to determine
            what action types to use. But it isn't used in this implementation.</param>
            <returns>A dictionary made of action id to action type pairs.</returns>
        </member>
        <member name="M:Libplanet.Action.StaticActionTypeLoader.LoadAllActionTypes(Libplanet.Action.IActionTypeLoaderContext)">
            <summary>
            Load all action types from assemblies.
            </summary>
            <param name="context">A <see cref="T:Libplanet.Action.IActionTypeLoaderContext"/> to determine what action
            types to use. But it isn't used in this implementation.</param>
            <returns>A dictionary made of action id to action type pairs.</returns>
        </member>
        <member name="T:Libplanet.Action.SupplyOverflowException">
            <summary>
            The exception thrown when a minter tries to mint a currency such that the resulting total
            supply exceed the maximum amount.
            </summary>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
        </member>
        <member name="M:Libplanet.Action.SupplyOverflowException.#ctor(System.String,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.SupplyOverflowException"/> object.
            </summary>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
            <param name="amount">The attempted amount to be minted.
            Corresponds to the <see cref="P:Libplanet.Action.SupplyOverflowException.Amount"/> property.</param>
        </member>
        <member name="P:Libplanet.Action.SupplyOverflowException.Amount">
            <summary>
            The attempted amount to be minted.
            </summary>
        </member>
        <member name="T:Libplanet.Action.Sys.Mint">
            <summary>
            A system action that mints specified <see cref="P:Libplanet.Action.Sys.Mint.Amount"/> of tokens to a given
            <see cref="P:Libplanet.Action.Sys.Mint.Recipient"/>.
            </summary>
            <remarks>Only native tokens can be minted.</remarks>
        </member>
        <member name="M:Libplanet.Action.Sys.Mint.#ctor(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Action.Sys.Mint"/> action.
            </summary>
            <param name="recipient">The address of the recipient to receive the minted tokens.
            </param>
            <param name="amount">The amount of the asset to be minted.</param>
        </member>
        <member name="P:Libplanet.Action.Sys.Mint.Recipient">
            <summary>
            The address of the recipient to receive the minted tokens.
            </summary>
        </member>
        <member name="P:Libplanet.Action.Sys.Mint.Amount">
            <summary>
            The amount of the asset to be minted.
            </summary>
        </member>
        <member name="P:Libplanet.Action.Sys.Mint.PlainValue">
            <inheritdoc cref="P:Libplanet.Action.IAction.PlainValue"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Mint.LoadPlainValue(Bencodex.Types.IValue)">
            <inheritdoc cref="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Mint.Execute(Libplanet.Action.IActionContext)">
            <inheritdoc cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Mint.Equals(Libplanet.Action.Sys.Mint)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Mint.Equals(Libplanet.Action.IAction)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Mint.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Mint.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Libplanet.Action.Sys.SetValidator">
            <summary>
            A system action that promotes given address to the validator.
            </summary>
        </member>
        <member name="M:Libplanet.Action.Sys.SetValidator.#ctor(Libplanet.Consensus.Validator)">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Action.Sys.SetValidator"/> action.
            </summary>
            <param name="validator">The <see cref="P:Libplanet.Action.Sys.SetValidator.Validator"/> to be set.</param>
        </member>
        <member name="P:Libplanet.Action.Sys.SetValidator.PlainValue">
            <inheritdoc cref="P:Libplanet.Action.IAction.PlainValue"/>
        </member>
        <member name="M:Libplanet.Action.Sys.SetValidator.LoadPlainValue(Bencodex.Types.IValue)">
            <inheritdoc cref="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.SetValidator.Execute(Libplanet.Action.IActionContext)">
            <inheritdoc cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.SetValidator.Equals(Libplanet.Action.Sys.SetValidator)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.SetValidator.Equals(Libplanet.Action.IAction)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.SetValidator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.SetValidator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Libplanet.Action.Sys.Transfer">
            <summary>
            A system action that transfers the ownership of specified <see cref="P:Libplanet.Action.Sys.Transfer.Amount"/> of tokens to
            another account.
            </summary>
            <remarks>Only native tokens can be transferred.</remarks>
        </member>
        <member name="M:Libplanet.Action.Sys.Transfer.#ctor(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Action.Sys.Transfer"/> action.
            </summary>
            <param name="recipient">The address of the recipient.</param>
            <param name="amount">The amount of the asset to be transferred.</param>
        </member>
        <member name="P:Libplanet.Action.Sys.Transfer.Recipient">
            <summary>
            The address of the recipient.
            </summary>
        </member>
        <member name="P:Libplanet.Action.Sys.Transfer.Amount">
            <summary>
            The amount of the asset to be transferred.
            </summary>
        </member>
        <member name="P:Libplanet.Action.Sys.Transfer.PlainValue">
            <inheritdoc cref="P:Libplanet.Action.IAction.PlainValue"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Transfer.LoadPlainValue(Bencodex.Types.IValue)">
            <inheritdoc cref="M:Libplanet.Action.IAction.LoadPlainValue(Bencodex.Types.IValue)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Transfer.Execute(Libplanet.Action.IActionContext)">
            <inheritdoc cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Transfer.Equals(Libplanet.Action.Sys.Transfer)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Transfer.Equals(Libplanet.Action.IAction)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Transfer.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Action.Sys.Transfer.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Libplanet.Action.TotalSupplyGetter">
            <summary>
            An delegate to provide a view of total supply of a currency.
            <para>Gets the total supply of the given <paramref name="currency"/>.
            </para>
            </summary>
            <param name="currency">The currency type to query the total supply.
            </param>
            <returns>The total supply value of the <paramref name="currency"/> in
            <see cref="T:Libplanet.Assets.FungibleAssetValue"/>.
            <exception cref="T:Libplanet.Action.TotalSupplyNotTrackableException">Thrown when the total supply of the
            given <paramref name="currency"/> is not trackable.</exception>
            </returns>
        </member>
        <member name="T:Libplanet.Action.TotalSupplyNotTrackableException">
            <summary>
            The exception thrown when <see cref="M:Libplanet.Action.IAccountStateView.GetTotalSupply(Libplanet.Assets.Currency)"/> was called on a
            legacy untracked currency with <see cref="F:Libplanet.Assets.Currency.TotalSupplyTrackable"/> set to
            <see langword="false"/>.
            </summary>
            <seealso cref="M:Libplanet.Action.IAccountStateView.GetTotalSupply(Libplanet.Assets.Currency)"/>
        </member>
        <member name="M:Libplanet.Action.TotalSupplyNotTrackableException.#ctor(System.String,Libplanet.Assets.Currency)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.TotalSupplyNotTrackableException"/> object.
            </summary>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
            <param name="currency">The currency queried for the total supply.
            Corresponds to the <see cref="P:Libplanet.Action.TotalSupplyNotTrackableException.Currency"/> property.
            </param>
        </member>
        <member name="P:Libplanet.Action.TotalSupplyNotTrackableException.Currency">
            <summary>
            The currency queried for the total supply.
            </summary>
        </member>
        <member name="T:Libplanet.Action.UnexpectedlyTerminatedActionException">
            <summary>
            The exception that is thrown during an <see cref="T:Libplanet.Action.IAction"/> is being evaluated.
            <para>The actual exception that the <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> threw
            is stored in the <see cref="P:System.Exception.InnerException"/> property.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Action.UnexpectedlyTerminatedActionException.#ctor(System.String,System.Nullable{System.Collections.Immutable.ImmutableArray{System.Byte}},System.Nullable{System.Int64},System.Nullable{Libplanet.Tx.TxId},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Action.IAction,System.Exception)">
            <summary>
            Creates a new <see cref="T:Libplanet.Action.UnexpectedlyTerminatedActionException"/> object.
            </summary>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
            <param name="preEvaluationHash">The <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/> of the
            <see cref="T:Libplanet.Blocks.Block`1"/> that <paramref name="action"/> belongs to.
            This can be <see langword="null"/> on rehearsal mode.</param>
            <param name="blockIndex">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that <paramref name="action"/> belongs to.
            This can be <see langword="null"/> on rehearsal mode.
            </param>
            <param name="txid">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of
            the <see cref="T:Libplanet.Tx.Transaction`1"/> that <paramref name="action"/> belongs to.
            This can be <see langword="null"/> on rehearsal mode or if <paramref name="action"/> is
            a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.
            </param>
            <param name="action">The <see cref="T:Libplanet.Action.IAction"/> object which threw an exception.</param>
            <param name="previousStateRootHash">The <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of states until
            previous action execution.  This can be null on rehearsal mode or if the chain which
            executed the action, was not using <see cref="T:Libplanet.Store.TrieStateStore"/>.</param>
            <param name="innerException">The actual exception that the <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> threw.
            </param>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.PreEvaluationHash">
            <summary>
            The <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> that
            <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> belongs to.  This can be <see langword="null"/> on rehearsal mode.
            </summary>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.BlockIndex">
            <summary>
            The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> that <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/>
            belongs to.  This can be <see langword="null"/> on rehearsal mode.
            </summary>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.TxId">
            <summary>
            The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/> that
            <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> belongs to.
            This can be <see langword="null"/> on rehearsal mode or
            if <see cref="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action"/> is a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Action.UnexpectedlyTerminatedActionException.Action">
            <summary>
            The <see cref="T:Libplanet.Action.IAction"/> object which threw an exception.
            </summary>
        </member>
        <member name="T:Libplanet.Action.ValidatorSetGetter">
            <summary>
            An delegate to provide a view of the <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            </summary>
            <returns>The instance of <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Action.ValidatorStateExtensions.SetValidator(Libplanet.Action.IAccountStateDelta,Libplanet.Consensus.Validator)">
            <summary>
            Sets <paramref name="validator"/> to the stored <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            If 0 is given as its power, removes the validator from the <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            </summary>
            <param name="delta">The target <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance.</param>
            <param name="validator">The <see cref="T:Libplanet.Consensus.Validator"/> instance to write.</param>
            <returns>A new <see cref="T:Libplanet.Action.IAccountStateDelta"/> instance with
            <paramref name="validator"/> set.</returns>
        </member>
        <member name="T:Libplanet.Address">
            <summary>
            An identifier of 20 bytes (or 40 letters in hexadecimal, commonly with
            a prefix <c>0x</c>) that refers to a unique account.
            <para>It is derived from the corresponding <see cref="T:Libplanet.Crypto.PublicKey"/>
            of an account, but as a derivation loses information, it is always
            unidirectional.</para>
            <para>The address derivation from a public key is as follows:</para>
            <list type="number">
            <item><description>Calculates the Keccak-256, which is a previous form
            of SHA-3 before NIST standardized it and does not follow
            <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf"
            >FIPS-202</a>, of the corresponding <see cref="T:Libplanet.Crypto.PublicKey"/>.
            </description></item>
            <item><description>Takes only the last 20 bytes of the calculated
            Keccak-256 hash.</description></item>
            <item><description>When the address needs to be shown to end users,
            displays these 20 bytes in hexadecimal, with a prefix <c>0x</c>.
            </description></item>
            </list>
            <para>Since the scheme of the address derivation and the <see
            cref="T:Libplanet.Crypto.PrivateKey"/>/<see cref="T:Libplanet.Crypto.PublicKey"/> is the same to
            <a href="https://www.ethereum.org/">Ethereum</a>, Ethereum addresses
            can be used by Libplanet-backed games/apps too.</para>
            </summary>
            <remarks>Every <see cref="T:Libplanet.Address"/> value is immutable.</remarks>
            <seealso cref="T:Libplanet.Crypto.PublicKey"/>
        </member>
        <member name="F:Libplanet.Address.Size">
            <summary>
            The <see cref="T:System.Byte"/>s size that each <see cref="T:Libplanet.Address"/> takes.
            <para>It is 20 <see cref="T:System.Byte"/>s.</para>
            </summary>
        </member>
        <member name="M:Libplanet.Address.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Creates an <see cref="T:Libplanet.Address"/> instance from the given immutable <see
            cref="T:System.Byte"/> array (i.e., <paramref name="address"/>).
            </summary>
            <param name="address">An immutable array of 20 <see cref="T:System.Byte"/>s which
            represents an <see cref="T:Libplanet.Address"/>.</param>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref
            name="address"/> array did not lengthen 20 bytes.</exception>
            <remarks>A valid <see cref="T:System.Byte"/> array which represents an
            <see cref="T:Libplanet.Address"/> can be gotten using <see cref="M:Libplanet.Address.ToByteArray"
            /> method.</remarks>
            <seealso cref="P:Libplanet.Address.ByteArray"/>
        </member>
        <member name="M:Libplanet.Address.#ctor(System.Byte[])">
            <summary>
            Creates an <see cref="T:Libplanet.Address"/> instance from the given <see
            cref="T:System.Byte"/> array (i.e., <paramref name="address"/>).
            </summary>
            <param name="address">An array of 20 <see cref="T:System.Byte"/>s which
            represents an <see cref="T:Libplanet.Address"/>.</param>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref
            name="address"/> array did not lengthen 20 bytes.</exception>
            <remarks>A valid <see cref="T:System.Byte"/> array which represents an
            <see cref="T:Libplanet.Address"/> can be gotten using <see cref="M:Libplanet.Address.ToByteArray"
            /> method.</remarks>
            <seealso cref="M:Libplanet.Address.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Address.#ctor(Libplanet.Crypto.PublicKey)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a <see
            cref="T:Libplanet.Crypto.PublicKey"/>.
            <para>Note that there is an equivalent extension method
            <see cref="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PublicKey)"/>, which enables
            a code like <c>publicKey.ToAddress()</c> instead of
            <c>new Address(publicKey)</c>, for convenience.</para>
            </summary>
            <param name="publicKey">A <see cref="T:Libplanet.Crypto.PublicKey"/> to derive
            the corresponding <see cref="T:Libplanet.Address"/> from.</param>
            <seealso cref="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PublicKey)"/>
        </member>
        <member name="M:Libplanet.Address.#ctor(System.String)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a hexadecimal
            address string.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="hex"/>
            is neither 40 chars long nor 42 chars long with 0x prefix.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="hex"/>
            is mixed-case and the checksum is invalid.</exception>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="hex"/>
            does not consist of ASCII characters.</exception>
            <param name="hex">A 40 characters or included 0x prefix hexadecimal
            address string to derive the corresponding <see cref="T:Libplanet.Address"/> from.
            The string should be all lower-case or mixed-case which follows <a
            href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md"
            >EIP 55</a>.</param>
        </member>
        <member name="M:Libplanet.Address.#ctor(Bencodex.Types.IValue)">
            <summary>
            Creates an <see cref="T:Libplanet.Address"/> instance from given <paramref name="bencoded"/>.
            </summary>
            <param name="bencoded">A Bencodex <see cref="T:Bencodex.Types.Binary"/> of 20 <see cref="T:System.Byte"/>s which
            represents an <see cref="T:Libplanet.Address"/>.
            </param>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="bencoded"/>
            is not of type <see cref="T:Bencodex.Types.Binary"/>.</exception>
            <seealso cref="M:Libplanet.Address.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)"/>
        </member>
        <member name="P:Libplanet.Address.ByteArray">
            <summary>
            An immutable array of 20 <see cref="T:System.Byte"/>s that represent this
            <see cref="T:Libplanet.Address"/>.
            </summary>
            <remarks>This is immutable.  For a mutable array, call <see
            cref="M:Libplanet.Address.ToByteArray"/> method.</remarks>
            <seealso cref="M:Libplanet.Address.ToByteArray"/>
        </member>
        <member name="P:Libplanet.Address.Bencoded">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Address.ToByteArray">
            <summary>
            Gets a mutable array of 20 <see cref="T:System.Byte"/>s that represent
            this <see cref="T:Libplanet.Address"/>.
            </summary>
            <returns>A new mutable array which represents this
            <see cref="T:Libplanet.Address"/>.  Since it is created every time the method
            is called, any mutation on that does not affect internal states of
            this <see cref="T:Libplanet.Address"/>.</returns>
            <seealso cref="P:Libplanet.Address.ByteArray"/>
            <seealso cref="M:Libplanet.Address.#ctor(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Address.ToHex">
            <summary>
            Gets a mixed-case hexadecimal string of 40 letters that represent
            this <see cref="T:Libplanet.Address"/>. The returned hexadecimal string follows
            <a
            href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md"
            >EIP 55</a>.
            </summary>
            <example>A returned string looks like
            <c>87Ae4774E20963fd6caC967CF47aDCF880C3e89B</c>.</example>
            <returns>A hexadecimal string of 40 letters that represent
            this <see cref="T:Libplanet.Address"/>.  Note that it does not start with
            a prefix.</returns>
            <remarks>As the returned string has no prefix, for
            <c>0x</c>-prefixed hexadecimal, call <see cref="M:Libplanet.Address.ToString"/>
            method instead.</remarks>
            <seealso cref="M:Libplanet.Address.ToString"/>
        </member>
        <member name="M:Libplanet.Address.ToString">
            <summary>
            Gets a <c>0x</c>-prefixed mixed-case hexadecimal string of
            42 letters that represent this <see cref="T:Libplanet.Address"/>. The returned
            hexadecimal string follows
            <a
            href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md"
            >EIP 55</a>.
            </summary>
            <example>A returned string looks like
            <c>0x87Ae4774E20963fd6caC967CF47aDCF880C3e89B</c>.</example>
            <returns>A <c>0x</c>-hexadecimal string of 42 letters that represent
            this <see cref="T:Libplanet.Address"/>.</returns>
            <remarks>As the returned string is <c>0x</c>-prefixed, for
            hexadecimal without prefix, call <see cref="M:Libplanet.Address.ToHex"/> method
            instead.</remarks>
            <seealso cref="M:Libplanet.Address.ToHex"/>
        </member>
        <member name="M:Libplanet.Address.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Address.CompareTo(Libplanet.Address)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Libplanet.Address.CompareTo(System.Object)">
            <inheritdoc cref="M:System.IComparable.CompareTo(System.Object)"/>
        </member>
        <member name="T:Libplanet.AddressExtensions">
            <summary>
            This extension class enables some convenient methods (sugar for
            the most part) to deal with <see cref="T:Libplanet.Address"/>.
            </summary>
            <seealso cref="T:Libplanet.Address"/>
        </member>
        <member name="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PublicKey)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a <see
            cref="T:Libplanet.Crypto.PublicKey"/>.
            <para>This enables a code like <c>publicKey.ToAddress()</c> instead
            of <c>new Address(publicKey)</c>.</para>
            </summary>
            <param name="publicKey">A <see cref="T:Libplanet.Crypto.PublicKey"/> to derive
            the corresponding <see cref="T:Libplanet.Address"/> from.</param>
            <returns>The corresponding <see cref="T:Libplanet.Address"/> derived from
            <paramref name="publicKey"/>.</returns>
            <seealso cref="M:Libplanet.Address.#ctor(Libplanet.Crypto.PublicKey)"/>
        </member>
        <member name="M:Libplanet.AddressExtensions.ToAddress(Libplanet.Crypto.PrivateKey)">
            <summary>
            Derives the corresponding <see cref="T:Libplanet.Address"/> from a <see
            cref="T:Libplanet.Crypto.PrivateKey"/>.
            <para>This enables a code like <c>privateKey.ToAddress()</c> instead
            of <c>new Address(privateKey.PublicKey)</c>.</para>
            </summary>
            <param name="privateKey">A <see cref="T:Libplanet.Crypto.PrivateKey"/> to derive
            the corresponding <see cref="T:Libplanet.Address"/> from.</param>
            <returns>The corresponding <see cref="T:Libplanet.Address"/> derived from
            <paramref name="privateKey"/>.</returns>
        </member>
        <member name="T:Libplanet.Assets.Currency">
            <summary>
            Represents a currency type.  Every single value of <see cref="T:Libplanet.Assets.Currency"/> defines
            a distinct currency type.  To draw a parallel with real world monetary,
            each <see cref="T:Libplanet.Assets.Currency"/> value represents such currencies as USD (US Dollar) or
            EUR (Euro), <em>not values</em> like $100 or 100.
            </summary>
            <example>
            Here is how US Dollar can be represented using <see cref="T:Libplanet.Assets.Currency"/>:
            <code>
            var USMint = new PrivateKey();
            var USD = Currency.Uncapped(ticker: "USD", decimalPlaces: 2, minter: USMint.ToAddress());
            var twentyThreeBucks = 23 * USD;
            // Or alternatively: USD * 23;
            // Or explicitly: new FungibleAssetValue(USD, 23, 0)
            </code>
            </example>
            <remarks>There are two types of <see cref="T:Libplanet.Assets.Currency">Currencies</see>: capped and uncapped.
            Capped currencies have a hard limit on the maximum minted amount, and uncapped currencies
            do not have the said limit. To define a <see cref="T:Libplanet.Assets.Currency"/> you may call either of the
            following.
            <list type="bullet">
            <item><see
            cref="M:Libplanet.Assets.Currency.Capped(System.String,System.Byte,System.ValueTuple{System.Numerics.BigInteger,System.Numerics.BigInteger},System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
            </item>
            <item><see cref="M:Libplanet.Assets.Currency.Capped(System.String,System.Byte,System.ValueTuple{System.Numerics.BigInteger,System.Numerics.BigInteger},Libplanet.Address)"/></item>
            <item><see cref="M:Libplanet.Assets.Currency.Uncapped(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/></item>
            <item><see cref="M:Libplanet.Assets.Currency.Uncapped(System.String,System.Byte,Libplanet.Address)"/></item>
            </list>
            </remarks>
            <seealso cref="T:Libplanet.Assets.FungibleAssetValue"/>
        </member>
        <member name="F:Libplanet.Assets.Currency.Ticker">
            <summary>
            The ticker symbol, e.g., <c>&quot;USD&quot;</c>.
            </summary>
        </member>
        <member name="F:Libplanet.Assets.Currency.DecimalPlaces">
            <summary>
            The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.
            </summary>
        </member>
        <member name="F:Libplanet.Assets.Currency.Minters">
            <summary>
            The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            If this is <see langword="null"/> <em>anyone</em> can mint the currency.
            </summary>
            <remarks>
            Unlike <see langword="null"/>, an empty set means <em>no one</em> can mint the currency.
            </remarks>
            <seealso cref="M:Libplanet.Action.IAccountStateDelta.MintAsset(Libplanet.Address,Libplanet.Assets.FungibleAssetValue)"/>
        </member>
        <member name="F:Libplanet.Assets.Currency.Hash">
            <summary>
            The deterministic hash derived from other fields.
            </summary>
        </member>
        <member name="F:Libplanet.Assets.Currency.TotalSupplyTrackable">
            <summary>
            Whether the total supply of this instance of <see cref="T:Libplanet.Assets.Currency"/> is trackable.
            </summary>
        </member>
        <member name="M:Libplanet.Assets.Currency.#ctor(Bencodex.Types.IValue)">
            <summary>
            Deserializes a <see cref="T:Libplanet.Assets.Currency"/> type from a Bencodex value.
            </summary>
            <param name="serialized">The Bencodex value serialized by <see cref="M:Libplanet.Assets.Currency.Serialize"/>
            method.</param>
            <seealso cref="M:Libplanet.Assets.Currency.Serialize"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.#ctor(Libplanet.HashDigest{System.Security.Cryptography.SHA1},System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Boolean,System.Nullable{Libplanet.Assets.FungibleAssetValue})">
            <summary>
            An internal constructor for JSON deserialization.  Do not use this directly.
            </summary>
        </member>
        <member name="M:Libplanet.Assets.Currency.#ctor(System.String,System.Byte,System.Nullable{System.ValueTuple{System.Numerics.BigInteger,System.Numerics.BigInteger}},System.Collections.Immutable.IImmutableSet{Libplanet.Address})">
            <summary>
            Private implementation to create a capped instance of <see cref="T:Libplanet.Assets.Currency"/> or
            a deserialized instance.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="maximumSupply">The uppermost quantity of currency allowed to exist. For
            example, a <paramref name="maximumSupply"/> parameter of <c>(123, 45)</c> means that the
            token of the currency can be minted up to <c>123.45</c>. See also
            <see cref="P:Libplanet.Assets.Currency.MaximumSupply"/> field which corresponds to this.</param>
            <param name="minters">The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string, or when either the Major or the Minor values of
            <paramref name="maximumSupply"/> is a negative number, or when the given Minor unit for
            the <paramref name="maximumSupply"/> is too big for the given
            <paramref name="decimalPlaces"/>.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.#ctor(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Boolean)">
            <summary>
            Private implementation to create a general instance of <see cref="T:Libplanet.Assets.Currency"/>.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="minters">The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <param name="totalSupplyTrackable">A feature flag whether this instance of
            <see cref="T:Libplanet.Assets.Currency"/> supports total supply tracking. Legacy behavior is characterized
            with a value of false.</param>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string.</exception>
        </member>
        <member name="P:Libplanet.Assets.Currency.MaximumSupply">
            <summary>
            The uppermost quantity of currency allowed to exist.
            <see langword="null"/> means unlimited supply.
            </summary>
        </member>
        <member name="M:Libplanet.Assets.Currency.op_Multiply(Libplanet.Assets.Currency,System.Numerics.BigInteger)">
            <summary>
            Gets a fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.
            </summary>
            <param name="currency">The currency to get a value.</param>
            <param name="quantity">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.</param>
            <returns>A fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.</returns>
            <remarks>This cannot specify <see cref="P:Libplanet.Assets.FungibleAssetValue.MinorUnit"/> but only
            <see cref="P:Libplanet.Assets.FungibleAssetValue.MajorUnit"/>.  For more precision, directly use <see
            cref="T:Libplanet.Assets.FungibleAssetValue"/>'s constructors instead.</remarks>
        </member>
        <member name="M:Libplanet.Assets.Currency.op_Multiply(System.Numerics.BigInteger,Libplanet.Assets.Currency)">
            <summary>
            Gets a fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.
            </summary>
            <param name="quantity">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.</param>
            <param name="currency">The currency to get a value.</param>
            <returns>A fungible asset value with the given <paramref name="quantity"/> of the
            specified <paramref name="currency"/>.</returns>
            <remarks>This cannot specify <see cref="P:Libplanet.Assets.FungibleAssetValue.MinorUnit"/> but only
            <see cref="P:Libplanet.Assets.FungibleAssetValue.MajorUnit"/>.  For more precision, directly use <see
            cref="T:Libplanet.Assets.FungibleAssetValue"/>'s constructors instead.</remarks>
        </member>
        <member name="M:Libplanet.Assets.Currency.Capped(System.String,System.Byte,System.ValueTuple{System.Numerics.BigInteger,System.Numerics.BigInteger},System.Collections.Immutable.IImmutableSet{Libplanet.Address})">
            <summary>
            Define a <see cref="T:Libplanet.Assets.Currency"/> with a maximum supply limit.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="maximumSupply">The uppermost quantity of currency allowed to exist. For
            example, the <paramref name="maximumSupply"/> parameter in <c>Currency.Capped("ABC", 2,
            (123, 45), ...)</c> means that the token <c>ABC</c> can be minted up to <c>123.45 ABC
            </c>. See also <see cref="P:Libplanet.Assets.Currency.MaximumSupply"/> field which corresponds to this.</param>
            <param name="minters">The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <returns>An instance of <see cref="T:Libplanet.Assets.Currency"/> with a maximum supply limit.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string, or when either the Major or the Minor values of
            <paramref name="maximumSupply"/> is a negative number, or when the given Minor unit for
            the <paramref name="maximumSupply"/> is too big for the given
            <paramref name="decimalPlaces"/>.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.Capped(System.String,System.Byte,System.ValueTuple{System.Numerics.BigInteger,System.Numerics.BigInteger},Libplanet.Address)">
            <summary>
            Define a <see cref="T:Libplanet.Assets.Currency"/> with a maximum supply limit.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="maximumSupply">The uppermost quantity of currency allowed to exist. For
            example, the <paramref name="maximumSupply"/> parameter in <c>Currency.Capped("ABC", 2,
            (123, 45), ...)</c> means that the token <c>ABC</c> can be minted up to <c>123.45 ABC
            </c>. See also <see cref="P:Libplanet.Assets.Currency.MaximumSupply"/> field which corresponds to this.</param>
            <param name="minter">The address who can mint the currency.  To specify multiple
            minters, use the <see
            cref="M:Libplanet.Assets.Currency.Capped(System.String,System.Byte,System.ValueTuple{System.Numerics.BigInteger,System.Numerics.BigInteger},System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <returns>An instance of <see cref="T:Libplanet.Assets.Currency"/> with a maximum supply limit.</returns>
            <seealso
            cref="M:Libplanet.Assets.Currency.Capped(System.String,System.Byte,System.ValueTuple{System.Numerics.BigInteger,System.Numerics.BigInteger},System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string, or when either the Major or the Minor values of
            <paramref name="maximumSupply"/> is a negative number, or when the given Minor unit for
            the <paramref name="maximumSupply"/> is too big for the given
            <paramref name="decimalPlaces"/>.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.Uncapped(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})">
            <summary>
            Define a <see cref="T:Libplanet.Assets.Currency"/> without a maximum supply limit.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="minters">The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <returns>An instance of <see cref="T:Libplanet.Assets.Currency"/> without a maximum supply limit.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.Uncapped(System.String,System.Byte,Libplanet.Address)">
            <summary>
            Define a <see cref="T:Libplanet.Assets.Currency"/> without a maximum supply limit.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="minter">The address who can mint the currency.  To specify multiple
            minters, use the <see cref="M:Libplanet.Assets.Currency.Uncapped(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <returns>An instance of <see cref="T:Libplanet.Assets.Currency"/> without a maximum supply limit.</returns>
            <seealso cref="M:Libplanet.Assets.Currency.Uncapped(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.Legacy(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})">
            <summary>
            <b>OBSOLETE! DO NOT USE.</b><br/><br/>(unless you are upgrading your project from an old
            version of Libplanet that did not support total supply tracking for
            <see cref="T:Libplanet.Assets.Currency">Currencies</see> and had a legacy <see cref="T:Libplanet.Assets.Currency"/> defined.)
            <br/><br/>Define a legacy <see cref="T:Libplanet.Assets.Currency"/> without total supply tracking, which is
            internally compatible with the legacy version.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="minters">The <see cref="T:Libplanet.Address"/>es who can mint the currency.
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <returns>An instance of legacy <see cref="T:Libplanet.Assets.Currency"/> without total supply tracking.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.Legacy(System.String,System.Byte,Libplanet.Address)">
            <summary>
            <b>OBSOLETE! DO NOT USE.</b><br/><br/>(unless you are upgrading your project from an old
            version of Libplanet that did not support total supply tracking for
            <see cref="T:Libplanet.Assets.Currency">Currencies</see> and had a legacy <see cref="T:Libplanet.Assets.Currency"/> defined.)
            <br/><br/>Define a legacy <see cref="T:Libplanet.Assets.Currency"/> without total supply tracking, which is
            internally compatible with the legacy version.
            </summary>
            <param name="ticker">The ticker symbol, e.g., <c>&quot;USD&quot;</c>.</param>
            <param name="decimalPlaces">The number of digits to treat as <a
            href="https://w.wiki/ZXv#Treatment_of_minor_currency_units_(the_%22exponent%22)">minor
            units (i.e., exponent)</a>.</param>
            <param name="minter">The address who can mint the currency.  To specify multiple
            minters, use the <see cref="M:Libplanet.Assets.Currency.Legacy(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
            See also <see cref="F:Libplanet.Assets.Currency.Minters"/> field which corresponds to this.</param>
            <returns>An instance of legacy <see cref="T:Libplanet.Assets.Currency"/> without total supply tracking.
            </returns>
            <seealso cref="M:Libplanet.Assets.Currency.Legacy(System.String,System.Byte,System.Collections.Immutable.IImmutableSet{Libplanet.Address})"/>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="ticker"/>
            is an empty string.</exception>
        </member>
        <member name="M:Libplanet.Assets.Currency.AllowsToMint(Libplanet.Address)">
            <summary>
            Returns <see langword="true"/> if and only if
            the given <paramref name="address"/> is allowed
            to mint or burn assets of this currency.
            </summary>
            <param name="address">The account address to test.</param>
            <returns><see langword="true"/> if and only if
            the given <paramref name="address"/> is allowed to
            mint or burn assets of this currency.</returns>
        </member>
        <member name="M:Libplanet.Assets.Currency.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.Equals(Libplanet.Assets.Currency)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Assets.Currency.Serialize">
            <summary>
            Serializes the currency into a Bencodex value.
            </summary>
            <returns>The serialized Bencodex value.</returns>
        </member>
        <member name="T:Libplanet.Assets.FungibleAssetValue">
            <summary>
            Holds a fungible asset value which holds its <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/> together.
            </summary>
            <remarks>
            It behaves like numbers except for division operator (<c>/</c>) to prevent to forget
            to handle its remainder; use <see cref="M:Libplanet.Assets.FungibleAssetValue.DivRem(Libplanet.Assets.FungibleAssetValue)"/> and <see
            cref="M:Libplanet.Assets.FungibleAssetValue.DivRem(System.Numerics.BigInteger)"/> methods instead.
            </remarks>
        </member>
        <member name="F:Libplanet.Assets.FungibleAssetValue.Currency">
            <summary>
            The currency of the fungible asset.
            </summary>
        </member>
        <member name="F:Libplanet.Assets.FungibleAssetValue.RawValue">
            <summary>
            The internal representation of the fungible asset.
            </summary>
            <remarks>
            Since this is an internal representation, this does not guarantee forward compatibility.
            Therefore, do not depend on this value for permanent uses but only for volatile data.
            </remarks>
            <seealso cref="M:Libplanet.Assets.FungibleAssetValue.FromRawValue(Libplanet.Assets.Currency,System.Numerics.BigInteger)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency)">
            <summary>
            Creates a zero value of the <paramref name="currency"/>.
            </summary>
            <param name="currency">The currency to create a zero value.</param>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency,System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Creates a value of the <paramref name="currency"/> from the given
            <paramref name="majorUnit"/> and <paramref name="minorUnit"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="majorUnit">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.</param>
            <param name="minorUnit">The minor unit of the fungible asset value,
            i.e., digits <em>after</em> the decimal separator.</param>
            <exception cref="T:System.ArgumentException">Thrown when the negativity sign is ambiguous
            (e.g., both units have signs) or too big for the <paramref name="currency"/>.
            </exception>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency,System.Int32,System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Creates a value of the <paramref name="currency"/> from the given <paramref
            name="sign"/>, <paramref name="majorUnit"/> and <paramref name="minorUnit"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="sign">Indicates the sign (negative, positive, or zero) of the value.
            <c>-1</c> indicates negative, <c>1</c> indicates positive, and <c>0</c> indicates
            zero.</param>
            <param name="majorUnit">The major unit of the fungible asset value,
            i.e., digits <em>before</em> the decimal separator.  Must not be negative.</param>
            <param name="minorUnit">The minor unit of the fungible asset value,
            i.e., digits <em>after</em> the decimal separator.  Must not be negative.</param>
            <exception cref="T:System.ArgumentException">Thrown when the the <paramref name="sign"/> is not
            one of <c>1</c>, <c>0</c>, and <c>-1</c>, or <paramref name="majorUnit"/> or
            <paramref name="minorUnit"/> is negative.
            </exception>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(Libplanet.Assets.Currency,System.Numerics.BigInteger)">
            <summary>
            Creates a value of the <paramref name="currency"/> with the specified <paramref
            name="rawValue"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="rawValue">The raw quantity of the value to create.</param>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes a fungible asset value.
            </summary>
            <param name="info">A serialization information.</param>
            <param name="context">A streaming context.</param>
        </member>
        <member name="P:Libplanet.Assets.FungibleAssetValue.Sign">
            <summary>
            Gets a number that indicates the sign (negative, positive, or zero) of the value.
            </summary>
            <value>
            A number that indicates the sign of the fungible asset value, as shown in the following
            table:
            <list type="table">
            <listheader><term>Number</term><description>Description</description></listheader>
            <item><term>-1</term><description>The value is negative.</description></item>
            <item><term>0</term><description>The value is zero.</description></item>
            <item><term>1</term><description>The value is positive.</description></item>
            </list>
            </value>
        </member>
        <member name="P:Libplanet.Assets.FungibleAssetValue.MajorUnit">
            <summary>
            The major unit of the fungible asset value, i.e., digits <em>before</em> the decimal
            separator, in absolute value.
            </summary>
            <remarks>It is absolute value, which lacks <see cref="P:Libplanet.Assets.FungibleAssetValue.Sign"/>.</remarks>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="P:Libplanet.Assets.FungibleAssetValue.MinorUnit">
            <summary>
            The minor unit of the fungible asset value, i.e., digits <em>after</em> the decimal
            separator, in absolute value.
            </summary>
            <remarks>It is absolute value, which lacks <see cref="P:Libplanet.Assets.FungibleAssetValue.Sign"/>.</remarks>
            <seealso cref="F:Libplanet.Assets.Currency.DecimalPlaces"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Equality(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if two values are equal.
            </summary>
            <param name="obj">A value.</param>
            <param name="other">Another value.</param>
            <returns><see langword="true"/> if two values are equal.
            Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Inequality(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if two values are unequal.
            </summary>
            <param name="obj">A value.</param>
            <param name="other">Another value.</param>
            <returns><see langword="false"/> if two values are equal.
            Otherwise <see langword="true"/>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_LessThan(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is less than the right operand
            (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><see langword="true"/>
            if the left operand (<paramref name="obj"/>) is less than the right
            operand (<paramref name="other"/>).  Otherwise (even if two operands are equal)
            <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_LessThanOrEqual(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is less than or equal to the right
            operand (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><see langword="true"/>
            if the left operand (<paramref name="obj"/>) is less than or equal
            to the right operand (<paramref name="other"/>).  Otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_GreaterThan(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is greater than the right operand
            (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><see langword="true"/>
            if the left operand (<paramref name="obj"/>) is greater than
            the right operand (<paramref name="other"/>).  Otherwise (even if two operands are
            equal) <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_GreaterThanOrEqual(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Tests if the left operand (<paramref name="obj"/>) is greater than or equal to the right
            operand (<paramref name="other"/>).
            </summary>
            <param name="obj">The left operand to compare.</param>
            <param name="other">The right operand to compare.</param>
            <returns><see langword="true"/>
            if the left operand (<paramref name="obj"/>) is greater than or
            equal to the right operand (<paramref name="other"/>).
            Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_UnaryNegation(Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Negates a <paramref name="value"/>.
            <para>Adds a negative sign to the <paramref name="value"/> if it's positive.
            Removes a negative sign from the <paramref name="value"/> if it's already negative.
            Does nothing if the <paramref name="value"/> is zero.</para>
            </summary>
            <param name="value">A value to negate.</param>
            <returns>A negated <paramref name="value"/>.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Addition(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Adds two values and returns the result.
            </summary>
            <param name="left">The first value to add.</param>
            <param name="right">The second value to add.</param>
            <returns>The sum of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Subtraction(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Subtracts the <paramref name="right"/> value from the <paramref name="left"/> value.
            </summary>
            <param name="left">The value to subtract from (the minuend).</param>
            <param name="right">The value to subtract (the subtrahend).</param>
            <returns>The result of subtracting <paramref name="right"/> from
            <paramref name="left"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Multiply(Libplanet.Assets.FungibleAssetValue,System.Numerics.BigInteger)">
            <summary>
            Multiplies <paramref name="right"/> times the <paramref name="left"/> value.
            </summary>
            <param name="left">The value to multiply.</param>
            <param name="right">The times to multiply.</param>
            <returns>The multiplied value.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Multiply(System.Numerics.BigInteger,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Multiplies <paramref name="left"/> times the <paramref name="right"/> value.
            </summary>
            <param name="left">The times to multiply.</param>
            <param name="right">The value to multiply.</param>
            <returns>The multiplied value.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Modulus(Libplanet.Assets.FungibleAssetValue,System.Numerics.BigInteger)">
            <summary>
            Divides the value (<paramref name="dividend"/>) by <paramref name="divisor"/>,
            and returns the remainder.
            </summary>
            <param name="dividend">The value to be divided.</param>
            <param name="divisor">The number to divide by.</param>
            <returns>The remainder after dividing <paramref name="dividend"/>
            by <paramref name="divisor"/>.</returns>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            <c>0</c> (zero).</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.op_Modulus(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Divides the value (<paramref name="dividend"/>) by <paramref name="divisor"/>,
            and returns the remainder.
            </summary>
            <param name="dividend">The value to be divided.</param>
            <param name="divisor">The value to divide by.</param>
            <returns>The remainder after dividing <paramref name="dividend"/>
            by <paramref name="divisor"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            zero.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Parse(Libplanet.Assets.Currency,System.String)">
            <summary>
            Parses a numeric string and returns a corresponding <see cref="T:Libplanet.Assets.FungibleAssetValue"/>.
            </summary>
            <param name="currency">The currency of the value to parse.</param>
            <param name="value">A numeric string to parse.  Can consist of digits, plus (+),
            minus (-), and decimal separator (.).</param>
            <returns>The parsed asset value.</returns>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="value"/> is not
            a valid numeric string.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.FromRawValue(Libplanet.Assets.Currency,System.Numerics.BigInteger)">
            <summary>
            Restores a value from a <paramref name="rawValue"/> of a <paramref name="currency"/>.
            </summary>
            <param name="currency">The currency to create a value.</param>
            <param name="rawValue">The <see cref="F:Libplanet.Assets.FungibleAssetValue.RawValue"/> to restore.</param>
            <returns>The value restored from the given <paramref name="rawValue"/>.</returns>
            <seealso cref="F:Libplanet.Assets.FungibleAssetValue.RawValue"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(System.Numerics.BigInteger,Libplanet.Assets.FungibleAssetValue@)">
            <summary>
            Divides the value by <paramref name="divisor"/>, returns the quotient, and returns
            the <paramref name="remainder"/> in an output parameter.
            </summary>
            <param name="divisor">The number to divide by.</param>
            <param name="remainder">When this method returns (without any exception), the remainder
            after dividing the value by <paramref name="divisor"/>.  This parameter is passed
            uninitialized.</param>
            <returns>The quotient of the division.</returns>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            <c>0</c> (zero).</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(Libplanet.Assets.FungibleAssetValue,Libplanet.Assets.FungibleAssetValue@)">
            <summary>
            Divides the value by <paramref name="divisor"/>, returns the quotient, and returns
            the <paramref name="remainder"/> in an output parameter.
            </summary>
            <param name="divisor">The value to divide by.</param>
            <param name="remainder">When this method returns (without any exception), the remainder
            after dividing the value by <paramref name="divisor"/>.  This parameter is passed
            uninitialized.</param>
            <returns>The quotient of the division.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            zero.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(System.Numerics.BigInteger)">
            <summary>
            Divides the value by <paramref name="divisor"/>, and returns a pair of the quotient
            and the remainder.
            </summary>
            <param name="divisor">The number to divide by.</param>
            <returns>A tuple of the <c>Quotient</c> and <c>Remainder</c> of the division.</returns>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            <c>0</c> (zero).</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.DivRem(Libplanet.Assets.FungibleAssetValue)">
            <summary>
            Divides the value by <paramref name="divisor"/>, and returns a pair of the quotient
            and the remainder.
            </summary>
            <param name="divisor">The value to divide by.</param>
            <returns>A tuple of the <c>Quotient</c> and <c>Remainder</c> of the division.</returns>
            <exception cref="T:System.ArgumentException">Thrown when two values do not have the same
            <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>.</exception>
            <exception cref="T:System.DivideByZeroException">Thrown when the <paramref name="divisor"/> is
            zero.</exception>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Abs">
            <summary>
            Gets the absolute value.
            <para>Removes the negative sign if it's negative.  Otherwise does nothing.</para>
            </summary>
            <returns>Its absolute value.</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.GetQuantityString(System.Boolean)">
            <summary>
            Gets the value quantity without its <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/> in <see cref="T:System.String"/>.
            </summary>
            <param name="minorUnit">Whether to show all possible decimal places even
            if they are zeros.</param>
            <returns>A quantity string in decimal system.  Consists of an optional sign (minus),
            digits and an optional decimal separator (period).</returns>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Equals(Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.CompareTo(System.Object)">
            <inheritdoc cref="M:System.IComparable.CompareTo(System.Object)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.CompareTo(Libplanet.Assets.FungibleAssetValue)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="M:Libplanet.Assets.FungibleAssetValue.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Assets.NonNativeTokenException">
            <summary>
            The exception that is thrown when a non-native asset is tried to be used for system actions.
            </summary>
        </member>
        <member name="M:Libplanet.Assets.NonNativeTokenException.#ctor(Libplanet.Assets.Currency,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Assets.NonNativeTokenException"/> instance.
            </summary>
            <param name="nonNativeToken">The non-native token which caused this exception.</param>
            <param name="message">Specifies a <see cref="P:System.Exception.Message"/>.</param>
        </member>
        <member name="P:Libplanet.Assets.NonNativeTokenException.NonNativeToken">
            <summary>
            The non-native token which caused this exception.
            </summary>
        </member>
        <member name="M:Libplanet.Assets.NonNativeTokenException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Blockchain.BlockChain`1">
             <summary>
             A class have <see cref="T:Libplanet.Blocks.Block`1"/>s, <see cref="T:Libplanet.Tx.Transaction`1"/>s, and the chain
             information.
             <para>In order to watch its state changes, implement <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>
             interface and pass it to the <see cref="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}})"/> constructor.</para>
             </summary>
             <remarks>This object is guaranteed that it has at least one block, since it takes a genesis
             block when it's instantiated.</remarks>
             <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
             to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
            
        </member>
        <member name="F:Libplanet.Blockchain.BlockChain`1._blocks">
            <summary>
            All <see cref="T:Libplanet.Blocks.Block`1"/>s in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>
            storage, including orphan <see cref="T:Libplanet.Blocks.Block`1"/>s.
            Keys are <see cref="P:Libplanet.Blocks.Block`1.Hash"/>es and values are
            their corresponding <see cref="T:Libplanet.Blocks.Block`1"/>s.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.BlockChain`1._genesis">
            <summary>
            Cached genesis block.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> class.
            </summary>
            <param name="policy"><see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/> to use in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</param>
            <param name="stagePolicy">The staging policy to follow.</param>
            <param name="store"><see cref="T:Libplanet.Store.IStore"/> to store <see cref="T:Libplanet.Blocks.Block`1"/>s,
            <see cref="T:Libplanet.Tx.Transaction`1"/>s, and <see cref="T:Libplanet.Blockchain.BlockChain`1"/> information.</param>
            <param name="genesisBlock">The genesis <see cref="T:Libplanet.Blocks.Block`1"/> of
            the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>, which is a part of the consensus.
            If the given <paramref name="store"/> already contains the genesis block
            it checks if the existing genesis block and this argument is the same.
            If the <paramref name="store"/> has no genesis block yet this argument will
            be used for that.</param>
            <param name="renderers">Listens state changes on the created chain.  Listens nothing
            by default or if it is <see langword="null"/>.  Note that action renderers receive
            events made by unsuccessful transactions too; see also
            <see cref="T:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1"/> for workaround.</param>
            <param name="stateStore"><see cref="T:Libplanet.Store.IStateStore"/> to store states.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either of <paramref name="store"/>
            or <paramref name="stateStore"/> is <see langword="null"/>.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidGenesisBlockException">Thrown when the <paramref name="store"/>
            has a genesis block and it does not match to what the network expects
            (i.e., <paramref name="genesisBlock"/>).</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}},Libplanet.Blockchain.IBlockChainStates{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}})" />
            <param name="blockChainStates">The <see cref="T:Libplanet.Blockchain.IBlockChainStates`1"/> implementation to state lookup.</param>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}},Libplanet.Blockchain.IBlockChainStates{`0},Libplanet.Action.ActionEvaluator{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}},Libplanet.Blockchain.IBlockChainStates{`0})" />
            <param name="actionEvaluator">The <see cref="T:Libplanet.Action.ActionEvaluator`1" /> implementation to calculate next states when append new blocks.</param>
        </member>
        <member name="E:Libplanet.Blockchain.BlockChain`1.TipChanged">
            <summary>
            An event which is invoked when <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> is changed.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Renderers">
            <summary>
            The list of registered renderers listening the state changes.
            </summary>
            <remarks>
            Since this value is immutable, renderers cannot be registered after once a <see
            cref="T:Libplanet.Blockchain.BlockChain`1"/> object is instantiated; use <c>renderers</c> option of <see cref=
            "M:Libplanet.Blockchain.BlockChain`1.#ctor(Libplanet.Blockchain.Policies.IBlockPolicy{`0},Libplanet.Blockchain.Policies.IStagePolicy{`0},Libplanet.Store.IStore,Libplanet.Store.IStateStore,Libplanet.Blocks.Block{`0},System.Collections.Generic.IEnumerable{Libplanet.Blockchain.Renderers.IRenderer{`0}})"/>
            constructor instead.
            </remarks>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.ActionRenderers">
            <summary>
            A filtered list, from <see cref="P:Libplanet.Blockchain.BlockChain`1.Renderers"/>, which contains only <see
            cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instances.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Policy">
            <summary>
            The block and blockchain policy.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.StagePolicy">
            <summary>
            The staging policy.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Tip">
            <summary>
            The topmost <see cref="T:Libplanet.Blocks.Block`1"/> of the current blockchain.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Genesis">
            <summary>
            The first <see cref="T:Libplanet.Blocks.Block`1"/> in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.BlockHashes">
            <summary>
            All <see cref="P:Libplanet.Blocks.Block`1.Hash"/>es in the current index.  The genesis block's hash goes
            first, and the tip goes last.
            Returns a <see cref="T:System.Int64"/> integer that represents the number of elements in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Count">
            <summary>
            Returns a <see cref="T:System.Int64"/> integer that represents the number of elements in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <returns>A number that represents how many elements in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </returns>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.IsCanonical">
            <summary>
            Whether the instance is canonical or not.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Item(System.Int32)">
            <summary>
            Gets the block corresponding to the <paramref name="index"/>.
            </summary>
            <param name="index">A number of index of <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given index of
            <see cref="T:Libplanet.Blocks.Block`1"/> does not exist.</exception>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Item(System.Int64)">
            <summary>
            Gets the block corresponding to the <paramref name="index"/>.
            </summary>
            <param name="index">A number of index of <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given index of
            <see cref="T:Libplanet.Blocks.Block`1"/> does not exist.</exception>
        </member>
        <member name="P:Libplanet.Blockchain.BlockChain`1.Item(Libplanet.Blocks.BlockHash@)">
            <summary>
            Gets the block corresponding to the <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">A <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> to
            get. </param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when there is no <see cref="T:Libplanet.Blocks.Block`1"/>
            with a given <paramref name="blockHash"/>.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MakeGenesisBlock(System.Collections.Generic.IEnumerable{`0},Libplanet.Crypto.PrivateKey,System.Nullable{System.DateTimeOffset},Libplanet.Action.IAction,System.Predicate{Libplanet.Assets.Currency})">
            <summary>
            Mine the genesis block of the blockchain.
            </summary>
            <param name="actions">List of actions will be included in the genesis block.
            If it's null, it will be replaced with <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>
            as default.</param>
            <param name="privateKey">A private key to sign the transaction and the genesis block.
            If it's null, it will use new private key as default.</param>
            <param name="timestamp">The timestamp of the genesis block. If it's null, it will
            use <see cref="P:System.DateTimeOffset.UtcNow"/> as default.</param>
            <param name="blockAction">A block action to execute and be rendered for every block.
            It must match to <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockAction"/> of <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.
            </param>
            <param name="nativeTokenPredicate">A predicate function to determine whether
            the specified <see cref="T:Libplanet.Assets.Currency"/> is a native token defined by chain's
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/> or not.
            Treat no <see cref="T:Libplanet.Assets.Currency"/> as native token if the argument omitted.</param>
            <returns>The genesis block mined with parameters.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ContainsBlock(Libplanet.Blocks.BlockHash)">
            <summary>
            Determines whether the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> contains <see cref="T:Libplanet.Blocks.Block`1"/>
            the specified <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">The <see cref="T:Libplanet.HashDigest`1"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> to
            check if it is in the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> contains
            <see cref="T:Libplanet.Blocks.Block`1"/> with the specified <paramref name="blockHash"/>; otherwise,
            <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetTransaction(Libplanet.Tx.TxId)">
            <summary>
            Gets the transaction corresponding to the <paramref name="txId"/>.
            </summary>
            <param name="txId">A <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/> to get.
            </param>
            <returns><see cref="T:Libplanet.Tx.Transaction`1"/> with <paramref name="txId"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when there is no
            <see cref="T:Libplanet.Tx.Transaction`1"/> with a given <paramref name="txId"/>.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetState(Libplanet.Address,System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Blockchain.StateCompleter{`0})">
            <summary>
            Gets the state of the given <paramref name="address"/> in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> from <paramref name="offset"/>.
            </summary>
            <param name="address">An <see cref="T:Libplanet.Address"/> to get the states of.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to start finding
            the state.  It will be The tip of the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> if it is
            <see langword="null"/>.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states dirty of the block which lastly updated states of a requested address,
            this delegate is called and its return value is used instead.
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Recalculate"/> makes the incomplete states
            recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Reject"/> (which is default) makes the incomplete
            states (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> instead.</para>
            </param>
            <returns>The current state of given <paramref name="address"/>.  This can be
            <see langword="null"/> if <paramref name="address"/> has no value.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetStates(System.Collections.Generic.IReadOnlyList{Libplanet.Address},System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Blockchain.StateCompleter{`0})">
            <summary>
            Gets multiple states associated to the specified <paramref name="addresses"/>.
            </summary>
            <param name="addresses">Addresses of states to query.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to start finding
            the states.  <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> by default.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states of the block, this delegate is called and its return values are used
            instead.
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Recalculate"/> makes the incomplete states
            recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Reject"/> (which is default) makes the incomplete
            states (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> instead.</para>
            </param>
            <returns>The states associated to the specified <paramref name="addresses"/>.
            Associated values are ordered in the same way to the corresponding
            <paramref name="addresses"/>.  Absent states are represented as <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Blockchain.FungibleAssetStateCompleter{`0})">
            <summary>
            Queries <paramref name="address"/>'s balance of the <paramref name="currency"/> in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> from <paramref name="offset"/>.
            </summary>
            <param name="address">The owner <see cref="T:Libplanet.Address"/> to query.</param>
            <param name="currency">The currency type to query.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to
            start finding the state. It will be the tip of the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> if it is <see langword="null"/>.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states dirty of the block which lastly updated states of a requested address,
            this delegate is called and its return value is used instead.
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Recalculate"/> makes the incomplete
            states recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Reject"/> (which is default) makes
            the incomplete states (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>
            instead.</para></param>
            <returns>The <paramref name="address"/>'s current balance (or balance as of the given
            <paramref name="offset"/>) of the <paramref name="currency"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.FungibleAssetStateCompleter{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.FungibleAssetStateCompleter{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetTotalSupply(Libplanet.Assets.Currency,System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Blockchain.TotalSupplyStateCompleter{`0})">
            <summary>
            Gets the total supply of a <paramref name="currency"/> in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> from <paramref name="offset"/>, and if not found, derive
            from the sum of all balances.
            </summary>
            <param name="currency">The currency type to query.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to
            start finding the state.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states of the block, this delegate is called and its return values are used
            instead.
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Recalculate"/> makes the incomplete
            states recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Reject"/> makes the incomplete states
            (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> instead.</para>
            </param>
            <returns>The total supply value of <paramref name="currency"/> at
            <paramref name="offset"/> in <see cref="T:Libplanet.Assets.FungibleAssetValue"/>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetTotalSupply(Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.TotalSupplyStateCompleter{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetTotalSupply(Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.TotalSupplyStateCompleter{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetValidatorSet(Libplanet.Blocks.BlockHash,Libplanet.Blockchain.ValidatorSetStateCompleter{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetValidatorSet(Libplanet.Blocks.BlockHash,Libplanet.Blockchain.ValidatorSetStateCompleter{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetTxExecution(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId)">
            <summary>
            Queries the recorded <see cref="T:Libplanet.Tx.TxExecution"/> for a successful or failed
            <see cref="T:Libplanet.Tx.Transaction`1"/> within a <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that the <see cref="T:Libplanet.Tx.Transaction`1"/> is executed within.</param>
            <param name="txid">The executed <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.</param>
            <returns>The recorded <see cref="T:Libplanet.Tx.TxExecution"/>.  If the transaction has never been
            executed within the block, it returns <see langword="null"/> instead.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.Append(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})">
            <summary>
            Adds a <paramref name="block"/> to the end of this chain.
            <para><see cref="P:Libplanet.Blocks.Block`1.Transactions"/> in the <paramref name="block"/> updates
            states and balances in the blockchain, and <see cref="T:Libplanet.Tx.TxExecution"/>s for
            transactions are recorded.</para>
            <para>Note that <see cref="P:Libplanet.Blockchain.BlockChain`1.Renderers"/> receive events right after the <paramref
            name="block"/> is confirmed (and thus all states reflect changes in the <paramref
            name="block"/>).</para>
            </summary>
            <param name="block">A next <see cref="T:Libplanet.Blocks.Block`1"/>, which is mined,
            to add.</param>
            <param name="stateCompleters">The strategy to complement incomplete block states which
            are required for action execution and rendering.
            <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.
            </param>
            <exception cref="T:Libplanet.Blocks.BlockPolicyViolationException">Thrown when given
            <paramref name="block"/> does not satisfy any of the constraints
            validated by <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.ValidateNextBlock(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.Block{`0})"/> of <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.
            </exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockException">Thrown when the given <paramref name="block"/>
            is invalid, in itself or according to the <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxNonceException">Thrown when the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> is different from
            <see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/> result of the
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.StageTransaction(Libplanet.Tx.Transaction{`0})">
            <summary>
            Adds <paramref name="transaction"/> to the pending list so that a next
            <see cref="T:Libplanet.Blocks.Block`1"/> to be mined may contain given <paramref name="transaction"/>.
            </summary>
            <param name="transaction"><see cref="T:Libplanet.Tx.Transaction`1"/> to add to the pending list.
            </param>
            <returns><see langword="true"/> if staging was successful,
            <see langword="false"/> otherwise.</returns>
            <exception cref="T:Libplanet.Tx.InvalidTxGenesisHashException">Thrown when given
            <paramref name="transaction"/> has invalid <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>.
            </exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.UnstageTransaction(Libplanet.Tx.Transaction{`0})">
            <summary>
            Removes a <paramref name="transaction"/> from the pending list.
            </summary>
            <param name="transaction">A <see cref="T:Libplanet.Tx.Transaction`1"/>
            to remove from the pending list.</param>
            <returns><see langword="true"/> if unstaging was successful,
            <see langword="false"/> otherwise.</returns>
            <seealso cref="M:Libplanet.Blockchain.BlockChain`1.StageTransaction(Libplanet.Tx.Transaction{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)">
            <summary>
            Gets next <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> of the address.
            </summary>
            <param name="address">The <see cref="T:Libplanet.Address"/> from which to obtain the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> value.</param>
            <returns>The next <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> value of the
            <paramref name="address"/>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MakeTransaction(Libplanet.Crypto.PrivateKey,Libplanet.Action.IAction,System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.Transaction`1"/> with a system action and stage it.
            It's available only if the genesis block exists.
            </summary>
            <param name="privateKey">A <see cref="T:Libplanet.Crypto.PrivateKey"/> of the account who creates and
            signs a new transaction.</param>
            <param name="systemAction">A system action to include to a new transaction.</param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose states affected by
            the <paramref name="systemAction"/>.</param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/> is created and
            signed.</param>
            <returns>A created new <see cref="T:Libplanet.Tx.Transaction`1"/> signed by the given
            <paramref name="privateKey"/>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MakeTransaction(Libplanet.Crypto.PrivateKey,System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.Transaction`1"/> with custom actions and stage it.
            It's available only if the genesis block exists.
            </summary>
            <param name="privateKey">A <see cref="T:Libplanet.Crypto.PrivateKey"/> of the account who creates and
            signs a new transaction.</param>
            <param name="customActions">A list of custom actions to include to a new transaction.
            </param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose states affected by
            <paramref name="customActions"/>.</param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/> is created and
            signed.</param>
            <returns>A created new <see cref="T:Libplanet.Tx.Transaction`1"/> signed by the given
            <paramref name="privateKey"/>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetStagedTransactionIds">
            <summary>
            Lists all staged <see cref="T:Libplanet.Tx.TxId"/>s.
            </summary>
            <returns><see cref="T:System.Collections.Immutable.IImmutableSet`1"/> of staged transactions.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ExecuteActions(Libplanet.Blocks.Block{`0},System.Nullable{Libplanet.Blockchain.StateCompleterSet{`0}})">
            <summary>
            Evaluates actions in the given <paramref name="block"/> and fills states with the
            results.
            </summary>
            <param name="block">A block to execute.</param>
            <param name="stateCompleters">The strategy to complement incomplete previous block
            states.  <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.
            </param>
            <returns>The result of action evaluations of the given <paramref name="block"/>.
            </returns>
            <remarks>This method is idempotent (except for rendering).  If the given
            <paramref name="block"/> has executed before, it does not execute it nor mutate states.
            Exposed as public for benchmarking.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.FindNextHashes(Libplanet.Blockchain.BlockLocator,System.Nullable{Libplanet.Blocks.BlockHash},System.Int32)">
            <summary>
            Finds the branch point <see cref="T:Libplanet.Blocks.BlockHash"/> between this <see cref="T:Libplanet.Blockchain.BlockChain`1"/>
            and <paramref name="locator"/> and returns the list of <see cref="T:Libplanet.Blocks.BlockHash"/>es of
            successive <see cref="T:Libplanet.Blocks.Block`1"/>s starting from the branch point
            <see cref="T:Libplanet.Blocks.BlockHash"/>.</summary>
            <param name="locator">The <see cref="T:Libplanet.Blockchain.BlockLocator"/> to find the branching point
            from.</param>
            <param name="stop">The <see cref="T:Libplanet.Blocks.BlockHash"/> to stop looking for subsequent blocks
            once encountered.
            </param>
            <param name="count">The Maximum number of <see cref="T:Libplanet.Blocks.BlockHash"/>es to return.</param>
            <returns>A tuple of the index of the branch point and <see cref="T:Libplanet.Blocks.BlockHash"/>es
            including the branch point <see cref="T:Libplanet.Blocks.BlockHash"/>.  If no branch point is found,
            returns a tuple of <see langword="null"/> and an empty array of
            <see cref="T:Libplanet.Blocks.BlockHash"/>es.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.Fork(Libplanet.Blocks.BlockHash,System.Boolean)">
            <summary>
            Forks the chain at <paramref name="point"/> and returns the newly forked chain.
            </summary>
            <param name="point">The hash in which to fork from.</param>
            <param name="inheritRenderers">Whether to inherit the renderers from the existing chain.
            </param>
            <returns>An instance of the newly forked chain.</returns>
            <exception cref="T:System.ArgumentException">Throws when the provided <paramref name="point"/>
            does not exist in the current chain.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetBlockLocator(System.Int32)">
            <summary>
            Returns a new <see cref="T:Libplanet.Blockchain.BlockLocator"/> from the tip of current chain.
            </summary>
            <param name="threshold">The amount of consequent blocks to include before sampling.
            </param>
            <returns>A instance of block locator.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.FindBranchpoint(Libplanet.Blockchain.BlockLocator)">
            <summary>
            Find an approximate to the topmost common ancestor between this
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> and a given <see cref="T:Libplanet.Blockchain.BlockLocator"/>.
            </summary>
            <param name="locator">A block locator that contains candidate common ancestors.</param>
            <returns>An approximate to the topmost common ancestor.  If it failed to find anything
            returns <see langword="null"/>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ListStagedTransactions(System.Collections.Generic.IComparer{Libplanet.Tx.Transaction{`0}})">
            <summary>
            Lists the all staged transactions, with properly ordered nonces.
            </summary>
            <param name="txPriority">An optional comparer for give certain transactions to
            priority to belong to the block.  No certain priority by default.</param>
            <returns>A list of staged transactions.  This guarantees that for transactions signed
            by the same address, those with greater nonce never comes before those with
            lesser nonce.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MineBlock(Libplanet.Crypto.PrivateKey,System.Nullable{System.DateTimeOffset},System.Nullable{System.Boolean},System.Collections.Generic.IComparer{Libplanet.Tx.Transaction{`0}},System.Nullable{System.Threading.CancellationToken})">
            <summary>
            <para>
            Mines a next <see cref="T:Libplanet.Blocks.Block`1"/> using staged <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </para>
            <para>
            All unprovided and/or <see langword="null"/> arguments are reassigned accordingly
            and redirected to a overloaded method with non-nullable parameters.  By default,
            a policy adhering block is produced with current timestamp and appended immediately
            to the chain.
            </para>
            </summary>
            <param name="miner">The miner's <see cref="T:Libplanet.Crypto.PublicKey"/> that mines the block.</param>
            <param name="timestamp">The <see cref="T:System.DateTimeOffset"/> when mining started.</param>
            <param name="append">Whether to append the mined block immediately after mining.</param>
            <param name="txPriority">An optional comparer for give certain transactions to
            priority to belong to the block.  No certain priority by default.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task with a <see cref="T:Libplanet.Blocks.Block`1"/> that is mined.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> is changed while mining.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MineBlock(Libplanet.Crypto.PrivateKey,System.DateTimeOffset,System.Boolean,System.Int64,System.Int32,System.Int32,System.Collections.Generic.IComparer{Libplanet.Tx.Transaction{`0}},System.Threading.CancellationToken)">
            <summary>
            Mines a next <see cref="T:Libplanet.Blocks.Block`1"/> using staged <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </summary>
            <param name="miner">The miner's <see cref="T:Libplanet.Crypto.PublicKey"/> that mines the block.</param>
            <param name="timestamp">The <see cref="T:System.DateTimeOffset"/> when mining started.</param>
            <param name="append">Whether to append the mined block immediately after mining.</param>
            <param name="maxTransactionsBytes">The maximum number of bytes a block can have.
            See also <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxTransactionsBytes(System.Int64)"/>.</param>
            <param name="maxTransactions">The maximum number of transactions that a block can
            accept.  See also <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxTransactionsPerBlock(System.Int64)"/>.
            </param>
            <param name="maxTransactionsPerSigner">The maximum number of transactions
            that a block can accept per signer.  See also
            <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxTransactionsPerSignerPerBlock(System.Int64)"/>.</param>
            <param name="txPriority">An optional comparer for give certain transactions to
            priority to belong to the block.  No certain priority by default.</param>
            <param name="cancellationToken">A cancellation token used to propagate notification
            that this operation should be canceled.</param>
            <returns>An awaitable task with a <see cref="T:Libplanet.Blocks.Block`1"/> that is mined.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> is changed while mining.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GatherTransactionsToMine(System.Int64,System.Int32,System.Int32,System.Collections.Generic.IComparer{Libplanet.Tx.Transaction{`0}})">
            <summary>
            Gathers <see cref="T:Libplanet.Tx.Transaction`1"/>s for mining a next block
            from the current set of staged <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </summary>
            <param name="maxTransactionsBytes">The maximum number of bytes a block can have.</param>
            <param name="maxTransactions">The maximum number of <see cref="T:Libplanet.Tx.Transaction`1"/>s
            allowed.</param>
            <param name="maxTransactionsPerSigner">The maximum number of
            <see cref="T:Libplanet.Tx.Transaction`1"/>s with the same signer allowed.</param>
            <param name="txPriority">An optional comparer for give certain transactions to
            priority to belong to the block.  No certain priority by default.</param>
            <returns>An <see cref="T:System.Collections.Immutable.ImmutableList"/> of <see cref="T:Libplanet.Tx.Transaction`1"/>s with its
            count not exceeding <paramref name="maxTransactions"/> and the number of
            <see cref="T:Libplanet.Tx.Transaction`1"/>s in the list for each signer not exceeding
            <paramref name="maxTransactionsPerSigner"/>.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.RecalculateBlockStates(Libplanet.Blocks.BlockHash)">
            <summary>
            Recalculates <i>all</i> block states and complements missing states including and upto
            given <paramref name="blockHash"/> starting from the genesis block.
            </summary>
            <param name="blockHash">The inclusive limit of target hash to terminate recalculation.
            </param>
            <remarks>
            If a recalcuation of the entire blockchain is needed, call with the tip hash of the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ComplementAllBlockStates(Libplanet.Blocks.BlockHash)">
            <summary>
            Recalculates and complements all <i>missing</i> block states including and upto given
            <paramref name="blockHash"/> starting from the genesis block.
            </summary>
            <param name="blockHash">The inclusive limit of target hash to terminate complementation.
            </param>
            <remarks>
            <para>
            If a complementation of the entire blockchain is needed, call with the tip hash of the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </para>
            <para>
            Unlike <see cref="M:Libplanet.Blockchain.BlockChain`1.RecalculateBlockStates(Libplanet.Blocks.BlockHash)"/>, this method skips recalculations if states
            are found for intermediate blocks. This may not be fully secure if states for
            blocks in <see cref="T:Libplanet.Store.IStateStore"/> are somehow corrupted.
            </para>
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.ComplementLatestBlockStates(Libplanet.Blocks.BlockHash)">
            <summary>
            Recalculates and complements all <i>missing</i> block states including and upto given
            <paramref name="blockHash"/> starting from the last known states in
            <see cref="P:Libplanet.Blockchain.BlockChain`1.StateStore"/> before <paramref name="blockHash"/> if the states are missing
            for <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">The starting point for searching backwards.</param>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.RenderActions(System.Collections.Generic.IReadOnlyList{Libplanet.Action.ActionEvaluation},Libplanet.Blocks.Block{`0},Libplanet.Blockchain.StateCompleterSet{`0})">
            <summary>
            Render actions of the given <paramref name="block"/>.
            </summary>
            <param name="evaluations"><see cref="T:Libplanet.Action.ActionEvaluation"/>s of the block.  If it is
            <see langword="null"/>, evaluate actions of the <paramref name="block"/> again.</param>
            <param name="block"><see cref="T:Libplanet.Blocks.Block`1"/> to render actions.</param>
            <param name="stateCompleters">The strategy to complement incomplete block states.
            <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/> by default.</param>
            <returns>The number of actions rendered.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetRewindPath(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.BlockHash)">
            <summary>
            Generates a list of <see cref="T:Libplanet.Blocks.BlockHash"/>es to traverse starting from
            the tip of <paramref name="chain"/> to reach <paramref name="targetHash"/>.
            </summary>
            <param name="chain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> to traverse.</param>
            <param name="targetHash">The target <see cref="T:Libplanet.Blocks.BlockHash"/> to reach.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> of <see cref="T:Libplanet.Blocks.BlockHash"/>es to traverse from
            the tip of <paramref name="chain"/> to reach <paramref name="targetHash"/> excluding
            <paramref name="targetHash"/>.
            </returns>
            <remarks>
            <para>
            This is a reverse of <see cref="M:Libplanet.Blockchain.BlockChain`1.GetFastForwardPath(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.BlockHash)"/>.
            </para>
            <para>
            As the genesis is always fixed, returned results never include the genesis.
            </para>
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.GetFastForwardPath(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.BlockHash)">
            <summary>
            Generates a list of <see cref="T:Libplanet.Blocks.BlockHash"/>es to traverse starting from
            <paramref name="originHash"/> to reach the tip of <paramref name="chain"/>.
            </summary>
            <param name="chain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> to traverse.</param>
            <param name="originHash">The <see cref="T:Libplanet.Blocks.BlockHash"/> to start from.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> of <see cref="T:Libplanet.Blocks.BlockHash"/>es to traverse
            to reach the tip of <paramref name="chain"/> from <paramref name="originHash"/>
            excluding <paramref name="originHash"/>.
            </returns>
            <remarks>
            This is a reverse of <see cref="M:Libplanet.Blockchain.BlockChain`1.GetRewindPath(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.BlockHash)"/>.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.FindTopCommon(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blockchain.BlockChain{`0})">
            <summary>
            Finds the top most common <see cref="T:Libplanet.Blocks.Block`1"/> between chains <paramref name="c1"/>
            and <paramref name="c2"/>.
            </summary>
            <param name="c1">The first <see cref="T:Libplanet.Blockchain.BlockChain`1"/> to compare.</param>
            <param name="c2">The second <see cref="T:Libplanet.Blockchain.BlockChain`1"/> to compare.</param>
            <returns>
            The top most common <see cref="T:Libplanet.Blocks.Block`1"/> between chains <paramref name="c1"/>
            and <paramref name="c2"/>. If there is no such <see cref="T:Libplanet.Blocks.Block`1"/>,
            returns <see langword="null"/> instead.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChain`1.MakeTxExecutions(Libplanet.Blocks.Block{`0},System.Collections.Generic.IReadOnlyList{Libplanet.Action.ActionEvaluation})">
            <summary>
            Makes <see cref="T:Libplanet.Tx.TxExecution"/> instances from the given <paramref name="evaluations"/>.
            </summary>
            <param name="block">The block that evaluated actions belong to.</param>
            <param name="evaluations">The result of evaluated actions.</param>
            <returns>The corresponding <see cref="T:Libplanet.Tx.TxExecution"/>s.</returns>
        </member>
        <member name="T:Libplanet.Blockchain.BlockChainStates`1">
            <summary>
            A default implementation of <see cref="T:Libplanet.Blockchain.IBlockChainStates`1" /> interface.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChainStates`1.GetStates(System.Collections.Generic.IReadOnlyList{Libplanet.Address},Libplanet.Blocks.BlockHash,Libplanet.Blockchain.StateCompleter{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetStates(System.Collections.Generic.IReadOnlyList{Libplanet.Address},Libplanet.Blocks.BlockHash,Libplanet.Blockchain.StateCompleter{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChainStates`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.FungibleAssetStateCompleter{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.FungibleAssetStateCompleter{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.BlockChainStates`1.GetTotalSupply(Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.TotalSupplyStateCompleter{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetTotalSupply(Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.TotalSupplyStateCompleter{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.BlockLocator">
            <summary>
            A class that contains <see cref="T:Libplanet.Blocks.BlockHash"/>es for a series of blocks.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.BlockLocator.#ctor(System.Collections.Generic.IEnumerable{Libplanet.Blocks.BlockHash})">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blockchain.BlockLocator"/> from <paramref name="hashes"/>.
            </summary>
            <param name="hashes">Enumerable of <see cref="T:Libplanet.Blocks.BlockHash"/>es to convert from.</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="hashes"/> is empty.
            </exception>
        </member>
        <member name="M:Libplanet.Blockchain.BlockLocator.Create(System.Int64,System.Func{System.Int64,System.Nullable{Libplanet.Blocks.BlockHash}},System.Int64)">
            <summary>
            <para>
            Creates a new instance of <see cref="T:Libplanet.Blockchain.BlockLocator"/> with an indexer
            function, sampling after <paramref name="sampleAfter"/> number of
            <see cref="T:Libplanet.Blocks.Block`1"/>s.
            </para>
            <para>
            This collects all <see cref="T:Libplanet.Blocks.BlockHash"/>es corresponding to indices inductively
            defined by:
            <list type="bullet">
              <item><description>
                <c>i_0 = startIndex</c>
              </description></item>
              <item><description>
                <c>i_k = max(i_(k - 1) - 1, 0)</c> for <c>0 &lt; k</c> and  <c>k &lt;= s</c>
              </description></item>
              <item><description>
                <c>i_k = max(i_(k - 1) - 2^(k - 1 - s), 0)</c> for <c>0 &lt; k</c>
                and <c>s &lt; k</c>
              </description></item>
            </list>
            where <c>s = max(sampleAfter, 0)</c> and the sequence terminates after index <c>i_k</c>
            reaches zero or the <see cref="T:Libplanet.Blocks.BlockHash"/> returned by
            <paramref name="indexToBlockHash"/> for <c>i_k</c> is <see langword="null"/>,
            in which case the <see cref="T:Libplanet.Blocks.BlockHash"/> corresponding to index <c>0</c>
            (presumably a <see cref="T:Libplanet.Blocks.BlockHash"/> of the genesis <see cref="T:Libplanet.Blocks.Block`1"/>)
            is added at the end.
            </para>
            </summary>
            <param name="startIndex">The starting index.</param>
            <param name="indexToBlockHash">The function that converts an index to a
            <see cref="T:Libplanet.Blocks.BlockHash"/>.  This can be <see langword="null"/> which indicates
            a missing <see cref="T:Libplanet.Blocks.Block`1"/> at the index.  Any value from <c>0</c> to
            <paramref name="startIndex"/> may be used as an argument to call this function.</param>
            <param name="sampleAfter">The number of consecutive blocks to include before sampling.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when <paramref name="startIndex"/>
            is negative.</exception>
            <exception cref="T:System.ArgumentException">Thrown when either <see cref="T:Libplanet.Blocks.BlockHash"/> returned
            by <paramref name="indexToBlockHash"/> for index <c>0</c> is <see langword="null"/>.
            </exception>
            <returns>
            An instance of <see cref="T:Libplanet.Blockchain.BlockLocator"/> created with given arguments.
            </returns>
            <remarks>
            Returned <see cref="T:Libplanet.Blockchain.BlockLocator"/> created by this factory method is guaranteed
            to have the <see cref="T:Libplanet.Blocks.BlockHash"/> corresponding to index <c>0</c>.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.BlockLocator.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Libplanet.Blockchain.Branch`1">
            <summary>
            A class representing a consecutive list of <see cref="T:Libplanet.Blocks.Block`1"/>s.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Branch`1.#ctor(System.Collections.Generic.IEnumerable{Libplanet.Blocks.Block{`0}})">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blockchain.Branch`1"/> from <paramref name="blocks"/>.
            </summary>
            <param name="blocks">An enumerable of <see cref="T:Libplanet.Blocks.Block`1"/>es to convert from.</param>
            <exception cref="T:System.ArgumentException">Thrown for failing to satisfy any of the following:
            <list type="bullet">
                <item><description>
                    Given <paramref name="blocks"/> is non-empty.
                </description></item>
                <item><description>
                    Given <paramref name="blocks"/> are consecutive in the sense that indices
                    are unique, consecutive, and every <see cref="P:Libplanet.Blocks.Block`1.PreviousHash"/> match
                    the <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the previous <see cref="T:Libplanet.Blocks.Block`1"/>.
                </description></item>
            </list>
            </exception>
        </member>
        <member name="P:Libplanet.Blockchain.Branch`1.Blocks">
            <summary>
            An <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> of <see cref="T:Libplanet.Blocks.Block`1"/>s guarenteed to satisfy
            the following properties:
            <list type="bullet">
                <item><description>
                    The collection is non-empty.
                </description></item>
                <item><description>
                    The collection is sorted by index.
                </description></item>
                <item><description>
                    The elements are consecutive in the sense that indices
                    are unique, consecutive, and every <see cref="P:Libplanet.Blocks.Block`1.PreviousHash"/> match
                    the <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the previous <see cref="T:Libplanet.Blocks.Block`1"/>.
                </description></item>
            </list>
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.FungibleAssetStateCompleter`1">
            <summary>
            A delegate to be called when <see cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.FungibleAssetStateCompleter{`0})"/> method encounters
            a block having incomplete dirty states. <see cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.FungibleAssetStateCompleter{`0})"/> method
            returns this delegate's return value instead for such case.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <param name="blockChain">The blockchain to query.</param>
            <param name="blockHash">The hash of a block to lacks its dirty states.</param>
            <param name="address">The account to query its balance.</param>
            <param name="currency">The currency to query.</param>
            <returns>A complement balance value.  <em>Its <see cref="F:Libplanet.Assets.FungibleAssetValue.Currency"/>
            must match to the given <paramref name="currency"/>.</em></returns>
            <seealso cref="T:Libplanet.Blockchain.FungibleAssetStateCompleters`1"/>
        </member>
        <member name="T:Libplanet.Blockchain.FungibleAssetStateCompleters`1">
            <summary>
            Predefined built-in state completers that satisfy
            <see cref="T:Libplanet.Blockchain.FungibleAssetStateCompleter`1"/> delegate.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Recalculate">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.ComplementAll">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementAll"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.ComplementLatest">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementLatest"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Reject">
            <summary>
            Rejects to complement incomplete state and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.IBlockChainStates`1">
            <summary>
            A minimal interface to get states from a blockchain.
            <para>Note that <see cref="T:Libplanet.Blockchain.BlockChain`1"/> implements this interface.</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.IBlockChainStates`1.GetStates(System.Collections.Generic.IReadOnlyList{Libplanet.Address},Libplanet.Blocks.BlockHash,Libplanet.Blockchain.StateCompleter{`0})">
            <summary>
            Gets multiple states associated to the specified <paramref name="addresses"/>.
            </summary>
            <param name="addresses">Addresses of states to query.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to start finding
            the states.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states of the block, this delegate is called and its return values are used
            instead.
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Recalculate"/> makes the incomplete states
            recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.StateCompleters`1.Reject"/> makes the incomplete states (if needed)
            to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> instead.</para></param>
            <returns>The states associated to the specified <paramref name="addresses"/>.
            Associated values are ordered in the same way to the corresponding
            <paramref name="addresses"/>.  Absent states are represented as <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.IBlockChainStates`1.GetBalance(Libplanet.Address,Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.FungibleAssetStateCompleter{`0})">
            <summary>
            Queries <paramref name="address"/>'s balance of the <paramref name="currency"/> in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> from <paramref name="offset"/>.
            </summary>
            <param name="address">The owner <see cref="T:Libplanet.Address"/> to query.</param>
            <param name="currency">The currency type to query.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to
            start finding the state.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states dirty of the block which lastly updated states of a requested address,
            this delegate is called and its return value is used instead.
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Recalculate"/> makes the incomplete
            states recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Reject"/> makes the incomplete states
            (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> instead.</para>
            </param>
            <returns>The <paramref name="address"/>'s current balance (or balance as of the given
            <paramref name="offset"/>) of the <paramref name="currency"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Blockchain.IBlockChainStates`1.GetTotalSupply(Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.TotalSupplyStateCompleter{`0})">
            <summary>
            Gets the total supply of a <paramref name="currency"/> in the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/> from <paramref name="offset"/>, and if not found, return 0.
            </summary>
            <param name="currency">The currency type to query.</param>
            <param name="offset">The <see cref="T:Libplanet.HashDigest`1"/> of the block to
            start finding the state.</param>
            <param name="stateCompleter">When the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance does not
            contain states of the block, this delegate is called and its return values are used
            instead.
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Recalculate"/> makes the incomplete
            states recalculated and filled on the fly.</para>
            <para><see cref="F:Libplanet.Blockchain.FungibleAssetStateCompleters`1.Reject"/> makes the incomplete states
            (if needed) to cause <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> instead.</para>
            </param>
            <returns>The total supply value of <paramref name="currency"/> at
            <paramref name="offset"/> in <see cref="T:Libplanet.Assets.FungibleAssetValue"/>.</returns>
        </member>
        <member name="T:Libplanet.Blockchain.IncompleteBlockStatesException">
            <summary>
            An exception thrown when a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> have
            not calculated the complete states for all blocks but an operation
            is requested that requires the missing states.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.IncompleteBlockStatesException.#ctor(Libplanet.Blocks.BlockHash,System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/> object.
            </summary>
            <param name="blockHash">Specifies <see cref="P:Libplanet.Blockchain.IncompleteBlockStatesException.BlockHash"/>.
            It is automatically included in the <see cref="P:System.Exception.Message"/>
            string.</param>
            <param name="message">Specifies the <see cref="P:System.Exception.Message"/>.
            </param>
        </member>
        <member name="P:Libplanet.Blockchain.IncompleteBlockStatesException.BlockHash">
            <summary>
            The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of <see cref="T:Libplanet.Blocks.Block`1"/> that
            a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> lacks the states.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.Policies.BlockPolicy`1">
            <summary>
            A default implementation of <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/> interface.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.#ctor(Libplanet.Action.IAction,System.Nullable{System.TimeSpan},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Func{Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0},Libplanet.Tx.TxPolicyViolationException},System.Func{Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.BlockPolicyViolationException},System.Collections.Generic.IComparer{Libplanet.Blocks.IBlockExcerpt},System.Func{System.Int64,System.Int64},System.Func{System.Int64,System.Int32},System.Func{System.Int64,System.Int32},System.Func{System.Int64,System.Int32},System.Func{System.Int64,System.Int32},System.Collections.Immutable.IImmutableSet{Libplanet.Assets.Currency})">
            <summary>
            <para>
            Creates a default <see cref="T:Libplanet.Blockchain.Policies.BlockPolicy`1"/> instance.
            </para>
            <para>
            Each unprovided argument will be assigned a default value.  See each parameter
            description for more detail.
            </para>
            </summary>
            <param name="blockAction">A <see cref="T:Libplanet.Action.IAction"/> to executed for
            every <see cref="T:Libplanet.Blocks.Block`1"/>.  Set to <see langword="null"/> by default, which results
            in no additional execution other than those included in <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </param>
            <param name="blockInterval">Goes to <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockInterval"/>.
            Set to <see cref="F:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.DefaultTargetBlockInterval"/>
            by default.
            </param>
            <param name="difficultyStability">Goes to <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.DifficultyStability"/>.
            Set to <see cref="F:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.DefaultDifficultyStability"/>
            by default.</param>
            <param name="minimumDifficulty">Goes to <see cref="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MinimumDifficulty"/>.
            Set to <see cref="F:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.DefaultMinimumDifficulty"/>
            by default.</param>
            <param name="validateNextBlockTx">The predicate that determines if
            a <see cref="T:Libplanet.Tx.Transaction`1"/> follows the policy.  Set to a constant function of
            <see langword="null"/> by default.</param>
            <param name="validateNextBlock">The predicate that determines if
            a <see cref="T:Libplanet.Blocks.Block`1"/> follows the policy.  Set to a default implementation
            where block's hash algorithm type, bytes count, and transactions count are validated.
            </param>
            <param name="canonicalChainComparer">The custom rule to determine which is the canonical
            chain.  If omitted, <see cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/> is used by default.</param>
            <param name="getMaxTransactionsBytes">The function determining the maximum size of
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> in number of <c>byte</c>s given
            its <see cref="P:Libplanet.Blocks.Block`1.Index"/>.  Goes to <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxTransactionsBytes(System.Int64)"/>.
            Set to a constant size of <c>100</c>KiB, i.e. <c>100 * 1024</c>, by default.</param>
            <param name="getMinTransactionsPerBlock">The function determining the minimum number of
            <see cref="T:Libplanet.Tx.Transaction`1"/>s that must be included in a <see cref="T:Libplanet.Blocks.Block`1"/>.
            Goes to <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMinTransactionsPerBlock(System.Int64)"/>.  Set to a constant function
            of <c>0</c> by default.</param>
            <param name="getMaxTransactionsPerBlock">The function determining how many
            <see cref="T:Libplanet.Tx.Transaction`1"/>s can be included in a <see cref="T:Libplanet.Blocks.Block`1"/>.
            Goes to <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxTransactionsPerBlock(System.Int64)"/>.  Set to a constant function
            of <c>100</c> by default.</param>
            <param name="getMaxTransactionsPerSignerPerBlock">The function determining the maximum
            number of transactions from the same signer that can be included in
            a <see cref="T:Libplanet.Blocks.Block`1"/> given the <see cref="T:Libplanet.Blocks.Block`1"/>'s index.
            Goes to <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxTransactionsPerSignerPerBlock(System.Int64)"/>.  Set to
            <see cref="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxTransactionsPerBlock(System.Int64)"/> by default.</param>
            <param name="getMinBlockProtocolVersion">The function determining the minimum
            block protocol version of a <see cref="T:Libplanet.Blocks.Block`1"/> given the <see cref="T:Libplanet.Blocks.Block`1"/>'s
            index.  Set to a constant function of <c>0</c> by default.</param>
            <param name="nativeTokens">A fixed set of <see cref="T:Libplanet.Assets.Currency"/> objects that are
            supported by the blockchain as first-class citizens.  Empty by default.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockAction">
            <inheritdoc/>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.NativeTokens">
            <inheritdoc cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.BlockInterval">
            <summary>
            Targeted time interval between two consecutive <see cref="T:Libplanet.Blocks.Block`1"/>s.
            See the corresponding parameter description for
            <see cref="M:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.BaseAlgorithm(Libplanet.Blockchain.BlockChain{`0},System.TimeSpan,System.Int64,System.Int64)"/> for full detail.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.DifficultyStability">
            <summary>
            Stability of a series of difficulties for a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            See the corresponding parameter description for
            <see cref="M:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.BaseAlgorithm(Libplanet.Blockchain.BlockChain{`0},System.TimeSpan,System.Int64,System.Int64)"/> for full detail.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.MinimumDifficulty">
            <summary>
            Minimum difficulty for a <see cref="T:Libplanet.Blocks.Block`1"/>.  See the corresponding
            parameter description for <see cref="M:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.BaseAlgorithm(Libplanet.Blockchain.BlockChain{`0},System.TimeSpan,System.Int64,System.Int64)"/> for
            full detail.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.BlockPolicy`1.CanonicalChainComparer">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.ValidateNextBlockTx(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.ValidateNextBlock(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetNextBlockDifficulty(Libplanet.Blockchain.BlockChain{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxTransactionsBytes(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMinTransactionsPerBlock(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxTransactionsPerBlock(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMaxTransactionsPerSignerPerBlock(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.BlockPolicy`1.GetMinBlockProtocolVersion(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.BaseAlgorithm(Libplanet.Blockchain.BlockChain{`0},System.TimeSpan,System.Int64,System.Int64)">
            <summary>
            An Ethereum based difficulty adjustment algorithm.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> instance
            to calculate the next difficulty from.</param>
            <param name="targetBlockInterval">The base block interval this difficulty adjustment
            algorithm targets.  In reality, the algorithm does not actually target the given
            <see cref="T:System.TimeSpan"/>.  Assuming stable hash rate, the actual average of
            block intervals comes out to be about <c>targetBaseInterval * 1.4</c>.</param>
            <param name="difficultystability">Determines how stable difficulty should be over time.
            </param>
            <param name="minimumDifficulty">The lower bound on the difficulty.  This is ignored
            for genesis blocks.</param>
            <returns>The next target difficulty of a <see cref="T:Libplanet.Blocks.Block`1"/> that gets
            appended to <paramref name="blockChain"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">When the number of blocks
            in <see cref="T:Libplanet.Blockchain.BlockChain`1"/> is negative.</exception>
            <remarks>
            It is strongly recommended to use the factory version <see cref="M:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.AlgorithmFactory(System.TimeSpan,System.Int64,System.Int64)"/>
            to get a working difficulty adjustment algorithm.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.AlgorithmFactory(System.TimeSpan,System.Int64,System.Int64)">
            <summary>
            Does sanity checks and binds arguments to the <see cref="M:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.BaseAlgorithm(Libplanet.Blockchain.BlockChain{`0},System.TimeSpan,System.Int64,System.Int64)"/> based
            difficulty adjustment algorithm.
            </summary>
            <param name="targetBlockInterval">The base block interval this difficulty adjustment
            algorithm targets.  In reality, the algorithm does not actually target the given
            <see cref="T:System.TimeSpan"/>.  Assuming stable hash rate, the actual average of
            block intervals comes out to be about <c>targetBaseInterval * 1.4</c>.
            If ommited, set to <see cref="F:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.DefaultTargetBlockInterval"/> by default.
            </param>
            <param name="difficultyStability">Determines how stable difficulty should be over time.
            If ommited, set to <see cref="F:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.DefaultDifficultyStability"/> by default.
            </param>
            <param name="minimumDifficulty">The lower bound on the difficulty.</param>
            <returns>The next target difficulty of a <see cref="T:Libplanet.Blocks.Block`1"/> that gets
            appended to some <See cref="T:Libplanet.Blockchain.BlockChain`1"/>.  If ommited, set to
            <see cref="F:Libplanet.Blockchain.Policies.DifficultyAdjustment`1.DefaultMinimumDifficulty"/> by default.</returns>
            <returns>A difficulty adjustment algorithm with bound constants provided.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If any of the arguments fail to
            satisfy the necessary constraints for the formula to work.</exception>
        </member>
        <member name="T:Libplanet.Blockchain.Policies.IBlockPolicy`1">
            <summary>
            <para>
            An interface to determine if consecutive <see cref="T:Libplanet.Blocks.Block`1"/>s are valid.
            </para>
            <para>
            An implementation of this interface should perform <em>all policy dependent checks</em>,
            such as whether a <see cref="T:Libplanet.Blocks.Block`1"/> has the right difficulty,
            a <see cref="T:Libplanet.Tx.Transaction`1"/> has the right signer, etc.
            </para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer">
            <summary>
            A comparer to determine which branch is the canonical chain (i.e., best chain).
            The most greater one according to this comparer is considered to be the canon.
            </summary>
            <seealso cref="T:Libplanet.Blocks.IBlockExcerpt"/>
            <seealso cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction">
            <summary>
            An <see cref="T:Libplanet.Action.IAction"/> to execute and be rendered for every block, if any.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens">
            <summary>
            A fixed set of <see cref="T:Libplanet.Assets.Currency"/> objects that are supported by the blockchain
            as first-class assets.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.ValidateNextBlockTx(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})">
            <summary>
            Checks if a <see cref="T:Libplanet.Tx.Transaction`1"/> can be included in a yet to be mined
            <see cref="T:Libplanet.Blocks.Block`1"/> that can be appended to the given <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <param name="blockChain">The target <see cref="T:Libplanet.Blockchain.BlockChain`1"/> to include
            given <paramref name="transaction"/>.</param>
            <param name="transaction">The <see cref="T:Libplanet.Tx.Transaction`1"/> to consider.</param>
            <returns>A <see cref="T:Libplanet.Tx.TxPolicyViolationException"/> with a description
            as to why given <paramref name="transaction"/> is <em>invalid</em>,
            or <see langword="null"/> if <paramref name="transaction"/> is <em>valid</em>.</returns>
            <remarks>
            This is used in two different cases:
            <list type="bullet">
            <item>
                <description>When selecting which <see cref="T:Libplanet.Tx.Transaction`1"/> to include
                when mining a next <see cref="T:Libplanet.Blocks.Block`1"/>.</description>
            </item>
            <item>
                <description>When appending a <see cref="T:Libplanet.Blocks.Block`1"/>
                with <paramref name="transaction"/> to a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</description>
            </item>
            </list>
            This is called separately from <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.ValidateNextBlock(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.Block{`0})"/> from
            a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.ValidateNextBlock(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Checks if a <see cref="T:Libplanet.Blocks.Block`1"/> can be appended to
            the given <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <param name="blockChain">The target <see cref="T:Libplanet.Blockchain.BlockChain`1"/> to
            append <paramref name="nextBlock"/>.</param>
            <param name="nextBlock">The next block to append to
            <paramref name="blockChain"/>.</param>
            <returns>A <see cref="T:Libplanet.Blocks.BlockPolicyViolationException"/> with a description
            as to why given <paramref name="nextBlock"/> is <em>invalid</em>,
            or <see langword="null"/> if <paramref name="nextBlock"/> is <em>valid</em>.</returns>
            <remarks>
            Note that <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.ValidateNextBlockTx(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})"/> will be called separately from
            a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> when appending a <see cref="T:Libplanet.Blocks.Block`1"/>.
            Hence, to reduce redundancy, an implementation of this interface should not
            call <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.ValidateNextBlockTx(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})"/>.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetNextBlockDifficulty(Libplanet.Blockchain.BlockChain{`0})">
            <summary>
            Determines a right <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/>
            for a new <see cref="T:Libplanet.Blocks.Block`1"/> to be mined
            right after the given <paramref name="blockChain"/>.
            </summary>
            <param name="blockChain">Consecutive <see cref="T:Libplanet.Blocks.Block`1"/>s to be
            followed by a new <see cref="T:Libplanet.Blocks.Block`1"/> to be mined.</param>
            <returns>A right <see cref="P:Libplanet.Blocks.Block`1.Difficulty"/>
            for a new <see cref="T:Libplanet.Blocks.Block`1"/> to be mined.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxTransactionsBytes(System.Int64)">
            <summary>
            Gets the maximum length of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> in bytes.
            </summary>
            <param name="index">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            for which this constraint should apply.</param>
            <returns>The maximum length of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> in bytes
            to accept.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMinTransactionsPerBlock(System.Int64)">
            <summary>
            Gets the minimum number of <see cref="T:Libplanet.Tx.Transaction`1"/>s allowed for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="index">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            for which this constraint should apply.</param>
            <returns>The minimum number of <see cref="T:Libplanet.Tx.Transaction`1"/>s allowed for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/> can accept.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxTransactionsPerBlock(System.Int64)">
            <summary>
            Gets the maximum number of <see cref="T:Libplanet.Tx.Transaction`1"/>s allowed for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="index">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            for which this constraint should apply.</param>
            <returns>The maximum number of <see cref="T:Libplanet.Tx.Transaction`1"/>s allowed for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/> can accept.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxTransactionsPerSignerPerBlock(System.Int64)">
            <summary>
            Gets the maximum number of <see cref="T:Libplanet.Tx.Transaction`1"/>s allowed per signer for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="index">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            for which this constraint should apply.</param>
            <returns>The maximum number of <see cref="T:Libplanet.Tx.Transaction`1"/>s allowed per signer for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/> can accept.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMinBlockProtocolVersion(System.Int64)">
            <summary>
            Gets the minimum <see cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/> allowed for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="index">The <see cref="P:Libplanet.Blocks.Block`1.Index"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            for which this constraint should apply.</param>
            <returns>The minimum value for <see cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/> allowed for
            a valid <see cref="T:Libplanet.Blocks.Block`1"/>.</returns>
        </member>
        <member name="T:Libplanet.Blockchain.Policies.IStagePolicy`1">
            <summary>
            An interface to configure a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s strategy to deal with staged
            transactions.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <remarks>
            Every operation of an implementation of this <c>interface</c> must be thread-safe.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Stage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})">
            <summary>
            Stages a <paramref name="transaction"/>.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> that the stage belongs to.
            </param>
            <param name="transaction">The <seealso cref="T:Libplanet.Tx.Transaction`1"/> to be staged.</param>
            <returns><see langword="true"/> if staging was successful,
            <see langword="false"/> otherwise.</returns>
            <remarks>
            <para>
            This does not throw any exception regardless of whether <paramref name="transaction"/>
            was successfully staged or not.
            </para>
            <para>
            If the <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of <paramref name="transaction"/> is marked
            as ignored, <paramref name="transaction"/> will not be staged.
            </para>
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Unstage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <summary>
            Unstages a transaction <paramref name="id"/>.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> that the stage belongs to.
            </param>
            <param name="id">The <seealso cref="P:Libplanet.Tx.Transaction`1.Id"/> to unstage.</param>
            <returns><see langword="true"/> if unstaging was successful,
            <see langword="false"/> otherwise.</returns>
            <remarks>
            This does not throw any exception regardless of whether <paramref name="id"/> was
            successfully unstaged or not.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Ignore(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <summary>
            Marks given <paramref name="id"/> as ignored.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> that the stage belongs to.
            </param>
            <param name="id">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> to ignore.</param>
            <remarks>
            If the <see cref="T:Libplanet.Tx.Transaction`1"/> associated with <paramref name="id"/> is already
            staged, this also unstages the <see cref="T:Libplanet.Tx.Transaction`1"/>.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Ignores(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <summary>
            Checks if given <paramref name="id"/> is marked as ignored.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> that the stage belongs to.
            </param>
            <param name="id">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> to check.</param>
            <returns><see langword="true"/> if <paramref name="id"/> is marked as ignored,
            <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Get(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId,System.Boolean)">
            <summary>
            Retrieves a staged <see cref="T:Libplanet.Tx.Transaction`1"/> by its <paramref name="id"/>.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> that the stage belongs to.
            </param>
            <param name="id">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> to get.</param>
            <param name="filtered">Whether to filter masked staged <see cref="T:Libplanet.Tx.Transaction`1"/>s
            or not.  Set to <see langword="true"/> by default.</param>
            <returns>The staged <see cref="T:Libplanet.Tx.Transaction`1"/> associated with <paramref name="id"/>
            if found,  <see langword="null"/> otherwise.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.Iterate(Libplanet.Blockchain.BlockChain{`0},System.Boolean)">
            <summary>
            Enumerates all staged <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> that the stage belongs to.
            </param>
            <param name="filtered">Whether to filter masked staged <see cref="T:Libplanet.Tx.Transaction`1"/>s
            or not.  Set to <see langword="true"/> by default.</param>
            <returns>All staged transactions.  No ordering is guaranteed.</returns>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.IStagePolicy`1.GetNextTxNonce(Libplanet.Blockchain.BlockChain{`0},Libplanet.Address)">
            <summary>
            Calculates the next nonce according for given <paramref name="address"/>.
            </summary>
            <param name="blockChain">The <see cref="T:Libplanet.Blockchain.BlockChain`1"/> that the stage belongs to.
            </param>
            <param name="address">The <see cref="T:Libplanet.Address"/> to calculate the next nonce for.
            </param>
            <returns>The next appropriate nonce for <paramref name="address"/>.</returns>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.NullBlockPolicy`1.NativeTokens">
            <inheritdoc cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/>
        </member>
        <member name="T:Libplanet.Blockchain.Policies.VolatileStagePolicy`1">
            <summary>
            <para>
            An in memory implementation of the <see cref="T:Libplanet.Blockchain.Policies.IStagePolicy`1"/>.
            </para>
            <para>
            This implementation holds on to every unconfirmed <see cref="T:Libplanet.Tx.Transaction`1"/> except
            for the following reasons:
            <list type="bullet">
                <item>
                    <description>A <see cref="T:Libplanet.Tx.Transaction`1"/> has been specifically marked to
                    be ignored due to <see cref="T:Libplanet.Tx.Transaction`1"/> not being valid.</description>
                </item>
                <item>
                    <description>A <see cref="T:Libplanet.Tx.Transaction`1"/> has expired due to its staleness.
                    </description>
                </item>
            </list>
            </para>
            <para>
            Additionally, any <see cref="T:Libplanet.Tx.Transaction`1"/> with a lower nonce than that of returned by
            the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> is masked and filtered by default.
            </para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            the <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.#ctor">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Policies.VolatileStagePolicy`1"/> instance.
            By default, <see cref="P:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Lifetime"/> is set to 10 minutes.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.#ctor(System.TimeSpan)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Policies.VolatileStagePolicy`1"/> instance.
            </summary>
            <param name="lifetime">Volatilizes staged transactions older than this
            <see cref="T:System.TimeSpan"/>.  See also <see cref="P:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Lifetime"/>.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Lifetime">
            <summary>
            Lifespan for <see cref="T:Libplanet.Tx.Transaction`1"/>s.  Any <see cref="T:Libplanet.Tx.Transaction`1"/> older
            than this <see cref="T:System.TimeSpan"/> will be considered expired.
            </summary>
            <remarks>
            Expired <see cref="T:Libplanet.Tx.Transaction`1"/>s cannot be staged.
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Stage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.Transaction{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Unstage(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Ignore(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Ignores(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Get(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.Iterate(Libplanet.Blockchain.BlockChain{`0},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.GetNextTxNonce(Libplanet.Blockchain.BlockChain{`0},Libplanet.Address)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Blockchain.Policies.VolatileStagePolicy`1.GetInner(Libplanet.Blockchain.BlockChain{`0},Libplanet.Tx.TxId,System.Boolean)">
            <remarks>
            It has been intended to avoid recursive lock, hence doesn't hold any synchronous scope.
            Therefore, we should manage the lock from its caller side.
            </remarks>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1">
            <summary>
            An <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> that invokes its callbacks.
            In other words, this is an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> version of
            <see cref="T:Libplanet.Blockchain.Renderers.AnonymousRenderer`1"/>.
            <para>This class is useful when you want an one-use ad-hoc implementation (i.e., Java-style
            anonymous class) of <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> interface.</para>
            </summary>
            <example>
            With object initializers, you can easily make an one-use action renderer:
            <code><![CDATA[
            var actionRenderer = new AnonymousActionRenderer<ExampleAction>
            {
                ActionRenderer = (action, context, nextStates) =>
                {
                    // Implement RenderAction() here.
                };
            };
            ]]></code>
            </example>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionUnrenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionErrorRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.ActionErrorUnrenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.BlockEndRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.AnonymousRenderer`1">
            <summary>
            A renderer that invokes its callbacks.
            <para>This class is useful when you want an one-use ad-hoc implementation (i.e., Java-style
            anonymous class) of <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> interface.</para>
            </summary>
            <example>
            With object initializers, you can easily make an one-use renderer:
            <code>
            var renderer = new AnonymousRenderer&lt;ExampleAction&gt;
            {
                BlockRenderer = (oldTip, newTip) =>
                {
                    // Implement RenderBlock() here.
                };
            };
            </code>
            </example>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.BlockRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.ReorgRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.ReorgEndRenderer">
            <summary>
            A callback function to be invoked together with
            <see cref="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AnonymousRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1">
            <summary>
            A middleware to make action render events to satisfy transactions' atomicity.
            <para>Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance and filters out render events
            made by unsuccessful transactions (i.e., transactions with one or more exception-throwing
            actions).</para>
            </summary>
            <remarks>The wrapped <see cref="P:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.ActionRenderer"/> will not receive any
            <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> and
            <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> events except for block actions,
            which do not belong to any transactions.
            </remarks>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IActionRenderer{`0})">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1"/> instance decorating the given
            <paramref name="actionRenderer"/>.
            </summary>
            <param name="actionRenderer">The inner action renderer which has the <em>actual</em>
            implementations and expects to receive no <see cref="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>/<see
            cref="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> events.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.ActionRenderer">
            <summary>
            The inner action renderer which has the <em>actual</em> implementations and expects to
            receive no <see cref="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>/<see cref="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> events.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1">
            <summary>
            Exception thrown by <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/>.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1.#ctor(System.String,System.Collections.Generic.IReadOnlyList{Libplanet.Blockchain.Renderers.Debug.RenderRecord{`0}})">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/> instance.
            </summary>
            <param name="message">The exception message string.</param>
            <param name="records">Recorded render events.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1.Records">
            <summary>
            Recorded render events.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.InvalidRenderException`1.Message">
            <inheritdoc cref="P:System.Exception.Message"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1">
            <summary>
            Records every render events.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.#ctor">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1"/> instance.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.Records">
            <summary>
            The list of recorded render events.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.ResetRecords">
            <summary>
            Empties the render event <see cref="P:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.Records"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1">
            <summary>
            A render event represented by <see cref="T:Libplanet.Blockchain.Renderers.Debug.RecordingActionRenderer`1"/>.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Index">
            <summary>
            The ordinal number of the render event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.StackTrace">
            <summary>
            The stack trace of the render event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase">
            <summary>
            Represents an action render/unrender event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Action">
            <summary>
            The rendered action.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Context">
            <summary>
            The action evaluation context.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Render">
            <summary>
            Whether it is not an unrender event, but a render event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.Unrender">
            <summary>
            Whether it is a render event, but an unrender event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionBase.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess">
            <summary>
            Represents a succeeded action render/unrender event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess.#ctor(System.Int64,System.String,Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta,System.Boolean)">
            <summary>
            Creates a succeeded action render/unrender event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="action">The rendered action.</param>
            <param name="context">The action evaluation context.</param>
            <param name="nextStates">The resulting states after the action is evaluated.</param>
            <param name="unrender">Whether it is an unrender event.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess.NextStates">
            <summary>
            The resulting states after the action is evaluated.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionSuccess.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError">
            <summary>
            Represents a failed action render/unrender event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError.#ctor(System.Int64,System.String,Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception,System.Boolean)">
            <summary>
            Creates a failed action render/unrender event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="action">The rendered action.</param>
            <param name="context">The action evaluation context.</param>
            <param name="exception">The exception thrown by the action.</param>
            <param name="unrender">Whether it is an unrender event.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError.Exception">
            <summary>
            The exception thrown by the action.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ActionError.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase">
            <summary>
            Represents a block/reorg event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.OldTip">
            <summary>
            The tip before update.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.NewTip">
            <summary>
            The tip after update.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.Begin">
            <summary>
            Whether it is not an <c>End</c> event.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.End">
            <summary>
            Whether it is an <c>End</c> event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Block">
            <summary>
            Represents a block event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Block.#ctor(System.Int64,System.String,Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},System.Boolean)">
            <summary>
            Creates a block event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="oldTip">The tip before update.</param>
            <param name="newTip">The tip after update.</param>
            <param name="end">Whether it is an <c>End</c> event.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Block.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg">
            <summary>
            Represents a reorg event.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg.#ctor(System.Int64,System.String,Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},System.Boolean)">
            <summary>
            Creates a reorg event record.
            </summary>
            <param name="index">The ordinal number of the render event.</param>
            <param name="stackTrace">The stack trace of the render event.</param>
            <param name="oldTip">The tip before update.</param>
            <param name="newTip">The tip after update.</param>
            <param name="branchpoint">The topmost common ancestor between
            <paramref name="oldTip"/> and <paramref name="newTip"/>.</param>
            <param name="end">Whether it is an <c>End</c> event.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg.Branchpoint">
            <summary>
            The topmost common ancestor between <see cref="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.OldTip"/>
            and <see cref="P:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.BlockBase.NewTip"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.Reorg.ToString">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.Debug.RenderRecord`1.ToString"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1">
            <summary>
            Validates if rendering events are in the correct order according to the documented automata
            (see also the docs for <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> and <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/>)
            using profiling-guided analysis.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.#ctor(System.Action{Libplanet.Blockchain.Renderers.Debug.InvalidRenderException{`0}})">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1"/> instance.
            </summary>
            <param name="onError">An optional event handler which is triggered when invalid
            render events occur.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.BlockChain">
            <summary>
            The chain that publishes the render events.  More stricter validations are conducted
            if it's configured.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.Debug.ValidatingActionRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1">
            <summary>
            An <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> version of <see cref="T:Libplanet.Blockchain.Renderers.DelayedRenderer`1"/>.
            <para>Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance and delays the events until
            blocks are <em>confirmed</em> the certain number of blocks.  When blocks are recognized
            the delayed events relevant to these blocks are relayed to the decorated
            <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/>.</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IStore store = GetStore();
            IBlockPolicy<ExampleAction> policy = GetPolicy();
            IActionRenderer<ExampleAction> actionRenderer = new SomeActionRenderer();
            // Wraps the actionRenderer with DelayedActionRenderer; the SomeActionRenderer instance
            // becomes to receive event messages only after the relevent blocks are confirmed
            // by 3+ blocks.
            actionRenderer = new DelayedActionRenderer<ExampleAction>(
               actionRenderer,
               policy,
               store,
               confirmations: 3);
            // You must pass the same policy & store to the BlockChain<T>() constructor:
            var chain = new BlockChain<ExampleAction>(
               ...,
               policy: policy,
               store: store,
               renderers: new[] { actionRenderer });
            ]]></code>
            </example>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IActionRenderer{`0},System.Collections.Generic.IComparer{Libplanet.Blocks.IBlockExcerpt},Libplanet.Store.IStore,System.Int32,System.Int64)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1"/> instance decorating the given
            <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives delayed events.</param>
            <param name="canonicalChainComparer">The same canonical chain comparer to
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.</param>
            <param name="store">The same store to what <see cref="T:Libplanet.Blockchain.BlockChain`1"/> uses.</param>
            <param name="confirmations">The required number of confirmations to recognize a block.
            See also the <see cref="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Confirmations"/> property.</param>
            <param name="reorgResistantHeight">Configures the height of blocks to maintain the
            <see cref="T:Libplanet.Action.ActionEvaluation"/> buffer. Buffered <see cref="T:Libplanet.Action.ActionEvaluation"/>s
            that belong to blocks older than this height from the tip are gone.
            If zero, which is a default value, is passed the buffer is not cleared.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.ActionRenderer">
            <summary>
            The inner action renderer which has the <em>actual</em> implementations and receives
            delayed events.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.LocateBlockPath(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Lists all descendants from <paramref name="lower"/> (exclusive) to
            <paramref name="upper"/> (inclusive).
            </summary>
            <param name="lower">The block to get its descendants (excluding it).</param>
            <param name="upper">The block to get its ancestors (including it).</param>
            <returns>Block hashes from <paramref name="lower"/> to <paramref name="upper"/>.
            Lower block hashes go first, and upper block hashes go last.
            Does not contain <paramref name="lower"/>'s hash but <paramref name="upper"/>'s one.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="upper"/> block's index
            is not greater than <paramref name="lower"/> block's index.</exception>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1.OnTipChanged(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.OnTipChanged(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.DelayedRenderer`1">
            <summary>
            Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> instance and delays the events until blocks
            are <em>confirmed</em> the certain number of blocks.  When blocks are recognized
            the delayed events relevant to these blocks are relayed to the decorated
            <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IStore store = GetStore();
            IBlockPolicy<ExampleAction> policy = GetPolicy();
            IRenderer<ExampleAction> renderer = new SomeRenderer();
            // Wraps the renderer with DelayedRenderer; the SomeRenderer instance becomes to receive
            // event messages only after the relevent blocks are confirmed by 3+ blocks.
            renderer = new DelayedRenderer<ExampleAction>(renderer, policy, store, confirmations: 3);
            // You must pass the same policy & store to the BlockChain<T>() constructor:
            var chain = new BlockChain<ExampleAction>(
                ...,
                policy: policy,
                store: store,
                renderers: new[] { renderer });
            ]]></code>
            </example>
            <remarks>Since <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> is a subtype of <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            <see cref="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},System.Collections.Generic.IComparer{Libplanet.Blocks.IBlockExcerpt},Libplanet.Store.IStore,System.Int32)"/>
            constructor can take an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance as well.
            However, even it takes an action renderer, action-level fine-grained events won't hear.
            For action renderers, please use <see cref="T:Libplanet.Blockchain.Renderers.DelayedActionRenderer`1"/> instead.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},System.Collections.Generic.IComparer{Libplanet.Blocks.IBlockExcerpt},Libplanet.Store.IStore,System.Int32)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.DelayedRenderer`1"/> instance decorating the given
            <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives delayed events.</param>
            <param name="canonicalChainComparer">The same canonical chain comparer to
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.</param>
            <param name="store">The same store to what <see cref="T:Libplanet.Blockchain.BlockChain`1"/> uses.</param>
            <param name="confirmations">The required number of confirmations to recognize a block.
            It must be greater than zero (note that zero <paramref name="confirmations"/> mean
            nothing is delayed so that it is equivalent to the bare <paramref name="renderer"/>).
            See also the <see cref="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Confirmations"/> property.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the argument
            <paramref name="confirmations"/> is not greater than zero.</exception>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Renderer">
            <summary>
            The inner renderer which has the <em>actual</em> implementations and receives delayed
            events.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.CanonicalChainComparer">
            <summary>
            The same canonical chain comparer to <see cref="P:Libplanet.Blockchain.BlockChain`1.Policy"/>.
            </summary>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Store">
            <summary>
            The same store to what <see cref="T:Libplanet.Blockchain.BlockChain`1"/> uses.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Confirmations">
            <summary>
            The required number of confirmations to recognize a block.
            <para>For example, the required confirmations are 2, the block #N is recognized after
            the block #N+1 and the block #N+2 are discovered.</para>
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Tip">
            <summary>
            The <em>recognized</em> topmost block.  If not enough blocks are discovered yet,
            this property can be <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Logger">
            <summary>
            The logger to record internal state changes.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.DelayedRenderer`1.OnTipChanged(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            The callback method which is invoked when the new <see cref="P:Libplanet.Blockchain.Renderers.DelayedRenderer`1.Tip"/> is recognized and
            changed.
            </summary>
            <param name="oldTip">The previously recognized topmost block.</param>
            <param name="newTip">The topmost block recognized this time.</param>
            <param name="branchpoint">A branchpoint between <paramref name="oldTip"/> and
            <paramref name="newTip"/> if the tip change is a reorg.
            Otherwise <see langword="null"/>.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.IActionRenderer`1">
            <summary>
            Listens state changes of every step of actions, besides blocks,
            on a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            If you need more fine-grained events than <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            implement this interface instead.
            <para>The invocation order of methods for each <see cref="T:Libplanet.Blocks.Block`1"/> are:</para>
            <list type="number">
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
            (one time)</description></item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
            &amp; <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> (zero or more
            times)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)
            </description></item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
            &amp; <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> (zero or more
            times)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
            (one time)</description></item>
            </list>
            </summary>
            <remarks>Although <see cref="T:Libplanet.Tx.Transaction`1"/>s affect the states in
            the <see cref="T:Libplanet.Store.IStateStore"/> all or nothing at all (i.e., atomically),
            <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> receives all action-related events
            (<see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>/<see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>/<see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"
            />/<see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>) <em>immediately</em> without buffering,
            which means actions are rendered <em>even before</em> whether there are any actions throwing
            an exception in the same transaction is determined.  In other words, for <see
            cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/>s, it is not guaranteed that actions in a transaction are atomic.
            <para>If your action renderer expects to receive only render events about actions belonging
            successful transactions, wrap your action renderer with
            <see cref="T:Libplanet.Blockchain.Renderers.AtomicActionRenderer`1"/>.</para>
            </remarks>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <summary>
            Does things that should be done right after an <paramref name="action"/>
            is executed and applied to the blockchain.
            </summary>
            <param name="action">An executed action.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.  For the states after this action executed,
            use the <paramref name="nextStates"/> argument instead.</param>
            <param name="nextStates">The states right <em>after</em> this action executed,
            which means it is equivalent to the states <paramref name="action"/>'s
            <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method returned.</param>
            <remarks>
            It is guaranteed to be called only once for an <paramref name="action"/>,
            and only after applied to the blockchain, unless an exception is thrown during executing
            the <paramref name="action"/> (in that case <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> is called instead) or
            once the <paramref name="action"/> has been unrendered.
            <para>Also note that this method is invoked after <see
            cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> method is called
            (where its second parameter <c>newTip</c> contains a transaction the <paramref
            name="action"/> belongs to).</para>
            <para>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</para>
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <summary>
            Does things that should be undone right after the given <paramref name="action"/> is
            invalidated (mostly due to reorg, i.e., a block which the action has belonged to becomes
            considered stale).
            <para>This method takes the equivalent arguments to <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/> method.</para>
            </summary>
            <param name="action">A stale action.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.  For the states after this action executed,
            use the <paramref name="nextStates"/> argument instead.</param>
            <param name="nextStates">The states right <em>after</em> this action executed,
            which means it is equivalent to the states <paramref name="action"/>'s
            <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method returned.</param>
            <remarks>As a rule of thumb, this should be the inverse of
            <see cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/> method
            with redrawing the graphics on the display at the finish.</remarks>
            <remarks>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <summary>
            Does the similar things to <see cref=
            "M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>, except that this method
            is invoked when <paramref name="action"/> has terminated with an exception.
            </summary>
            <param name="action">An action which threw an exception during execution.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.</param>
            <param name="exception">The exception thrown during executing the <paramref
            name="action"/>.</param>
            <remarks>
            Also note that this method is invoked after <see
            cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> method is called
            (where its second parameter <c>newTip</c> contains a transaction the <paramref
            name="action"/> belongs to).
            <para>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</para>
            </remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <summary>
            Does the similar things to <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>, except that
            this method is invoked when <paramref name="action"/> has terminated with an exception.
            <para>This method takes the equivalent arguments to <see
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/> method.</para>
            </summary>
            <param name="action">An action which threw an exception during execution.</param>
            <param name="context">The equivalent context object to an object passed to
            the <paramref name="action"/>'s <see cref="M:Libplanet.Action.IAction.Execute(Libplanet.Action.IActionContext)"/> method.
            That means <see cref="P:Libplanet.Action.IActionContext.PreviousStates"/> are the states right
            <em>before</em> this action executed.</param>
            <param name="exception">The exception thrown during executing the <paramref
            name="action"/>.</param>
            <remarks>The reason why the parameter <paramref name="action"/> takes
            <see cref="T:Libplanet.Action.IAction"/> instead of <typeparamref name="T"/> is because it can take
            block actions (<see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) besides transaction
            actions (<see cref="P:Libplanet.Tx.Transaction`1.Actions"/>).</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right all actions in a new <see cref="T:Libplanet.Blocks.Block`1"/> are
            rendered.
            </summary>
            <remarks>It is guaranteed to be called only once for a block.</remarks>
            <param name="oldTip">The previous <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
            <param name="newTip">The current <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.IRenderer`1">
            <summary>
            Listens state changes on a <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            <para>Usually, implementations of this interface purpose to update the in-memory game states
            (if exist), or send a signal to the UI thread (usually the main thread) so that the graphics
            on the display is redrawn.</para>
            <para>The invocation order of methods for each <see cref="T:Libplanet.Blocks.Block`1"/> are:</para>
            <list type="number">
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)
            </description></item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)</description>
            </item>
            <item><description><see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> (one time)
            </description></item>
            </list>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right after a new <see cref="T:Libplanet.Blocks.Block`1"/> is appended to
            a <see cref="T:Libplanet.Blockchain.BlockChain`1"/> (so that its <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> has changed).
            </summary>
            <remarks>It is guaranteed to be called only once for a block, and only after applied to
            the blockchain, unless it has been stale due to reorg (for that case, <see
            cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> is called in advance).</remarks>
            <param name="oldTip">The previous <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
            <param name="newTip">The current <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/>.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right before reorg happens to a <see
            cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <remarks>For every call to this method, calls to
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> and
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})" /> methods with the same
            <paramref name="newTip"/> is made too.  Note that this method is guaranteed to be called
            before <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> method for the same
            <paramref name="newTip"/>.</remarks>
            <param name="oldTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> right before reorg.</param>
            <param name="newTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> after reorg.</param>
            <param name="branchpoint">The highest common <see cref="T:Libplanet.Blocks.Block`1"/> between
            <paramref name="oldTip"/> and <paramref name="newTip"/>.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Does things that should be done right after reorg happens to a <see
            cref="T:Libplanet.Blockchain.BlockChain`1"/>.
            </summary>
            <remarks>Note that this method is guaranteed to be called after
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> and
            <see cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/> methods for the same
            <paramref name="newTip"/>.</remarks>
            <param name="oldTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> right before reorg.</param>
            <param name="newTip">The <see cref="P:Libplanet.Blockchain.BlockChain`1.Tip"/> after reorg.</param>
            <param name="branchpoint">The highest common <see cref="T:Libplanet.Blocks.Block`1"/> between
            <paramref name="oldTip"/> and <paramref name="newTip"/>.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1">
            <summary>
            Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> so that all event messages are logged.
            In other words, this is an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> version of
            <see cref="T:Libplanet.Blockchain.Renderers.LoggedRenderer`1"/>.
            <para>Every single event message causes two log messages: one is logged <em>before</em>
            rendering, and other one is logged <em>after</em> rendering.  If any exception is thrown
            it is also logged with the log level <see cref="F:Serilog.Events.LogEventLevel.Error"/> (regardless of
            <see cref="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Level"/> configuration).</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IActionRenderer<ExampleAction> actionRenderer = new SomeActionRenderer();
            // Wraps the action renderer with LoggedActionRenderer:
            actionRenderer = new LoggedActionRenderer<ExampleAction>(
                actionRenderer,
                Log.Logger,
                LogEventLevel.Information,
            );
            ]]></code>
            </example>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IActionRenderer{`0},Serilog.ILogger,Serilog.Events.LogEventLevel)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1"/> instance which decorates the given
            action <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The actual action renderer to forward all event messages to and
            actually render things.</param>
            <param name="logger">The logger to write log messages to.  Note that all log messages
            this decorator writes become in the context of the <paramref name="renderer"/>'s
            type (with the context property <c>SourceContext</c>).</param>
            <param name="level">The log event level.  All log messages become this level.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.ActionRenderer">
            <summary>
            The inner action renderer to forward all event messages to and actually render things.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.LoggedRenderer`1">
            <summary>
            Decorates an <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> so that all event messages are logged.
            <para>Every single event message causes two log messages: one is logged <em>before</em>
            rendering, and other one is logged <em>after</em> rendering.  If any exception is thrown
            it is also logged with the log level <see cref="F:Serilog.Events.LogEventLevel.Error"/> (regardless of
            <see cref="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Level"/> configuration).</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code>
            IRenderer&lt;ExampleAction&gt; renderer = new SomeRenderer();
            // Wraps the renderer with LoggedRenderer:
            renderer = new LoggedRenderer&lt;ExampleAction&gt;(
                renderer,
                Log.Logger,
                LogEventLevel.Information,
            );
            </code>
            </example>
            <remarks>Since <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> is a subtype of <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/>,
            <see cref="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},Serilog.ILogger,Serilog.Events.LogEventLevel)"/> constructor can take
            an <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance as well.  However, even it takes an action
            renderer, action-level fine-grained events will not be logged.  For action renderers,
            please use <see cref="T:Libplanet.Blockchain.Renderers.LoggedActionRenderer`1"/> instead.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},Serilog.ILogger,Serilog.Events.LogEventLevel)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blockchain.Renderers.LoggedRenderer`1"/> instance which decorates the given
            <paramref name="renderer"/>.
            </summary>
            <param name="renderer">The actual renderer to forward all event messages to and actually
            render things.</param>
            <param name="logger">The logger to write log messages to.  Note that all log messages
            this decorator writes become in the context of the <paramref name="renderer"/>'s
            type (with the context property <c>SourceContext</c>).</param>
            <param name="level">The log event level.  All log messages become this level.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Renderer">
            <summary>
            The inner renderer to forward all event messages to and actually render things.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Level">
            <summary>
            The log event level.  All log messages become this level.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Logger">
            <summary>
            The logger to write log messages to.  Note that all log messages this decorator writes
            become in the context of the <see cref="P:Libplanet.Blockchain.Renderers.LoggedRenderer`1.Renderer"/>'s type (with the context
            property <c>SourceContext</c>).
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.LoggedRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1">
            <summary>
            Decorates a <see cref="T:Libplanet.Blockchain.Renderers.IActionRenderer`1"/> instance and lets all rendering events be
            non-blocking.
            <para>Every method call on the renderer will immediately return and the rendering
            will be performed in a background thread.  Note that the order of render events is
            still guaranteed.  In other words, a later event never arrives before events earlier
            than it.</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IActionRenderer<ExampleAction> actionRenderer = new SomeActionRenderer();
            // Wraps the actionRenderer with NonblockActionRenderer; the SomeActionRenderer instance
            // becomes to receive event messages in NonblockActionRenderer's backround thread:
            actionRenderer = new NonblockActionRenderer<ExampleAction>(
               actionRenderer,
               queue: 1024,
               fullFallback: droppedEvent => ShowError("Too many rendering events in a short time."));
            /// ...
            // Should be disposed when no longer needed:
            actionRenderer.Dispose();
            ]]></code>
            </example>
            <remarks>As rendering events become performed in a background thread instead of the main
            thread, some graphics/UI drawings might be disallowed.  In such case, communicate with the
            main thread through <a
            href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/"
            >producer/consumer channels</a>.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IActionRenderer{`0},System.Int32,Libplanet.Blockchain.Renderers.NonblockRenderer{`0}.FullMode)">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1"/> decorating the given
            <paramref name="renderer"/> instance.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives events in a background thread.</param>
            <param name="queueSize">The size of the internal event queue.</param>
            <param name="fullMode">Specifies the behavior when the internal event queue is full so
            that no more event can be added.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IActionRenderer{`0},System.Int32,Libplanet.Blockchain.Renderers.NonblockRenderer{`0}.FullFallback)">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1"/> decorating the given
            <paramref name="renderer"/> instance.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives events in a background thread.</param>
            <param name="queueSize">The size of the internal event queue.</param>
            <param name="fullFallback">Specifies the custom behavior when the internal event
            queue is full so that no more event can be added.</param>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.ActionRenderer">
            <summary>
            The inner action renderer which has the <em>actual</em> implementations and receives
            events.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderAction(Libplanet.Action.IAction,Libplanet.Action.IActionContext,Libplanet.Action.IAccountStateDelta)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)">
            <inheritdoc
            cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.UnrenderActionError(Libplanet.Action.IAction,Libplanet.Action.IActionContext,System.Exception)"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IActionRenderer`1.RenderBlockEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.NonblockRenderer`1">
            <summary>
            Decorates a <see cref="T:Libplanet.Blockchain.Renderers.IRenderer`1"/> instance and lets all rendering events be
            non-blocking.
            <para>Every method call on the renderer will immediately return and the rendering
            will be performed in a background thread.  Note that the order of render events is
            still guaranteed.  In other words, a later event never arrives before events earlier
            than it.</para>
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <example>
            <code><![CDATA[
            IRenderer<ExampleAction> renderer = new SomeRenderer();
            // Wraps the renderer with NonblockRenderer; the SomeRenderer instance becomes to receive
            // event messages in NonblockRenderer's backround thread:
            renderer = new NonblockRenderer<ExampleAction>(
               renderer,
               queue: 1024,
               fullFallback: droppedEvent => ShowError("Too many rendering events in a short time."));
            /// ...
            // Should be disposed when no longer needed:
            renderer.Dispose();
            ]]></code>
            </example>
            <remarks>As rendering events become performed in a background thread instead of the main
            thread, some graphics/UI drawings might be disallowed.  In such case, communicate with the
            main thread through <a
            href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/"
            >producer/consumer channels</a>.</remarks>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},System.Int32,Libplanet.Blockchain.Renderers.NonblockRenderer{`0}.FullMode)">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Blockchain.Renderers.NonblockRenderer`1"/> decorating the given
            <paramref name="renderer"/> instance.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives events in a background thread.</param>
            <param name="queueSize">The size of the internal event queue.</param>
            <param name="fullMode">Specifies the behavior when the internal event queue is full so
            that no more event can be added.</param>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockRenderer`1.#ctor(Libplanet.Blockchain.Renderers.IRenderer{`0},System.Int32,Libplanet.Blockchain.Renderers.NonblockRenderer{`0}.FullFallback)">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Blockchain.Renderers.NonblockRenderer`1"/> decorating the given
            <paramref name="renderer"/> instance.
            </summary>
            <param name="renderer">The renderer to decorate which has the <em>actual</em>
            implementations and receives events in a background thread.</param>
            <param name="queueSize">The size of the internal event queue.</param>
            <param name="fullFallback">Specifies the custom behavior when the internal event
            queue is full so that no more event can be added.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.NonblockRenderer`1.FullFallback">
            <summary>
            Customizes behavior when the internal event queue is full so that no more event
            can be added.
            </summary>
            <param name="droppedEvent">The render event failed to be queued.</param>
        </member>
        <member name="T:Libplanet.Blockchain.Renderers.NonblockRenderer`1.FullMode">
            <summary>
            Specifies the behavior when the internal event queue is full so that no more event
            can be added.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.Renderers.NonblockRenderer`1.FullMode.DropOldest">
            <summary>
            Drops the oldest event when the queue is full.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.Renderers.NonblockRenderer`1.FullMode.DropNewest">
            <summary>
            Drops the newest event when the queue is full.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.Renderers.NonblockRenderer`1.Renderer">
            <summary>
            The inner renderer which has the <em>actual</em> implementations and receives events.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockRenderer`1.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderBlock(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorg(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:Libplanet.Blockchain.Renderers.IRenderer`1.RenderReorgEnd(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})"/>
        </member>
        <member name="M:Libplanet.Blockchain.Renderers.NonblockRenderer`1.Queue(System.Action)">
            <summary>
            Queues the callback to be executed in the worker thread.
            </summary>
            <param name="action">The callback to be executed in the worker thread.</param>
        </member>
        <member name="T:Libplanet.Blockchain.StateCompleter`1">
            <summary>
            A delegate to be called when <see cref="M:Libplanet.Blockchain.BlockChain`1.GetState(Libplanet.Address,System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Blockchain.StateCompleter{`0})"/> method encounters a block
            having incomplete dirty states. <see cref="M:Libplanet.Blockchain.BlockChain`1.GetState(Libplanet.Address,System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Blockchain.StateCompleter{`0})"/> method returns this
            delegate's return value instead for such case.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
            <param name="blockChain">The blockchain to query.</param>
            <param name="blockHash">The hash of a block to lacks its dirty states.</param>
            <param name="addresses">The addresses of states to look up.</param>
            <returns>Complement states associated to the specified <paramref name="addresses"/>.
            The associated values are ordered in the same way to the corresponding
            <paramref name="addresses"/>.  Absent states are represented as <see langword="null"/>.
            </returns>
            <seealso cref="T:Libplanet.Blockchain.StateCompleters`1"/>
        </member>
        <member name="T:Libplanet.Blockchain.StateCompleters`1">
            <summary>
            Predefined built-in state completers that satisfy <see cref="T:Libplanet.Blockchain.StateCompleter`1"/> delegate.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match to
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleters`1.Recalculate">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleters`1.ComplementAll">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementAll"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleters`1.ComplementLatest">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementLatest"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleters`1.Reject">
            <summary>
            Rejects to complement incomplete states and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.StateCompleterSet`1">
            <summary>
            Groups three kinds of state completers, <see cref="T:Libplanet.Blockchain.StateCompleters`1"/>,
            <see cref="T:Libplanet.Blockchain.FungibleAssetStateCompleters`1"/>, and
            <see cref="T:Libplanet.Blockchain.TotalSupplyStateCompleters`1"/>.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate">
            <summary>
            Recalculates <i>all</i> block states and complements missing states including and upto
            a given hash starting from the genesis block.
            </summary>
            <remarks>
            Complemented states are permanently stored.
            </remarks>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementAll">
            <summary>
            Recalculates and complements all <i>missing</i> block states including and upto
            a given hash starting from the genesis block.
            </summary>
            <remarks>
            Complemented states are permanently stored.
            </remarks>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementLatest">
            <summary>
            Recalculates and complements all <i>missing</i> block states including and upto
            a given hash starting from the last known states in state storage before
            the given hash if the states are missing for the given hash.
            </summary>
            <remarks>
            Complemented states are permanently stored.
            </remarks>
        </member>
        <member name="F:Libplanet.Blockchain.StateCompleterSet`1.Reject">
            <summary>
            Rejects to complement incomplete state and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.StateCompleterSet`1.StateCompleter">
            <summary>
            Holds a <see cref="T:Libplanet.Blockchain.StateCompleter`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.StateCompleterSet`1.FungibleAssetStateCompleter">
            <summary>
            Holds a <see cref="T:Libplanet.Blockchain.FungibleAssetStateCompleter`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.StateCompleterSet`1.TotalSupplyStateCompleter">
            <summary>
            Holds a <see cref="T:Libplanet.Blockchain.TotalSupplyStateCompleter`1"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blockchain.StateCompleterSet`1.ValidatorSetStateCompleter">
            <summary>
            Holds a <see cref="T:Libplanet.Blockchain.ValidatorSetStateCompleter`1"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.TotalDifficultyComparer">
            <summary>
            The default canonical chain comparer (which purpose to be a <see
            cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>).
            <para>The chain which has the most <see cref="P:Libplanet.Blocks.Block`1.TotalDifficulty"/> is considered
            the greatest, i.e., canonical chain.</para>
            </summary>
            <remarks>Although this compares blocks' total difficulty, if two blocks have different
            protocol version, it always consider the higher version greater.</remarks>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>
            <seealso cref="T:Libplanet.Blocks.IBlockExcerpt"/>
        </member>
        <member name="M:Libplanet.Blockchain.TotalDifficultyComparer.#ctor">
            <summary>
            Creates a <see cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/> instance.
            </summary>
        </member>
        <member name="M:Libplanet.Blockchain.TotalDifficultyComparer.Compare(Libplanet.Blocks.IBlockExcerpt,Libplanet.Blocks.IBlockExcerpt)">
            <inheritdoc cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>
        </member>
        <member name="T:Libplanet.Blockchain.TotalSupplyStateCompleter`1">
            <summary>
            A delegate to be called when <see cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetTotalSupply(Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.TotalSupplyStateCompleter{`0})"/>
            method encounters a block having incomplete dirty states.
            <see cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetTotalSupply(Libplanet.Assets.Currency,Libplanet.Blocks.BlockHash,Libplanet.Blockchain.TotalSupplyStateCompleter{`0})"/> method returns this delegate's
            return value instead for such case.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            the type parameter of <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</typeparam>
            <param name="blockChain">The blockchain to query.</param>
            <param name="blockHash">The hash of a block lacking its dirty states.</param>
            <param name="currency">The currency to query.</param>
            <returns>The total supply value of <paramref name="currency"/> in
            <see cref="T:Libplanet.Assets.FungibleAssetValue"/>.</returns>
            <seealso cref="T:Libplanet.Blockchain.FungibleAssetStateCompleters`1"/>
        </member>
        <member name="T:Libplanet.Blockchain.TotalSupplyStateCompleters`1">
            <summary>
            Predefined built-in state completers that satisfy the
            <see cref="T:Libplanet.Blockchain.TotalSupplyStateCompleter`1"/> delegate.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type. It should match the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.TotalSupplyStateCompleters`1.Recalculate">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.TotalSupplyStateCompleters`1.ComplementAll">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementAll"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.TotalSupplyStateCompleters`1.ComplementLatest">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementLatest"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.TotalSupplyStateCompleters`1.Reject">
            <summary>
            Rejects to complement incomplete state and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blockchain.ValidatorSetStateCompleter`1">
            <summary>
            A delegate to be called when <see cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetValidatorSet(Libplanet.Blocks.BlockHash,Libplanet.Blockchain.ValidatorSetStateCompleter{`0})"/>
            method encounters a block having incomplete dirty states.
            <see cref="M:Libplanet.Blockchain.IBlockChainStates`1.GetValidatorSet(Libplanet.Blocks.BlockHash,Libplanet.Blockchain.ValidatorSetStateCompleter{`0})"/> method returns this delegate's
            return value instead for such case.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            the type parameter of <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</typeparam>
            <param name="blockChain">The blockchain to query.</param>
            <param name="blockHash">The hash of a block lacking its dirty states.</param>
            <returns>The <see cref="T:Libplanet.Consensus.ValidatorSet"/> of the block.</returns>
            <seealso cref="T:Libplanet.Blockchain.ValidatorSetStateCompleters`1"/>
        </member>
        <member name="T:Libplanet.Blockchain.ValidatorSetStateCompleters`1">
            <summary>
            Predefined built-in state completers that satisfy the
            <see cref="T:Libplanet.Blockchain.ValidatorSetStateCompleter`1"/> delegate.
            </summary>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type. It should match the
            <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blockchain.ValidatorSetStateCompleters`1.Recalculate">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.Recalculate"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.ValidatorSetStateCompleters`1.ComplementAll">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementAll"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.ValidatorSetStateCompleters`1.ComplementLatest">
            <summary>
            See <see cref="F:Libplanet.Blockchain.StateCompleterSet`1.ComplementLatest"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Blockchain.ValidatorSetStateCompleters`1.Reject">
            <summary>
            Rejects to complement incomplete state and throws
            an <see cref="T:Libplanet.Blockchain.IncompleteBlockStatesException"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.Block`1">
            <summary>
            The complete block including all block contents and done proof-of-work and action
            evaluation.
            </summary>
            <typeparam name="T">A class implementing <see cref="T:Libplanet.Action.IAction"/> to include.  This type
            parameter is aligned with <see cref="T:Libplanet.Tx.Transaction`1"/>'s type parameter.</typeparam>
        </member>
        <member name="F:Libplanet.Blocks.Block`1.CurrentProtocolVersion">
            <summary>
            The latest protocol version.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.#ctor(Libplanet.Blocks.IBlockHeader,System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}})">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.Block`1"/> instance by combining a block <paramref name="header"/>
            and <paramref name="transactions"/>.
            </summary>
            <param name="header">The block header.</param>
            <param name="transactions">The transactions to include.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockProtocolVersionException">Thrown when
            the <paramref name="header"/>'s <see cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
            is less than 0, or greater than <see cref="F:Libplanet.Blocks.BlockMetadata.CurrentProtocolVersion"/>,
            the latest known protocol version.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockIndexException">Thrown when the <paramref name="header"/>
            has a negative <see cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockDifficultyException">Thrown when
            the <paramref name="header"/>'s <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/> is negative.
            </exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTotalDifficultyException">Thrown when
            the <paramref name="header"/>'s <see cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/> is less
            than its <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when any tx signature is invalid or
            not signed by its signer.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxNonceException">Thrown when the same tx nonce is used by
            a signer twice or more, or a tx nonce is used without its previous nonce by a signer.
            Note that this validates only a block's intrinsic integrity between its transactions,
            but does not guarantee integrity between blocks.  Such validation needs to be conducted
            by <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxGenesisHashException">Thrown when transactions to set have
            inconsistent genesis hashes.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTxHashException">Thrown when the given block
            <paramref name="header"/>'s <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/> is not consistent with
            its <paramref name="transactions"/>.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException">Thrown when the given
            <paramref name="header"/> has an invalid
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/>.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockNonceException">Thrown when the given
            <paramref name="header"/>'s <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/> does not
            satisfy the required <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Difficulty"/>.</exception>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.#ctor(Libplanet.Blocks.PreEvaluationBlock{`0},System.ValueTuple{Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Nullable{System.Collections.Immutable.ImmutableArray{System.Byte}},Libplanet.Blocks.BlockHash})">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.Block`1"/> instance by combining
            a <paramref name="preEvaluationBlock"/>, its corresponding
            <paramref name="proof.StateRootHash.StateRootHash"/>, valid <paramref name="proof.Signature.Signature"/>,
            and correctly derived <paramref name="proof.Hash.Hash"/>.
            </summary>
            <param name="preEvaluationBlock">A pre-evaluation block.</param>
            <param name="proof">A triple of the state root hash, the block signature,
            and the block hash.</param>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Header">
            <summary>
            The <see cref="T:Libplanet.Blocks.BlockHeader"/> of the block.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.ProtocolVersion">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Hash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockExcerpt.Hash"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Signature">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockHeader.Signature"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.PreEvaluationHash">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.StateRootHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockHeader.StateRootHash"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Index">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Difficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.TotalDifficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Nonce">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Miner">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.PublicKey">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.PreviousHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Timestamp">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.TxHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Transactions">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockContent`1.Transactions"/>
        </member>
        <member name="P:Libplanet.Blocks.Block`1.Libplanet#Blocks#IBlockContent#Transactions">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockContent.Transactions"/>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.op_Equality(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Equivalent to <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <param name="left">A block.</param>
            <param name="right">Another block.</param>
            <returns><see langword="true"/> if two blocks are equal.
            Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.op_Inequality(Libplanet.Blocks.Block{`0},Libplanet.Blocks.Block{`0})">
            <summary>
            Negation of <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <param name="left">A block.</param>
            <param name="right">Another block.</param>
            <returns><see langword="true"/> if two blocks are different.
            Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.Equals(Libplanet.Blocks.Block{`0})">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.Blocks.Block`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Blocks.BlockContent`1">
            <summary>
            A block content without any proofs like nonce or hash.  This represents contents of a
            block that is not yet mined.
            </summary>
            <typeparam name="T">A class implementing <see cref="T:Libplanet.Action.IAction"/> to include.  This type
            parameter is aligned with <see cref="T:Libplanet.Tx.Transaction`1"/>'s type parameter.</typeparam>
            <remarks>Unlike other model types like <see cref="T:Libplanet.Blocks.Block`1"/> or
            <see cref="T:Libplanet.Tx.Transaction`1"/>, this type is mutable.</remarks>
        </member>
        <member name="M:Libplanet.Blocks.BlockContent`1.#ctor(Libplanet.Blocks.IBlockMetadata,System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}})">
            <summary>
            Creates a new <see cref="T:Libplanet.Blocks.BlockContent`1"/> instance filled with given
            <paramref name="metadata"/> and <paramref name="transactions"/>.
            </summary>
            <remarks>
            This creates a new instance of <see cref="T:Libplanet.Blocks.BlockMetadata"/> to check the validity
            of <paramref name="metadata"/>, hence throws any <see cref="T:System.Exception"/>s that may
            arise from a <see cref="T:Libplanet.Blocks.BlockMetadata"/>'s constructor in addition to the ones
            explicitly listed below.
            </remarks>
            <param name="metadata">The <see cref="T:Libplanet.Blocks.IBlockMetadata"/> to copy.</param>
            <param name="transactions">The transactions to include in the block.</param>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when any tx signature is invalid or
            not signed by its signer.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxNonceException">Thrown when the same tx nonce is used by
            a signer twice or more, or a tx nonce is used without its previous nonce by a signer.
            Note that this validates only a block's intrinsic integrity between its transactions,
            but does not guarantee integrity between blocks.  Such validation needs to be conducted
            by <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxGenesisHashException">Thrown when transactions to set have
            inconsistent genesis hashes.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTxHashException">Thrown when the given
            <paramref name="metadata"/>'s <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/> is inconsistent with
            <paramref name="transactions"/>.</exception>
            <seealso cref="T:Libplanet.Blocks.BlockMetadata"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockContent`1.#ctor(Libplanet.Blocks.BlockMetadata)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blocks.BlockContent`1"/> instance with given
            <paramref name="metadata"/> and without any <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </summary>
            <param name="metadata">The <see cref="T:Libplanet.Blocks.BlockMetadata"/> to include in the block.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTxHashException">Thrown when the given
            <paramref name="metadata"/>'s <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/> is not
            <see lagnword="null"/>.</exception>
        </member>
        <member name="M:Libplanet.Blocks.BlockContent`1.#ctor(Libplanet.Blocks.BlockMetadata,System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}})">
            <summary>
            Creates a new <see cref="T:Libplanet.Blocks.BlockContent`1"/> instance with given
            <paramref name="metadata"/> and <paramref name="transactions"/>.
            </summary>
            <param name="metadata">The <see cref="T:Libplanet.Blocks.BlockMetadata"/> to include in the block.</param>
            <param name="transactions">The transactions to include in the block.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTxHashException">Thrown when the given
            <paramref name="metadata"/>'s <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/> is inconsistent with
            <paramref name="transactions"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when any tx signature is invalid
            or not signed by its signer.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxNonceException">Thrown when the same tx nonce is used by
            a signer twice or more, or a tx nonce is used without its previous nonce by a signer.
            Note that this validates only a block's intrinsic integrity between its transactions,
            but does not guarantee integrity between blocks.  Such validation needs to be conducted
            by <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxGenesisHashException">Thrown when transactions to set have
            inconsistent genesis hashes.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="transactions"/> is
            not ordered by <see cref="P:Libplanet.Tx.Transaction`1.Id"/>s.</exception>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.Metadata">
            <summary>
            Internal <see cref="T:Libplanet.Blocks.BlockMetadata"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.ProtocolVersion">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.Index">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.Timestamp">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.Miner">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.PublicKey">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.Difficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.TotalDifficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.PreviousHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.TxHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockContent`1.Transactions">
            <summary>
            Transactions belonging to the block.
            </summary>
            <remarks>This is always ordered by <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.</remarks>
        </member>
        <member name="M:Libplanet.Blocks.BlockContent`1.DeriveTxHash(System.Collections.Generic.IEnumerable{Libplanet.Tx.Transaction{`0}})">
            <summary>
            Derives <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/> from given <paramref name="transactions"/>.
            </summary>
            <param name="transactions">The transactions to derive
            <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/> from.  This must be ordered by
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.</param>
            <returns>The derived <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the <paramref name="transactions"/> are
            not ordered by their <see cref="P:Libplanet.Tx.Transaction`1.Id"/>s.</exception>
        </member>
        <member name="M:Libplanet.Blocks.BlockContent`1.Mine(System.Threading.CancellationToken)">
            <summary>
            Mines the PoW (proof-of-work) nonce satisfying the block
            <see cref="P:Libplanet.Blocks.BlockMetadata.Difficulty"/>, and returns a valid
            <see cref="T:Libplanet.Blocks.PreEvaluationBlock`1"/> instance.
            </summary>
            <param name="cancellationToken">An optional cancellation token used to propagate signal
            that this operation should be cancelled.</param>
            <returns>A <see cref="T:Libplanet.Blocks.PreEvaluationBlock`1"/> instance with a valid proof-of-work.
            </returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the specified
            <paramref name="cancellationToken"/> received a cancellation request.</exception>
        </member>
        <member name="T:Libplanet.Blocks.BlockExcerptExtensions">
            <summary>
            The extension methods for <see cref="T:Libplanet.Blocks.IBlockExcerpt"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockExcerptExtensions.ToExcerptString(Libplanet.Blocks.IBlockExcerpt)">
            <summary>
            Shows <see cref="T:Libplanet.Blocks.IBlockExcerpt"/> instance's members as a string.
            </summary>
            <param name="excerpt">An excerpt object to show.</param>
            <returns>Extracted members as a string.</returns>
        </member>
        <member name="T:Libplanet.Blocks.BlockHash">
            <summary>
            A value type to represent SHA-256 digest of <see cref="T:Libplanet.Blocks.Block`1"/> data.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.Hash"/>
        </member>
        <member name="F:Libplanet.Blocks.BlockHash.Size">
            <summary>
            The size of bytes that each <see cref="T:Libplanet.Blocks.BlockHash"/> consists of.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Converts an immutable <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Blocks.BlockHash"/>.
            </summary>
            <param name="blockHash">An immutable <see cref="T:System.Byte"/> array that encodes
            a SHA-256 digest of a <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="blockHash"/>'s <see cref="P:System.Collections.Immutable.ImmutableArray`1.Length"/> is not 32.
            </exception>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.#ctor(System.Byte[])">
            <summary>
            Converts a <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Blocks.BlockHash"/>.
            </summary>
            <param name="blockHash">A <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.Blocks.BlockHash"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="blockHash"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="blockHash"/>'s <see cref="P:System.Collections.Immutable.ImmutableArray`1.Length"/> is not 32.
            </exception>
        </member>
        <member name="P:Libplanet.Blocks.BlockHash.ByteArray">
            <summary>
            A bare immutable <see cref="T:System.Byte"/> array of the block hash.
            </summary>
            <remarks>It is immutable.  For a mutable array, use <see cref="M:Libplanet.Blocks.BlockHash.ToByteArray"/> method
            instead.</remarks>
            <seealso cref="M:Libplanet.Blocks.BlockHash.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.FromString(System.String)">
            <summary>
            Converts a given hexadecimal representation of a block hash into
            a <see cref="T:Libplanet.Blocks.BlockHash"/> value.
            <para>This is an inverse function of <see cref="M:Libplanet.Blocks.BlockHash.ToString"/> method.</para>
            </summary>
            <param name="hex">A hexadecimal representation of a <see cref="T:Libplanet.Blocks.BlockHash"/>.</param>
            <returns>A corresponding <see cref="T:Libplanet.Blocks.BlockHash"/> value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given <paramref name="hex"/> is
            <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of the given
            <paramref name="hex"/> string is an odd number.</exception>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="hex"/> string
            is not a valid hexadecimal string.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hex"/>'s length is not 64.</exception>
            <seealso cref="M:Libplanet.Blocks.BlockHash.ToString"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.FromHashDigest(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Converts a given <see cref="T:Libplanet.HashDigest`1"/> into a <see cref="T:Libplanet.Blocks.BlockHash"/> value.
            </summary>
            <param name="hashDigest">A SHA-256 digest.</param>
            <returns>A block hash corresponding to the <paramref name="hashDigest"/>.</returns>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.DeriveFrom(System.Collections.Generic.IReadOnlyList{System.Byte})">
            <summary>
            Computes a SHA-256 digest from the given <paramref name="blockBytes"/>.
            </summary>
            <param name="blockBytes">The bytes serializing a block to compute its hash.</param>
            <returns>The SHA-256 hash digest derived from <paramref name="blockBytes"/>.</returns>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.ToByteArray">
            <summary>
            Gets a bare mutable <see cref="T:System.Byte"/> array of the block hash.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array of the block hash.
            Since a returned array is created every time the method is called,
            any mutations on that array does not affect to the block hash object.
            </returns>
            <seealso cref="P:Libplanet.Blocks.BlockHash.ByteArray"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.Equals(Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHash.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Blocks.BlockHeader">
            <summary>
            Block header containing information about <see cref="T:Libplanet.Blocks.Block`1"/>s except transactions.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockHeader.#ctor(Libplanet.Blocks.IBlockHeader)">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.BlockHeader"/> by copying the fields of another
            block <paramref name="header"/>.
            </summary>
            <remarks>
            <para>
            As <paramref name="header"/> needn't be an actual <see cref="T:Libplanet.Blocks.BlockHeader"/>
            instance, but simply any object implementing <see cref="T:Libplanet.Blocks.IBlockHeader"/>
            interface, it can't be trusted to satisfy all the constraints for a valid
            <see cref="T:Libplanet.Blocks.BlockHeader"/> instance.  As such, conditions are checked again
            whilst creating a copy.  This is a relatively heavy operation, so must be used
            sparingly.
            </para>
            <para>
            In particular, this creates a new instance of
            <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/> with data extracted from
            <paramref name="header"/>.  Thus any <see cref="T:System.Exception"/>s that can be thrown from a
            <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/>'s constructors may also be thrown
            in addition to the ones explicitly listed below.
            </para>
            </remarks>
            <param name="header">The block header to copy.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockSignatureException">Thrown if
            <paramref name="header.Signature.Signature"/> is invalid.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockHashException">Thrown when <paramref name="header.Hash.Hash"/>
            is inconsistent with other arguments.</exception>
            <seealso cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHeader.#ctor(Libplanet.Blocks.PreEvaluationBlockHeader,System.ValueTuple{Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Nullable{System.Collections.Immutable.ImmutableArray{System.Byte}},Libplanet.Blocks.BlockHash})">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.BlockHeader"/> instance with its
            <paramref name="preEvaluationBlockHeader"/> and <paramref name="proof"/>.
            </summary>
            <param name="preEvaluationBlockHeader">The pre-evaluation block header.</param>
            <param name="proof">A triple of the state root hash, the block signature, and the block
            hash which is probably considered as to be derived from
            the <paramref name="preEvaluationBlockHeader"/> and the state root hash.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockSignatureException">Thrown if
            <paramref name="proof.Signature.Signature"/> signature is invalid.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockHashException">Thrown when <paramref name="proof.Hash.Hash"/>
            is inconsistent with other arguments.</exception>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Header">
            <summary>
            Internal <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.ProtocolVersion">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Index">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Timestamp">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Miner">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.PublicKey">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Difficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.TotalDifficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.PreviousHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.TxHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Nonce">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.PreEvaluationHash">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.StateRootHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockHeader.StateRootHash"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Signature">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockHeader.Signature"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockHeader.Hash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockExcerpt.Hash"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockHeader.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Blocks.BlockMarshaler">
            <summary>
            Marshaling and unmarshaling block data.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.BlockMetadata">
            <summary>
            A block metadata without transactions or any proofs like nonce or hash.  This represents
            metadata of a block that is not yet mined nor proven.
            <para>To represent a block content including its metadata and transactions, use
            <see cref="T:Libplanet.Blocks.BlockContent`1"/>.</para>
            </summary>
            <seealso cref="T:Libplanet.Blocks.BlockContent`1"/>
        </member>
        <member name="F:Libplanet.Blocks.BlockMetadata.CurrentProtocolVersion">
            <summary>
            The latest protocol version.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockMetadata.#ctor(Libplanet.Blocks.IBlockMetadata)">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.BlockMetadata"/> by copying the fields of another block
            <paramref name="metadata"/>.
            </summary>
            <remarks>
            <para>
            As <paramref name="metadata"/> needn't be an actual <see cref="T:Libplanet.Blocks.BlockMetadata"/>
            instance, but simply any object implementing <see cref="T:Libplanet.Blocks.IBlockMetadata"/> interface,
            it can't be trusted to satisfy all the constraints for a valid
            <see cref="T:Libplanet.Blocks.BlockMetadata"/> instance.  As such, conditions are checked again whilst
            creating a copy.  This is a relatively heavy operation, so must be used sparingly.
            </para>
            <para>
            This gets redirected to <see cref="M:Libplanet.Blocks.BlockMetadata.#ctor(System.Int32,System.Int64,System.DateTimeOffset,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Int64,System.Numerics.BigInteger,System.Nullable{Libplanet.Blocks.BlockHash},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})"/>.  Refer to the
            aforementioned constructor to see the full list of <see cref="T:System.Exception"/>s
            that may be thrown.
            </para>
            </remarks>
            <param name="metadata">The source block metadata to copy.  This needn't be
            an actual <see cref="T:Libplanet.Blocks.BlockMetadata"/> instance, but can be any object which
            implements <see cref="T:Libplanet.Blocks.IBlockMetadata"/>.</param>
            <seealso cref="M:Libplanet.Blocks.BlockMetadata.#ctor(System.Int32,System.Int64,System.DateTimeOffset,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Int64,System.Numerics.BigInteger,System.Nullable{Libplanet.Blocks.BlockHash},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockMetadata.#ctor(System.Int64,System.DateTimeOffset,Libplanet.Crypto.PublicKey,System.Int64,System.Numerics.BigInteger,System.Nullable{Libplanet.Blocks.BlockHash},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.BlockMetadata"/> with
            <see cref="F:Libplanet.Blocks.BlockMetadata.CurrentProtocolVersion"/> as its
            <see cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>.
            </summary>
            <remarks>
            With this, <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/> is set as current time and
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/> is derived from <paramref name="publicKey"/>.
            This gets redirected to <see cref="M:Libplanet.Blocks.BlockMetadata.#ctor(System.Int32,System.Int64,System.DateTimeOffset,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Int64,System.Numerics.BigInteger,System.Nullable{Libplanet.Blocks.BlockHash},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})"/>.  Refer to the
            aforementioned constructor to see the full list of <see cref="T:System.Exception"/>s
            that may be thrown.
            </remarks>
            <param name="index">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>.</param>
            <param name="timestamp">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>.</param>
            <param name="publicKey">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>.</param>
            <param name="difficulty">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.</param>
            <param name="totalDifficulty">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>.
            </param>
            <param name="previousHash">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>.</param>
            <param name="txHash">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>.</param>
            <seealso cref="M:Libplanet.Blocks.BlockMetadata.#ctor(System.Int32,System.Int64,System.DateTimeOffset,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Int64,System.Numerics.BigInteger,System.Nullable{Libplanet.Blocks.BlockHash},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockMetadata.#ctor(System.Int32,System.Int64,System.DateTimeOffset,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Int64,System.Numerics.BigInteger,System.Nullable{Libplanet.Blocks.BlockHash},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.BlockMetadata"/> by manually filling in the fields for
            <see cref="T:Libplanet.Blocks.BlockMetadata"/>.  All other public constructors are redirected to this one.
            </summary>
            <remarks>
            Except for debuggin and/or testing purposes, this shouldn't be called directly.
            </remarks>
            <param name="protocolVersion">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>.
            </param>
            <param name="index">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>.</param>
            <param name="timestamp">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>.</param>
            <param name="miner">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>.</param>
            <param name="publicKey">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>.</param>
            <param name="difficulty">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.</param>
            <param name="totalDifficulty">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>.
            </param>
            <param name="previousHash">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>.</param>
            <param name="txHash">Goes to <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockProtocolVersionException">Thrown when
            <paramref name="protocolVersion"/> is less than zero or greater than
            <see cref="F:Libplanet.Blocks.BlockMetadata.CurrentProtocolVersion"/>, the latest known protocol version.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockIndexException">Thrown when <paramref name="index"/> is
            less than zero.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPublicKeyException">Thrown when any of the following
            conditions isn't satisfied:
            <list type="bullet">
              <item><description>If <paramref name="protocolVersion"/> >= 2,
              <paramref name="miner"/> should match the derived address of
              <paramref name="publicKey"/>.</description></item>
              <item><description>Otherwise, <paramref name="publicKey"/> must be
              <see langword="null"/>.</description></item>
            </list>
            </exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockDifficultyException">Thrown when one of the following
            conditions is met:
            <list type="bullet">
                <item><description>If <paramref name="difficulty"/> is less than 0.
                </description></item>
                <item><description>If <paramref name="index"/> is 0 and
                <paramref name="difficulty"/> is not 0.</description></item>
                <item><description>If <paramref name="index"/> is greater than 0 and
                <paramref name="difficulty"/> is 0.</description></item>
            </list>
            </exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTotalDifficultyException">Thrown when one of the following
            conditions is met:
            <list type="bullet">
                <item><description>If <paramref name="totalDifficulty"/> is less than 0.
                </description></item>
                <item><description>If <paramref name="totalDifficulty"/> is less than
                <paramref name="difficulty"/>.</description></item>
            </list>
            </exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPreviousHashException">Thrown when
            <paramref name="previousHash"/> is not null while <paramref name="index"/> is zero
            or <paramref name="previousHash"/> is null while <paramref name="index"/> is nonzero.
            </exception>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.ProtocolVersion">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.Index">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.Timestamp">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.Miner">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.PublicKey">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.Difficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.TotalDifficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.PreviousHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>
        </member>
        <member name="P:Libplanet.Blocks.BlockMetadata.TxHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>
        </member>
        <member name="M:Libplanet.Blocks.BlockMetadata.MineNonce(System.Threading.CancellationToken)">
            <summary>
            Mines the PoW (proof-of-work) nonce satisfying the block
            <see cref="P:Libplanet.Blocks.BlockMetadata.Difficulty"/>.
            </summary>
            <param name="cancellationToken">An optional cancellation token used to propagate signal
            that this operation should be cancelled.</param>
            <returns>A pair of the mined nonce and the pre-evaluation hash that satisfy the
            block <see cref="P:Libplanet.Blocks.BlockMetadata.Difficulty"/>.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the specified
            <paramref name="cancellationToken"/> received a cancellation request.</exception>
        </member>
        <member name="M:Libplanet.Blocks.BlockMetadata.MineNonce(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Mines the PoW (proof-of-work) nonce satisfying the block
            <see cref="P:Libplanet.Blocks.BlockMetadata.Difficulty"/>.
            </summary>
            <param name="workers">The number of workers to run in parallel.
            Must be greater than zero.</param>
            <param name="cancellationToken">An optional cancellation token used to propagate signal
            that this operation should be cancelled.</param>
            <returns>A pair of the mined nonce and the pre-evaluation hash that satisfy the
            block <see cref="P:Libplanet.Blocks.BlockMetadata.Difficulty"/>.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the specified
            <paramref name="cancellationToken"/> received a cancellation request.</exception>
        </member>
        <member name="M:Libplanet.Blocks.BlockMetadata.DerivePreEvaluationHash(Libplanet.Nonce)">
            <summary>
            Derives a hash digest from the block metadata and <paramref name="nonce"/>.
            </summary>
            <param name="nonce">The proof-of-work nonce.</param>
            <returns>A pre-evaluation block hash.</returns>
        </member>
        <member name="M:Libplanet.Blocks.BlockMetadata.MakeCandidateData(Libplanet.Nonce)">
            <summary>
            Makes a serialized representation for mining.
            </summary>
            <param name="nonce">The proof-of-work nonce.</param>
            <returns>A <see cref="T:Bencodex.Types.Dictionary"/> representation for mining.</returns>
        </member>
        <member name="T:Libplanet.Blocks.BlockPolicyViolationException">
            <summary>
            An exception <em>returned</em> when a <see cref="T:Libplanet.Blocks.Block`1"/> violates
            a <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.BlockPolicyViolationException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blocks.BlockPolicyViolationException"/> instance.
            </summary>
            <param name="message">A description for the reason of violation
            given by an implementation of <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            </param>
        </member>
        <member name="T:Libplanet.Blocks.IBlockContent`1">
            <summary>
            A common interface for blocks that do not have any proofs, but have their metadata and
            containing <see cref="P:Libplanet.Blocks.IBlockContent`1.Transactions"/>.
            </summary>
            <typeparam name="T">A class implementing <see cref="T:Libplanet.Action.IAction"/> to include.  This type
            parameter is aligned with <see cref="T:Libplanet.Tx.Transaction`1"/>'s type parameter.</typeparam>
        </member>
        <member name="P:Libplanet.Blocks.IBlockContent`1.Transactions">
            <summary>
            Transactions belonging to the block.
            </summary>
            <remarks>This is always ordered by <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.</remarks>
        </member>
        <member name="T:Libplanet.Blocks.IBlockContent">
            <summary>
            A common interface for blocks that do not have any proofs, but have their metadata and
            containing <see cref="P:Libplanet.Blocks.IBlockContent.Transactions"/>.
            </summary>
            <remarks>This is always ordered by <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.</remarks>
            <remarks>It is similar with <see cref="T:Libplanet.Blocks.IBlockContent`1"/> but
            it is non-generic interface. It means that it doesn't check the action types
            in serialization.</remarks>
        </member>
        <member name="P:Libplanet.Blocks.IBlockContent.Transactions">
            <summary>
            Transactions belonging to the block.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.IBlockExcerpt">
            <summary>
            The very essential metadata extracted from a block.  This purposes to determine
            the canonical chain.
            </summary>
            <seealso cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.CanonicalChainComparer"/>
            <seealso cref="T:Libplanet.Blockchain.TotalDifficultyComparer"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.ProtocolVersion">
            <summary>
            A block's protocol version.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.Index">
            <summary>
            A block's index (height).
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.Hash">
            <summary>
            A block's hash.
            </summary>
            <summary>
            The hash digest derived from the whole contents of the block including
            <see cref="P:Libplanet.Blocks.IBlockHeader.StateRootHash"/>, which is determined by evaluating transactions
            and a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/> (if exists).
            <para>This is used for block's unique identifier.</para>
            </summary>
            <seealso cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/>
            <seealso cref="P:Libplanet.Blocks.IBlockHeader.StateRootHash"/>
            <seealso cref="P:Libplanet.Blocks.Block`1.Hash"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockExcerpt.TotalDifficulty">
            <summary>
            The sum of a block and its all ancestors' difficulties.
            </summary>
            <seealso cref="P:Libplanet.Blocks.Block`1.TotalDifficulty"/>
        </member>
        <member name="T:Libplanet.Blocks.IBlockHeader">
            <summary>
            A common interface for blocks that have their proof-of-work <see cref="T:Libplanet.Nonce"/>s and
            <see cref="P:Libplanet.Blocks.IBlockHeader.StateRootHash"/>es, but no transactions.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IBlockHeader.StateRootHash">
            <summary>
            The <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of the resulting states after evaluating transactions and
            a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/> (if exists).
            </summary>
            <seealso cref="P:Libplanet.Store.Trie.ITrie.Hash"/>
        </member>
        <member name="P:Libplanet.Blocks.IBlockHeader.Signature">
            <summary>
            The digital signature of the whole block content (except for
            <see cref="P:Libplanet.Blocks.IBlockExcerpt.Hash"/>, which is derived from the signature and other
            contents).  This is made by the <see cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>'s
            <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            <para>As the block signature is introduced since the protocol version 2, it is
            <see langword="null"/> for blocks with earlier protocol versions than 2.  Although
            the property is type-wise, the block signature is mandatory since the protocol
            version 2.</para>
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.IBlockMetadata">
            <summary>
            A common interface for blocks that do not have any proofs nor transactions (but only
            <see cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>).
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion">
            <summary>
            The protocol version number.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.Index">
            <summary>
            The height of the block.
            </summary>
            <remarks>Zero means it is a genesis block.  Not allowed to be negative.</remarks>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.Timestamp">
            <summary>
            The time the block is created.
            </summary>
            <remarks>This is always UTC.</remarks>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.Miner">
            <summary>
            The address of the miner.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.PublicKey">
            <summary>
            The public key of the <see cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>.  This is used for verifying the signature.
            <para>Although this is nullable type-wise, it is mandatory where
            <see cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/> is 2 or later.  As blocks had not been signed in
            the previous protocol versions, the type of this is nullable.
            </para>
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.Difficulty">
            <summary>
            The mining difficulty that the block's <see cref="T:Libplanet.Nonce"/> has to satisfy.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty">
            <summary>
            The total mining difficulty since the genesis including the block's
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.
            </summary>
            <remarks>This must be greater than or equal to <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/> at least, and
            must not be negative.</remarks>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.PreviousHash">
            <summary>
            The previous block's hash.  If it's a genesis block (i.e., its <see cref="P:Libplanet.Blocks.IBlockMetadata.Index"/> is 0)
            this must be <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IBlockMetadata.TxHash">
            <summary>
            The hash of all transactions in the block.  This is <see langword="null"/> if the block
            has no transactions.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.IBlockMetadataExtensions">
            <summary>
            Convenient extension methods for <see cref="T:Libplanet.Blocks.IBlockMetadata"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.IBlockMetadataExtensions.ValidateTimestamp(Libplanet.Blocks.IBlockMetadata)">
            <summary>
            Checks if the given <paramref name="metadata"/>'s
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/> is valid.  No-op if valid.
            </summary>
            <param name="metadata">The block metadata to validate.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTimestampException">Thrown when
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/> is invalid.  For example,
            if <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/> is too far in the future
            compared to the current time.</exception>
        </member>
        <member name="M:Libplanet.Blocks.IBlockMetadataExtensions.ValidateTimestamp(Libplanet.Blocks.IBlockMetadata,System.DateTimeOffset)">
            <summary>
            Checks if the given <paramref name="metadata"/>'s
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/> is valid.  No-op if valid.
            </summary>
            <param name="metadata">The block metadata to validate.</param>
            <param name="currentTime">Explicitly specify the current time.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockTimestampException">Thrown when
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/> is invalid.  For example,
            if <see cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/> is too far in the future
            compared to <paramref name="currentTime"/>.</exception>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockBytesLengthException">
            <summary>
            An exception thrown when the encoded bytes of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> exceeds
            <see cref="M:Libplanet.Blockchain.Policies.IBlockPolicy`1.GetMaxTransactionsBytes(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockBytesLengthException.#ctor(System.String,System.Int64)">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockBytesLengthException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="bytesLength">The actual encoded length of
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> as bytes.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockBytesLengthException.BytesLength">
            <summary>
            The actual encoded length of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/> as bytes.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockBytesLengthException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockException">
            <summary>
            Serves as the base class for exceptions related <see cref="T:Libplanet.Blocks.Block`1"/>s' integrity and
            validity.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockException.#ctor(System.String)">
            <inheritdoc cref="M:System.Exception.#ctor(System.String)"/>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException">
            <summary>
            The exception that is thrown when the a <see cref="T:Libplanet.Blocks.Block`1"/>'s
            <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/> is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockPreEvaluationHashException.#ctor(System.String,System.Collections.Immutable.ImmutableArray{System.Byte},System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="actualPreEvaluationHash">The hash recorded as
            <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/>.</param>
            <param name="expectedPreEvaluationHash">The hash calculated from the block except
            <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockPreEvaluationHashException.ActualPreEvaluationHash">
            <summary>
            The hash calculated from the block except <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockPreEvaluationHashException.ExpectedPreEvaluationHash">
            <summary>
            The hash recorded as <see cref="P:Libplanet.Blocks.Block`1.PreEvaluationHash"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockProtocolVersionException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Blocks.Block`1"/>'s
            <see cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/> (or a <see cref="T:Libplanet.Blocks.BlockHeader"/>'s
            <see cref="P:Libplanet.Blocks.BlockHeader.ProtocolVersion"/>) is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockProtocolVersionException.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockProtocolVersionException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="actualProtocolVersion">The actual block protocol version which is invalid.
            </param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockProtocolVersionException.ActualProtocolVersion">
            <summary>
            The actual block protocol version which is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockProtocolVersionException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockPublicKeyException">
            <summary>
            An exception thrown when a block's public key is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockPublicKeyException.#ctor(System.String,Libplanet.Crypto.PublicKey)">
            <summary>
            Creates a new <see cref="T:Libplanet.Blocks.InvalidBlockPublicKeyException"/> instance.
            </summary>
            <param name="message">A message that describes the error.</param>
            <param name="invalidPublicKey">The invalid public key tried to be used
            in the block.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockPublicKeyException.InvalidPublicKey">
            <summary>
            The invalid public key tried to be used in the block.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockSignatureException">
            <summary>
            An exception thrown when a block's signature is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockSignatureException.#ctor(System.String,Libplanet.Crypto.PublicKey,System.Nullable{System.Collections.Immutable.ImmutableArray{System.Byte}})">
            <summary>
            Creates a new <see cref="T:Libplanet.Blocks.InvalidBlockPublicKeyException"/> instance.
            </summary>
            <param name="message">A message that describes the error.</param>
            <param name="publicKey">The public key used for signing the block.</param>
            <param name="invalidSignature">The block signature which is invalid.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockSignatureException.PublicKey">
            <summary>
            The public key used for signing the block.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockSignatureException.InvalidSignature">
            <summary>
            The block signature which is invalid.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockStateRootHashException">
            <summary>
            The exception that is thrown when the state root hash in the block has
            mismatches to the state root hash of the trie on the block executed in local.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockStateRootHashException.#ctor(System.String,Libplanet.HashDigest{System.Security.Cryptography.SHA256},Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Blocks.InvalidBlockStateRootHashException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="expectedStateRootHash">The hash recorded as
            <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>>.</param>
            <param name="actualStateRootHash">The hash of state trie on the block executed.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockStateRootHashException.ActualStateRootHash">
            <summary>
            The hash of state trie on the block executed.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockStateRootHashException.ExpectedStateRootHash">
            <summary>
            The hash recorded as <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>>.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockTxCountException">
            <summary>
            An exception thrown when the count of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/>
            does not follow the constraint provided by <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockTxCountException.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockTxCountException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="txCount">The invalid count of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/>
            according to <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.</param>
        </member>
        <member name="T:Libplanet.Blocks.InvalidBlockTxCountPerSignerException">
            <summary>
            An exception thrown when the count of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/>
            does not follow the constraint provided by <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockTxCountPerSignerException.#ctor(System.String,Libplanet.Address,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockTxCountPerSignerException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="signer">An offending <see cref="T:Libplanet.Address"/> with too many
            <see cref="T:Libplanet.Tx.Transaction`1"/>'s in a <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <param name="txCount">The invalid count of <see cref="P:Libplanet.Blocks.Block`1.Transactions"/>
            by <paramref name="signer"/> according to the <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.</param>
        </member>
        <member name="M:Libplanet.Blocks.InvalidBlockTxHashException.#ctor(System.String,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <summary>
            Initializes a new instance of <see cref="T:Libplanet.Blocks.InvalidBlockTxHashException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="blockTxHash">The hash digest of <see cref="P:Libplanet.Blocks.Block`1.TxHash"/>.</param>
            <param name="calculatedTxHash">The calculated hash digest from
            <see cref="P:Libplanet.Blocks.Block`1.Transactions"/>.</param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockTxHashException.BlockTxHash">
            <summary>
            The hash digest from actual block.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidBlockTxHashException.CalculatedTxHash">
            <summary>
            The calculated hash digest from transactions in the block.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.InvalidGenesisBlockException">
            <summary>
            The exception that is thrown when the genesis block the <see cref="T:Libplanet.Store.IStore"/> contains
            mismatches to the genesis block the <see cref="T:Libplanet.Blockchain.BlockChain`1"/> constructor (i.e., network)
            expects or the first block of <see cref="T:Libplanet.Blockchain.BlockLocator"/> which the <see cref="T:Libplanet.Store.IStore"/>
            doesn't contain, because the block which <see cref="T:Libplanet.Store.IStore"/> doesn't means
            the genesis block in other network.
            </summary>
        </member>
        <member name="M:Libplanet.Blocks.InvalidGenesisBlockException.#ctor(System.String,Libplanet.Blocks.BlockHash,Libplanet.Blocks.BlockHash)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Blocks.InvalidGenesisBlockException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="networkExpected">The genesis block that the network expects.</param>
            <param name="stored">The genesis block that a local <see cref="T:Libplanet.Store.IStore"/> contains.
            </param>
        </member>
        <member name="P:Libplanet.Blocks.InvalidGenesisBlockException.NetworkExpected">
            <summary>
            The genesis block that the network expects.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.InvalidGenesisBlockException.Stored">
            <summary>
            The genesis block that a local <see cref="T:Libplanet.Store.IStore"/> contains.
            </summary>
        </member>
        <member name="T:Libplanet.Blocks.IPreEvaluationBlock`1">
            <summary>
            A common interface for blocks that have their proof-of-work
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>s and
            <see cref="P:Libplanet.Blocks.IBlockContent`1.Transactions"/>, but are not evaluated yet (i.e., their state
            root hashes are not yet determined).
            </summary>
            <typeparam name="T">A class implementing <see cref="T:Libplanet.Action.IAction"/> to include.  This type
            parameter is aligned with <see cref="T:Libplanet.Tx.Transaction`1"/>'s type parameter.</typeparam>
        </member>
        <member name="T:Libplanet.Blocks.IPreEvaluationBlock">
            <summary>
            A common interface for blocks that have their proof-of-work
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>s and
            <see cref="P:Libplanet.Blocks.IBlockContent.Transactions"/>, but are not evaluated yet (i.e., their state
            root hashes are not yet determined).
            </summary>
            <remarks>It is similar with <see cref="T:Libplanet.Blocks.IPreEvaluationBlock`1"/> but
            it is non-generic interface. It means that it doesn't check the action types
            in serialization.</remarks>
        </member>
        <member name="T:Libplanet.Blocks.IPreEvaluationBlockHeader">
            <summary>
            A common interface for blocks that have their proof-of-work <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>s,
            but are not evaluated yet (i.e., state root hash is not yet determined).
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce">
            <summary>
            The proof-of-work nonce which satisfies the required
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash">
            <summary>
            The hash derived from the block <em>except of</em> its state root hash (i.e., without
            action evaluation).  Used for validating <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>.
            </summary>
            <seealso cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>
        </member>
        <member name="T:Libplanet.Blocks.PreEvaluationBlock`1">
            <summary>
            A block candidate without evaluating actions (in its <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions"/> and
            a possible <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) and state root
            hash.
            </summary>
            <typeparam name="T">A class implementing <see cref="T:Libplanet.Action.IAction"/> to include.  This type
            parameter is aligned with <see cref="T:Libplanet.Tx.Transaction`1"/>'s type parameter.</typeparam>
            <remarks>It guarantees that every instance of this type has a valid proof-of-work
            <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Nonce"/> which satisfies its <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Difficulty"/>.
            </remarks>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.#ctor(Libplanet.Blocks.BlockContent{`0},System.ValueTuple{Libplanet.Nonce,System.Collections.Immutable.ImmutableArray{System.Byte}}@)">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.PreEvaluationBlock`1"/> instance with its
            <paramref name="content"/> data, a valid proof-of-work <paramref name="proof.Nonce.Nonce"/>
            which satisfies the required <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Difficulty"/>,
            and a <paramref name="proof.PreEvaluationHash.PreEvaluationHash"/> digest derived from them.
            </summary>
            <param name="content">Block's content data.</param>
            <param name="proof">A pair of a valid proof-of-work nonce which satisfies the required
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Difficulty"/> and a hash digest which is
            derived from <paramref name="content"/> and the nonce.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockNonceException">Thrown when <paramref name="proof"/>'s
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/> does not satisfy the required
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException">Thrown when
            <paramref name="proof"/>'s hash is invalid.</exception>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Header">
            <summary>
            Internal <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockContent`1.Transactions"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Libplanet#Blocks#IBlockContent#Transactions">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockContent.Transactions" />
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.ProtocolVersion">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Index">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Timestamp">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Miner">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.PublicKey">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Difficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.TotalDifficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.PreviousHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.TxHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.Nonce">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlock`1.PreEvaluationHash">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.Evaluate(Libplanet.Crypto.PrivateKey,Libplanet.Action.IAction,System.Predicate{Libplanet.Assets.Currency},Libplanet.Store.IStateStore)">
            <summary>
            Evaluates all actions in the <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions"/> and
            a <paramref name="blockAction"/> (if any), and returns a <see cref="T:Libplanet.Blocks.Block`1"/> instance
            combined with the <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/> determined from ground zero
            (i.e., empty state root).  The returned <see cref="T:Libplanet.Blocks.Block`1"/> is signed by the given
            <paramref name="privateKey"/>.
            </summary>
            <param name="privateKey">The miner's private key to be used for signing the block.
            This must match to the block's <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Miner"/> and
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.PublicKey"/>.</param>
            <param name="blockAction">An optional
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.</param>
            <param name="nativeTokenPredicate">A predicate function to determine whether
            the specified <see cref="T:Libplanet.Assets.Currency"/> is a native token defined by chain's
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/> or not.</param>
            <param name="stateStore">The <see cref="P:Libplanet.Blockchain.BlockChain`1.StateStore"/>.</param>
            <returns>The block combined with the resulting <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.
            It is signed by the given <paramref name="privateKey"/>.</returns>
            <remarks>This can be used with only genesis blocks.  For blocks with indices greater
            than zero, use <see cref="M:Libplanet.Blocks.PreEvaluationBlock`1.DetermineStateRootHash(Libplanet.Blockchain.BlockChain{`0})"/> overloaded one
            instead.</remarks>
            <exception cref="T:System.InvalidOperationException">Thrown when its
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Index"/> is not zero, or the block's
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> is less than 2.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="privateKey"/>
            does not match to the block miner's <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.PublicKey"/>.</exception>
            <remarks>As blocks have their signatures since the <see
            cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> 2, it is not usable with blocks of
            the earlier <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/>s than 2.
            To create a <see cref="T:Libplanet.Blocks.Block`1"/> instance with <see cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/>
            less than 2, use <see cref="T:Libplanet.Blocks.Block`1"/>'s constructors with <see langword="null"/>
            signatures.</remarks>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.Evaluate(Libplanet.Crypto.PrivateKey,Libplanet.Blockchain.BlockChain{`0})">
            <summary>
            Evaluates all actions in the <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions"/> and an optional
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>, and returns
            a <see cref="T:Libplanet.Blocks.Block`1"/> instance combined with the <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>
            determined from ground zero (i.e., empty state root). The returned
            <see cref="T:Libplanet.Blocks.Block`1"/> is signed by the given <paramref name="privateKey"/>.
            </summary>
            <param name="privateKey">The miner's private key to be used for signing the block.
            This must match to the block's <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Miner"/> and
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.PublicKey"/>.</param>
            <param name="blockChain">The blockchain on which actions are evaluated based.</param>
            <returns>The block combined with the resulting <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.
            It is signed by the given <paramref name="privateKey"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the block's
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> is less than 2.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="privateKey"/>
            does not match to the block miner's <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.PublicKey"/>.</exception>
            <remarks>As blocks have their signatures since the <see
            cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> 2, it is not usable with blocks of
            the earlier <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/>s than 2.
            To create a <see cref="T:Libplanet.Blocks.Block`1"/> instance with <see cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/>
            less than 2, use <see cref="T:Libplanet.Blocks.Block`1"/>'s constructors with
            <see langword="null"/> signatures.</remarks>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.Sign(Libplanet.Crypto.PrivateKey,Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Signs the block content with the given <paramref name="stateRootHash"/>.
            </summary>
            <param name="privateKey">The miner's private key to be used for signing the block.
            This must match to the block's <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Miner"/> and
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.PublicKey"/>.</param>
            <param name="stateRootHash">The state root hash to include to the input message to
            sign.</param>
            <returns>The signed block with the <paramref name="stateRootHash"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the block's
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> is less than 2.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="privateKey"/>
            does not match to the block miner's <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.PublicKey"/>.</exception>
            <remarks>As blocks have their signatures since the <see
            cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> 2, it is not usable with blocks of
            the earlier <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/>s than 2.
            To create a <see cref="T:Libplanet.Blocks.Block`1"/> instance with <see cref="P:Libplanet.Blocks.Block`1.ProtocolVersion"/>
            less than 2, use <see cref="T:Libplanet.Blocks.Block`1"/>'s constructors with <see langword="null"/>
            signatures.</remarks>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.DetermineStateRootHash(Libplanet.Action.IAction,System.Predicate{Libplanet.Assets.Currency},Libplanet.Store.IStateStore)">
            <summary>
            Evaluates all actions in the <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions"/> and
            a <paramref name="blockAction"/> (if any), and determines
            the <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/> from ground zero (i.e., empty state root).
            </summary>
            <param name="blockAction">An optional
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.</param>
            <param name="nativeTokenPredicate">A predicate function to determine whether
            the specified <see cref="T:Libplanet.Assets.Currency"/> is a native token defined by chain's
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/> or not.</param>
            <param name="stateStore">The <see cref="P:Libplanet.Blockchain.BlockChain`1.StateStore"/>.</param>
            <returns>The resulting <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.</returns>
            <remarks>This can be used with only genesis blocks.  For blocks with indices greater
            than zero, use <see cref="M:Libplanet.Blocks.PreEvaluationBlock`1.DetermineStateRootHash(Libplanet.Blockchain.BlockChain{`0})"/> overloaded one
            instead.</remarks>
            <exception cref="T:System.InvalidOperationException">Thrown when its
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Index"/> is not zero.</exception>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.DetermineStateRootHash(Libplanet.Action.IAction,System.Predicate{Libplanet.Assets.Currency},Libplanet.Store.IStateStore,System.Collections.Immutable.IImmutableDictionary{System.String,Bencodex.Types.IValue}@)">
            <summary>
            Evaluates all actions in the <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions"/> and
            a <paramref name="blockAction"/> (if any), and determines
            the <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/> from ground zero (i.e., empty state root).
            </summary>
            <param name="blockAction">An optional
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>.</param>
            <param name="nativeTokenPredicate">A predicate function to determine whether
            the specified <see cref="T:Libplanet.Assets.Currency"/> is a native token defined by chain's
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.NativeTokens"/> or not.</param>
            <param name="stateStore">The <see cref="P:Libplanet.Blockchain.BlockChain`1.StateStore"/>.</param>
            <param name="statesDelta">Returns made changes on states.</param>
            <returns>The resulting <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.</returns>
            <remarks>This can be used with only genesis blocks.  For blocks with indices greater
            than zero, use <see cref="M:Libplanet.Blocks.PreEvaluationBlock`1.DetermineStateRootHash(Libplanet.Blockchain.BlockChain{`0})"/> overloaded one
            instead.</remarks>
            <exception cref="T:System.InvalidOperationException">Thrown when its
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Index"/> is not zero.</exception>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.DetermineStateRootHash(Libplanet.Blockchain.BlockChain{`0})">
            <summary>
            Evaluates all actions in the <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions"/> and an optional
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>, and determines
            the <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.
            </summary>
            <param name="blockChain">The blockchain on which actions are evaluated based.</param>
            <returns>The resulting <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.</returns>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlock`1.DetermineStateRootHash(Libplanet.Blockchain.BlockChain{`0},Libplanet.Blockchain.StateCompleterSet{`0},System.Collections.Immutable.IImmutableDictionary{System.String,Bencodex.Types.IValue}@)">
            <summary>
            Evaluates all actions in the <see cref="P:Libplanet.Blocks.PreEvaluationBlock`1.Transactions"/> and an optional
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>, and determines
            the <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.
            </summary>
            <param name="blockChain">The blockchain on which actions are evaluated based.</param>
            <param name="stateCompleterSet">The <see cref="T:Libplanet.Blockchain.StateCompleterSet`1"/> to use when
            it needs states unevaluated yet.</param>
            <param name="statesDelta">Returns made changes on states.</param>
            <returns>The resulting <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/>.</returns>
        </member>
        <member name="T:Libplanet.Blocks.PreEvaluationBlockHeader">
            <summary>
            A block candidate without evaluating actions (in its transactions and a possible
            <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/>) and state root hash.
            </summary>
            <remarks>It guarantees that every instance of this type has a valid proof-of-work
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Nonce"/> which satisfies its <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Difficulty"/>.</remarks>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlockHeader.#ctor(Libplanet.Blocks.IPreEvaluationBlockHeader)">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/> by copying the fields of another
            pre-evaluation block <paramref name="header"/>.
            </summary>
            <remarks>
            <para>
            As <paramref name="header"/> needn't be an actual <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/>
            instance, but simply any object implementing <see cref="T:Libplanet.Blocks.IPreEvaluationBlockHeader"/>
            interface, it can't be trusted to satisfy all the constraints for a valid
            <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/> instance.  As such, conditions are checked again
            whilst creating a copy.  This is a relatively heavy operation, so must be used
            sparingly.
            </para>
            <para>
            In particular, this creates a new instance of
            <see cref="T:Libplanet.Blocks.BlockMetadata"/> with data extracted from <paramref name="header"/>.
            Thus any <see cref="T:System.Exception"/>s that can be thrown from a
            <see cref="T:Libplanet.Blocks.BlockMetadata"/>'s constructors may also be thrown in addition to the ones
            explicitly listed below.
            </para>
            </remarks>
            <param name="header">The pre-evaluation block header to copy.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException">Thrown when the given
            pre-evaluation <paramref name="header"/>'s
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/> is invalid.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockNonceException">Thrown when the given
            pre-evaluation <paramref name="header"/>'s
            <see cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/> does not satisfy the required
            <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.
            </exception>
            <seealso cref="T:Libplanet.Blocks.BlockMetadata"/>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlockHeader.#ctor(Libplanet.Blocks.BlockMetadata,System.ValueTuple{Libplanet.Nonce,System.Collections.Immutable.ImmutableArray{System.Byte}}@)">
            <summary>
            Creates a <see cref="T:Libplanet.Blocks.PreEvaluationBlockHeader"/> instance with its
            <paramref name="metadata"/> and a valid <paramref name="proof"/>.  All other public
            constructors should be redirected to this one.
            </summary>
            <param name="metadata">Block's metadata.</param>
            <param name="proof">A pair of the valid proof-of-work nonce which is probably considered
            as to satisfy the required <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Difficulty"/>, and the hash digest which is
            probably considered as to be derived from the block <paramref name="metadata"/> and the
            nonce.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException">Thrown when
            <paramref name="proof.PreEvaluationHash.PreEvaluationHash"/> is invalid.</exception>
            <exception cref="T:Libplanet.Blocks.InvalidBlockNonceException">Thrown when <paramref name="proof.Nonce.Nonce"/>
            does not satisfy the required <see cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>.</exception>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.Metadata">
            <summary>
            Internal <see cref="T:Libplanet.Blocks.BlockMetadata"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.Index">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.Timestamp">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.Miner">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.PublicKey">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.Difficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.TotalDifficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.PreviousHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.TxHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.Nonce">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.Nonce"/>
        </member>
        <member name="P:Libplanet.Blocks.PreEvaluationBlockHeader.PreEvaluationHash">
            <inheritdoc cref="P:Libplanet.Blocks.IPreEvaluationBlockHeader.PreEvaluationHash"/>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlockHeader.MakeCandidateData(Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Nullable{System.Collections.Immutable.ImmutableArray{System.Byte}})">
            <summary>
            Serializes data of a possible candidate shifted from it into a Bencodex dictionary.
            This data is used as the input to calculate the block <see cref="P:Libplanet.Blocks.Block`1.Hash"/>,
            rather than transmitting the block over the network.
            </summary>
            <param name="stateRootHash">The <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of
            the resulting states after evaluating transactions and
            a <see cref="P:Libplanet.Blockchain.Policies.IBlockPolicy`1.BlockAction"/> (if exists).</param>
            <param name="signature">The block signature created using <see cref="M:Libplanet.Blocks.PreEvaluationBlockHeader.MakeSignature(Libplanet.Crypto.PrivateKey,Libplanet.HashDigest{System.Security.Cryptography.SHA256})"/>
            method with the <paramref name="stateRootHash"/>.  This must be <see langword="null"/>
            for blocks with earlier <seealso cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/>s than 2.</param>
            <returns>The serialized block header in a Bencodex dictionary.</returns>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlockHeader.MakeSignature(Libplanet.Crypto.PrivateKey,Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Makes a signature of the block content with a <paramref name="stateRootHash"/> using
            the given <paramref name="privateKey"/>.
            </summary>
            <param name="privateKey">The miner's private key.  This must match to the block's
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.Miner"/> and <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.PublicKey"/>.</param>
            <param name="stateRootHash">The state root hash to include to the input message to
            sign.</param>
            <returns>The signature of the block content with a <paramref name="stateRootHash"/>
            using the given <paramref name="privateKey"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the block's
            <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> is less than 2.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="privateKey"/>
            does not match to the block miner's <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.PublicKey"/>.</exception>
            <remarks>As blocks have their signatures since the <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/> 2,
            it is not usable with blocks of the earlier <see cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/>s than 2.
            </remarks>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlockHeader.VerifySignature(System.Nullable{System.Collections.Immutable.ImmutableArray{System.Byte}},Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Verifies if the given block <paramref name="signature"/> is valid with the block
            content and the specified <paramref name="stateRootHash"/>.
            </summary>
            <param name="signature">The block signature created using <see cref="M:Libplanet.Blocks.PreEvaluationBlockHeader.MakeSignature(Libplanet.Crypto.PrivateKey,Libplanet.HashDigest{System.Security.Cryptography.SHA256})"/>
            method with the <paramref name="stateRootHash"/>.  This must be <see langword="null"/>
            for blocks with earlier <seealso cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/>s than 2.</param>
            <param name="stateRootHash">The state root hash included in the original message
            of the signature.</param>
            <returns><see langword="true"/> if the signature is valid.  <see langword="false"/>
            otherwise.</returns>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlockHeader.DeriveBlockHash(Libplanet.HashDigest{System.Security.Cryptography.SHA256}@,System.Nullable{System.Collections.Immutable.ImmutableArray{System.Byte}}@)">
            <summary>
            Derives a hash digest from the given pre-evaluation block header and
            <paramref name="stateRootHash"/>.
            </summary>
            <param name="stateRootHash">The state root hash.</param>
            <param name="signature">The block signature created using <see cref="M:Libplanet.Blocks.PreEvaluationBlockHeader.MakeSignature(Libplanet.Crypto.PrivateKey,Libplanet.HashDigest{System.Security.Cryptography.SHA256})"/>
            method with the <paramref name="stateRootHash"/>.  This must be <see langword="null"/>
            for blocks with earlier <seealso cref="P:Libplanet.Blocks.PreEvaluationBlockHeader.ProtocolVersion"/>s than 2.</param>
            <returns>A block hash.</returns>
        </member>
        <member name="M:Libplanet.Blocks.PreEvaluationBlockHeader.CheckPreEvaluationHash(Libplanet.Blocks.BlockMetadata,Libplanet.Nonce@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Verifies if the <paramref name="preEvaluationHash"/> is the proper hash digest
            derived from the given block <paramref name="metadata"/> and <paramref name="nonce"/>.
            If it's incorrect throws an <see cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException"/>.
            Throws nothing and returns a pair of the <paramref name="nonce"/> and
            <paramref name="preEvaluationHash"/> instead.
            </summary>
            <param name="metadata">The block metadata.</param>
            <param name="nonce">The proof-of-work nonce.</param>
            <param name="preEvaluationHash">The pre-evaluation hash digest to verify.</param>
            <exception cref="T:Libplanet.Blocks.InvalidBlockPreEvaluationHashException">Thrown when the given
            <paramref name="preEvaluationHash"/> is incorrect.</exception>
        </member>
        <member name="T:Libplanet.ByteArrayExtensions">
            <summary>
            This extension class enables some convenient methods to deal with byte array.
            </summary>
            <seealso cref="T:Libplanet.Address"/>
        </member>
        <member name="M:Libplanet.ByteArrayExtensions.StartsWith(System.Byte[],System.Byte[])">
            <summary>
            Determines whether the beginning of this byte array instance matches a specified string.
            </summary>
            <param name="bytes">A byte array to check.</param>
            <param name="prefix">The prefix byte array to compare.</param>
            <returns>
            true if <paramref name="prefix"/> matches the beginning of <paramref name="bytes"/>;
            otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="bytes"/> or <paramref name="prefix"/> is null.
            </exception>
        </member>
        <member name="T:Libplanet.ByteUtil">
            <summary>
            Utility methods to deal with <see cref="T:System.Byte"/> arrays.
            </summary>
        </member>
        <member name="M:Libplanet.ByteUtil.ParseHex(System.String)">
            <summary>
            Converts a hexadecimal string to a mutable <see cref="T:System.Byte"/> array.
            </summary>
            <param name="hex">A <see cref="T:System.String"/> which encodes
            <see cref="T:System.Byte"/>s in hexadecimal.  Its length must be zero or
            an even number.  It must not be <see langword="null"/>.</param>
            <returns>A <see cref="T:System.Byte"/> array that the given
            <paramref name="hex"/> string represented in hexadecimal.
            It lengthens the half of the given <paramref name="hex"/> string.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length
            of the given <paramref name="hex"/> string is an odd number.
            </exception>
            <exception cref="T:System.FormatException">Thrown when the given
            <paramref name="hex"/> string is not a valid hexadecimal string.
            </exception>
            <seealso cref="M:Libplanet.ByteUtil.ParseHexToImmutable(System.String)"/>
            <seealso cref="M:Libplanet.ByteUtil.Hex(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.ByteUtil.ParseHexToImmutable(System.String)">
            <summary>
            Converts a hexadecimal string to an immutable <see cref="T:System.Byte"/> array.
            </summary>
            <param name="hex">A <see cref="T:System.String"/> which encodes <see cref="T:System.Byte"/>s in
            hexadecimal.  Its length must be zero or an even number.  It must not be
            <see langword="null"/>.</param>
            <returns>A <see cref="T:System.Byte"/> array that the given <paramref name="hex"/> string
            represented in hexadecimal.  It lengthens the half of the given <paramref name="hex"/>
            string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given <paramref name="hex"/>
            string is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of the given
            <paramref name="hex"/> string is an odd number.</exception>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="hex"/> string
            is not a valid hexadecimal string.</exception>
            <seealso cref="M:Libplanet.ByteUtil.ParseHex(System.String)"/>
            <seealso cref="M:Libplanet.ByteUtil.Hex(System.Collections.Immutable.ImmutableArray{System.Byte}@)"/>
        </member>
        <member name="M:Libplanet.ByteUtil.Hex(System.Byte[])">
            <summary>
            Renders a hexadecimal string from a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">A <see cref="T:System.Byte"/> array to renders
            the corresponding hexadecimal string.
            </param>
            <returns>A hexadecimal string which encodes the given
            <paramref name="bytes"/>.</returns>
            <seealso cref="M:Libplanet.ByteUtil.Hex(System.Collections.Immutable.ImmutableArray{System.Byte}@)"/>
            <seealso cref="M:Libplanet.ByteUtil.ParseHex(System.String)"/>
        </member>
        <member name="M:Libplanet.ByteUtil.Hex(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Renders a hexadecimal string from a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">A <see cref="T:System.Byte"/> array to renders
            the corresponding hexadecimal string.
            </param>
            <returns>A hexadecimal string which encodes the given
            <paramref name="bytes"/>.</returns>
            <seealso cref="M:Libplanet.ByteUtil.Hex(System.Byte[])"/>
            <seealso cref="M:Libplanet.ByteUtil.ParseHexToImmutable(System.String)"/>
        </member>
        <member name="M:Libplanet.ByteUtil.CalculateHashCode(System.Byte[])">
            <summary>
            Calculates a deterministic hash code from a given
            <paramref name="bytes"/>.  It is mostly used to implement
            <see cref="M:System.Object.GetHashCode"/> method.
            </summary>
            <param name="bytes">A <see cref="T:System.Byte"/> array, which completely
            determines (or encodes) an object, to calculate a hash code.</param>
            <returns>A hash code determined from the given
            <paramref name="bytes"/>.  For equivalent <paramref name="bytes"/>,
            the same hash code is returned.  It must not be <see langword="null"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="bytes"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Libplanet.ByteUtil.TimingSafelyCompare(System.Collections.Generic.IReadOnlyList{System.Byte},System.Collections.Generic.IReadOnlyList{System.Byte})">
            <summary>
            Timing safe comparision of two byte arrays.
            </summary>
            <remarks>In case of two byte arrays do not have the same length, it tries to keep
            the timing dependent on the length of the shorter one.</remarks>
            <param name="left">A byte array.</param>
            <param name="right">Another byte array.</param>
            <returns><see langword="true"/> iff two byte arrays have the exactly same contents.
            </returns>
        </member>
        <member name="M:Libplanet.ByteUtil.Satisfies(System.Collections.Generic.IReadOnlyList{System.Byte},System.Int64)">
            <summary>
            Tests if a hash digest is less than the target computed for the given
            <paramref name="difficulty"/>).
            </summary>
            <param name="hashDigest">A hash digest to test.</param>
            <param name="difficulty">The difficulty to compute target number.</param>
            <returns><see langword="true"/> only if a digest is less than the target computed for
            the given <paramref name="difficulty"/>).  If <paramref name="difficulty"/> is <c>0</c>
            it always returns <see langword="true"/>.</returns>
        </member>
        <member name="T:Libplanet.Consensus.Validator">
            <summary>
            A class designed for a <see langword="Validator"/> of consensus.
            A <see cref="T:Libplanet.Consensus.Validator"/> consists of operator's <see cref="P:Libplanet.Consensus.Validator.PublicKey"/>
            and its corresponding <see langword="Power"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Consensus.Validator.#ctor(Libplanet.Crypto.PublicKey,System.Numerics.BigInteger)">
            <summary>
            Creates an instance of <see cref="T:Libplanet.Consensus.Validator"/>, with given <paramref name="publicKey"/>
            and <paramref name="power"/>.
            </summary>
            <param name="publicKey">The <see cref="T:Libplanet.Crypto.PublicKey"/>
            of validator operator.</param>
            <param name="power">The <see langword="Power"/> of validator operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="power"/> is
            negative.</exception>
        </member>
        <member name="P:Libplanet.Consensus.Validator.PublicKey">
            <summary>
            A <see cref="P:Libplanet.Consensus.Validator.PublicKey"/> of validator operator.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.Validator.Power">
            <summary>
            The <see langword="Power"/> of validator.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.Validator.OperatorAddress">
            <summary>
            An <see cref="T:Libplanet.Address"/> of the validator operator's <see cref="P:Libplanet.Consensus.Validator.PublicKey"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Consensus.Validator.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Consensus.Validator.Equals(Libplanet.Consensus.Validator)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Consensus.Validator.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Consensus.Validator.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Consensus.ValidatorSet">
            <summary>
            A wrapper class for a <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:Libplanet.Consensus.Validator"/>s.
            This standardizes the ordering of validators by <see cref="T:Libplanet.Address"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.#ctor">
            <summary>
            Creates an instance of an empty <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            to <see cref="P:Libplanet.Consensus.ValidatorSet.Validators"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.#ctor(System.Collections.Generic.List{Libplanet.Consensus.Validator})">
            <summary>
            Creates an instance of <see cref="T:Libplanet.Consensus.ValidatorSet"/>.  Given <paramref name="validators"/>
            is ordered internally by <see cref="T:Libplanet.Address"/> before getting assigned
            to <see cref="P:Libplanet.Consensus.ValidatorSet.Validators"/>.
            </summary>
            <param name="validators">The <see cref="T:System.Collections.Generic.List`1"/> of validators to use.</param>
            <exception cref="T:System.ArgumentException">Thrown when one of the following is true:
            <list type="bullet">
                <item><description>There is a duplicate among <see cref="T:Libplanet.Crypto.PublicKey"/>s for
                <paramref name="validators"/>.
                </description></item>
                <item><description>There is a <see cref="T:Libplanet.Consensus.Validator"/> with zero power.
                </description></item>
            </list>
            </exception>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.Validators">
            <summary>
            An <see cref="T:System.Collections.Immutable.ImmutableList`1"/> of validators.  This is guaranteed to be ordered
            by <see cref="T:Libplanet.Address"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.PublicKeys">
            <summary>
            An <see cref="T:System.Collections.Immutable.ImmutableList`1"/> of public keys of validators.
            This is guaranteed to be ordered by <see cref="T:Libplanet.Address"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.TotalCount">
            <summary>
            The total number of validators.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.TotalPower">
            <summary>
            The total power of validators.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.TwoThirdsCount">
            <summary>
            The two thirds of validator count, rounded down.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.TwoThirdsPower">
            <summary>
            The two thirds of validator total power, rounded down.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.OneThirdCount">
            <summary>
            The one third of validator count, rounded down.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.OneThirdPower">
            <summary>
            The one third of validator total power, rounded down.
            </summary>
        </member>
        <member name="P:Libplanet.Consensus.ValidatorSet.Item(System.Int32)">
            <summary>
            Gets the validator at given <paramref name="index"/>.
            </summary>
            <param name="index">The index to search.</param>
            <returns>The validator at given <paramref name="index"/>.</returns>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.Contains(Libplanet.Consensus.Validator)">
            <summary>
            Checks if given <paramref name="validator"/> is a member of <see cref="T:Libplanet.Consensus.ValidatorSet"/>.
            Checks both of <see cref="P:Libplanet.Consensus.Validator.PublicKey"/> and <see cref="P:Libplanet.Consensus.Validator.Power"/>.
            </summary>
            <param name="validator">The <see cref="T:Libplanet.Consensus.Validator"/> to check.</param>
            <returns><see langword="true"/> if given <paramref name="validator"/>
            is in <see cref="P:Libplanet.Consensus.ValidatorSet.Validators"/>, <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.Update(Libplanet.Consensus.Validator)">
            <summary>
            Creates a new <see cref="T:Libplanet.Consensus.ValidatorSet"/> that has been updated with
            given <paramref name="validator"/> according to the following rule:
            <list type="bullet">
                <item><description>
                    If <paramref name="validator"/>'s power is zero, the <see cref="T:Libplanet.Consensus.Validator"/>
                    with the same <see cref="T:Libplanet.Crypto.PublicKey"/> is removed, if it exists.
                    If no matching <see cref="T:Libplanet.Consensus.Validator"/> is found, no change is made.
                </description></item>
                <item><description>
                    If <paramref name="validator"/>'s power is positive, the <see cref="T:Libplanet.Consensus.Validator"/>
                    with the same <see cref="T:Libplanet.Crypto.PublicKey"/> is overwritten, if it exists.
                    If no matching <see cref="T:Libplanet.Consensus.Validator"/> is found, <paramref name="validator"/>
                    is added to the set.
                </description></item>
            </list>
            </summary>
            <param name="validator">The <see cref="T:Libplanet.Consensus.Validator"/> to update.</param>
            <returns>New <see cref="T:Libplanet.Consensus.ValidatorSet"/> updated with
            given <paramref name="validator"/>.</returns>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.Equals(Libplanet.Consensus.ValidatorSet)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Consensus.ValidatorSet.GetProposer(System.Int64,System.Int32)">
            <summary>
            Gets the proposer for a given context.
            </summary>
            <param name="height">The height of the context under consideration.</param>
            <param name="round">The round of the context under consideration.</param>
            <returns>A <see cref="T:Libplanet.Consensus.Validator"/> deterministically chosen from
            <see cref="P:Libplanet.Consensus.ValidatorSet.Validators"/>, <paramref name="height"/>, and <paramref name="round"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown when
            <see cref="P:Libplanet.Consensus.ValidatorSet.Validators"/> is empty.</exception>
        </member>
        <member name="T:Libplanet.Crypto.CryptoConfig">
            <summary>
            Libplanet cryptography configuration information.
            </summary>
        </member>
        <member name="P:Libplanet.Crypto.CryptoConfig.CryptoBackend">
            <summary>
            Global cryptography backend to sign and verify messages.
            </summary>
        </member>
        <member name="T:Libplanet.Crypto.ICryptoBackend`1">
            <summary>
            Cryptography backend interface.
            </summary>
            <typeparam name="T">A <see cref="T:System.Security.Cryptography.HashAlgorithm"/> which corresponds to a digest.</typeparam>
            <seealso cref="T:System.Security.Cryptography.HashAlgorithm"/>
        </member>
        <member name="M:Libplanet.Crypto.ICryptoBackend`1.Sign(Libplanet.HashDigest{`0},Libplanet.Crypto.PrivateKey)">
            <summary>
            Creates a signature from <paramref name="messageHash"/> with the corresponding
            <paramref name="privateKey"/>.
            </summary>
            <param name="messageHash">A 32 bytes message hash digest hashed with SHA256 to sign.
            </param>
            <param name="privateKey"><see cref="T:Libplanet.Crypto.PrivateKey"/> to sign
            <paramref name="messageHash"/>.
            </param>
            <returns> Created a signature from <paramref name="messageHash"/> with the corresponding
            <paramref name="privateKey"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Crypto.ICryptoBackend`1.Verify(Libplanet.HashDigest{`0},System.Byte[],Libplanet.Crypto.PublicKey)">
            <summary>
            Verifies whether a <paramref name="signature"/> was created from
            a <paramref name="messageHash"/> with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
            <param name="messageHash">A 32 bytes message hash digest hashed with SHA256.</param>
            <param name="signature">A signature that was created from the
            <paramref name="messageHash"/>.</param>
            <param name="publicKey"><see cref="T:Libplanet.Crypto.PublicKey"/> used for verification.</param>
            <returns><see langword="true"/> if the <paramref name="signature"/> was created
            from the <paramref name="messageHash"/> with the corresponding
            <see cref="T:Libplanet.Crypto.PrivateKey"/>. Otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.Exception">If any exception is thrown, the given
            <paramref name="signature"/> is considered as invalid.</exception>
        </member>
        <member name="T:Libplanet.Crypto.PrivateKey">
            <summary>
            A secret part of a key pair involved in
            <a href="https://en.wikipedia.org/wiki/ECDSA">ECDSA</a>, the digital
            signature algorithm on which the Libplanet is based.  It can be used to
            create signatures, which can be verified with the corresponding
            <see cref="T:Libplanet.Crypto.PublicKey"/>, as well as to decrypt
            messages which were encrypted with the corresponding
            <see cref="T:Libplanet.Crypto.PublicKey"/>.
            <para>Note that it uses <a href="https://en.bitcoin.it/wiki/Secp256k1"
            >secp256k1</a> as the parameters of the elliptic curve, which is
            the same to <a href="https://bitcoin.org/">Bitcoin</a> and
            <a href="https://www.ethereum.org/">Ethereum</a>.
            It means private keys generated for Bitcoin/Ethereum can be used by
            Libplanet-backed games/apps too.</para>
            </summary>
            <remarks>
            These (and any derived representations, e.g., <see cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>)
            must be kept secret, if they are exposed, an attacker will be able to
            forge signatures.
            <para>Every <see cref="T:Libplanet.Crypto.PrivateKey"/> object is immutable.</para>
            </remarks>
            <seealso cref="T:Libplanet.Crypto.PublicKey"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.#ctor">
            <summary>
            Generates a new unique <see cref="T:Libplanet.Crypto.PrivateKey"/> instance.
            It can be analogous to creating a new account in a degree.
            </summary>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.PrivateKey"/> instance from the given <see cref="T:System.Byte"/>s (i.e.,
            <paramref name="privateKey"/>), which encodes a valid
            <a href="https://en.wikipedia.org/wiki/ECDSA">ECDSA</a> private key.
            </summary>
            <param name="privateKey">A valid <see cref="T:System.Byte"/>s that encodes an ECDSA private key.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="privateKey"/> is too short or too long.</exception>
            <remarks>A valid <see cref="T:System.Byte"/> array for a <see cref="T:Libplanet.Crypto.PrivateKey"/> can be encoded
            using <see cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/> property.</remarks>
            <seealso cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.#ctor(System.String)">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.PrivateKey"/> instance from the given hexadecimal
            <see cref="T:System.String"/> (i.e.,<paramref name="hex"/>).
            </summary>
            <param name="hex">A hexadecimal string of a private key's
            <see cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given <paramref name="hex"/>
            string is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of the given
            <paramref name="hex"/> string is too short or too long.</exception>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="hex"/> string is
            not a valid hexadecimal string.</exception>
        </member>
        <member name="P:Libplanet.Crypto.PrivateKey.PublicKey">
            <summary>
            The corresponding <see cref="T:Libplanet.Crypto.PublicKey"/> of
            this private key.
            </summary>
        </member>
        <member name="P:Libplanet.Crypto.PrivateKey.ByteArray">
            <summary>
            An encoded <see cref="T:System.Byte"/> array representation.
            </summary>
            <remarks>
            An encoded <see cref="T:System.Byte"/> array representation can be recovered to a <see
            cref="T:Libplanet.Crypto.PrivateKey"/> instance again using <see cref="M:Libplanet.Crypto.PrivateKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/>
            constructor.
            <para>As like <see cref="T:Libplanet.Crypto.PrivateKey"/> instances, it also must be kept secret.
            In practice, this must not be sent over the network, and be securely stored in the file
            system.  If you just want to store the in-memory private key in the persistent storage,
            use <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/> or <see cref="T:Libplanet.KeyStore.Web3KeyStore"/>.
            </para>
            <para>To get a mutable array instead of immutable one, use <see cref="M:Libplanet.Crypto.PrivateKey.ToByteArray"/>
            method instead.</para>
            </remarks>
            <seealso cref="M:Libplanet.Crypto.PrivateKey.ToByteArray"/>
            <seealso cref="M:Libplanet.Crypto.PrivateKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.FromString(System.String)">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.PrivateKey"/> instance from hexadecimal string of bytes.
            </summary>
            <param name="hex">A hexadecimal string of a private key's
            <see cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>.</param>
            <returns>A created <see cref="T:Libplanet.Crypto.PrivateKey"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given <paramref name="hex"/>
            string is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of the given
            <paramref name="hex"/> string is too short or too long.</exception>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="hex"/> string is
            not a valid hexadecimal string.</exception>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.Sign(System.Byte[])">
            <summary>
            Creates a signature from the given <paramref name="message"/>.
            <para>
            A created signature can be verified by the corresponding
            <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/>.
            </para>
            <para>
            Signatures can be created by only the <see cref="T:Libplanet.Crypto.PrivateKey"/>
            which corresponds a <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> to verify these
            signatures.
            </para>
            <para>
            To sum up, a signature is used to guarantee:
            </para>
            <list type="bullet">
            <item><description>that the <paramref name="message"/> was created
            by someone possessing the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>,
            </description></item>
            <item><description>that the possessor cannot deny having sent the
            <paramref name="message"/>, and</description></item>
            <item><description>that the <paramref name="message"/> was not
            forged in the middle of transit.</description></item>
            </list>
            </summary>
            <param name="message">A message <see cref="T:System.Byte"/>s to sign.</param>
            <returns>A signature that proves the authenticity of the <paramref name="message"/>.
            It can be verified using <see cref="M:Libplanet.Crypto.PublicKey.Verify(System.Collections.Generic.IReadOnlyList{System.Byte},System.Collections.Generic.IReadOnlyList{System.Byte})"/> method.
            </returns>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Verify(System.Collections.Generic.IReadOnlyList{System.Byte},System.Collections.Generic.IReadOnlyList{System.Byte})"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.Sign(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Creates a signature from the given <paramref name="message"/>.
            <para>A created signature can be verified by the corresponding <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/>.
            </para>
            <para>Signatures can be created by only the <see cref="T:Libplanet.Crypto.PrivateKey"/> which corresponds
            a <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> to verify these signatures.</para>
            <para>To sum up, a signature is used to guarantee:</para>
            <list type="bullet">
            <item><description>that the <paramref name="message"/> was created by someone possessing
            the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>,</description></item>
            <item><description>that the possessor cannot deny having sent the
            <paramref name="message"/>, and</description></item>
            <item><description>that the <paramref name="message"/> was not forged in the middle of
            transit.</description></item>
            </list>
            </summary>
            <param name="message">A message <see cref="T:System.Byte"/>s to sign.</param>
            <returns>A signature that proves the authenticity of the <paramref name="message"/>.
            It can be verified using <see cref="M:Libplanet.Crypto.PublicKey.Verify(System.Collections.Generic.IReadOnlyList{System.Byte},System.Collections.Generic.IReadOnlyList{System.Byte})"/> method.
            </returns>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Verify(System.Collections.Generic.IReadOnlyList{System.Byte},System.Collections.Generic.IReadOnlyList{System.Byte})"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.Decrypt(System.Byte[])">
            <summary>
            Decrypts a <paramref name="ciphertext"/> which was encrypted with the corresponding
            <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> to the original plain text.
            </summary>
            <param name="ciphertext">The encrypted message.</param>
            <returns>The decrypted original message.</returns>
            <exception cref="T:Libplanet.Crypto.InvalidCiphertextException">Thrown when the given
            <paramref name="ciphertext"/> is invalid.</exception>
            <remarks>
            Although the parameter name <paramref name="ciphertext"/> has the
            word &#x201c;text&#x201d;, both a <paramref name="ciphertext"/> and a returned message
            are <see cref="T:System.Byte"/>s, not Unicode <see cref="T:System.String"/>s.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Encrypt(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.Decrypt(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Decrypts a <paramref name="ciphertext"/> which was encrypted with the corresponding
            <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> to the original plain text.
            </summary>
            <param name="ciphertext">The encrypted message.</param>
            <returns>The decrypted original message.</returns>
            <exception cref="T:Libplanet.Crypto.InvalidCiphertextException">Thrown when the given
            <paramref name="ciphertext"/> is invalid.</exception>
            <remarks>
            Although the parameter name <paramref name="ciphertext"/> has the
            word &#x201c;text&#x201d;, both a <paramref name="ciphertext"/> and a returned message
            are <see cref="T:System.Byte"/>s, not Unicode <see cref="T:System.String"/>s.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Encrypt(System.Collections.Immutable.ImmutableArray{System.Byte})"/>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.ExchangeKey(Libplanet.Crypto.PublicKey)">
            <summary>
            Securely exchange a <see cref="T:Libplanet.Crypto.SymmetricKey"/> with a peer's
            <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/>.
            Two parties can agree on a (new, unique, and typically temporal)
            key without revealing to any eavesdropping party what key has been
            agreed upon.
            <para>Technically it is <a href="https://en.wikipedia.org/wiki/ECDH"
            >ECDH</a>, a <a
            href="https://en.wikipedia.org/wiki/DH_key_exchange"
            >Diffie&#x2013;Hellman key exchange</a> of elliptic-curve version.
            </para>
            </summary>
            <param name="publicKey">The <see cref="P:Libplanet.Crypto.PrivateKey.PublicKey"/> possessed by
            a peer to whom exchange a private key with.</param>
            <returns>An exchanged (agreed) <see cref="T:Libplanet.Crypto.SymmetricKey"/>.
            Note that it is not an elliptic-curve private key, but an <a
            href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
            >AES</a> key.</returns>
        </member>
        <member name="M:Libplanet.Crypto.PrivateKey.ToByteArray">
            <summary>
            Encodes the private key into a corresponding mutable <see cref="T:System.Byte"/> array
            representation.
            </summary>
            <returns>An encoded <see cref="T:System.Byte"/> array representation.  It guarantees that
            returned arrays are never reused, and mutating on them does not affect
            <see cref="T:Libplanet.Crypto.PrivateKey"/> instance's internal states.</returns>
            <remarks>
            An encoded <see cref="T:System.Byte"/> array representation can be recovered to a <see
            cref="T:Libplanet.Crypto.PrivateKey"/> instance again using <see cref="M:Libplanet.Crypto.PrivateKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/>
            constructor.
            <para>As like <see cref="T:Libplanet.Crypto.PrivateKey"/> instances, it also must be kept secret.
            In practice, this must not be sent over the network, and be securely stored in the file
            system.  If you just want to store the in-memory private key in the persistent storage,
            use <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/> or <see cref="T:Libplanet.KeyStore.Web3KeyStore"/>.
            </para>
            <para>To get an immutable array instead of mutable one, use <see cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>
            property.</para>
            </remarks>
            <seealso cref="P:Libplanet.Crypto.PrivateKey.ByteArray"/>
            <seealso cref="M:Libplanet.Crypto.PrivateKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/>
        </member>
        <member name="T:Libplanet.Crypto.PublicKey">
            <summary>
            A public part of a key pair involved in
            <a href="https://en.wikipedia.org/wiki/ECDSA">ECDSA</a>, the digital
            signature algorithm on which the Libplanet is based.
            It can be used to verify signatures created with the corresponding
            <see cref="T:Libplanet.Crypto.PrivateKey"/> and to encrypt messages for someone
            possessing the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            This can be distributed publicly, hence the name.
            <para>Note that it uses <a href="https://en.bitcoin.it/wiki/Secp256k1"
            >secp256k1</a> as the parameters of the elliptic curve, which is same to
            <a href="https://bitcoin.org/">Bitcoin</a> and
            <a href="https://www.ethereum.org/">Ethereum</a>.
            It means public keys generated for Bitcoin/Ethereum can be used by
            Libplanet-backed games/apps too.</para>
            </summary>
            <remarks>Every <see cref="T:Libplanet.Crypto.PublicKey"/> object is immutable.</remarks>
            <seealso cref="T:Libplanet.Crypto.PrivateKey"/>
            <seealso cref="T:Libplanet.Address"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.PublicKey"/> instance from the given
            <see cref="T:System.Byte"/> array (i.e., <paramref name="publicKey"/>),
            which encodes a valid <a href="https://en.wikipedia.org/wiki/ECDSA">
            ECDSA</a> public key.
            </summary>
            <param name="publicKey">A valid <see cref="T:System.Byte"/> array that
            encodes an ECDSA public key.  It can be either compressed or
            not.</param>
            <remarks>A valid <see cref="T:System.Byte"/> array for
            a <see cref="T:Libplanet.Crypto.PublicKey"/> can be encoded using
            <see cref="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)"/> method.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)">
            <summary>
            Encodes this public key into a mutable <see cref="T:System.Byte"/> array representation.
            <para>To get an immutable one, use <see cref="M:Libplanet.Crypto.PublicKey.ToImmutableArray(System.Boolean)"/> method
            instead.</para>
            </summary>
            <param name="compress">Returns a short length representation if it is
            <see langword="true"/>.  This option does not lose any information.</param>
            <returns>An encoded mutable <see cref="T:System.Byte"/> array representation.  It can be
            recovered to a <see cref="T:Libplanet.Crypto.PublicKey"/> instance again using
            <see cref="M:Libplanet.Crypto.PublicKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/> constructor whether it is compressed
            or not.</returns>
            <seealso cref="M:Libplanet.Crypto.PublicKey.ToImmutableArray(System.Boolean)"/>
            <seealso cref="M:Libplanet.Crypto.PublicKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.ToImmutableArray(System.Boolean)">
            <summary>
            Encodes this public key into a immutable <see cref="T:System.Byte"/> array representation.
            <para>To get an mutable one, use <see cref="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)"/> method instead.</para>
            </summary>
            <param name="compress">Returns a short length representation if it is
            <see langword="true"/>.  This option does not lose any information.</param>
            <returns>An encoded immutable <see cref="T:System.Byte"/> array representation.  It can be
            recovered to a <see cref="T:Libplanet.Crypto.PublicKey"/> instance again using
            <see cref="M:Libplanet.Crypto.PublicKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/> constructor whether it is compressed
            or not.</returns>
            <seealso cref="M:Libplanet.Crypto.PublicKey.Format(System.Boolean)"/>
            <seealso cref="M:Libplanet.Crypto.PublicKey.#ctor(System.Collections.Generic.IReadOnlyList{System.Byte})"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.Encrypt(System.Byte[])">
            <summary>
            Encrypts a plaintext <paramref name="message"/> to a ciphertext, which can be decrypted
            with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
            <param name="message">A binary data to encrypt.</param>
            <returns>
            A ciphertext that was encrypted from the original <paramref name="message"/>.
            This can be decrypted with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey" />.
            </returns>
            <remarks>Although the word &#x201c;ciphertext&#x201d; has the word &#x201c;text&#x201d;,
            a returned ciphertext is not a Unicode <see cref="T:System.String"/>, but a mutable
            <see cref="T:System.Byte"/> array.</remarks>
            <seealso cref="M:Libplanet.Crypto.PrivateKey.Decrypt(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.Encrypt(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Encrypts a plaintext <paramref name="message"/> to a ciphertext, which can be decrypted
            with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
            <param name="message">A binary data to encrypt.</param>
            <returns>
            A ciphertext that was encrypted from the original <paramref name="message"/>.
            This can be decrypted with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey" />.
            </returns>
            <remarks>Although the word &#x201c;ciphertext&#x201d; has the word &#x201c;text&#x201d;,
            a returned ciphertext is not a Unicode <see cref="T:System.String"/>, but a mutable
            <see cref="T:System.Byte"/> array.</remarks>
            <seealso cref="M:Libplanet.Crypto.PrivateKey.Decrypt(System.Collections.Immutable.ImmutableArray{System.Byte})"/>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.Verify(System.Collections.Generic.IReadOnlyList{System.Byte},System.Collections.Generic.IReadOnlyList{System.Byte})">
            <summary>
            Verifies whether a <paramref name="signature"/> proves authenticity of
            <paramref name="message"/> with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
            <param name="message">A original plaintext message that the <paramref name="signature"/>
            tries to prove its authenticity.  I.e., an argument data passed to
            <see cref="M:Libplanet.Crypto.PrivateKey.Sign(System.Byte[])"/> or <see
            cref="M:Libplanet.Crypto.PrivateKey.Sign(System.Collections.Immutable.ImmutableArray{System.Byte})" /> methods.</param>
            <param name="signature">A signature which tries to authenticity of
            <paramref name="message"/>.  I.e., a data that <see cref="M:Libplanet.Crypto.PrivateKey.Sign(System.Byte[])"/> or
            <see cref="M:Libplanet.Crypto.PrivateKey.Sign(System.Collections.Immutable.ImmutableArray{System.Byte})"/> methods returned.</param>
            <returns><see langword="true"/> if the <paramref name="signature"/> proves authenticity
            of the <paramref name="message"/> with the corresponding <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Libplanet.Crypto.PublicKey.ToString">
            <summary>
            Gets the public key's hexadecimal representation in compressed form.
            </summary>
            <returns>The hexadecimal string of the public key's compressed bytes.</returns>
        </member>
        <member name="T:Libplanet.Crypto.SymmetricKey">
            <summary>
            An <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
            >AES</a>-<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"
            >GCM</a> <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm"
            >symmetric key</a>.  Unlike <see cref="T:Libplanet.Crypto.PrivateKey"/> and
            <see cref="T:Libplanet.Crypto.PublicKey"/> that are involved in an asymmetric key
            cryptography, it uses the same <see cref="T:Libplanet.Crypto.SymmetricKey"/> for both
            encrypting a plaintext and decrypting a ciphertext.
            </summary>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.#ctor(System.Byte[])">
            <summary>
            Creates a <see cref="T:Libplanet.Crypto.SymmetricKey"/> instance from the given
            <see cref="T:System.Byte"/> array (i.e., <paramref name="key"/>),
            which encodes a valid <a
            href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
            >AES</a>-<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"
            >GCM</a> <a
            href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm"
            >symmetric key</a>.
            </summary>
            <param name="key">A valid <see cref="T:System.Byte"/> array that
            encodes an AES-GCM symmetric key.
            </param>
            <remarks>A valid <see cref="T:System.Byte"/> array for
            a <see cref="T:Libplanet.Crypto.SymmetricKey"/> can be encoded using
            <see cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/> method.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/>
        </member>
        <member name="P:Libplanet.Crypto.SymmetricKey.ByteArray">
            <summary>
            An immutable <see cref="T:System.Byte"/> array encoding of this key.
            </summary>
            <remarks>This is immutable.  For a mutable array, call
            <see cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/> method.</remarks>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.Encrypt(System.Byte[],System.Byte[])">
            <summary>
            Converts a plain <paramref name="message"/> to a ciphertext
            which can be decrypted with the same key.
            </summary>
            <param name="message">A binary data to be encrypted.</param>
            <param name="nonSecret">An extra data not to be encrypted, but
            to be just transmitted as is.  The default value is <see langword="null"/>,
            which means empty.</param>
            <returns>
            A ciphertext that was encrypted from the <paramref name="message"/>
            and can be decrypted with the same key.
            (Although the word &#x201c;ciphertext&#x201d; has the word
            &#x201c;text&#x201d;, a returned ciphertext is not a Unicode
            <see cref="T:System.String"/>, but a <see cref="T:System.Byte"/> array.)
            </returns>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.Decrypt(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.Decrypt(System.Byte[],System.Int32)">
            <summary>
            Converts a <paramref name="ciphertext"/> which was encrypted with
            the same key to the plain message.
            </summary>
            <param name="ciphertext">The encrypted data.</param>
            <param name="nonSecretLength">The length of <c>nonSecret</c> data.
            (See also <see cref="M:Libplanet.Crypto.SymmetricKey.Encrypt(System.Byte[],System.Byte[])"/> method's the second
            parameter, which is optional.)  <c>0</c> by default.</param>
            <returns>The plain data the <paramref name="ciphertext"/> encrypted.
            It returns <see langword="null"/> if the <paramref name="ciphertext"/> is
            invalid (this behavior will be eventually changed in the future to
            throw an exception instead).</returns>
            <remarks>
            Although the parameter name <paramref name="ciphertext"/> has the
            word &#x201c;text&#x201d;, both a <paramref name="ciphertext"/>
            and a returned message are a <see cref="T:System.Byte"/> string,
            not a Unicode <see cref="T:System.String"/>.
            </remarks>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.Encrypt(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:Libplanet.Crypto.SymmetricKey.ToByteArray">
            <summary>
            Gets a mutable <see cref="T:System.Byte"/> array which encodes this key.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array which encodes this
            key.  Since it is created every time the method is called, any
            mutation on that does not affect this <see cref="T:Libplanet.Crypto.SymmetricKey"/>
            object.</returns>
            <seealso cref="P:Libplanet.Crypto.SymmetricKey.ByteArray"/>
            <seealso cref="M:Libplanet.Crypto.SymmetricKey.#ctor(System.Byte[])"/>
        </member>
        <member name="M:Libplanet.EnumerableExtensions.Greatest``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Similar to <see
            cref="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
            method, but it returns the source element with the maximum value of the given
            <paramref name="selector"/>, instead of the maximum value.
            </summary>
            <param name="source">The source enumerable.</param>
            <param name="selector">A function to select the value to compare.</param>
            <typeparam name="TSource">The type of the source elements.</typeparam>
            <typeparam name="TComparable">The type of the value to compare.</typeparam>
            <returns>The source element with the maximum value of the given
            <paramref name="selector"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the source sequence is empty.
            </exception>
        </member>
        <member name="T:Libplanet.EnumerableMeasurement">
            <summary>
            Extension methods for measuring exact evaluation time of lazy <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            objects.
            </summary>
        </member>
        <member name="M:Libplanet.EnumerableMeasurement.OnBeforeAndAfter``1(System.Collections.Generic.IEnumerable{``0},System.Action,System.Action)">
            <summary>
            Invokes the specified actions before and after the actual evaluation of the specified
            <paramref name="enumerable"/> object.
            </summary>
            <example><![CDATA[
            Console.WriteLine("Before GetStream() call.");
            IEnumerable<int> stream = GetStream().OnBeforeAndAfter(
                before: () => Console.WriteLine("Before enumeration."),
                after: () => Console.WriteLine("After enumeration.")
            );
            Console.WriteLine("After GetStream() call.");
            foreach (int i in stream) Console.WriteLine("Enumerating... {0}", i);
            // Output:
            // Before GetStream() call.
            // After GetStream() call.
            // Before enumeration.
            // Enumerating... 1
            // Enumerating... 2
            // ...
            // After enumeration.
            ]]></example>
            <param name="enumerable">An enumerable object.</param>
            <param name="before">An action to be invoked right before enumeration.</param>
            <param name="after">An action to be invoked right after enumeration.</param>
            <typeparam name="T">The type of the elements of <paramref name="enumerable"/>.
            </typeparam>
            <returns>Equivalent to <paramref name="enumerable"/>.</returns>
        </member>
        <member name="M:Libplanet.EnumerableMeasurement.WithMeasuringTime``1(System.Collections.Generic.IEnumerable{``0},System.Action{System.Diagnostics.Stopwatch})">
            <summary>
            Measures how long it takes to actually evaluate the specified
            <paramref name="enumerable"/> and then reports the elapsed time through
            the specified <paramref name="onMeasured"/> callback.
            </summary>
            <example><![CDATA[
            IEnumerable<int> stream = GetStream().WithMeasuringTime(
                elapsed => Console.WriteLine("Elapsed time: {0} ms", elapsed.ElapsedMilliseconds)
            );
            foreach (int i in stream) Console.WriteLine("Enumerating... {0}", i);
            // Output:
            // Enumerating... 1
            // Enumerating... 2
            // ...
            // Elapsed time: ... ms
            ]]></example>
            <param name="enumerable">An enumerable object.</param>
            <param name="onMeasured">A callback to be invoked when the enumeration and its
            measurement is done.  A <see cref="T:System.Diagnostics.Stopwatch"/> instance is passed as the
            first argument to the callback.</param>
            <typeparam name="T">The type of the elements of <paramref name="enumerable"/>.
            </typeparam>
            <returns>Equivalent to <paramref name="enumerable"/>.</returns>
        </member>
        <member name="T:Libplanet.FixedSizedQueue`1">
            <summary>
            Equivalent to <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, except this does not accept more than
            the specified maximum size.
            </summary>
            <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
        </member>
        <member name="F:Libplanet.FixedSizedQueue`1._syncObject">
            <summary>
            Simple object for thread synchronization.
            </summary>
        </member>
        <member name="M:Libplanet.FixedSizedQueue`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Libplanet.FixedSizedQueue`1"/>
            with the specified <paramref name="size"/>.
            </summary>
            <param name="size">The maximum size of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.</param>
        </member>
        <member name="P:Libplanet.FixedSizedQueue`1.Size">
            <summary>
            Gets the fixed size of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.
            </summary>
        </member>
        <member name="M:Libplanet.FixedSizedQueue`1.Enqueue(`0)">
            <summary>
            Adds an object at the end of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.
            </summary>
            <param name="obj">The object to add at the
            end of the <see cref="T:Libplanet.FixedSizedQueue`1"/>.</param>
        </member>
        <member name="T:Libplanet.HashAlgorithmType">
            <summary>
            Represents the type of <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.
            <para>It is guaranteed that only one instance is created for the same subclass of
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.</para>
            </summary>
        </member>
        <member name="P:Libplanet.HashAlgorithmType.Type">
            <summary>
            The <see cref="P:Libplanet.HashAlgorithmType.Type"/> object which refers to a subclass of
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.
            </summary>
        </member>
        <member name="P:Libplanet.HashAlgorithmType.DigestSize">
            <summary>
            The length of bytes of every digest that the <see cref="T:Libplanet.HashAlgorithmType"/> makes.
            </summary>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.op_Equality(Libplanet.HashAlgorithmType,Libplanet.HashAlgorithmType)">
            <summary>
            Checks if two <see cref="T:Libplanet.HashAlgorithmType"/>s refers to the same
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/> class.
            </summary>
            <param name="left">An instance.</param>
            <param name="right">Another instance.</param>
            <returns><see langword="true"/> iff two operands refers to the same
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/> class.</returns>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.op_Inequality(Libplanet.HashAlgorithmType,Libplanet.HashAlgorithmType)">
            <summary>
            Checks if two <see cref="T:Libplanet.HashAlgorithmType"/>s do not refer to the different
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/> class.
            </summary>
            <param name="left">An instance.</param>
            <param name="right">Another instance.</param>
            <returns><see langword="false"/> iff two operands refers to the same
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/> class.</returns>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.Of``1(``0)">
            <summary>
            Creates a <see cref="T:Libplanet.HashAlgorithmType"/> which refers to <typeparamref name="T"/>.
            </summary>
            <param name="objectToInferType">An optional object to make the compiler infers the
            type parameter <typeparamref name="T"/> from this.  Note that the value in itself is
            never used at runtime.</param>
            <typeparam name="T">A subclass of <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.</typeparam>
            <returns>A <see cref="T:Libplanet.HashAlgorithmType"/> which refers to <typeparamref name="T"/>.
            </returns>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.Digest(System.Byte[])">
            <summary>
            Computes a hash digest of the hash algorithm from the given
            <paramref name="input"/> bytes.
            </summary>
            <param name="input">The bytes to compute its hash.</param>
            <returns>The hash digest derived from <paramref name="input"/>.</returns>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.Digest(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Computes a hash digest of the hash algorithm from the given
            <paramref name="input"/> bytes.
            </summary>
            <param name="input">The bytes to compute its hash.</param>
            <returns>The hash digest derived from <paramref name="input"/>.</returns>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.Digest(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Computes a hash digest of the hash algorithm from the given <paramref name="chunks"/> of
            input bytes.
            </summary>
            <param name="chunks">The chunks of bytes to compute its hash.</param>
            <returns>The hash digest derivied from input <paramref name="chunks"/>.</returns>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.Digest(System.Collections.Generic.IEnumerable{System.Collections.Immutable.ImmutableArray{System.Byte}})">
            <summary>
            Computes a hash digest of the hash algorithm from the given <paramref name="chunks"/> of
            input bytes.
            </summary>
            <param name="chunks">The chunks of bytes to compute its hash.</param>
            <returns>The hash digest derivied from input <paramref name="chunks"/>.</returns>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.Equals(Libplanet.HashAlgorithmType)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.HashAlgorithmType.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Hashcash">
            <summary>
            This contains a set of functions that implements
            <a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a>,
            a <a href="https://en.wikipedia.org/wiki/Proof-of-work_system"
            >proof-of-work system</a>.
            </summary>
        </member>
        <member name="T:Libplanet.Hashcash.Stamp">
            <summary>
            A delegate to determine a consistent <see cref="T:System.Byte"/>s
            representation derived from a given <paramref name="nonce"/>.
            <para>Since it is called multiple times with different
            <paramref name="nonce"/>s for
            <a href="https://en.wikipedia.org/wiki/Proof-of-work_system"
            >proof-of-work system</a>, the total time an implementation elapses
            should not vary for different <paramref name="nonce"/>s.</para>
            </summary>
            <param name="nonce">An arbitrary nonce for an attempt, provided by
            <see cref="M:Libplanet.Hashcash.Answer(Libplanet.Hashcash.Stamp,Libplanet.HashAlgorithmType,System.Int64,System.Int32,System.Threading.CancellationToken)"/> method.
            </param>
            <returns>Chunked <see cref="T:System.Byte"/>s determined from the given <paramref name="nonce"/>.
            It should return consistently equivalent bytes for equivalent <paramref name="nonce"/>
            values.  The way how bytes are split into chunks can be flexible; regardless of the way,
            they are concatenated into a single byte array.</returns>
            <seealso cref="M:Libplanet.Hashcash.Answer(Libplanet.Hashcash.Stamp,Libplanet.HashAlgorithmType,System.Int64,System.Int32,System.Threading.CancellationToken)"/>
            <seealso cref="T:Libplanet.Nonce"/>
        </member>
        <member name="M:Libplanet.Hashcash.Answer(Libplanet.Hashcash.Stamp,Libplanet.HashAlgorithmType,System.Int64,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Finds a <see cref="T:Libplanet.Nonce"/> that satisfies the given
            <paramref name="difficulty"/>.  This process is so-called
            &#x0201c;<a
            href="https://en.wikipedia.org/wiki/Cryptocurrency#Mining"
            >mining</a>&#x0201d;.
            </summary>
            <param name="stamp">A callback to get a &#x0201c;stamp&#x0201d;
            which is a <see cref="T:System.Byte"/> array determined from a given
            <see cref="T:Libplanet.Nonce"/> value.</param>
            <param name="hashAlgorithmType">The hash algorithm to use.</param>
            <param name="difficulty">A number to calculate the target number
            for which the returned answer should be less than.</param>
            <param name="seed">The seed number for random generator.</param>
            <param name="cancellationToken">
            A cancellation token used to propagate notification that this
            operation should be canceled.
            </param>
            <returns>A pair of <see cref="T:Libplanet.Nonce"/> value which satisfies the
            given <paramref name="difficulty"/>, and the succeeded hash
            digest.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when the specified
            <paramref name="cancellationToken"/> received a cancellation request.</exception>
            <seealso cref="T:Libplanet.Hashcash.Stamp"/>
        </member>
        <member name="T:Libplanet.HashDigest`1">
            <summary>
            A value type to represent digest bytes determined by a
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.  For more type safety, it takes
            a type parameter <typeparamref name="T"/> of
            <see cref="T:System.Security.Cryptography.HashAlgorithm"/>.
            </summary>
            <typeparam name="T">A <see cref="T:System.Security.Cryptography.HashAlgorithm"/> which corresponds to
            a digest.  This determines <see cref="F:Libplanet.HashDigest`1.Size"/> of a digest.</typeparam>
            <seealso cref="T:System.Security.Cryptography.HashAlgorithm"/>
        </member>
        <member name="F:Libplanet.HashDigest`1.Size">
            <summary>
            The fixed, and valid <see cref="P:System.Array.Length"/> of
            a <see cref="T:System.Byte"/> array of every digest.
            <para>This varies depending upon what <see cref="T:System.Security.Cryptography.HashAlgorithm"/> is
            used for <typeparamref name="T"/>.  For example, if <typeparamref
            name="T"/> is <see cref="T:System.Security.Cryptography.SHA1"/> <see cref="F:Libplanet.HashDigest`1.Size"/> is <c>20</c>,
            and if <see cref="T:System.Security.Cryptography.SHA256"/> it is <c>32</c>.</para>
            </summary>
        </member>
        <member name="M:Libplanet.HashDigest`1.#ctor(System.Byte[])">
            <summary>
            Converts a <see cref="T:System.Byte"/> array into a
            <see cref="T:Libplanet.HashDigest`1"/>.
            </summary>
            <param name="hashDigest">A <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.HashDigest`1"/>.  It must not be <see langword="null"/>,
            and its <see cref="P:System.Array.Length"/> must be the same to
            <see cref="F:Libplanet.HashDigest`1.Size"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hashDigest"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hashDigest"/>'s <see cref="P:System.Array.Length"/> is not
            the same to the <see cref="F:Libplanet.HashDigest`1.Size"/> the hash algorithm
            (i.e., <typeparamref name="T"/> requires.</exception>
        </member>
        <member name="M:Libplanet.HashDigest`1.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Converts an immutable <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.HashDigest`1"/>.
            </summary>
            <param name="hashDigest">An immutable <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.HashDigest`1"/>.  It must not be <see langword="null"/>, and its
            <see cref="P:System.Array.Length"/> must be the same to <see cref="F:Libplanet.HashDigest`1.Size"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hashDigest"/>'s <see cref="P:System.Collections.Immutable.ImmutableArray`1.Length"/> is not
            the same to the <see cref="F:Libplanet.HashDigest`1.Size"/> the hash algorithm
            (i.e., <typeparamref name="T"/>) requires.</exception>
        </member>
        <member name="P:Libplanet.HashDigest`1.ByteArray">
            <summary>
            A bare immutable <see cref="T:System.Byte"/> array of the digest.
            </summary>
            <remarks>It is immutable.  For a mutable array, use
            <see cref="M:Libplanet.HashDigest`1.ToByteArray"/> method instead.</remarks>
            <seealso cref="M:Libplanet.HashDigest`1.ToByteArray"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.FromString(System.String)">
            <summary>
            Converts a given hexadecimal representation of a digest into
            a <see cref="T:Libplanet.HashDigest`1"/> object.
            <para>This is an inverse function of <see cref="M:Libplanet.HashDigest`1.ToString"/>
            method.</para>
            </summary>
            <param name="hexDigest">A hexadecimal representation of
            a <see cref="T:Libplanet.HashDigest`1"/>.</param>
            <returns>A corresponding <see cref="T:Libplanet.HashDigest`1"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hexDigest"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hexDigest"/>'s length is not the double of
            the <see cref="F:Libplanet.HashDigest`1.Size"/>, the hash algorithm
            (i.e., <typeparamref name="T"/> requires.</exception>
            <seealso cref="M:Libplanet.HashDigest`1.ToString"/>
            <seealso cref="M:Libplanet.HashDigestExtensions.ToHashDigest``1(System.String)"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.DeriveFrom(System.Byte[])">
            <summary>
            Computes a hash digest of the algorithm <typeparamref name="T"/> from the given
            <paramref name="input"/> bytes.
            </summary>
            <param name="input">The bytes to compute its hash.</param>
            <returns>The hash digest derived from <paramref name="input"/>.</returns>
        </member>
        <member name="M:Libplanet.HashDigest`1.DeriveFrom(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Computes a hash digest of the algorithm <typeparamref name="T"/> from the given
            <paramref name="input"/> bytes.
            </summary>
            <param name="input">The bytes to compute its hash.</param>
            <returns>The hash digest derived from <paramref name="input"/>.</returns>
        </member>
        <member name="M:Libplanet.HashDigest`1.DeriveFrom(System.ReadOnlySpan{System.Byte})">
            <summary>
            Computes a hash digest of the algorithm <typeparamref name="T"/> from the given
            <paramref name="input"/> bytes.
            </summary>
            <param name="input">The bytes to compute its hash.</param>
            <returns>The hash digest derived from <paramref name="input"/>.</returns>
        </member>
        <member name="M:Libplanet.HashDigest`1.ToByteArray">
            <summary>
            Gets a bare mutable <see cref="T:System.Byte"/> array of the digest.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array of the digest.
            Since a returned array is created every time the method is called,
            any mutations on that array does not affect to the digest object.
            </returns>
            <seealso cref="P:Libplanet.HashDigest`1.ByteArray"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.ToString">
            <summary>
            Gets a hexadecimal representation of a digest.
            <para>This is an inverse function of <see cref="M:Libplanet.HashDigest`1.FromString(System.String)"/>.
            </para>
            </summary>
            <returns>A hexadecimal representation of a digest.</returns>
            <seealso cref="M:Libplanet.HashDigest`1.FromString(System.String)"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.Equals(Libplanet.HashDigest{`0})">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.HashDigest`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.HashDigestExtensions">
            <summary>
            Augments types to have some shortcut methods dealing with
            <see cref="T:Libplanet.HashDigest`1"/> values.
            </summary>
        </member>
        <member name="M:Libplanet.HashDigestExtensions.ToHashDigest``1(System.String)">
            <summary>
            Converts a given hexadecimal representation of a digest into
            a <see cref="T:Libplanet.HashDigest`1"/> object.
            <para>This is a shortcut of
            <see cref="M:Libplanet.HashDigest`1.FromString(System.String)"/> method.</para>
            <para>This is an inverse function of
            <see cref="M:Libplanet.HashDigest`1.ToString"/> method.</para>
            </summary>
            <param name="hexDigest">A hexadecimal representation of
            a <see cref="T:Libplanet.HashDigest`1"/>.</param>
            <typeparam name="T">A <see cref="T:System.Security.Cryptography.HashAlgorithm"/> which corresponds
            to a digest.</typeparam>
            <returns>A corresponding <see cref="T:Libplanet.HashDigest`1"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="hexDigest"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hexDigest"/>'s length is not the double of
            the <see cref="F:Libplanet.HashDigest`1.Size"/>, the hash algorithm
            (i.e., <typeparamref name="T"/> requires.</exception>
            <seealso cref="M:Libplanet.HashDigest`1.FromString(System.String)"/>
            <seealso cref="M:Libplanet.HashDigest`1.ToString"/>
        </member>
        <member name="T:Libplanet.KeyStore.Ciphers.Aes128Ctr">
            <summary>
            AES-128-CTR (AES 128-bit in counter moder).
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.#ctor(System.Byte[])">
            <summary>
            Creates an <see cref="T:Libplanet.KeyStore.Ciphers.Aes128Ctr"/> instance with the given <paramref name="iv"/>.
            </summary>
            <param name="iv">Initialization vector.</param>
            <exception cref="T:System.ArgumentException">Thrown when the length of <paramref name="iv"/> is
            invalid.</exception>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Creates an <see cref="T:Libplanet.KeyStore.Ciphers.Aes128Ctr"/> instance with the given <paramref name="iv"/>.
            </summary>
            <param name="iv">Initialization vector.</param>
            <exception cref="T:System.ArgumentException">Thrown when the length of <paramref name="iv"/> is
            invalid.</exception>
        </member>
        <member name="P:Libplanet.KeyStore.Ciphers.Aes128Ctr.Iv">
            <summary>
            Initialization vector.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.Encrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.Decrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.Aes128Ctr.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.KeyStore.Ciphers.ICipher">
            <summary>
            An interface to define symmetric cipher algorithm.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.ICipher.Encrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Encrypts the given <paramref name="plaintext"/> using the given <paramref name="key"/>.
            </summary>
            <param name="key">A symmetric key.</param>
            <param name="plaintext">An immutable <see cref="T:System.Byte"/> array to encrypt.</param>
            <returns>The ciphertext made from the <paramref name="plaintext"/>
            using the <paramref name="key"/>.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.ICipher.Decrypt(System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Decrypts the given <paramref name="ciphertext"/> using the given <paramref name="key"/>.
            </summary>
            <param name="key">A symmetric key.</param>
            <param name="ciphertext">An immutable <see cref="T:System.Byte"/> array to decrypt.</param>
            <returns>The plain text decrypted from the <paramref name="ciphertext"/>
            using the <paramref name="key"/>.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.Ciphers.ICipher.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <summary>
            Dumps the cipher parameters as a JSON representation according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="writer">A JSON writer which has not begun object nor array.</param>
            <returns>A unique identifier of the cipher algorithm.  This is going to be the
            <c>crypto.cipher</c> field in the key JSON file.</returns>
        </member>
        <member name="T:Libplanet.KeyStore.IKeyStore">
            <summary>
            The interface to store <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>s.  An appropriate implementation
            should be used according to a running platform.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.ListIds">
            <summary>
            Lists all keys IDs in the key store.
            </summary>
            <returns>All keys IDs in the key store.  The order is undefined and not deterministic.
            </returns>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.List">
            <summary>
            Lists all keys in the key store.
            </summary>
            <returns>All keys in the key store.  The order is undefined and not deterministic.
            </returns>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.Get(System.Guid)">
            <summary>
            Looks for a key having the requested <paramref name="id"/> in the key store.
            </summary>
            <param name="id">The key ID to look for.</param>
            <returns>The found key.</returns>
            <exception cref="T:Libplanet.KeyStore.NoKeyException">Thrown when there are no key of the given
            <paramref name="id"/>.</exception>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.Add(Libplanet.KeyStore.ProtectedPrivateKey)">
            <summary>
            Adds a new <paramref name="key"/> into the key store.
            </summary>
            <param name="key">A key to add.</param>
            <returns>The id of the added <paramref name="key"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <see langword="null"/> is passed to
            <paramref name="key"/>.</exception>
        </member>
        <member name="M:Libplanet.KeyStore.IKeyStore.Remove(System.Guid)">
            <summary>
            Removes a key having the given <pramref name="id"/> from the key store.
            </summary>
            <param name="id">The key ID to remove.</param>
            <exception cref="T:Libplanet.KeyStore.NoKeyException">Thrown when there is no key having
            the given <paramref name="id"/>.</exception>
        </member>
        <member name="T:Libplanet.KeyStore.IncorrectPassphraseException">
            <summary>
            The exception that is thrown when a user input passphrase (i.e., password) is incorrect.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.IncorrectPassphraseException.#ctor(System.String,System.String,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.IncorrectPassphraseException"/> object.
            </summary>
            <param name="message">The error message that explains the reason for the exception.
            </param>
            <param name="paramName">The name of the parameter that caused the current exception.
            </param>
            <param name="expectedMac">The expected MAC of the correct passphrase.
            It is automatically included to the <paramref name="message"/> string.</param>
            <param name="inputMac">The actual MAC of the user input passphrase.
            It is automatically included to the <paramref name="message"/> string.</param>
        </member>
        <member name="P:Libplanet.KeyStore.IncorrectPassphraseException.ExpectedMac">
            <summary>
            The expected MAC of the correct passphrase.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.IncorrectPassphraseException.InputMac">
            <summary>
            The actual MAC of the user input passphrase.
            </summary>
        </member>
        <member name="T:Libplanet.KeyStore.InvalidKeyJsonException">
            <summary>
            The exception that is thrown when a key JSON is invalid, e.g., missing field.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.InvalidKeyJsonException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.InvalidKeyJsonException"/> instance.
            </summary>
            <param name="message">A detailed exception message.</param>
        </member>
        <member name="T:Libplanet.KeyStore.Kdfs.IKdf">
            <summary>
            An interface to form key derivation functions (KDF) that are used to derive a valid
            cryptographic key from a user input passphrase (i.e., password).
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.IKdf.Derive(System.String)">
            <summary>
            Derives a cryptographic key in <see cref="T:System.Byte"/>s from a user input
            <paramref name="passphrase"/>.
            </summary>
            <param name="passphrase">A user input passphrase.</param>
            <returns>A derived cryptographic key.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.IKdf.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <summary>
            Dumps the KDF parameters as a JSON representation.
            </summary>
            <param name="writer">A JSON writer which has not begun object nor array.</param>
            <returns>A unique identifier of the KDF.  This is going to be the
            <c>crypto.kdf</c> field in the key JSON file.</returns>
        </member>
        <member name="T:Libplanet.KeyStore.Kdfs.Pbkdf2`1">
            <summary>
            <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>.
            </summary>
            <typeparam name="T">PRF (pseudorandom function) to use, e.g.,
            <see cref="T:Org.BouncyCastle.Crypto.Digests.Sha256Digest"/>.</typeparam>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.#ctor(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>.
            </summary>
            <param name="iterations">The number of iterations desired.
            Corresponds to <c>c</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>.
            </summary>
            <param name="iterations">The number of iterations desired.
            Corresponds to <c>c</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Pbkdf2`1.Iterations">
            <summary>
            The number of iterations desired.  Corresponds to <c>c</c>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Pbkdf2`1.KeyLength">
            <summary>
            The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Pbkdf2`1.Salt">
            <summary>
            A cryptographic salt.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.Derive(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Pbkdf2`1.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.KeyStore.Kdfs.Scrypt">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt</a>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.#ctor(System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt</a>.
            </summary>
            <param name="cost">The CPU/memory cost parameter. Corresponds to <c>n</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
            <param name="parallelization">The parallelization parameter.
            Corresponds to <c>p</c>.</param>
            <param name="blockSize">The blocksize parameter. Corresponds to <c>r</c>.</param>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.#ctor(System.Int32,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Configures parameters of <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt</a>.
            </summary>
            <param name="cost">The CPU/memory cost parameter. Corresponds to <c>n</c>.</param>
            <param name="salt">A cryptographic salt.</param>
            <param name="keyLength">The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.</param>
            <param name="parallelization">The parallelization parameter.
            Corresponds to <c>p</c>.</param>
            <param name="blockSize">The blocksize parameter. Corresponds to <c>r</c>.</param>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.Cost">
            <summary>
            The CPU/memory cost parameter. Corresponds to <c>n</c>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.KeyLength">
            <summary>
            The desired byte-length of the derived key.
            Corresponds to <c>dkLen</c> except that it's not bit-wise but byte-wise.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.Salt">
            <summary>
            A cryptographic salt.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.Parallelization">
            <summary>
            The parallelization parameter. Corresponds to <c>p</c>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.Kdfs.Scrypt.BlockSize">
            <summary>
            The blocksize parameter. Corresponds to <c>r</c>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.Derive(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Kdfs.Scrypt.WriteJson(System.Text.Json.Utf8JsonWriter)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.KeyStore.KeyJsonException">
            <summary>
            Serves as the base class for exceptions thrown by
            <see cref="M:Libplanet.KeyStore.ProtectedPrivateKey.FromJson(System.String)"/> method.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.KeyJsonException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.KeyJsonException"/> instance with a message.
            </summary>
            <param name="message">A detailed exception message.</param>
        </member>
        <member name="T:Libplanet.KeyStore.KeyStoreException">
            <summary>
            Serves as the base class for exceptions thrown by <see cref="T:Libplanet.KeyStore.IKeyStore"/>
            implementations.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.KeyStoreException.#ctor(System.String)">
            <summary>
            Initializes a new instance with the given <paramref name="message"/>.
            </summary>
            <param name="message">A descriptive error message for programmers.
            Goes to <see cref="P:System.Exception.Message"/>.</param>
        </member>
        <member name="T:Libplanet.KeyStore.MismatchedAddressException">
            <summary>
            The exception that is thrown when an unprotected private key's actual address does
            not match to the expected address.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.MismatchedAddressException.#ctor(System.String,Libplanet.Address@,Libplanet.Address@)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.MismatchedAddressException"/> object.
            </summary>
            <param name="message">The error message that explains the reason for the exception.
            </param>
            <param name="expectedAddress">The expected address of a protected private key.
            It is automatically included to the <paramref name="message"/> string.</param>
            <param name="actualAddress">The actual address of an unprotected private key.
            It is automatically included to the <paramref name="message"/> string.</param>
        </member>
        <member name="P:Libplanet.KeyStore.MismatchedAddressException.ExpectedAddress">
            <summary>
            The expected address of the protected private key.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.MismatchedAddressException.ActualAddress">
            <summary>
            The actual address of the unprotected private key.
            </summary>
        </member>
        <member name="T:Libplanet.KeyStore.NoKeyException">
            <summary>
            The exception that is thrown when there is no <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>
            with a given key ID in an <see cref="T:Libplanet.KeyStore.IKeyStore"/>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.NoKeyException.#ctor(System.String,System.Guid)">
            <summary>
            Instantiates a new exception object with proper metadata.
            </summary>
            <param name="message">A descriptive error message for programmers.
            Goes to <see cref="P:System.Exception.Message"/>.</param>
            <param name="keyId">The key ID tried to look for.
            It is automatically included to the <see cref="P:System.Exception.Message"/>
            string.
            </param>
        </member>
        <member name="P:Libplanet.KeyStore.NoKeyException.KeyId">
            <summary>
            The key ID tried to look for.
            </summary>
        </member>
        <member name="T:Libplanet.KeyStore.ProtectedPrivateKey">
            <summary>
            Protects a <see cref="T:Libplanet.Crypto.PrivateKey"/> with a passphrase (i.e., password).
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.#ctor(Libplanet.Address,Libplanet.KeyStore.Kdfs.IKdf,System.Byte[],Libplanet.KeyStore.Ciphers.ICipher,System.Byte[])">
            <summary>
            Loads a protected private key.
            </summary>
            <param name="address">The address of the protected private key.</param>
            <param name="kdf">A key derivation function to derive a symmetric key to decrypt
            a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="mac">MAC digest to check if a derived key is correct or not.</param>
            <param name="cipher">A symmetric cipher to decrypt a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="ciphertext">An encrypted <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.#ctor(Libplanet.Address,Libplanet.KeyStore.Kdfs.IKdf,System.Collections.Immutable.ImmutableArray{System.Byte},Libplanet.KeyStore.Ciphers.ICipher,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Loads a protected private key.
            </summary>
            <param name="address">The address of the protected private key.</param>
            <param name="kdf">A key derivation function to derive a symmetric key to decrypt
            a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="mac">MAC digest to check if a derived key is correct or not.</param>
            <param name="cipher">A symmetric cipher to decrypt a <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
            <param name="ciphertext">An encrypted <see cref="T:Libplanet.Crypto.PrivateKey"/>.</param>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Address">
            <summary>
            The address of the protected private key.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Kdf">
            <summary>
            A key derivation function to derive a symmetric key to decrypt
            a <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Cipher">
            <summary>
            A symmetric cipher to decrypt a <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
        </member>
        <member name="P:Libplanet.KeyStore.ProtectedPrivateKey.Ciphertext">
            <summary>
            An encrypted <see cref="T:Libplanet.Crypto.PrivateKey"/>.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.Protect(Libplanet.Crypto.PrivateKey,System.String)">
            <summary>
            Protects a bare <see cref="T:Libplanet.Crypto.PrivateKey"/> using a user input
            <paramref name="passphrase"/>.
            </summary>
            <param name="privateKey">A bare private key to protect.</param>
            <param name="passphrase">A user input passphrase (i.e., password).</param>
            <returns>A passphrase-protected private key.</returns>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.FromJson(System.String)">
            <summary>
            Loads a <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/> from a JSON, according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="json">A JSON string that encodes a <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>.
            </param>
            <returns>A protected private key loaded from the given <paramref name="json"/>.
            </returns>
            <exception cref="T:System.Text.Json.JsonException">Thrown when the given <paramref name="json"/> is not
            a valid JSON.</exception>
            <exception cref="T:Libplanet.KeyStore.InvalidKeyJsonException">Thrown when the given key data lacks some
            required fields or consists of wrong types.</exception>
            <exception cref="T:Libplanet.KeyStore.UnsupportedKeyJsonException">Thrown when the given key data depends on
            an unsupported features (e.g., KDF).</exception>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.Unprotect(System.String)">
            <summary>
            Gets the protected <see cref="T:Libplanet.Crypto.PrivateKey"/> using a user input
            <paramref name="passphrase"/>.
            </summary>
            <param name="passphrase">A user input passphrase (i.e., password).</param>
            <returns>A bare <see cref="T:Libplanet.Crypto.PrivateKey"/>.</returns>
            <exception cref="T:Libplanet.KeyStore.IncorrectPassphraseException">Thrown when the given
            <paramref name="passphrase"/> does not match to the <see cref="T:Libplanet.KeyStore.ProtectedPrivateKey"/>'s
            passphrase.</exception>
            <exception cref="T:Libplanet.KeyStore.MismatchedAddressException">Thrown when the unprotected
            <see cref="T:Libplanet.Crypto.PrivateKey"/> does not match to the expected <see cref="P:Libplanet.KeyStore.ProtectedPrivateKey.Address"/>.
            </exception>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.WriteJson(System.Text.Json.Utf8JsonWriter,System.Nullable{System.Guid}@)">
            <summary>
            Dumps the cipher parameters as a JSON representation according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="writer">A JSON writer which has not begun object nor array.</param>
            <param name="id">A unique identifier, which goes to the <c>id</c> field in the key JSON
            file.  If <see langword="null"/> (which is default) it is random-generated.</param>
        </member>
        <member name="M:Libplanet.KeyStore.ProtectedPrivateKey.WriteJson(System.IO.Stream,System.Nullable{System.Guid}@)">
            <summary>
            Dumps the cipher parameters as a JSON representation according to Ethereum's
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3
            Secret Storage Definition</a>.
            </summary>
            <param name="stream">The destination for writing JSON text.</param>
            <param name="id">A unique identifier, which goes to the <c>id</c> field in the key JSON
            file.  If <see langword="null"/> (which is default) it is random-generated.</param>
        </member>
        <member name="T:Libplanet.KeyStore.UnsupportedKeyJsonException">
            <summary>
            The exception that is thrown when a key JSON is valid but uses an unsupported feature,
            e.g., unsupported cipher algorithm.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.UnsupportedKeyJsonException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.KeyStore.UnsupportedKeyJsonException"/> instance with a message.
            </summary>
            <param name="message">A detailed exception message.</param>
        </member>
        <member name="T:Libplanet.KeyStore.Web3KeyStore">
            <summary>
            <a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret
            Storage</a> (i.e., Ethereum-style key store) compliant <see cref="T:Libplanet.KeyStore.IKeyStore"/>
            implementation.  Key files are placed in a directory of the <see cref="P:Libplanet.KeyStore.Web3KeyStore.Path"/>.
            <para>Use <see cref="P:Libplanet.KeyStore.Web3KeyStore.DefaultKeyStore"/> property to get an instance.</para>
            <para>In order to get an instance with a customized directory,
            use the <see cref="M:Libplanet.KeyStore.Web3KeyStore.#ctor(System.String)"/> constructor.</para>
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.#ctor(System.String)">
            <summary>
            Creates a <see cref="T:Libplanet.KeyStore.Web3KeyStore"/> instance with a custom directory
            <paramref name="path"/>.
            </summary>
            <param name="path">A path of the directory to store key files.  A new directory is
            created if not exists.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <see langword="null"/> is passed to
            <paramref name="path"/>.</exception>
            <seealso cref="P:Libplanet.KeyStore.Web3KeyStore.DefaultKeyStore"/>
        </member>
        <member name="P:Libplanet.KeyStore.Web3KeyStore.DefaultKeyStore">
            <summary>
            A default <see cref="T:Libplanet.KeyStore.Web3KeyStore"/> instance which refers to a user-local directory.
            The <see cref="P:Libplanet.KeyStore.Web3KeyStore.Path"/> differs on the platform:
            <list type="table">
            <listheader>
            <term>OS</term>
            <description>Directory path</description>
            </listheader>
            <item>
            <term>Linux/macOS</term>
            <description><var>$HOME</var>/.config/planetarium/keystore</description>
            </item>
            <item>
            <term>Windows</term>
            <description><var>%AppData%</var>\planetarium\keystore</description>
            </item>
            </list>
            </summary>
            <seealso cref="M:Libplanet.KeyStore.Web3KeyStore.#ctor(System.String)"/>
        </member>
        <member name="P:Libplanet.KeyStore.Web3KeyStore.Path">
            <summary>
            The path of the directory key files are placed.
            </summary>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.List">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.ListIds">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.Get(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.Add(Libplanet.KeyStore.ProtectedPrivateKey)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.KeyStore.Web3KeyStore.Remove(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.KeyValuePairExtensions">
            <summary>
            Extension methods that help you to write more fluent dictionary-manipulating code.
            </summary>
            <example>
            The following example shows how an immutable dictionary can transform only its keys or
            its values:
            <code><![CDATA[
            var a = ImmutableDictionary<string, int>.Empty.Add("foo", 1).Add("bar", 2);
            // a: foo => 1, bar => 2
            var b = a.SelectWithinKeys(k => k.ToUpperInvariant()).ToImmutableDictionary();
            // b: FOO => 1, BAR => 2
            var c = a.SelectWithinValues(v => -v * 2).ToImmutableDictionary();
            // c: foo => -2, bar => -4
            ]]></code>
            </example>
        </member>
        <member name="T:Libplanet.Misc.ArrayEqualityComparer`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to compare two arrays of the same
            element type.  This compares the elements in the order of the array.
            <para>The way to compare each element can be customized by specifying
            the <see cref="P:Libplanet.Misc.ArrayEqualityComparer`1.ElementComparer"/>.</para>
            </summary>
            <typeparam name="T">The element type of the array.</typeparam>
        </member>
        <member name="M:Libplanet.Misc.ArrayEqualityComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of <see cref="T:Libplanet.Misc.ArrayEqualityComparer`1"/>.
            </summary>
            <param name="elementComparer">Optionally customize the way to compare each element.
            </param>
        </member>
        <member name="P:Libplanet.Misc.ArrayEqualityComparer`1.ElementComparer">
            <summary>
            Optionally customizes the way to compare each element.
            </summary>
        </member>
        <member name="M:Libplanet.Misc.ArrayEqualityComparer`1.Equals(`0[],`0[])">
            <inheritdoc cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)"/>
        </member>
        <member name="M:Libplanet.Misc.ArrayEqualityComparer`1.GetHashCode(`0[])">
            <inheritdoc cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/>
        </member>
        <member name="T:Libplanet.Misc.NameValueCollectionExtensions">
            <summary>
            Useful extension methods for <see cref="T:System.Collections.Specialized.NameValueCollection"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Misc.NameValueCollectionExtensions.GetInt32(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Tries to get the numeric text associated with the specified <paramref name="name"/> as
            an <see cref="T:System.Int32"/> value from the specified name-value <paramref name="collection"/>.
            </summary>
            <param name="collection">The <see cref="T:System.Collections.Specialized.NameValueCollection"/> that contains the entry
            to find.</param>
            <param name="name">The <see cref="T:System.String"/> key of the entry that contains the value to
            find.</param>
            <returns>An <see cref="T:System.Int32"/> value converted from the text value associated with
            the specified key <paramref name="name"/> from the <paramref name="collection"/>,
            if found; otherwise, <see langword="null"/>.</returns>
            <exception cref="T:System.FormatException">Thrown when the value is not a numeric text.
            </exception>
            <exception cref="T:System.OverflowException">Thrown when the value is outside the range of the
            <see cref="T:System.Int32"/> type.</exception>
            <remarks>This method assumes the <paramref name="collection"/> contains zero or
            one entry for the specified <paramref name="name"/>.</remarks>
        </member>
        <member name="M:Libplanet.Misc.NameValueCollectionExtensions.GetInt32(System.Collections.Specialized.NameValueCollection,System.String,System.Int32)">
            <summary>
            Tries to get the numeric text associated with the specified <paramref name="name"/> as
            an <see cref="T:System.Int32"/> value from the specified name-value <paramref name="collection"/>.
            </summary>
            <param name="collection">The <see cref="T:System.Collections.Specialized.NameValueCollection"/> that contains the entry
            to find.</param>
            <param name="name">The <see cref="T:System.String"/> key of the entry that contains the value to
            find.</param>
            <param name="defaultValue">Returns this value if the specified key
            <paramref name="name"/> is not found in the <paramref name="collection"/>, or
            the associated value is not a numeric text or outside the range of the <see cref="T:System.Int32"/>
            type.</param>
            <returns>An <see cref="T:System.Int32"/> value converted from the text value associated with
            the specified key <paramref name="name"/> from the <paramref name="collection"/>,
            if found; otherwise, <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:Libplanet.Misc.NameValueCollectionExtensions.GetUInt64(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Tries to get the numeric text associated with the specified <paramref name="name"/> as
            a <see cref="T:System.UInt64"/> value from the specified name-value <paramref name="collection"/>.
            </summary>
            <param name="collection">The <see cref="T:System.Collections.Specialized.NameValueCollection"/> that contains the entry
            to find.</param>
            <param name="name">The <see cref="T:System.String"/> key of the entry that contains the value to
            find.</param>
            <returns>A <see cref="T:System.UInt64"/> value converted from the text value associated with
            the specified key <paramref name="name"/> from the <paramref name="collection"/>,
            if found; otherwise, <see langword="null"/>.</returns>
            <exception cref="T:System.FormatException">Thrown when the value is not a numeric text.
            </exception>
            <exception cref="T:System.OverflowException">Thrown when the value is outside the range of the
            <see cref="T:System.UInt64"/> type.</exception>
            <remarks>This method assumes the <paramref name="collection"/> contains zero or
            one entry for the specified <paramref name="name"/>.</remarks>
        </member>
        <member name="M:Libplanet.Misc.NameValueCollectionExtensions.GetUInt64(System.Collections.Specialized.NameValueCollection,System.String,System.UInt64)">
            <summary>
            Tries to get the numeric text associated with the specified <paramref name="name"/> as
            a <see cref="T:System.UInt64"/> value from the specified name-value <paramref name="collection"/>.
            </summary>
            <param name="collection">The <see cref="T:System.Collections.Specialized.NameValueCollection"/> that contains the entry
            to find.</param>
            <param name="name">The <see cref="T:System.String"/> key of the entry that contains the value to
            find.</param>
            <param name="defaultValue">Returns this value if the specified key
            <paramref name="name"/> is not found in the <paramref name="collection"/>, or
            the associated value is not a numeric text or outside the range of
            the <see cref="T:System.UInt64"/> type.</param>
            <returns>An <see cref="T:System.Int32"/> value converted from the text value associated with
            the specified key <paramref name="name"/> from the <paramref name="collection"/>,
            if found; otherwise, <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:Libplanet.Misc.NameValueCollectionExtensions.GetBoolean(System.Collections.Specialized.NameValueCollection,System.String,System.Boolean)">
            <summary>
            Tries to get the boolean text associated with the specified <paramref name="name"/> as
            a <see cref="T:System.Boolean"/> value from the specified name-value <paramref name="collection"/>.
            <para>Supported keywords are: <see langword="true"/>, <see langword="false"/>,
            <c>yes</c>, <c>no</c>, <c>on</c>, <c>off</c>, <c>t</c>, <c>f</c>, <c>y</c>, <c>n</c>,
            <c>1</c>, <c>0</c> (all case-insensitive).</para>
            </summary>
            <param name="collection">The <see cref="T:System.Collections.Specialized.NameValueCollection"/> that contains the entry
            to find.</param>
            <param name="name">The <see cref="T:System.String"/> key of the entry that contains the value to
            find.</param>
            <param name="defaultValue">Returns this value if the specified key
            <paramref name="name"/> is not found in the <paramref name="collection"/>, or
            the associated value is not a valid boolean text.  Configured as <see langword="false"/>
            by default.</param>
            <returns>A <see cref="T:System.Boolean"/> value converted from the text value associated with
            the specified key <paramref name="name"/> from the <paramref name="collection"/>,
            if found; otherwise, <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="T:Libplanet.Nonce">
            <summary>
            An arbitrary <see cref="T:System.Byte"/>s that determines a
            <see cref="T:Libplanet.Hashcash.Stamp"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Nonce.#ctor(System.Byte[])">
            <summary>
            Converts a <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Nonce"/>
            value.
            <para>This constructor is an inverse function of
            <see cref="M:Libplanet.Nonce.ToByteArray"/> method.</para>
            </summary>
            <param name="nonce">A <see cref="T:System.Byte"/> array to convert to
            a <see cref="T:Libplanet.Nonce"/> object.  It must not be <see langword="null"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="nonce"/> is a <see langword="null"/>.</exception>
            <seealso cref="M:Libplanet.Nonce.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Nonce.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Converts an immutable <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Nonce"/> instance.
            <para>This constructor is inverse of <see cref="P:Libplanet.Nonce.ByteArray"/> property.</para>
            </summary>
            <param name="nonce">An immutable <see cref="T:System.Byte"/> array to convert to
            a <see cref="T:Libplanet.Nonce"/> instance.</param>
            <seealso cref="P:Libplanet.Nonce.ByteArray"/>
        </member>
        <member name="P:Libplanet.Nonce.ByteArray">
            <summary>
            A bare immutable <see cref="T:System.Byte"/> array of the nonce.
            </summary>
            <remarks>It is immutable.  For a mutable array, use
            <see cref="M:Libplanet.Nonce.ToByteArray"/> method instead.</remarks>
            <seealso cref="M:Libplanet.Nonce.ToByteArray"/>
        </member>
        <member name="M:Libplanet.Nonce.ToByteArray">
            <summary>
            Gets a bare mutable <see cref="T:System.Byte"/> array of the nonce.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array of the nonce.
            Since a returned array is created every time the method is called,
            any mutations on that array does not affect to
            the <see cref="T:Libplanet.Nonce"/> object.
            </returns>
            <seealso cref="P:Libplanet.Nonce.ByteArray"/>
        </member>
        <member name="M:Libplanet.Nonce.ToString">
            <summary>
            Gets a hexadecimal representation of a <see cref="T:Libplanet.Nonce"/>.
            </summary>
            <returns>A hexadecimal representation of a <see cref="T:Libplanet.Nonce"/>.
            </returns>
        </member>
        <member name="T:Libplanet.Store.BaseStore">
            <summary>
            Common code for several <see cref="T:Libplanet.Store.IStore"/> implementations.
            </summary>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ListChainIds">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetCanonicalChainId">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.SetCanonicalChainId(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.IndexBlockHash(System.Guid,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.AppendIndex(System.Guid,Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ForkBlockIndexes(System.Guid,System.Guid,Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.IterateBlockHashes">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetBlock``1(Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetBlockIndex(Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetBlockDigest(Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.PutBlock``1(Libplanet.Blocks.Block{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.DeleteBlock(Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ContainsBlock(Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.PutTxExecution(Libplanet.Tx.TxSuccess)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.PutTxExecution(Libplanet.Tx.TxFailure)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetTxExecution(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.PutTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.IterateTxIdBlockHashIndex(Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.DeleteTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ListTxNonces(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.GetTxNonce(System.Guid,Libplanet.Address)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ContainsTransaction(Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.DeleteChainId(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.ForkTxNonces(System.Guid,System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.BaseStore.PruneOutdatedChains(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.BlockDigest">
            <summary>
            Class that store uses to save blocks. This contains:
            <see cref="T:Libplanet.Blocks.BlockHeader"/>, and list of <see cref="T:Libplanet.Tx.TxId"/>s.
            </summary>
        </member>
        <member name="M:Libplanet.Store.BlockDigest.#ctor(Libplanet.Blocks.BlockHeader,System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{System.Byte}})">
            <summary>
            Creates <see cref="T:Libplanet.Store.BlockDigest"/> instance from <see cref="T:Libplanet.Blocks.BlockHeader"/> and
            <see cref="T:Libplanet.Tx.Transaction`1"/> ids the <see cref="T:Libplanet.Blocks.Block`1"/> has.
            </summary>
            <param name="header"><see cref="T:Libplanet.Blocks.BlockHeader"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>.</param>
            <param name="txIds"><see cref="T:Libplanet.Tx.Transaction`1"/> ids the <see cref="T:Libplanet.Blocks.Block`1"/> has.
            </param>
        </member>
        <member name="M:Libplanet.Store.BlockDigest.#ctor(Bencodex.Types.Dictionary)">
            <summary>
            Creates <see cref="T:Libplanet.Store.BlockDigest"/> instance from
            <see cref="T:Bencodex.Types.Dictionary"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="dict">
            <see cref="T:Bencodex.Types.Dictionary"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </param>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.ProtocolVersion">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.ProtocolVersion"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.Index">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Index"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.Timestamp">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.Miner">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Miner"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.PublicKey">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.Difficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.Difficulty"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.TotalDifficulty">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TotalDifficulty"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.PreviousHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.PreviousHash"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.TxHash">
            <inheritdoc cref="P:Libplanet.Blocks.IBlockMetadata.TxHash"/>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.Hash">
            <summary>
            The block hash.
            </summary>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.StateRootHash">
            <summary>
            The state root hash.
            </summary>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.Signature">
            <summary>
            The block signature.
            </summary>
        </member>
        <member name="P:Libplanet.Store.BlockDigest.TxIds">
            <summary>
            The <see cref="P:Libplanet.Tx.Transaction`1.Id"/>s of <see cref="T:Libplanet.Tx.Transaction`1"/>s in
            a <see cref="T:Libplanet.Blocks.Block`1"/>.  This is <em>not</em> necessarily ordered by
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.BlockDigest.FromBlock``1(Libplanet.Blocks.Block{``0})">
            <summary>
            Gets <see cref="T:Libplanet.Store.BlockDigest"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </summary>
            <param name="block">The block instance to get its digest.</param>
            <typeparam name="T">An action type.</typeparam>
            <returns><see cref="T:Libplanet.Store.BlockDigest"/> representation of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.BlockDigest.Deserialize(System.Byte[])">
            <summary>
            Gets <see cref="T:Libplanet.Store.BlockDigest"/> instance from serialized <paramref name="bytes"/>.
            </summary>
            <param name="bytes">Serialized <see cref="T:Libplanet.Store.BlockDigest"/>.</param>
            <returns>Deserialized <see cref="T:Libplanet.Store.BlockDigest"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the passed <paramref name="bytes"/>
            is <see langword="null"/>.</exception>
            <exception cref="T:Bencodex.DecodingException">Thrown when decoded value is not
            <see cref="T:Bencodex.Types.Dictionary"/> type.</exception>
        </member>
        <member name="M:Libplanet.Store.BlockDigest.Serialize">
            <summary>
            Gets serialized byte array of the <see cref="T:Libplanet.Store.BlockDigest"/>.
            </summary>
            <returns>Serialized byte array of <see cref="T:Libplanet.Store.BlockDigest"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.BlockDigest.GetHeader">
            <summary>
            Gets the block header.
            </summary>
            <returns>The block header.</returns>
        </member>
        <member name="M:Libplanet.Store.BlockDigest.ToBencodex">
            <summary>
            Gets <see cref="T:Bencodex.Types.Dictionary"/> representation of
            <see cref="T:Libplanet.Store.BlockDigest"/>.
            </summary>
            <returns><see cref="T:Bencodex.Types.Dictionary"/> representation of
            <see cref="T:Libplanet.Store.BlockDigest"/>.</returns>
        </member>
        <member name="T:Libplanet.Store.DataModel">
             <summary>
             <para>
             A <c>class</c> representing an abstract data model that can be easily
             encoded and decoded to and from a <see cref="T:Bencodex.Types.Dictionary"/>.
             </para>
             <para>
             Inheriting this class and simply declaring properties allows an instance of the child class
             to encode its data into a <see cref="T:Bencodex.Types.Dictionary"/> where the encoded
             <see cref="T:Bencodex.Types.Dictionary"/> has the concrete class'es each property name as its key and
             the each corresponding property value as its value.
             </para>
             <para>
             However, there are certain restrictions that apply when using this <c>class</c>:
             <list type="bullet">
                 <item><description>
                     The complete list of allowed property types are as follows:
                     <list type="bullet">
                         <item><description>
                             Primitive types: <c>bool</c>, <c>int</c>, <c>long</c>, <c>BigInteger</c>,
                             <c><![CDATA[ImmutableArray<byte>]]></c>, <c>Guid</c>, <c>Address</c>,
                             and <c>string</c>.
                         </description></item>
                         <item><description>
                             Special types: Any type inherited from <see cref="T:Libplanet.Store.DataModel"/>.
                         </description></item>
                         <item><description>
                             Collective types:
                             <list type="bullet">
                                 <item><description>
                                     <see cref="T:System.Collections.Immutable.ImmutableList`1"/> where <c>T</c> is a primitive type.
                                 </description></item>
                                 <item><description>
                                     <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> where
                                     <list type="bullet">
                                         <item><description>
                                             <c>TKey</c> is one of
                                             <c><![CDATA[ImmutableArray<byte>]]></c>, <c>Address</c>,
                                             <c>Guid</c>, and <c>string</c>.
                                         </description></item>
                                         <item><description>
                                             <c>TValue</c> is a primitive type.
                                         </description></item>
                                     </list>
                                 </description></item>
                             </list>
                         </description></item>
                     </list>
                 </description></item>
                 <item><description>
                     Value types are not allowed to be declared as <c>nullable</c>, not even as
                     a generic type parameter.  That is, types such as <c>bool?</c>, <c>Address?</c>,
                     and <c><![CDATA[ImmutableList<int?>]]></c>are not allowed.
                 </description></item>
                 <item><description>
                     Reference types are not allowed to be assigned <see langword="null"/>.  This will
                     result in an <see cref="T:System.Exception"/> when <see cref="M:Libplanet.Store.DataModel.Encode"/> is called.
                 </description></item>
                 <item><description>
                     Trying to assign <see langword="null"/> to any property or to a part of
                     a collection will result in an <see cref="T:System.Exception"/> when
                     <see cref="M:Libplanet.Store.DataModel.#ctor(Bencodex.Types.Dictionary)"/> is called.
                 </description></item>
             </list>
             </para>
             </summary>
             <example>
             The following example shows how this class can be used:
             <code><![CDATA[
             public class CharacterData : DataModel
             {
                 /// <summary>
                 /// Name of the character.
                 /// </summary>
                 public string Name { get; private set; }
            
                 /// <summary>
                 /// Current level of the character.
                 /// </summary>
                 public int Level { get; private set; }
            
                 /// <summary>
                 /// Inventory of the character.
                 /// </summary>
                 public InventoryData Inv { get; private set; }
            
                 public CharacterData(string name, int level, InventoryData inv)
                     : base()
                 {
                     Name = name;
                     Level = level;
                     Inv = inv;
                 }
            
                 public CharacterData(Bencodex.Types.Dictionary encoded)
                     : base(encoded)
                 {
                 }
             }
            
             public class InventoryData : DataModel
             {
                 /// <summary>
                 /// The amount of gold in the inventory.
                 /// </summary>
                 public int Gold { get; private set; }
            
                 public InventoryData(int gold)
                     : base()
                 {
                     Gold = gold;
                 }
            
                 public InventoryData(Bencodex.Types.Dictionary encoded)
                     : base(encoded)
                 {
                 }
             }
             ]]></code>
             Then the concrete model defined above can be used as shown below:
             <code><![CDATA[
             CharacterData characterData = new CharacterData("John", 5, new InventoryData(100));
             Bencodex.Types.Dictionary encoded = characterData.Encode()
             ]]></code>
             This would result in <c>encoded</c> in a following format:
             <code><![CDATA[
             Bencodex.Types.Dictionary {
               "Name": "John",
               "Level": 5,
               "Inv": {
                   "Gold": 100,
               },
             }
             ]]></code>
             To decode this back into an instance, simply use it as shown below:
             <code><![CDATA[
             CharacterData decoded = new CharacterData(encoded);
             ]]></code>
             Then <c>decoded.Name</c>, <c>decoded.Level</c>, and <c>decoded.Inv.Gold</c> will have
             values <c>"John"</c>, <c>5</c>, and <c>100</c> respectively.
             </example>
             <remarks>
             There are certain caveats for using this class:
             <list type="bullet">
                 <item><description>
                     Encoded data type is fixed to <see cref="T:Bencodex.Types.Dictionary"/>.  As each
                     property name is encoded into <see cref="T:Bencodex.Types.Text"/> as a key, it is
                     advisable to give short names for properties.  For example, <c>int HP</c> is better
                     than <c>int HealthPoint</c> to reduce storage size and/or network traffic.
                     As seen in the example above, actively use documented properties instead.
                 </description></item>
                 <item><description>
                     Property type of <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> is inefficient
                     to encode and decode.  Additional caution is needed when declaring
                     <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> property type.
                 </description></item>
                 <item><description>
                     As supported types are limited, in particular, nullable types and nested
                     collection types not being allowed, if a custom data model that isn't supported
                     by this class is needed, manual implementation of encoding and decoding
                     should be done separately.
                 </description></item>
             </list>
             </remarks>
        </member>
        <member name="M:Libplanet.Store.DataModel.#ctor(Bencodex.Types.Dictionary)">
            <summary>
            Decodes a <see cref="T:Bencodex.Types.Dictionary"/> data into an instance.
            </summary>
            <param name="encoded">The <see cref="T:Bencodex.Types.Dictionary"/> instance to decode.</param>
            <returns>A decoded instance from <paramref name="encoded"/>.</returns>
            <exception cref="T:System.NotSupportedException">Thrown when <see langword="null"/> value is
            encountered while decoding.</exception>
            <exception cref="T:System.ArgumentException">Thrown when invalid encoded type is encountered.
            </exception>
            <exception cref="T:System.NullReferenceException">Thrown when <paramref name="encoded"/> is
            <see langword="null"/> or <see langword="null"/> reference is returned by inner
            instantiation.</exception>
        </member>
        <member name="P:Libplanet.Store.DataModel.PropertyInfos">
            <summary>
            Cached property info for performance.
            </summary>
        </member>
        <member name="M:Libplanet.Store.DataModel.Encode">
            <summary>
            Encodes an instance into a <see cref="T:Bencodex.Types.Dictionary"/>.
            </summary>
            <returns>An encoded <see cref="T:Bencodex.Types.Dictionary"/> instance.</returns>
            <exception cref="T:System.NotSupportedException">Thrown when <c>nullable</c> value type property
            or <see langword="null"/> value inside a reference type is encountered.</exception>
            <exception cref="T:System.ArgumentException">Thrown when an unknown invalid property type is
            encountered.</exception>
        </member>
        <member name="T:Libplanet.Store.DefaultStore">
            <summary>
            The default built-in <see cref="T:Libplanet.Store.IStore"/> implementation.  This stores data in
            the file system or in memory.  It also uses <a href="https://www.litedb.org/">LiteDB</a>
            for some complex indices.
            <para><see cref="T:Libplanet.Store.DefaultStore"/> and <see cref="T:Libplanet.Store.Trie.DefaultKeyValueStore"/>-backed
            <see cref="T:Libplanet.Store.TrieStateStore"/> can be instantiated from a URI with <c>default+file:</c> scheme
            using <see cref="M:Libplanet.Store.StoreLoaderAttribute.LoadStore(System.Uri)"/>, e.g.:</para>
            <list type="bullet">
            <item><description><c>default+file:///var/data/planet/</c></description></item>
            <item><description><c>default+file:///c:/Users/john/AppData/Local/planet/</c></description>
            </item>
            <item><description><c>default+file:///var/data/planet/?secure=true</c>
            (trie keys are hashed)</description></item>
            </list>
            <para>The following query string parameters are supported:</para>
            <list type="table">
            <item>
            <term><c>journal</c></term>
            <description><see langword="true"/> (default) or <see langword="false"/>.  Corresponds to
            <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s <c>journal</c>
            parameter.</description>
            </item>
            <item>
            <term><c>index-cache</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s
            <c>indexCacheSize</c> parameter.  50000 by default.</description>
            </item>
            <item>
            <term><c>block-cache</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s
            <c>blockCacheSize</c> parameter.  512 by default.</description>
            </item>
            <item>
            <term><c>tx-cache</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s
            <c>txCacheSize</c> parameter.  1024 by default.</description>
            </item>
            <item>
            <term><c>flush</c></term>
            <description><see langword="true"/> (default) or <see langword="false"/>.  Corresponds to
            <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s <c>flush</c>
            parameter.</description>
            </item>
            <item>
            <term><c>readonly</c></term>
            <description><see langword="true"/> or <see langword="false"/> (default).  Corresponds to
            <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s <c>readOnly</c>
            parameter.</description>
            </item>
            <item>
            <term><c>states-dir</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.Trie.DefaultKeyValueStore.#ctor(System.String)"/>'s <c>path</c>
            parameter.  It is relative to the URI path, and defaults to <c>states</c>.</description>
            </item>
            <item>
            <term><c>secure</c></term>
            <description><see langword="true"/> or <see langword="false"/> (default).  Corresponds to
            <see cref="M:Libplanet.Store.TrieStateStore.#ctor(Libplanet.Store.Trie.IKeyValueStore,System.Boolean)"/>'s <c>secure</c> parameter.</description>
            </item>
            </list>
            </summary>
            <seealso cref="T:Libplanet.Store.IStore"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <seealso cref="T:Libplanet.Store.DefaultStore"/>.
            </summary>
            <param name="path">The path of the directory where the storage files will be saved.
            If the path is <see langword="null"/>, the database is created in memory.</param>
            <param name="journal">
            Enables or disables double write check to ensure durability.
            </param>
            <param name="indexCacheSize">Max number of pages in the index cache.</param>
            <param name="blockCacheSize">The capacity of the block cache.</param>
            <param name="txCacheSize">The capacity of the transaction cache.</param>
            <param name="flush">Writes data direct to disk avoiding OS cache.  Turned on by default.
            </param>
            <param name="readOnly">Opens database readonly mode. Turned off by default.</param>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ListChainIds">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.DeleteChainId(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetCanonicalChainId">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.DefaultStore.SetCanonicalChainId(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Store.DefaultStore.CountIndex(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IndexBlockHash(System.Guid,System.Int64)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.IndexBlockHash(System.Guid,System.Int64)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.AppendIndex(System.Guid,Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.AppendIndex(System.Guid,Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ForkBlockIndexes(System.Guid,System.Guid,Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.ForkBlockIndexes(System.Guid,System.Guid,Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetTransaction``1(Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PutTransaction``1(Libplanet.Tx.Transaction{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ContainsTransaction(Libplanet.Tx.TxId)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IterateBlockHashes">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.IterateBlockHashes"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetBlockDigest(Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.GetBlockDigest(Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PutBlock``1(Libplanet.Blocks.Block{``0})">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.DeleteBlock(Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.DeleteBlock(Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ContainsBlock(Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.ContainsBlock(Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PutTxExecution(Libplanet.Tx.TxSuccess)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.PutTxExecution(Libplanet.Tx.TxSuccess)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PutTxExecution(Libplanet.Tx.TxFailure)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.PutTxExecution(Libplanet.Tx.TxFailure)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetTxExecution(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.GetTxExecution(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PutTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.PutTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.DeleteTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)">
            <inheritdoc cref="M:Libplanet.Store.BaseStore.DeleteTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ListTxNonces(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.GetTxNonce(System.Guid,Libplanet.Address)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.ForkTxNonces(System.Guid,System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.PruneOutdatedChains(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.DefaultStore.CountBlocks">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.IStateStore">
            <summary>
            An interface to store states.
            </summary>
        </member>
        <member name="M:Libplanet.Store.IStateStore.GetStateRoot(System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <summary>
            Gets the state root trie of the <paramref name="stateRootHash"/> from the state store.
            </summary>
            <param name="stateRootHash">The state root hash of the state root trie to get.
            If <see langword="null"/> is passed the empty state root trie is returned.</param>
            <returns>The state root trie of the <paramref name="stateRootHash"/>.
            If <see langword="null"/> is passed the empty state root trie is returned.</returns>
        </member>
        <member name="M:Libplanet.Store.IStateStore.PruneStates(System.Collections.Immutable.IImmutableSet{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <summary>
            Prunes the states no more used from the state store.
            </summary>
            <param name="survivingStateRootHashes">The state root hashes <em>not</em> to prune.
            These state root hashes are guaranteed to survive after pruning.</param>
        </member>
        <member name="M:Libplanet.Store.IStore.ListChainIds">
            <summary>
            Lists chain IDs containing at least a single block.
            </summary>
            <returns>Chain IDs with at least a single block.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.DeleteChainId(System.Guid)">
            <summary>
            Deletes an index, tx nonces, and state references in the given
            <paramref name="chainId"/>.
            It also deletes chain itself.  If there is no such <paramref name="chainId"/> it
            does nothing.
            </summary>
            <param name="chainId">The ID of chain to delete.</param>
            <remarks>This does not delete blocks or transactions that belong to the index of
            the <paramref name="chainId"/>, but only the index, tx nonces, and state references.
            </remarks>
        </member>
        <member name="M:Libplanet.Store.IStore.GetCanonicalChainId">
            <summary>
            Gets the ID of the current canonical chain.
            </summary>
            <returns>The ID of the current canonical chain.  Maybe <see langword="null"/>.</returns>
            <seealso cref="M:Libplanet.Store.IStore.SetCanonicalChainId(System.Guid)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.SetCanonicalChainId(System.Guid)">
            <summary>
            Sets the canonical chain.
            </summary>
            <param name="chainId">The ID of a new canonical chain.</param>
            <seealso cref="M:Libplanet.Store.IStore.GetCanonicalChainId"/>
        </member>
        <member name="M:Libplanet.Store.IStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Lists all block hashes in <paramref name="chainId"/>.
            </summary>
            <param name="chainId">The chain ID of the index that contains block hashes to
            iterate.</param>
            <param name="offset">The starting point to return block hashes.</param>
            <param name="limit">The maximum number of block hashes to get.</param>
            <returns>Block hashes in the index of the <paramref name="chainId"/>, in ascending
            order; the genesis block goes first, and the tip block goes last.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.IndexBlockHash(System.Guid,System.Int64)">
            <summary>
            Determines the block hash by its <paramref name="index"/>.
            </summary>
            <param name="chainId">The chain ID of the index that contains the block.</param>
            <param name="index">The index of the block to query its hash.  Negative indices mean
            the offset from the end.  For example, -1 means the topmost block.</param>
            <returns>The block hash of the index in the chain.  If there is no such index,
            it returns <see langword="null"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.AppendIndex(System.Guid,Libplanet.Blocks.BlockHash)">
            <summary>
            Appends a block to a chain.
            </summary>
            <param name="chainId">The ID of a chain to append a block to.</param>
            <param name="hash">The hash of a block to append.  Assumes the block is already put
            into the store.</param>
            <returns>The index of the appended block.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.ForkBlockIndexes(System.Guid,System.Guid,Libplanet.Blocks.BlockHash)">
            <summary>
            Forks block indexes from
            <paramref name="sourceChainId"/> to
            <paramref name="destinationChainId"/>.
            </summary>
            <param name="sourceChainId">The chain ID of block indexes to
            fork.</param>
            <param name="destinationChainId">The chain ID of destination
            block indexes.</param>
            <param name="branchpoint">The branchpoint <see cref="T:Libplanet.Blocks.Block`1"/> to fork.</param>
            <seealso cref="M:Libplanet.Store.IStore.IterateIndexes(System.Guid,System.Int32,System.Nullable{System.Int32})"/>
            <seealso cref="M:Libplanet.Store.IStore.AppendIndex(System.Guid,Libplanet.Blocks.BlockHash)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.PutTransaction``1(Libplanet.Tx.Transaction{``0})">
            <summary>
            Puts a given <see cref="T:Libplanet.Tx.Transaction`1"/> to the store.  If the same transaction
            already exists in the store it does nothing.
            </summary>
            <param name="tx">A transaction to put into the store.</param>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Tx.Transaction`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStore.IterateBlockHashes">
            <summary>
            Lists all block hashes in the store, regardless of their belonging chains.
            </summary>
            <returns>All block hashes in the store.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.GetBlock``1(Libplanet.Blocks.BlockHash)">
            <summary>
            Gets the corresponding stored <see cref="T:Libplanet.Blocks.Block`1"/> to the given
            <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to find.</param>
            <returns>A found block, or <see langword="null"/> if no block having such
            <paramref name="blockHash"/> is stored.</returns>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> type.  It should match
            to <see cref="T:Libplanet.Blocks.Block`1"/>'s type parameter.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStore.GetBlockIndex(Libplanet.Blocks.BlockHash)">
            <summary>
            Gets a stored block's <see cref="P:Libplanet.Blocks.Block`1.Index"/> by its <see cref="P:Libplanet.Blocks.Block`1.Hash"/>.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to find.</param>
            <remarks>
            It provides only limited information, but can be called without any type parameter
            unlike <see cref="M:Libplanet.Store.IStore.GetBlock``1(Libplanet.Blocks.BlockHash)"/>.
            </remarks>
            <returns>A found block's <see cref="P:Libplanet.Blocks.Block`1.Index"/>, or <see langword="null"/> if
            no block having such <paramref name="blockHash"/> is stored.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.GetBlockDigest(Libplanet.Blocks.BlockHash)">
            <summary>
            Gets the corresponding stored <see cref="T:Libplanet.Store.BlockDigest"/> to the given
            <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash"><see cref="P:Libplanet.Blocks.Block`1.Hash"/> to find.</param>
            <returns>A found <see cref="T:Libplanet.Store.BlockDigest"/>, or <see langword="null"/> if no block
            having such <paramref name="blockHash"/> is stored.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.PutBlock``1(Libplanet.Blocks.Block{``0})">
            <summary>
            Puts the given <paramref name="block"/> in to the store.
            If the same block already exists in the store it does nothing.
            </summary>
            <param name="block">A <see cref="T:Libplanet.Blocks.Block`1"/> to put into the store.
            </param>
            <typeparam name="T">An <see cref="T:Libplanet.Action.IAction"/> class used with
            <paramref name="block"/>.</typeparam>
        </member>
        <member name="M:Libplanet.Store.IStore.DeleteBlock(Libplanet.Blocks.BlockHash)">
            <summary>
            Removes a block from the store.
            </summary>
            <param name="blockHash">The hash of a block to remove.</param>
            <returns><see langword="false"/> if such block does not exist. Otherwise
            <see langword="true"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.ContainsBlock(Libplanet.Blocks.BlockHash)">
            <summary>
            Determines whether the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Blocks.Block`1"/>
            the specified <paramref name="blockHash"/>.
            </summary>
            <param name="blockHash">The <see cref="T:Libplanet.HashDigest`1"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> to
            check if it is in the <see cref="T:Libplanet.Store.IStore"/>.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Blocks.Block`1"/> with
            the specified <paramref name="blockHash"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.IStore.PutTxExecution(Libplanet.Tx.TxSuccess)">
            <summary>
            Records the given <paramref name="txSuccess"/>.
            </summary>
            <remarks>If there is already the record for the same <see cref="P:Libplanet.Tx.TxExecution.BlockHash"/>
            and <see cref="P:Libplanet.Tx.TxExecution.TxId"/>, the record is silently overwritten.</remarks>
            <param name="txSuccess">The successful transaction execution summary to record.
            Must not be <see langword="null"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="txSuccess"/> is
            <see langword="null"/>.</exception>
            <seealso cref="M:Libplanet.Store.IStore.PutTxExecution(Libplanet.Tx.TxFailure)"/>
            <seealso cref="M:Libplanet.Store.IStore.GetTxExecution(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.PutTxExecution(Libplanet.Tx.TxFailure)">
            <summary>
            Records the given <paramref name="txFailure"/>.
            </summary>
            <remarks>If there is already the record for the same <see cref="P:Libplanet.Tx.TxExecution.BlockHash"/>
            and <see cref="P:Libplanet.Tx.TxExecution.TxId"/>, the record is silently overwritten.</remarks>
            <param name="txFailure">The failed transaction execution summary to record.
            Must not be <see langword="null"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="txFailure"/> is
            <see langword="null"/>.</exception>
            <seealso cref="M:Libplanet.Store.IStore.PutTxExecution(Libplanet.Tx.TxSuccess)"/>
            <seealso cref="M:Libplanet.Store.IStore.GetTxExecution(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.GetTxExecution(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId)">
            <summary>
            Retrieves the recorded transaction execution summary.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the recorded transaction
            execution to retrieve.</param>
            <param name="txid">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of the recorded transaction
            execution to retrieve.</param>
            <returns>The recorded transaction execution summary.  If it has been never recorded
            <see langword="null"/> is returned instead.</returns>
            <seealso cref="M:Libplanet.Store.IStore.PutTxExecution(Libplanet.Tx.TxFailure)"/>
            <seealso cref="M:Libplanet.Store.IStore.PutTxExecution(Libplanet.Tx.TxSuccess)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.PutTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)">
            <summary>
            Records a index for given pair <paramref name="txId"/> and <paramref name="blockHash"/>.
            If there exist a record for <paramref name="txId"/> already,
            it overwrites the record silently.
            </summary>
            <param name="txId">The <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/>.</param>
            <param name="blockHash">The <see cref="T:Libplanet.Blocks.BlockHash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>.
            </param>
        </member>
        <member name="M:Libplanet.Store.IStore.GetFirstTxIdBlockHashIndex(Libplanet.Tx.TxId)">
            <summary>
            Retrieves the <see cref="T:Libplanet.Blocks.BlockHash"/> indexed by the <paramref name="txId"/>.
            </summary>
            <param name="txId">The <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/>.</param>
            <returns><see cref="T:Libplanet.Blocks.BlockHash"/> if the index exists. Otherwise
            <see langword="null"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.IterateTxIdBlockHashIndex(Libplanet.Tx.TxId)">
            <summary>
            Retrieves <see cref="T:Libplanet.Blocks.BlockHash"/>es indexed by the <paramref name="txId"/>.
            </summary>
            <param name="txId">The <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/>.</param>
            <returns><see cref="T:Libplanet.Blocks.BlockHash"/>es if the index exists.</returns>
        </member>
        <member name="M:Libplanet.Store.IStore.DeleteTxIdBlockHashIndex(Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash)">
            <summary>
            Deletes the index for the <paramref name="txId"/> and <paramref name="blockHash"/>.
            </summary>
            <param name="txId">The <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/>.</param>
            <param name="blockHash">The <see cref="T:Libplanet.Blocks.BlockHash"/>
            of the <see cref="T:Libplanet.Blocks.Block`1"/>.</param>.
        </member>
        <member name="M:Libplanet.Store.IStore.ListTxNonces(System.Guid)">
            <summary>
            Lists all <see cref="T:Libplanet.Address"/>es that have ever signed <see cref="T:Libplanet.Tx.Transaction`1"/>,
            and their corresponding <see cref="T:Libplanet.Tx.Transaction`1"/> nonces.
            </summary>
            <param name="chainId">The ID of the chain to list <see cref="T:Libplanet.Address"/>es and their
            <see cref="T:Libplanet.Tx.Transaction`1"/> nonces.</param>
            <returns>Pairs of an <see cref="T:Libplanet.Address"/> and its tx nonce.  All nonces are greater
            than 0.  (If there are underlying entries having zero nonces these must be hidden.)
            </returns>
            <seealso cref="M:Libplanet.Store.IStore.GetTxNonce(System.Guid,Libplanet.Address)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.GetTxNonce(System.Guid,Libplanet.Address)">
            <summary>
            Gets <see cref="T:Libplanet.Tx.Transaction`1"/> nonce of the
            <paramref name="address"/>.
            </summary>
            <param name="chainId">The ID of the chain to get <see cref="T:Libplanet.Tx.Transaction`1"/> nonce.
            </param>
            <param name="address">The <see cref="T:Libplanet.Address"/> to get
            <see cref="T:Libplanet.Tx.Transaction`1"/> nonce.
            </param>
            <returns>A <see cref="T:Libplanet.Tx.Transaction`1"/> nonce. If there is no
            previous <see cref="T:Libplanet.Tx.Transaction`1"/>, return 0.</returns>
            <seealso cref="M:Libplanet.Store.IStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.IncreaseTxNonce(System.Guid,Libplanet.Address,System.Int64)">
            <summary>
            Increases (or decreases if a negative <paramref name="delta"/> is given)
            the tx nonce counter for <paramref name="signer"/>.
            </summary>
            <param name="chainId">The ID of the chain to increase
            <see cref="T:Libplanet.Tx.Transaction`1"/> nonce.</param>
            <param name="signer">The address of the account to increase tx nonce.</param>
            <param name="delta">How many to increase the counter.  A negative number decreases
            the counter.  1 by default.</param>
            <seealso cref="M:Libplanet.Store.IStore.GetTxNonce(System.Guid,Libplanet.Address)"/>
        </member>
        <member name="M:Libplanet.Store.IStore.ContainsTransaction(Libplanet.Tx.TxId)">
            <summary>
            Determines whether the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Tx.Transaction`1"/>
            the specified <paramref name="txId"/>.
            </summary>
            <param name="txId">The <see cref="T:Libplanet.Tx.TxId"/> of the <see cref="T:Libplanet.Tx.Transaction`1"/>
            to check if it is in the <see cref="T:Libplanet.Store.IStore"/>.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:Libplanet.Store.IStore"/> contains <see cref="T:Libplanet.Tx.Transaction`1"/>
            with the specified <paramref name="txId"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.IStore.ForkTxNonces(System.Guid,System.Guid)">
            <summary>
            Forks <see cref="T:Libplanet.Tx.Transaction`1"/> <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>s from
            <paramref name="sourceChainId"/> to
            <paramref name="destinationChainId"/>.
            </summary>
            <param name="sourceChainId">The chain <see cref="P:Libplanet.Blockchain.BlockChain`1.Id"/> of
            <see cref="T:Libplanet.Tx.Transaction`1"/> <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>s to fork.</param>
            <param name="destinationChainId">The chain <see cref="P:Libplanet.Blockchain.BlockChain`1.Id"/> of destination
            <see cref="T:Libplanet.Tx.Transaction`1"/> <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>s.</param>
        </member>
        <member name="M:Libplanet.Store.IStore.PruneOutdatedChains(System.Boolean)">
            <summary>
            Delete all non-canonical chains.
            </summary>
            <param name="noopWithoutCanon">
            Flag to determine whether the function throws exception
            when the canonical chain is not assigned.  <see langword="false"/> by default.
            If it set to <see langword="true"/>, does not throw exception when
            there is no canonical chain.
            Otherwise, throws <see cref="T:System.InvalidOperationException"/> when
            there is no canonical chain.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when there is no canonical chain and
            <paramref name="noopWithoutCanon"/> is false.
            </exception>
        </member>
        <member name="T:Libplanet.Store.MemoryStore">
            <summary>
            Volatile in-memory store.
            <para>It is useful for storing temporal small chains, e.g., fixtures for unit tests of
            game logic.</para>
            <para><see cref="T:Libplanet.Store.MemoryStore"/> and <see cref="T:Libplanet.Store.Trie.MemoryKeyValueStore"/>-backed
            <see cref="T:Libplanet.Store.TrieStateStore"/> can be instantiated from a URI with <c>memory:</c> scheme
            using <see cref="M:Libplanet.Store.StoreLoaderAttribute.LoadStore(System.Uri)"/>, e.g.:</para>
            <list type="bullet">
            <item><description><c>memory:</c></description></item>
            <item><description><c>memory://?secure=true</c> (trie keys are hashed)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:Libplanet.Store.StateStoreExtensions">
            <summary>
            Convenient extension methods for <see cref="T:Libplanet.Store.IStateStore"/>.
            </summary>
        </member>
        <member name="F:Libplanet.Store.StateStoreExtensions.KeyEncoding">
            <summary>
            The internal bytes encoding of raw state keys.
            </summary>
        </member>
        <member name="M:Libplanet.Store.StateStoreExtensions.EncodeKey(System.String)">
            <summary>
            Encodes a raw state key string to internal bytes representation.
            </summary>
            <param name="key">The raw state key to encode.</param>
            <returns>An encoded key bytes.</returns>
        </member>
        <member name="M:Libplanet.Store.StateStoreExtensions.DecodeKey(Libplanet.Store.Trie.KeyBytes@)">
            <summary>
            Decodes internal <paramref name="keyBytes"/> into a raw state key string.
            </summary>
            <param name="keyBytes">The key bytes to decode.</param>
            <returns>A decoded raw state key string.</returns>
        </member>
        <member name="M:Libplanet.Store.StateStoreExtensions.Commit(Libplanet.Store.IStateStore,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Immutable.IImmutableDictionary{System.String,Bencodex.Types.IValue})">
            <summary>
            Records <paramref name="rawStatesDelta"/> which is based on the previous state
            root, and returns the new state root.
            </summary>
            <param name="stateStore">The <see cref="T:Libplanet.Store.IStateStore"/> to records
            the <paramref name="rawStatesDelta"/>.</param>
            <param name="previousStateRootHash">The state root hash on which
            the <paramref name="rawStatesDelta"/> is based.</param>
            <param name="rawStatesDelta">The raw states delta to be recorded.</param>
            <returns>The new state root.</returns>
        </member>
        <member name="M:Libplanet.Store.StateStoreExtensions.GetStates(Libplanet.Store.IStateStore,System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Gets multiple states at once.
            </summary>
            <param name="stateStore">The <see cref="T:Libplanet.Store.IStateStore"/> to get states.</param>
            <param name="stateRootHash">The root hash of the state trie to look up states from.
            </param>
            <param name="rawStateKeys">State keys to get.</param>
            <returns>The state values associated to the specified <paramref name="rawStateKeys"/>.
            The associated values are ordered in the same way to the corresponding
            <paramref name="rawStateKeys"/>.  Absent values are represented as
            <see langword="null"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.StateStoreExtensions.ContainsStateRoot(Libplanet.Store.IStateStore,Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Checks if the state root is recorded in the <paramref name="stateStore"/>.
            </summary>
            <param name="stateStore">The <see cref="T:Libplanet.Store.IStateStore"/> to check if the state root is
            recorded in it.</param>
            <param name="stateRootHash">The hash of the state root to check if it is recorded.
            </param>
            <returns><see langword="true"/> if the state root exists in the
            <paramref name="stateStore"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:Libplanet.Store.StoreExtensions">
            <summary>
            Convenient extension methods for <see cref="T:Libplanet.Store.IStore"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.StoreExtensions.Copy(Libplanet.Store.IStore,Libplanet.Store.IStore)">
            <summary>
            Makes a store, <paramref name="to"/>, logically (but not necessarily physically)
            identical to another store, <paramref name="from"/>.  As this copies the contents
            of the store, instead of its physicall data, this can be used for migrating
            between two different types of <see cref="T:Libplanet.Store.IStore"/> implementations.
            </summary>
            <param name="from">The store containing the source contents.</param>
            <param name="to">The store to contain the copied contents. Expected to be empty.</param>
            <exception cref="T:System.ArgumentException">Thrown when the store passed through
            <paramref name="to"/> is not empty.</exception>
        </member>
        <member name="M:Libplanet.Store.StoreExtensions.GetStateRootHash(Libplanet.Store.IStore,System.Nullable{Libplanet.Blocks.BlockHash})">
            <summary>
            Gets the <see cref="P:Libplanet.Blocks.Block`1.StateRootHash"/> of the given <paramref name="blockHash"/>.
            </summary>
            <param name="store">The store that blocks are stored.</param>
            <param name="blockHash">The hash of the block to get the state root hash of.
            If <see langword="null"/> is present, <see langword="null"/> is returned.</param>
            <returns>The state root hash of the block, or <see langword="null"/> if the block is
            not found or <paramref name="blockHash"/> is <see langword="null"/>.</returns>
        </member>
        <member name="T:Libplanet.Store.StoreLoader">
            <summary>
            A function that parses a URI and returns a pair of <see cref="T:Libplanet.Store.IStore"/> and
            <see cref="T:Libplanet.Store.IStateStore"/>.
            </summary>
            <param name="storeUri">A URI referring to a store.</param>
            <returns>A pair of loaded <see cref="T:Libplanet.Store.IStore"/> and <see cref="T:Libplanet.Store.IStateStore"/> instances.
            </returns>
        </member>
        <member name="T:Libplanet.Store.StoreLoaderAttribute">
            <summary>
            Registers a static method as a store loader.  The method must comply with
            <see cref="T:Libplanet.Store.StoreLoader"/> delegate.
            </summary>
            <example>
            <para>With the below code, <c>SampleStore</c> and <c>SampleStateStore</c>-backed
            <see cref="T:Libplanet.Store.TrieStateStore"/> can be instantiated from a URI like
            <c>sample:///home/foo/bar?cache=512</c>:</para>
            <code><![CDATA[
            [StoreLoader("sample")]
            private static (IStore Store, IStateStore StateStore) Loader(Uri storeUri)
            {
                NameValueCollection query = HttpUtility.ParseQueryString(storeUri.Query);
                int cache = query.GetInt32("cache", 128);
                var store = new SampleStore(storeUri.LocalPath, cache);
                var stateStore = new SampleStateStore(storeUri.LocalPath, cache);
                return (store, stateStore);
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Libplanet.Store.StoreLoaderAttribute.#ctor(System.String)">
            <summary>
            Instniates a new <see cref="T:Libplanet.Store.StoreLoaderAttribute"/> with the specified
            <paramref name="uriScheme"/>.
            </summary>
            <param name="uriScheme">The URI scheme to associate with the attributed store loader
            method.</param>
        </member>
        <member name="P:Libplanet.Store.StoreLoaderAttribute.UriScheme">
            <summary>
            The URI scheme to associate with the attributed store loader method.
            </summary>
        </member>
        <member name="M:Libplanet.Store.StoreLoaderAttribute.LoadStore(System.Uri)">
            <summary>
            Loads a pair of <see cref="T:Libplanet.Store.IStore"/> and <see cref="T:Libplanet.Store.IStateStore"/> from the specified
            <paramref name="storeUri"/>.
            </summary>
            <param name="storeUri">A URI referring to a store.</param>
            <returns>A pair of loaded <see cref="T:Libplanet.Store.IStore"/> and <see cref="T:Libplanet.Store.IStateStore"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.StoreLoaderAttribute.ListStoreLoaders">
            <summary>
            Lists all registered store loaders.
            </summary>
            <returns>Pairs of registered URI scheme and declaring type.</returns>
        </member>
        <member name="T:Libplanet.Store.Trie.CacheableKeyValueStore">
            <summary>
            The proxy class to cache <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> operations.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.#ctor(Libplanet.Store.Trie.IKeyValueStore,System.Int32)">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.Trie.CacheableKeyValueStore"/>.
            </summary>
            <param name="keyValueStore">An <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> implementation to do real
            operations via <see cref="T:Libplanet.Store.Trie.CacheableKeyValueStore"/>.</param>
            <param name="cacheSize">The capacity of the values cache.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Get(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Get(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <inheritdoc cref="M:Libplanet.Store.Trie.IKeyValueStore.Get(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Set(Libplanet.Store.Trie.KeyBytes@,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Delete(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Delete(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <inheritdoc cref="M:Libplanet.Store.Trie.IKeyValueStore.Delete(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Exists(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.ListKeys">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.CacheableKeyValueStore.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:Libplanet.Store.Trie.DefaultKeyValueStore">
            <summary>
            The default built-in <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> implementation. This stores data in
            the file system or in memory.
            <para><see cref="T:Libplanet.Store.DefaultStore"/> and <see cref="T:Libplanet.Store.Trie.DefaultKeyValueStore"/>-backed
            <see cref="T:Libplanet.Store.TrieStateStore"/> can be instantiated from a URI with <c>default+file:</c> scheme
            using <see cref="M:Libplanet.Store.StoreLoaderAttribute.LoadStore(System.Uri)"/>, e.g.:</para>
            <list type="bullet">
            <item><description><c>default+file:///var/data/planet/</c></description></item>
            <item><description><c>default+file:///c:/Users/john/AppData/Local/planet/</c></description>
            </item>
            <item><description><c>default+file:///var/data/planet/?secure=true</c>
            (trie keys are hashed)</description></item>
            </list>
            <para>The following query string parameters are supported:</para>
            <list type="table">
            <item>
            <term><c>journal</c></term>
            <description><see langword="true"/> (default) or <see langword="false"/>.  Corresponds to
            <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s <c>journal</c>
            parameter.</description>
            </item>
            <item>
            <term><c>index-cache</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s
            <c>indexCacheSize</c> parameter.  50000 by default.</description>
            </item>
            <item>
            <term><c>block-cache</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s
            <c>blockCacheSize</c> parameter.  512 by default.</description>
            </item>
            <item>
            <term><c>tx-cache</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s
            <c>txCacheSize</c> parameter.  1024 by default.</description>
            </item>
            <item>
            <term><c>flush</c></term>
            <description><see langword="true"/> (default) or <see langword="false"/>.  Corresponds to
            <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s <c>flush</c>
            parameter.</description>
            </item>
            <item>
            <term><c>readonly</c></term>
            <description><see langword="true"/> or <see langword="false"/> (default).  Corresponds to
            <see cref="M:Libplanet.Store.DefaultStore.#ctor(System.String,System.Boolean,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)"/>'s <c>readOnly</c>
            parameter.</description>
            </item>
            <item>
            <term><c>states-dir</c></term>
            <description>Corresponds to <see cref="M:Libplanet.Store.Trie.DefaultKeyValueStore.#ctor(System.String)"/>'s <c>path</c>
            parameter.  It is relative to the URI path, and defaults to <c>states</c>.</description>
            </item>
            <item>
            <term><c>secure</c></term>
            <description><see langword="true"/> or <see langword="false"/> (default).  Corresponds to
            <see cref="M:Libplanet.Store.TrieStateStore.#ctor(Libplanet.Store.Trie.IKeyValueStore,System.Boolean)"/>'s <c>secure</c> parameter.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.Trie.DefaultKeyValueStore"/>.
            </summary>
            <param name="path">The path of the directory where the storage files will be saved.
            If the path is <see langword="null"/>, the database is created in memory.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Get(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Get(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <inheritdoc cref="M:Libplanet.Store.Trie.IKeyValueStore.Get(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Set(Libplanet.Store.Trie.KeyBytes@,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Delete(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Delete(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <inheritdoc cref="M:Libplanet.Store.Trie.IKeyValueStore.Delete(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.Exists(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.DefaultKeyValueStore.ListKeys">
            <inheritdoc/>
        </member>
        <member name="T:Libplanet.Store.Trie.IKeyValueStore">
            <summary>
            An interface to access key-value store.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.Get(Libplanet.Store.Trie.KeyBytes@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key whose value to get.</param>
            <returns>The value associated with the specified key.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key is not found.</exception>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.Get(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <summary>
            Gets multiple values associated with the specified keys at once.
            </summary>
            <param name="keys">Keys whose values to get.  The order of keys does not matter.
            Duplicate keys after their first occurrence are ignored.</param>
            <returns>Values associated the specified <paramref name="keys"/>.  Non-existent
            <paramref name="keys"/> are omitted (rather than being filled with
            <see langword="null"/>).</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.Set(Libplanet.Store.Trie.KeyBytes@,System.Byte[])">
            <summary>
            Sets the value to the key.  If the key already exists, the value is overwritten.
            </summary>
            <param name="key">The key of the value to set.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.Set(System.Collections.Generic.IDictionary{Libplanet.Store.Trie.KeyBytes,System.Byte[]})">
            <summary>
            Sets all values in the given dictionary.
            </summary>
            <param name="values">A values to set.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.Delete(Libplanet.Store.Trie.KeyBytes@)">
            <summary>
            Deletes the given key.  If the key does not exist, nothing happens.
            </summary>
            <param name="key">A key to delete.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.Delete(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <summary>
            Delete multiple <paramref name="keys"/> at once.
            </summary>
            <param name="keys">Keys to delete.  The order of keys does not matter.
            Non-existent keys are ignored.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.Exists(Libplanet.Store.Trie.KeyBytes@)">
            <summary>
            Checks whether the given key exists in the store.
            </summary>
            <param name="key">A key to check.</param>
            <returns><see langword="true"/> if the key exists; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.Trie.IKeyValueStore.ListKeys">
            <summary>
            Lists all keys that have been stored in the storage.
            </summary>
            <returns>All keys in an arbitrary order.  The order might be vary for each call.
            </returns>
        </member>
        <member name="T:Libplanet.Store.Trie.ITrie">
            <summary>
            An interface for <see href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</see>.
            </summary>
            <seealso cref="T:Libplanet.Store.Trie.MerkleTrie"/>
        </member>
        <member name="P:Libplanet.Store.Trie.ITrie.Hash">
            <summary>
            The state root hash of the trie.
            </summary>
        </member>
        <member name="P:Libplanet.Store.Trie.ITrie.Recorded">
            <summary>
            Whether the trie root is recorded in the store.
            </summary>
            <remarks>Empty root is considered as recorded.</remarks>
        </member>
        <member name="M:Libplanet.Store.Trie.ITrie.Set(Libplanet.Store.Trie.KeyBytes@,Bencodex.Types.IValue)">
            <summary>
            Stores the <paramref name="value"/> to the
            node corresponding to given <paramref name="key"/>.
            </summary>
            <param name="key">The unique key to associate with the <paramref name="value"/>.</param>
            <param name="value">The value to store.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the given
            <paramref name="value"/> is <see langword="null"/>.</exception>
            <returns>Returns new updated <see cref="T:Libplanet.Store.Trie.ITrie"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.ITrie.Get(System.Collections.Generic.IReadOnlyList{Libplanet.Store.Trie.KeyBytes})">
            <summary>
            Gets the values stored with <paramref name="keys"/> in <see cref="M:Libplanet.Store.Trie.ITrie.Set(Libplanet.Store.Trie.KeyBytes@,Bencodex.Types.IValue)"/>.
            </summary>
            <param name="keys">The keys used in <see cref="M:Libplanet.Store.Trie.ITrie.Set(Libplanet.Store.Trie.KeyBytes@,Bencodex.Types.IValue)"/> to store a value.</param>
            <returns>The values associated to the specified <paramref name="keys"/>.  The associated
            values are ordered in the same way to the corresponding <paramref name="keys"/>.  Absent
            values are represented as <see langword="null"/>.</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.ITrie.Commit">
            <summary>
            Cleans up and stores the <see cref="T:Libplanet.Store.Trie.ITrie"/> in storage.
            </summary>
            <returns>Returns new committed <see cref="T:Libplanet.Store.Trie.ITrie"/>.</returns>
        </member>
        <member name="T:Libplanet.Store.Trie.KeyBytes">
            <summary>
            Wraps a byte array and provides equality comparison and hash code calculation.  Designed
            to be used as a key in dictionaries.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.#ctor(System.Byte[])">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.Trie.KeyBytes"/> instance from the given byte array.
            </summary>
            <param name="bytes">A mutable byte array to wrap.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.Trie.KeyBytes"/> instance from the given byte array.
            </summary>
            <param name="bytes">An immutable byte array to wrap.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates a new <seealso cref="T:Libplanet.Store.Trie.KeyBytes"/> instance from the given <paramref
            name="string"/>.
            </summary>
            <param name="string">A key string.  This is encoded to bytes.</param>
            <param name="encoding">The text encoding used for the key string.</param>
        </member>
        <member name="P:Libplanet.Store.Trie.KeyBytes.Length">
            <summary>
            The length of the byte array.
            </summary>
        </member>
        <member name="P:Libplanet.Store.Trie.KeyBytes.ByteArray">
            <summary>
            The immutable array of bytes.
            </summary>
        </member>
        <member name="P:Libplanet.Store.Trie.KeyBytes.Hex">
            <summary>
            The hexadecimal string representation of the byte array.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.op_Equality(Libplanet.Store.Trie.KeyBytes,Libplanet.Store.Trie.KeyBytes)">
            <summary>
            Compares two <see cref="T:Libplanet.Store.Trie.KeyBytes"/> values.
            </summary>
            <param name="left">An operand.</param>
            <param name="right">Another operand.</param>
            <returns><see langword="true"/> if two values equal; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.op_Inequality(Libplanet.Store.Trie.KeyBytes,Libplanet.Store.Trie.KeyBytes)">
            <summary>
            Compares two <see cref="T:Libplanet.Store.Trie.KeyBytes"/> values.
            </summary>
            <param name="left">An operand.</param>
            <param name="right">Another operand.</param>
            <returns><see langword="false"/> if two values equal; otherwise <see langword="true"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.FromHex(System.String)">
            <summary>
            Parses the given hexadecimal string as bytes and returns a new <see cref="T:Libplanet.Store.Trie.KeyBytes"/>
            instance.
            </summary>
            <param name="hex">A hexadecimal string which encodes bytes.</param>
            <returns>A new <see cref="T:Libplanet.Store.Trie.KeyBytes"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the given <paramref name="hex"/>
            string is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of the given
            <paramref name="hex"/> string is an odd number.</exception>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="hex"/> string is
            not a valid hexadecimal string.</exception>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.ToByteArray">
            <summary>
            Converts to a mutable byte array.
            </summary>
            <returns>A new copy of mutable byte array.</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.Equals(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.Equals(Libplanet.Store.Trie.KeyBytes)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.Equals(System.Byte[])">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Libplanet.Store.Trie.KeyBytes.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Store.Trie.MemoryKeyValueStore">
            <summary>
            Volatile in-memory key-value store.
            <para>It is useful for storing temporal small chains, e.g., fixtures for unit tests of
            game logic.</para>
            <para><see cref="T:Libplanet.Store.MemoryStore"/> and <see cref="T:Libplanet.Store.Trie.MemoryKeyValueStore"/>-backed
            <see cref="T:Libplanet.Store.TrieStateStore"/> can be instantiated from a URI with <c>memory:</c> scheme
            using <see cref="M:Libplanet.Store.StoreLoaderAttribute.LoadStore(System.Uri)"/>, e.g.:</para>
            <list type="bullet">
            <item><description><c>memory:</c></description></item>
            <item><description><c>memory://?secure=true</c> (trie keys are hashed)</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.Libplanet#Store#Trie#IKeyValueStore#Get(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.Get(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <inheritdoc cref="M:Libplanet.Store.Trie.IKeyValueStore.Get(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.Libplanet#Store#Trie#IKeyValueStore#Set(Libplanet.Store.Trie.KeyBytes@,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.Libplanet#Store#Trie#IKeyValueStore#Set(System.Collections.Generic.IDictionary{Libplanet.Store.Trie.KeyBytes,System.Byte[]})">
            <inheritdoc cref="M:Libplanet.Store.Trie.IKeyValueStore.Set(System.Collections.Generic.IDictionary{Libplanet.Store.Trie.KeyBytes,System.Byte[]})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.Libplanet#Store#Trie#IKeyValueStore#Delete(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.Delete(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})">
            <inheritdoc cref="M:Libplanet.Store.Trie.IKeyValueStore.Delete(System.Collections.Generic.IEnumerable{Libplanet.Store.Trie.KeyBytes})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.Libplanet#Store#Trie#IKeyValueStore#Exists(Libplanet.Store.Trie.KeyBytes@)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MemoryKeyValueStore.System#IDisposable#Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:Libplanet.Store.Trie.MerkleTrie">
            <summary>
            An <see cref="T:Libplanet.Store.Trie.ITrie"/> implementation implemented
            <see href="https://eth.wiki/fundamentals/patricia-tree">Merkle Patricia Trie</see>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.#ctor(Libplanet.Store.Trie.IKeyValueStore,Libplanet.HashDigest{System.Security.Cryptography.SHA256},System.Boolean)">
            <summary>
            An <see cref="T:Libplanet.Store.Trie.ITrie"/> implementation.
            </summary>
            <param name="keyValueStore">The <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> storage to store
            nodes.</param>
            <param name="rootHash">The root <see cref="P:Libplanet.Store.Trie.ITrie.Hash"/> of
            <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.</param>
            <param name="secure">Whether to use <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in
            secure mode.  If it is turned on, <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> internally stores hashed keys
            instead of bare keys.  Keys will be hashed with SHA-256.</param>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.#ctor(Libplanet.Store.Trie.IKeyValueStore,Libplanet.Store.Trie.Nodes.INode,System.Boolean)">
            <summary>
            An <see cref="T:Libplanet.Store.Trie.ITrie"/> implementation.
            </summary>
            <param name="keyValueStore">The <see cref="T:Libplanet.Store.Trie.IKeyValueStore"/> storage to store
            nodes.</param>
            <param name="root">The root node of <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.  If it is
            <see langword="null"/>, it will be treated like empty trie.</param>
            <param name="secure">Whether to use <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in secure
            mode. If it is true, <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> will stores the value with the hashed
            result from the given key as the key. Keys will be hashed with SHA-256.</param>
        </member>
        <member name="P:Libplanet.Store.Trie.MerkleTrie.Hash">
            <inheritdoc cref="P:Libplanet.Store.Trie.ITrie.Hash"/>
        </member>
        <member name="P:Libplanet.Store.Trie.MerkleTrie.Recorded">
            <inheritdoc cref="P:Libplanet.Store.Trie.ITrie.Recorded"/>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.Set(Libplanet.Store.Trie.KeyBytes@,Bencodex.Types.IValue)">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.Get(System.Collections.Generic.IReadOnlyList{Libplanet.Store.Trie.KeyBytes})">
            <inheritdoc cref="M:Libplanet.Store.Trie.ITrie.Get(System.Collections.Generic.IReadOnlyList{Libplanet.Store.Trie.KeyBytes})"/>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.Commit">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrie.GetNode(Libplanet.HashDigest{System.Security.Cryptography.SHA256})">
            <summary>
            Gets the node corresponding to <paramref name="nodeHash"/> from storage,
            (i.e., <see cref="P:Libplanet.Store.Trie.MerkleTrie.KeyValueStore"/>).
            </summary>
            <param name="nodeHash">The hash of node to get.</param>
            <returns>The node corresponding to <paramref name="nodeHash"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the <paramref name="nodeHash"/> is
            not found.</exception>
        </member>
        <member name="T:Libplanet.Store.Trie.MerkleTrieExtensions">
            <summary>
            An extension class to provide some convenient methods to deal with <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrieExtensions.DifferentNodes(Libplanet.Store.Trie.MerkleTrie,Libplanet.Store.Trie.MerkleTrie)">
            <summary>
            Compares two given tries and gets different value nodes (leaf node).
            </summary>
            <param name="origin">A trie to compare.</param>
            <param name="other">An other trie to compare.</param>
            <returns><see cref="T:System.Tuple`3"/>s consists of different nodes.
            The first element is different values' key.
            The second element is the value at the given <paramref name="origin"/> trie.
            And the third element is the value at the given <paramref name="other"/> trie but
            it is <see langword="null"/> if it doesn't exist in <paramref name="other"/> trie.
            </returns>
        </member>
        <member name="M:Libplanet.Store.Trie.MerkleTrieExtensions.ListAllStates(Libplanet.Store.Trie.MerkleTrie)">
            <summary>
            Lists the all states key and the all states in the given <paramref name="merkleTrie"/>.
            </summary>
            <param name="merkleTrie">A trie to discover.</param>
            <returns>All state keys and the all states.</returns>
        </member>
        <member name="M:Libplanet.Store.Trie.Nodes.BaseNode.ToBencodex">
            <inheritdoc cref="M:Libplanet.Store.Trie.Nodes.INode.ToBencodex"/>
        </member>
        <member name="M:Libplanet.Store.Trie.Nodes.FullNode.ToBencodex">
            <inheritdoc cref="M:Libplanet.Store.Trie.Nodes.INode.ToBencodex"/>
        </member>
        <member name="T:Libplanet.Store.Trie.Nodes.HashNode">
            <summary>
            <see cref="T:Libplanet.HashDigest`1"/>'s wrapper class, used in <see cref="T:Libplanet.Store.Trie.ITrie"/> interface.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.Nodes.HashNode.ToBencodex">
            <inheritdoc cref="M:Libplanet.Store.Trie.Nodes.INode.ToBencodex"/>
        </member>
        <member name="T:Libplanet.Store.Trie.Nodes.INode">
            <summary>
            A constituent unit of <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.
            </summary>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.FullNode"/>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.ShortNode"/>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.ValueNode"/>
            <seealso cref="T:Libplanet.Store.Trie.Nodes.HashNode"/>
        </member>
        <member name="M:Libplanet.Store.Trie.Nodes.ShortNode.ToBencodex">
            <inheritdoc cref="M:Libplanet.Store.Trie.Nodes.INode.ToBencodex"/>
        </member>
        <member name="T:Libplanet.Store.Trie.Nodes.ValueNode">
            <summary>
            Wrapper class.
            </summary>
        </member>
        <member name="M:Libplanet.Store.Trie.Nodes.ValueNode.ToBencodex">
            <inheritdoc cref="M:Libplanet.Store.Trie.Nodes.INode.ToBencodex"/>
        </member>
        <member name="T:Libplanet.Store.TrieStateStore">
            <summary>
            An <see cref="T:Libplanet.Store.IStateStore"/> implementation. It stores states with <see cref="T:Libplanet.Store.Trie.MerkleTrie"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.#ctor(Libplanet.Store.Trie.IKeyValueStore,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Libplanet.Store.TrieStateStore"/>.
            </summary>
            <param name="stateKeyValueStore">The storage to store states. It used by
            <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in internal.</param>
            <param name="secure">Whether to use <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> in secure mode.
            <seealso cref="M:Libplanet.Store.Trie.MerkleTrie.#ctor(Libplanet.Store.Trie.IKeyValueStore,Libplanet.Store.Trie.Nodes.INode,System.Boolean)"/>.</param>
        </member>
        <member name="P:Libplanet.Store.TrieStateStore.Secure">
            <summary>
            <see langword="true"/> if the <see cref="T:Libplanet.Store.Trie.MerkleTrie"/> is in secure mode.
            In secure mode, keys are hashed under the hood.
            </summary>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.PruneStates(System.Collections.Immutable.IImmutableSet{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <inheritdoc cref="M:Libplanet.Store.IStateStore.PruneStates(System.Collections.Immutable.IImmutableSet{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})"/>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.CopyStates(System.Collections.Immutable.IImmutableSet{Libplanet.HashDigest{System.Security.Cryptography.SHA256}},Libplanet.Store.TrieStateStore)">
            <summary>
            Copies states under state root hashes of given <paramref name="stateRootHashes"/>
            to <paramref name="targetStateStore"/>.
            </summary>
            <param name="stateRootHashes">The state root hashes of states to copy.</param>
            <param name="targetStateStore">The target state store to copy state root hashes.</param>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.GetStateRoot(System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})">
            <inheritdoc cref="M:Libplanet.Store.IStateStore.GetStateRoot(System.Nullable{Libplanet.HashDigest{System.Security.Cryptography.SHA256}})"/>
        </member>
        <member name="M:Libplanet.Store.TrieStateStore.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxException">
            <summary>
            Serves as the base class for exceptions thrown by
            <see cref="M:Libplanet.Tx.Transaction`1.Validate"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxException.#ctor(System.String,Libplanet.Tx.TxId)">
            <summary>
            Instantiates a new exception object with proper metadata. Use
            <see cref="M:Libplanet.Tx.InvalidTxException.#ctor(System.String,Libplanet.Tx.TxId,System.Exception)"/> if innerException
            is required.
            </summary>
            <param name="message">A descriptive error message for programmers.
            </param>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxException.#ctor(System.String,Libplanet.Tx.TxId,System.Exception)">
            <inheritdoc cref="M:Libplanet.Tx.InvalidTxException.#ctor(System.String,Libplanet.Tx.TxId)"/>
            <param name="message">A descriptive error message for programmers.
            </param>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="innerException">The <see cref="T:System.Exception"/> for
            <see cref="P:System.Exception.InnerException"/>.</param>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxException.TxId">
            <summary>
            The <see cref="P:Libplanet.Tx.InvalidTxException.TxId"/> of the invalid <see cref="T:Libplanet.Tx.Transaction`1"/>.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxGenesisHashException">
            <summary>
            The exception that is thrown when the <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>
            is different from the <see cref="T:Libplanet.HashDigest`1"/> of
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Genesis"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxGenesisHashException.#ctor(System.String,Libplanet.Tx.TxId,Libplanet.Blocks.BlockHash,System.Nullable{Libplanet.Blocks.BlockHash})">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Tx.InvalidTxGenesisHashException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="expectedGenesisHash">The <see cref="T:Libplanet.HashDigest`1"/>
            value of <see cref="P:Libplanet.Blockchain.BlockChain`1.Genesis"/>.</param>
            <param name="improperGenesisHash">The actual
            <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>.  This can be <see langword="null"/>.</param>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxGenesisHashException.ExpectedGenesisHash">
            <summary>
            The <see cref="T:Libplanet.HashDigest`1"/> value of
            <see cref="P:Libplanet.Blockchain.BlockChain`1.Genesis"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxGenesisHashException.ImproperGenesisHash">
            <summary>
            The actual <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>, which is improper.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxIdException">
            <summary>
            The exception that is thrown when a given <see cref="T:Libplanet.Tx.TxId"/> cannot be
            found.
            </summary>
            <remarks>This does <em>not</em> mean a given value is an invalid
            encoding of <see cref="T:Libplanet.Tx.TxId"/>, but there is no corresponding entry to
            a given <see cref="T:Libplanet.Tx.TxId"/>, which is <em>valid</em>.</remarks>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxIdException.#ctor(System.String,Libplanet.Tx.TxId)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.InvalidTxIdException"/> object.
            </summary>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.
            </param>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.TxId"/>.
            It is automatically included to the <see cref="P:System.Exception.Message"/>
            string.</param>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxNonceException">
            <summary>
            The exception that is thrown when the <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>
            is different from <see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/> result of
            the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxNonceException.#ctor(System.String,Libplanet.Tx.TxId,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Libplanet.Tx.InvalidTxNonceException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
            <param name="expectedNonce"><see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/>
            result of the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.</param>
            <param name="improperNonce">The actual
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>.</param>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxNonceException.ExpectedNonce">
            <summary>
            <see cref="M:Libplanet.Blockchain.BlockChain`1.GetNextTxNonce(Libplanet.Address)"/> result of the
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.InvalidTxNonceException.ImproperNonce">
            <summary>
            The actual <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>, which is improper.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.InvalidTxSignatureException">
            <summary>
            The exception that is thrown when a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> is invalid.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.InvalidTxSignatureException.#ctor(System.String,Libplanet.Tx.TxId)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.InvalidTxSignatureException"/> object.
            </summary>
            <param name="message">Specifies an <see cref="P:System.Exception.Message"/>.</param>
            <param name="txid">The invalid <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.  It is automatically included to
            the <see cref="P:System.Exception.Message"/> string.</param>
        </member>
        <member name="T:Libplanet.Tx.ITransaction">
            <summary>
            Similar to <see cref="T:Libplanet.Tx.ITxExcerpt"/> except that it has <see cref="P:Libplanet.Tx.ITransaction.Signature"/>,
            <see cref="P:Libplanet.Tx.ITransaction.SystemAction"/> and <see cref="P:Libplanet.Tx.ITransaction.CustomActions"/> as well.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITransaction.Signature">
            <summary>
            A digital signature of the content of this <see cref="T:Libplanet.Tx.ITransaction"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITransaction.SystemAction">
            <summary>
            A system action (if any) that this <see cref="T:Libplanet.Tx.ITransaction"/> contains.
            </summary>
            <remarks>It is similar with <see cref="P:Libplanet.Tx.Transaction`1.SystemAction"/> but
            it is non-generic.  (i.e., it doesn't require to deserialize the system action to
            <see cref="T:Libplanet.Action.IAction"/> while serialization.</remarks>
        </member>
        <member name="P:Libplanet.Tx.ITransaction.CustomActions">
            <summary>
            Zero or more user-defined custom actions that this <see cref="T:Libplanet.Tx.ITransaction"/>
            contains.
            </summary>
            <remarks>It is similar with <see cref="P:Libplanet.Tx.Transaction`1.CustomActions"/> but
            it is non-generic.  (i.e., it doesn't require to deserialize the custom actions to
            <see cref="T:Libplanet.Action.IAction"/> while serialization.</remarks>
        </member>
        <member name="T:Libplanet.Tx.ITxExcerpt">
            <summary>
            Similar to <see cref="T:Libplanet.Tx.ITxMetadata"/> except that it has <see cref="T:Libplanet.Tx.TxId"/> as well.
            Note that this does not contain actions or signature.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITxExcerpt.Id">
            <summary>
            The unique identifier derived from this transaction's content including actions and
            signature.
            </summary>
            <seealso cref="T:Libplanet.Tx.TxId"/>
        </member>
        <member name="T:Libplanet.Tx.ITxMetadata">
            <summary>
            A common interface for transactions that do not have any proofs nor actions.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITxMetadata.Nonce">
            <summary>
            The number of previous <see cref="T:Libplanet.Tx.Transaction`1"/>s committed by
            the <see cref="P:Libplanet.Tx.ITxMetadata.Signer"/> of this transaction.  This nonce is used for preventing
            replay attack.
            </summary>
            <remarks>Don't confuse this with <see cref="P:Libplanet.Blocks.Block`1.Nonce"/> for proof-of-work.
            </remarks>
        </member>
        <member name="P:Libplanet.Tx.ITxMetadata.Signer">
            <summary>
            A <see cref="P:Libplanet.Tx.ITxMetadata.PublicKey"/> of the account who signs this transaction.
            This is derived from the <see cref="P:Libplanet.Tx.ITxMetadata.PublicKey"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITxMetadata.UpdatedAddresses">
            <summary>
            An approximated list of addresses whose states would be affected by actions in this
            transaction.  However, it could be wrong.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITxMetadata.Timestamp">
            <summary>
            The time this transaction is created and signed.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITxMetadata.PublicKey">
            <summary>
            A <see cref="P:Libplanet.Tx.ITxMetadata.PublicKey"/> of the account who signs this transaction.
            The <see cref="P:Libplanet.Tx.ITxMetadata.Signer"/> address is always corresponding to this
            for each transaction.  This cannot be <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.ITxMetadata.GenesisHash">
            <summary>
            A <see cref="T:Libplanet.HashDigest`1"/> value of the genesis which this transaction is made
            from.  This can be <see langword="null"/> iff the transaction is contained in
            the genesis block.
            </summary>
        </member>
        <member name="T:Libplanet.Tx.Transaction`1">
            <summary>
            Consists of <see cref="T:Libplanet.Action.IAction"/> and is signed to be included in
            a <see cref="T:Libplanet.Blocks.Block`1"/> and transmitted over the network.
            </summary>
            <typeparam name="T">A class implementing <see cref="T:Libplanet.Action.IAction"/> to
            include.
            Each game usually defines its own concrete class which implements
            <see cref="T:Libplanet.Action.IAction"/>, and uses it for this type parameter.
            This type parameter is aligned with <see cref="T:Libplanet.Blocks.Block`1"/>'s
            and <see cref="T:Libplanet.Blockchain.BlockChain`1"/>'s type parameters.
            </typeparam>
            <seealso cref="T:Libplanet.Action.IAction"/>
            <seealso cref="T:Libplanet.Action.PolymorphicAction`1"/>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.#ctor(Libplanet.Tx.ITxMetadata,Libplanet.Action.IAction,System.Byte[])">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.Transaction`1"/> instance by copying data from a specified
            transaction <paramref name="metadata"/>.
            </summary>
            <param name="metadata">The transaction metadata that contains data to copy.</param>
            <param name="systemAction">A system built-in action to include.  This cannot be
            <see langword="null"/>, and goes to the <see cref="P:Libplanet.Tx.Transaction`1.SystemAction"/> property.</param>
            <param name="signature">A digital signature of the content of this
            <see cref="T:Libplanet.Tx.Transaction`1"/>.  This has to be signed by <paramref name="metadata"/>'s
            <see cref="P:Libplanet.Tx.ITxMetadata.PublicKey"/>. This is copied and then assigned to
            the <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> property.</param>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.#ctor(Libplanet.Tx.ITxMetadata,System.Collections.Generic.IEnumerable{`0},System.Byte[])">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.Transaction`1"/> instance by copying data from a specified
            transaction <paramref name="metadata"/>.
            </summary>
            <param name="metadata">The transaction metadata that contains data to copy.</param>
            <param name="customActions">A list of user-defined custom actions to include.  This can
            be empty, but cannot be <see langword="null"/>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.CustomActions"/> property.</param>
            <param name="signature">A digital signature of the content of this
            <see cref="T:Libplanet.Tx.Transaction`1"/>.  This has to be signed by <paramref name="metadata"/>'s
            <see cref="P:Libplanet.Tx.ITxMetadata.PublicKey"/>. This is copied and then assigned to
            the <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> property.</param>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.#ctor(System.Int64,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.DateTimeOffset,System.Collections.Generic.IEnumerable{`0},System.Byte[])">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.Transaction`1"/>.
            <para>This constructor takes all required and only required values
            for a <see cref="T:Libplanet.Tx.Transaction`1"/>, so gives you full control of
            creating a <see cref="T:Libplanet.Tx.Transaction`1"/>, and in other words,
            this constructor is only useful when all details of
            a <see cref="T:Libplanet.Tx.Transaction`1"/> need to be manually adjusted.
            For the most cases, the fa&#xe7;ade factory <see
            cref="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})"/> is more useful.</para>
            </summary>
            <param name="nonce">The number of previous
            <see cref="T:Libplanet.Tx.Transaction`1"/>s committed by the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>
            of this transaction.  This goes to the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> property.</param>
            <param name="signer">Ignored.  Left only for backward compatibility.  It will be
            completely gone in the future.  See also <paramref name="publicKey"/> parameter's
            description.</param>
            <param name="publicKey">A <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/> used for signing this transaction.
            This cannot be <see langword="null"/>.  This goes to the <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>
            property, and <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> property is also derived from this value.</param>
            <param name="genesisHash">A <see cref="T:Libplanet.HashDigest`1"/> value
            of the genesis which this <see cref="T:Libplanet.Tx.Transaction`1"/> is made from.
            This can be <see langword="null"/> iff the transaction is contained
            in the genesis block.
            </param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose
            states affected by <paramref name="customActions"/>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property.</param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/>
            is created and signed.  This goes to the <see cref="P:Libplanet.Tx.Transaction`1.Timestamp"/>
            property.</param>
            <param name="customActions">A list of user-defined custom actions to include.  This can
            be empty, but cannot be <see langword="null"/>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.CustomActions"/> property.</param>
            <param name="signature">A digital signature of the content of
            this <see cref="T:Libplanet.Tx.Transaction`1"/>.  This has to be signed by
            the account who corresponds to <paramref name="publicKey"/>,
            or it will throw <see cref="T:Libplanet.Tx.InvalidTxSignatureException"/>.
            This is copied and then assigned to the <see cref="P:Libplanet.Tx.Transaction`1.Signature"/>
            property.</param>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.#ctor(Bencodex.Types.Dictionary)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.Transaction`1"/> instance from its serialization.
            </summary>
            <param name="dict">The <see cref="T:Bencodex.Types.Dictionary"/>
            representation of <see cref="T:Libplanet.Tx.Transaction`1"/> instance.
            </param>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Id">
            <summary>
            A unique identifier derived from this <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            content.
            <para>For more characteristics, see <see cref="T:Libplanet.Tx.TxId"/> type.</para>
            </summary>
            <seealso cref="T:Libplanet.Tx.TxId"/>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Nonce">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.Nonce"/>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Signer">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.Signer"/>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.UpdatedAddresses">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.UpdatedAddresses"/>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Signature">
            <summary>
            A digital signature of the content of this
            <see cref="T:Libplanet.Tx.Transaction`1"/>.  This is signed by the account
            who corresponds to <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            This cannot be <see langword="null"/>.
            </summary>
            <returns>A new <see cref="T:System.Byte"/> array of this transaction's
            signature.  Changing a returned array does not affect the internal
            state of this <see cref="T:Libplanet.Tx.Transaction`1"/> object.</returns>
            <remarks>Although this cannot be <see langword="null"/>, it can be an empty
            array if the transaction is not signed yet.</remarks>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Actions">
            <summary>
            A list of <see cref="T:Libplanet.Action.IAction"/>s.  These are executed in the order.
            This can be empty, but cannot be <see langword="null"/>.
            </summary>
            <remarks>This property is deprecated.  Use <see cref="P:Libplanet.Tx.Transaction`1.CustomActions"/> or
            <see cref="P:Libplanet.Tx.Transaction`1.SystemAction"/> instead.</remarks>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.SystemAction">
            <summary>
            A system action (if any) that this <see cref="T:Libplanet.Tx.Transaction`1"/> contains.
            </summary>
            <remarks>This property is mutually exclusive with <see cref="P:Libplanet.Tx.Transaction`1.CustomActions"/>;
            either one of them must be <see langword="null"/> and the other must not be
            <see langword="null"/>.</remarks>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.CustomActions">
            <summary>
            Zero or more user-defined custom actions that this <see cref="T:Libplanet.Tx.Transaction`1"/>
            contains.  These are executed in the order.
            </summary>
            <remarks>This property is mutually exclusive with <see cref="P:Libplanet.Tx.Transaction`1.SystemAction"/>;
            either one of them must be <see langword="null"/> and the other must not be
            <see langword="null"/>.</remarks>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.Timestamp">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.PublicKey">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Tx.Transaction`1.GenesisHash">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.GenesisHash"/>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Deserialize(System.Byte[],System.Boolean)">
            <summary>
            Decodes a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            <a href="https://bencodex.org/">Bencodex</a> representation.
            </summary>
            <param name="bytes">A <a href="https://bencodex.org/">Bencodex</a>
            representation of a <see cref="T:Libplanet.Tx.Transaction`1"/>.</param>
            <param name="validate">Whether to validate the transaction.</param>
            <returns>A decoded <see cref="T:Libplanet.Tx.Transaction`1"/> object.</returns>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> is invalid or not signed by
            the account who corresponds to <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            </exception>
            <seealso cref="M:Libplanet.Tx.Transaction`1.Serialize(System.Boolean)"/>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Action.IAction,System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            Almost same as <see cref="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})"/> except that this factory method takes
            a <paramref name="systemAction"/> instead of user-defined custom actions.
            </summary>
            <param name="nonce">Specifies <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>.</param>
            <param name="privateKey">Derives <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>,
            <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>, and <see cref="P:Libplanet.Tx.Transaction`1.Signature"/>
            from this.</param>
            <param name="genesisHash">Specifies <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>.</param>
            <param name="systemAction">Specifies <see cref="P:Libplanet.Tx.Transaction`1.SystemAction"/>.</param>
            <param name="updatedAddresses">Specifies <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/>.
            The resulting <see cref="T:Libplanet.Tx.Transaction`1"/> may contain more
            <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> than this argument.</param>
            <param name="timestamp">Specifies <see cref="P:Libplanet.Tx.Transaction`1.Timestamp"/>.</param>
            <returns>A created signed <see cref="T:Libplanet.Tx.Transaction`1"/>.</returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Create(System.Int64,Libplanet.Crypto.PrivateKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            A fa&#xe7;ade factory to create a new <see cref="T:Libplanet.Tx.Transaction`1"/>.
            Unlike the <see cref="M:Libplanet.Tx.Transaction`1.#ctor(System.Int64,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.DateTimeOffset,System.Collections.Generic.IEnumerable{`0},System.Byte[])"/>
            constructor, it automatically fills the following values from:
            <list type="table">
            <listheader>
            <term>Property</term>
            <description>Parameter the filled value derived from</description>
            </listheader>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.Signer"/></term>
            <description><paramref name="privateKey"/></description>
            </item>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/></term>
            <description><paramref name="privateKey"/></description>
            </item>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/></term>
            <description><paramref name="customActions"/> and
            <paramref name="updatedAddresses"/></description>
            </item>
            </list>
            <para>Note that the <paramref name="privateKey"/> in itself is not
            included in the created <see cref="T:Libplanet.Tx.Transaction`1"/>.</para>
            </summary>
            <remarks>
            This factory method tries its best to fill the <see
            cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property by actually evaluating
            the given <paramref name="customActions"/> (we call it &#x201c;rehearsal
            mode&#x201d;), but remember that its result
            is approximated in some degree, because the result of
            <paramref name="customActions"/> are not deterministic until
            the <see cref="T:Libplanet.Tx.Transaction`1"/> belongs to a <see
            cref="T:Libplanet.Blocks.Block`1"/>.
            <para>If an <see cref="T:Libplanet.Action.IAction"/> depends on previous states or
            some randomness to determine what <see cref="T:Libplanet.Address"/> to update,
            the automatically filled <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> became
            mismatched from the <see cref="T:Libplanet.Address"/>es
            <paramref name="customActions"/> actually update after
            a <see cref="T:Libplanet.Blocks.Block`1"/> is mined.
            Although such case would be rare, a programmer could manually give
            the <paramref name="updatedAddresses"/> parameter
            the <see cref="T:Libplanet.Address"/>es they predict to be updated.</para>
            <para>If an <see cref="T:Libplanet.Action.IAction"/> oversimplifies the assumption
            about the <see cref="T:Libplanet.Blocks.Block`1"/> it belongs to,
            runtime exceptions could be thrown from this factory method.
            The best solution to that is not to oversimplify things,
            there is an option to check <see cref="T:Libplanet.Action.IActionContext"/>'s
            <see cref="P:Libplanet.Action.IActionContext.Rehearsal"/> is <see langword="true"/> and
            a conditional logic for the case.</para>
            </remarks>
            <param name="nonce">The number of previous
            <see cref="T:Libplanet.Tx.Transaction`1"/>s committed by the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>
            of this transaction.  This goes to the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> property.</param>
            <param name="privateKey">A <see cref="T:Libplanet.Crypto.PrivateKey"/> of the account
            who creates and signs a new transaction.  This key is used to fill
            the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>, <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>, and
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> properties, but this in itself is not
            included in the transaction.</param>
            <param name="genesisHash">A <see cref="T:Libplanet.HashDigest`1"/> value
            of the genesis which this <see cref="T:Libplanet.Tx.Transaction`1"/> is made from.
            This can be <see langword="null"/> iff the transaction is contained
            in the genesis block.
            </param>
            <param name="customActions">A list of user-defined custom actions to include.  This can
            be empty, but cannot be <see langword="null"/>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.CustomActions"/> property, and these actionss are evaluated before
            a <see cref="T:Libplanet.Tx.Transaction`1"/> is created in order to fill
            the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/>.  See also <em>Remarks</em> section.</param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose
            states affected by <paramref name="customActions"/>.
            These <see cref="T:Libplanet.Address"/>es are also included in
            the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property, besides
            <see cref="T:Libplanet.Address"/>es projected by evaluating
            <paramref name="customActions"/>.  See also <em>Remarks</em> section.</param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/>
            is created and signed.  This goes to the <see cref="P:Libplanet.Tx.Transaction`1.Timestamp"/>
            property.  If <see langword="null"/> (which is default) is passed this will
            be the current time.</param>
            <returns>A created new <see cref="T:Libplanet.Tx.Transaction`1"/> signed by
            the given <paramref name="privateKey"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <see langword="null"/>
            is passed to <paramref name="privateKey"/> or <paramref name="customActions"/>.
            </exception>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.CreateUnsigned(System.Int64,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.Blocks.BlockHash},Libplanet.Action.IAction,System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            Almost same as <see cref="M:Libplanet.Tx.Transaction`1.CreateUnsigned(System.Int64,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})"/> except that this factory method takes
            a <paramref name="systemAction"/> instead of user-defined custom actions.
            </summary>
            <param name="nonce">Specifies <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/>.</param>
            <param name="publicKey">Specifies <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.</param>
            <param name="genesisHash">Specifies <see cref="P:Libplanet.Tx.Transaction`1.GenesisHash"/>.</param>
            <param name="systemAction">Specifies <see cref="P:Libplanet.Tx.Transaction`1.SystemAction"/>.</param>
            <param name="updatedAddresses">Specifies <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/>.
            The resulting <see cref="T:Libplanet.Tx.Transaction`1"/> may contain more
            <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> than this argument.</param>
            <param name="timestamp">Specifies <see cref="P:Libplanet.Tx.Transaction`1.Timestamp"/>.</param>
            <returns>A created unsigned <see cref="T:Libplanet.Tx.Transaction`1"/>.</returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.CreateUnsigned(System.Int64,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Generic.IEnumerable{`0},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.Nullable{System.DateTimeOffset})">
            <summary>
            A fa&#xe7;ade factory to create a new <see cref="T:Libplanet.Tx.Transaction`1"/>.
            Unlike the <see cref="M:Libplanet.Tx.Transaction`1.#ctor(System.Int64,Libplanet.Address,Libplanet.Crypto.PublicKey,System.Nullable{Libplanet.Blocks.BlockHash},System.Collections.Immutable.IImmutableSet{Libplanet.Address},System.DateTimeOffset,System.Collections.Generic.IEnumerable{`0},System.Byte[])"/>
            constructor, it automatically fills the following values from:
            <list type="table">
            <listheader>
            <term>Property</term>
            <description>Parameter the filled value derived from</description>
            </listheader>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.Signer"/></term>
            <description><paramref name="publicKey"/></description>
            </item>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/></term>
            <description><paramref name="publicKey"/></description>
            </item>
            <item>
            <term><see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/></term>
            <description><paramref name="customActions"/> and
            <paramref name="updatedAddresses"/></description>
            </item>
            </list>
            </summary>
            <remarks>
            This factory method tries its best to fill the <see
            cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property by actually evaluating
            the given <paramref name="customActions"/> (we call it &#x201c;rehearsal
            mode&#x201d;), but remember that its result
            is approximated in some degree, because the result of
            <paramref name="customActions"/> are not deterministic until
            the <see cref="T:Libplanet.Tx.Transaction`1"/> belongs to a <see
            cref="T:Libplanet.Blocks.Block`1"/>.
            <para>If an <see cref="T:Libplanet.Action.IAction"/> depends on previous states or
            some randomness to determine what <see cref="T:Libplanet.Address"/> to update,
            the automatically filled <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> became
            mismatched from the <see cref="T:Libplanet.Address"/>es
            <paramref name="customActions"/> actually update after
            a <see cref="T:Libplanet.Blocks.Block`1"/> is mined.
            Although such case would be rare, a programmer could manually give
            the <paramref name="updatedAddresses"/> parameter
            the <see cref="T:Libplanet.Address"/>es they predict to be updated.</para>
            <para>If an <see cref="T:Libplanet.Action.IAction"/> oversimplifies the assumption
            about the <see cref="T:Libplanet.Blocks.Block`1"/> it belongs to,
            runtime exceptions could be thrown from this factory method.
            The best solution to that is not to oversimplify things,
            there is an option to check <see cref="T:Libplanet.Action.IActionContext"/>'s
            <see cref="P:Libplanet.Action.IActionContext.Rehearsal"/> is <see langword="true"/> and
            a conditional logic for the case.</para>
            </remarks>
            <param name="nonce">The number of previous
            <see cref="T:Libplanet.Tx.Transaction`1"/>s committed by the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/>
            of this transaction.  This goes to the
            <see cref="P:Libplanet.Tx.Transaction`1.Nonce"/> property.</param>
            <param name="publicKey">A <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/> of the account
            who creates a new transaction.  This key is used to fill
            the <see cref="P:Libplanet.Tx.Transaction`1.Signer"/> and <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/> properties,
            but this in itself is not included in the transaction.</param>
            <param name="genesisHash">A <see cref="T:Libplanet.HashDigest`1"/> value
            of the genesis which this <see cref="T:Libplanet.Tx.Transaction`1"/> is made from.
            This can be <see langword="null"/> iff the transaction is contained
            in the genesis block.
            </param>
            <param name="customActions">A list of user-defined custom actions to include.  This can
            be empty, but cannot be <see langword="null"/>.  This goes to
            the <see cref="P:Libplanet.Tx.Transaction`1.CustomActions"/> property, and these actionss are evaluated before
            a <see cref="T:Libplanet.Tx.Transaction`1"/> is created in order to fill
            the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/>.  See also <em>Remarks</em> section.</param>
            <param name="updatedAddresses"><see cref="T:Libplanet.Address"/>es whose
            states affected by <paramref name="customActions"/>.
            These <see cref="T:Libplanet.Address"/>es are also included in
            the <see cref="P:Libplanet.Tx.Transaction`1.UpdatedAddresses"/> property, besides
            <see cref="T:Libplanet.Address"/>es projected by evaluating
            <paramref name="customActions"/>.  See also <em>Remarks</em> section.
            </param>
            <param name="timestamp">The time this <see cref="T:Libplanet.Tx.Transaction`1"/>
            is created.  This goes to the <see cref="P:Libplanet.Tx.Transaction`1.Timestamp"/>
            property.  If <see langword="null"/> (which is default) is passed this will
            be the current time.</param>
            <returns>A created new <see cref="T:Libplanet.Tx.Transaction`1"/> unsigned.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <see langword="null"/>
            is passed to <paramref name="customActions"/>.</exception>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Serialize(System.Boolean)">
            <summary>
            Encodes this <see cref="T:Libplanet.Tx.Transaction`1"/> into a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="sign">Whether to include its <see cref="P:Libplanet.Tx.Transaction`1.Signature"/>.
            </param>
            <returns>A <a href="https://bencodex.org/">Bencodex</a>
            representation of this <see cref="T:Libplanet.Tx.Transaction`1"/>.</returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.ToBencodex(System.Boolean)">
            <summary>
            Encodes this <see cref="T:Libplanet.Tx.Transaction`1"/> into a <see cref="T:Bencodex.Types.IValue"/>.
            </summary>
            <param name="sign">Whether to include its <see cref="P:Libplanet.Tx.Transaction`1.Signature"/>.
            Note that an encoding without signature cannot be decoded.
            </param>
            <returns>A <see cref="T:Bencodex.Types.Dictionary"/> typed
            <a href="https://bencodex.org/">Bencodex</a>
            representation of this <see cref="T:Libplanet.Tx.Transaction`1"/>.</returns>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Validate">
            <summary>
            Validates this <see cref="T:Libplanet.Tx.Transaction`1"/> and throws an appropriate exception
            if not valid.
            </summary>
            <exception cref="T:Libplanet.Tx.InvalidTxSignatureException">Thrown when its
            <see cref="P:Libplanet.Tx.Transaction`1.Signature"/> is invalid or not signed by
            the account who corresponds to its <see cref="P:Libplanet.Tx.Transaction`1.PublicKey"/>.
            </exception>
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Equals(Libplanet.Tx.Transaction{`0})">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Libplanet.Tx.Transaction`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Tx.TxExcerptExtensions">
            <summary>
            Useful extension methods for <see cref="T:Libplanet.Tx.ITxExcerpt"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxExcerptExtensions.ValidateTxNonces``1(System.Collections.Generic.IEnumerable{``0},System.Int64)">
            <summary>
            Validates if <paramref name="transactions"/> has valid nonces.
            It assumes all given <paramref name="transactions"/> belong to a block together.
            </summary>
            <param name="transactions">A list of transactions.  Their order does not matter.</param>
            <param name="blockIndex">The index of the block that transactions will belong to.
            It's only used for exception messages.</param>
            <typeparam name="T">A transaction type.</typeparam>
            <exception cref="T:Libplanet.Tx.InvalidTxNonceException">Thrown when the same tx nonce is used by
            a signer twice or more, or a tx nonce is used without its previous nonce by a signer.
            Note that this validates only a block's intrinsic integrity between its transactions,
            but does not guarantee integrity between blocks.  Such validation needs to be conducted
            by <see cref="T:Libplanet.Blockchain.BlockChain`1"/>.</exception>
            <exception cref="T:Libplanet.Tx.InvalidTxGenesisHashException">Thrown when transactions to set have
            inconsistent genesis hashes.</exception>
        </member>
        <member name="T:Libplanet.Tx.TxExecution">
            <summary>
            Summarizes an execution result of a <see cref="T:Libplanet.Tx.Transaction`1"/>.
            <para>Note that <see cref="T:Libplanet.Tx.Transaction`1"/>s cannot be executed without belonging to
            a <see cref="T:Libplanet.Blocks.Block`1"/>, and even if it's the same <see cref="T:Libplanet.Tx.Transaction`1"/> its
            result can vary depending on <see cref="T:Libplanet.Blocks.Block`1"/> that it is executed within.</para>
            </summary>
            <seealso cref="T:Libplanet.Tx.TxSuccess"/>
            <seealso cref="T:Libplanet.Tx.TxFailure"/>
        </member>
        <member name="P:Libplanet.Tx.TxExecution.BlockHash">
            <summary>
            The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/> that
            the <see cref="T:Libplanet.Tx.Transaction`1"/> is executed within.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.TxExecution.TxId">
            <summary>
            The executed <see cref="T:Libplanet.Tx.Transaction`1"/>'s <see cref="P:Libplanet.Tx.Transaction`1.Id"/>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.TxExecution.ActionsLogsList">
            <summary>
            The logs recorded while executing <see cref="T:Libplanet.Tx.Transaction`1"/>'s actions.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxExecution.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Tx.TxFailure">
            <summary>
            Summarizes an execution result of a <see cref="T:Libplanet.Tx.Transaction`1"/> with any exception-throwing
            actions.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxFailure.#ctor(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId,System.Collections.Generic.List{System.Collections.Generic.List{System.String}},System.String,Bencodex.Types.IValue)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxFailure"/> instance.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that the <see cref="T:Libplanet.Tx.Transaction`1"/> is executed within.</param>
            <param name="txId">The executed <see cref="T:Libplanet.Tx.Transaction`1"/>'s <see
            cref="P:Libplanet.Tx.Transaction`1.Id"/>.</param>
            <param name="actionsLogsList">The logs recorded while executing actions.</param>
            <param name="exceptionName">The name of the exception type,
            e.g., <c>System.ArgumentException</c>.</param>
            <param name="exceptionMetadata">Optional metadata about the exception.</param>
        </member>
        <member name="M:Libplanet.Tx.TxFailure.#ctor(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId,System.Collections.Generic.List{System.Collections.Generic.List{System.String}},System.Exception)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxFailure"/> instance.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that the <see cref="T:Libplanet.Tx.Transaction`1"/> is executed within.</param>
            <param name="txId">The executed <see cref="T:Libplanet.Tx.Transaction`1"/>'s <see
            cref="P:Libplanet.Tx.Transaction`1.Id"/>.</param>
            <param name="actionsLogsList">The logs recorded while executing actions.</param>
            <param name="exception">The uncaught exception thrown by an action in the transaction.
            </param>
        </member>
        <member name="P:Libplanet.Tx.TxFailure.ExceptionName">
            <summary>
            The name of the exception type, e.g., <c>System.ArgumentException</c>.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.TxFailure.ExceptionMetadata">
            <summary>
            Optional metadata about the exception.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxFailure.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:Libplanet.Tx.TxId">
            <summary>
            <see cref="T:Libplanet.Tx.TxId"/>, abbreviation of transaction identifier,
            is a SHA-256 digest derived from a <see cref="T:Libplanet.Tx.Transaction`1"/>'s
            content.
            <para>As it is a SHA-256 digest, it consists of 32 <see cref="T:System.Byte"/>s,
            and 64 characters in hexadecimal.
            (See also <see cref="F:Libplanet.Tx.TxId.Size"/> constant.)</para>
            </summary>
            <seealso cref="P:Libplanet.Tx.Transaction`1.Id"/>
        </member>
        <member name="F:Libplanet.Tx.TxId.Size">
            <summary>
            The <see cref="T:System.Byte"/>s size that each <see cref="T:Libplanet.Tx.TxId"/> takes.
            <para>As a txid is a SHA-256 digest, it is 32 <see cref="T:System.Byte"/>s.
            </para>
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)">
            <summary>
            Converts an immutable <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <param name="txid">An immutable <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.Tx.TxId"/>.  It must not be <see langword="null"/>, and its
            <see cref="P:System.Collections.Immutable.ImmutableArray`1.Length"/> must be the same to <see cref="F:Libplanet.Tx.TxId.Size"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="txid"/>'s <see cref="P:System.Array.Length"/> is not the same to the required
            <see cref="F:Libplanet.Tx.TxId.Size"/>.</exception>
        </member>
        <member name="M:Libplanet.Tx.TxId.#ctor(System.Byte[])">
            <summary>
            Converts a mutable <see cref="T:System.Byte"/> array into a <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <param name="txid">A mutable <see cref="T:System.Byte"/> array that encodes
            a <see cref="T:Libplanet.Tx.TxId"/>.  It must not be <see langword="null"/>,
            and its <see cref="P:System.Array.Length"/> must be the same to
            <see cref="F:Libplanet.Tx.TxId.Size"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="txid"/>'s <see cref="P:System.Array.Length"/> is not
            the same to the required <see cref="F:Libplanet.Tx.TxId.Size"/>.</exception>
        </member>
        <member name="M:Libplanet.Tx.TxId.#ctor(Bencodex.Types.IValue)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxId"/> instance from given <paramref name="bencoded"/>.
            </summary>
            <param name="bencoded">A Bencodex <see cref="T:Bencodex.Types.Binary"/> of 32 <see cref="T:System.Byte"/>s which
            represents an <see cref="T:Libplanet.Tx.TxId"/>.
            </param>
            <exception cref="T:System.ArgumentException">Thrown when given <paramref name="bencoded"/>
            is not of type <see cref="T:Bencodex.Types.Binary"/>.</exception>
            <seealso cref="M:Libplanet.Tx.TxId.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte}@)"/>
        </member>
        <member name="P:Libplanet.Tx.TxId.ByteArray">
            <summary>
            A bare immutable <see cref="T:System.Byte"/> array of
            this <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <remarks>It is immutable.  For a mutable array, use
            <see cref="M:Libplanet.Tx.TxId.ToByteArray"/> method instead.</remarks>
            <seealso cref="M:Libplanet.Tx.TxId.ToByteArray"/>
        </member>
        <member name="P:Libplanet.Tx.TxId.Bencoded">
            <inheritdoc/>
        </member>
        <member name="M:Libplanet.Tx.TxId.FromHex(System.String)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxId"/> value from a <paramref name="hex"/> string.
            </summary>
            <param name="hex">A hexadecimal string which encodes a <see cref="T:Libplanet.Tx.TxId"/>.
            This has to contain 64 hexadecimal digits and must not be <see langword="null"/>
            This is usually made by <see cref="M:Libplanet.Tx.TxId.ToHex"/> method.</param>
            <returns>A corresponding <see cref="T:Libplanet.Tx.TxId"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the given
            <paramref name="hex"/> is shorter or longer than 64 characters.</exception>
            <exception cref="T:System.FormatException">Thrown when the given <paramref name="hex"/> string is
            not a valid hexadecimal string.</exception>
            <seealso cref="M:Libplanet.Tx.TxId.ToHex"/>
        </member>
        <member name="M:Libplanet.Tx.TxId.ToByteArray">
            <summary>
            Gets a bare mutable <see cref="T:System.Byte"/> array of
            this <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <returns>A new mutable <see cref="T:System.Byte"/> array of
            this <see cref="T:Libplanet.Tx.TxId"/>.
            Since a returned array is created every time the method is called,
            any mutations on that array does not affect to
            the <see cref="T:Libplanet.Tx.TxId"/> object.
            </returns>
            <seealso cref="P:Libplanet.Tx.TxId.ByteArray"/>
        </member>
        <member name="M:Libplanet.Tx.TxId.ToHex">
            <summary>
            Gets a hexadecimal form of a <see cref="T:Libplanet.Tx.TxId"/>.
            </summary>
            <returns>64 hexadecimal characters.</returns>
        </member>
        <member name="M:Libplanet.Tx.TxId.ToString">
            <summary>
            Gets a <see cref="T:Libplanet.Tx.TxId"/>'s representative string.
            </summary>
            <returns>A string which represents this <see cref="T:Libplanet.Tx.TxId"/>.
            </returns>
        </member>
        <member name="M:Libplanet.Tx.TxId.CompareTo(Libplanet.Tx.TxId)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Libplanet.Tx.TxId.CompareTo(System.Object)">
            <inheritdoc cref="M:System.IComparable.CompareTo(System.Object)"/>
        </member>
        <member name="M:Libplanet.Tx.TxId.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Libplanet.Tx.TxMetadata">
            <summary>
            A concrete class implementing <see cref="T:Libplanet.Tx.ITxMetadata"/>.  It's used to represent drafts
            of unsigned <see cref="T:Libplanet.Tx.Transaction`1"/>s.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxMetadata.#ctor(Libplanet.Crypto.PublicKey)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxMetadata"/> instance with a <paramref name="publicKey"/>.
            Other fields can be set using property setters.
            </summary>
            <param name="publicKey">Configures <see cref="P:Libplanet.Tx.TxMetadata.PublicKey"/> and <see cref="P:Libplanet.Tx.TxMetadata.Signer"/>.
            </param>
        </member>
        <member name="M:Libplanet.Tx.TxMetadata.#ctor(Libplanet.Tx.ITxMetadata)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxMetadata"/> instance by copying fields from the specified
            <paramref name="metadata"/>.
            </summary>
            <param name="metadata">The transaction metadata whose data to copy.</param>
            <remarks><see cref="P:Libplanet.Tx.ITxMetadata.Signer"/> from the specified <paramref name="metadata"/>
            is ignored.  <see cref="P:Libplanet.Tx.TxMetadata.Signer"/> field is automatically derived from
            <see cref="P:Libplanet.Tx.TxMetadata.PublicKey"/> instead.</remarks>
        </member>
        <member name="M:Libplanet.Tx.TxMetadata.#ctor(Bencodex.Types.Dictionary)">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxMetadata"/> from a Bencodex <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">A Bencodex dictionary made using
            <see cref="M:Libplanet.Tx.TxMetadata.ToBencodex"/> method.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the given
            <paramref name="dictionary"/> lacks some fields.</exception>
            <exception cref="T:System.InvalidCastException">Thrown when the given
            <paramref name="dictionary"/> has some invalid values.</exception>
        </member>
        <member name="P:Libplanet.Tx.TxMetadata.Nonce">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.Nonce"/>
        </member>
        <member name="P:Libplanet.Tx.TxMetadata.Signer">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.Signer"/>
            <remarks>This is automatically derived from <see cref="P:Libplanet.Tx.TxMetadata.PublicKey"/>.</remarks>
        </member>
        <member name="P:Libplanet.Tx.TxMetadata.UpdatedAddresses">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.UpdatedAddresses"/>
        </member>
        <member name="P:Libplanet.Tx.TxMetadata.Timestamp">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.Timestamp"/>
        </member>
        <member name="P:Libplanet.Tx.TxMetadata.PublicKey">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.PublicKey"/>
        </member>
        <member name="P:Libplanet.Tx.TxMetadata.GenesisHash">
            <inheritdoc cref="P:Libplanet.Tx.ITxMetadata.GenesisHash"/>
        </member>
        <member name="M:Libplanet.Tx.TxMetadata.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Libplanet.Tx.TxPolicyViolationException">
            <summary>
            An exception <em>returned</em> when a <see cref="T:Libplanet.Tx.Transaction`1"/> violates
            a <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxPolicyViolationException.#ctor(System.String,Libplanet.Tx.TxId)">
            <summary>
            Creates a new <see cref="T:Libplanet.Tx.TxPolicyViolationException"/> instance. Use
            <see cref="M:Libplanet.Tx.TxPolicyViolationException.#ctor(System.String,Libplanet.Tx.TxId,System.Exception)"/> if innerException
            is required.
            </summary>
            <param name="message">A description for the reason of violation
            given by an implementation of <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            </param>
            <param name="txid">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of the
            <see cref="T:Libplanet.Tx.Transaction`1"/> violating a <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            Gets prepended to <paramref name="message"/>.</param>
        </member>
        <member name="M:Libplanet.Tx.TxPolicyViolationException.#ctor(System.String,Libplanet.Tx.TxId,System.Exception)">
            <inheritdoc cref="M:Libplanet.Tx.TxPolicyViolationException.#ctor(System.String,Libplanet.Tx.TxId)"/>
            <param name="message">A description for the reason of violation
            given by an implementation of <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>. </param>
            <param name="txid">The <see cref="P:Libplanet.Tx.Transaction`1.Id"/> of the
            <see cref="T:Libplanet.Tx.Transaction`1"/> violating a <see cref="T:Libplanet.Blockchain.Policies.IBlockPolicy`1"/>.
            Gets prepended to <paramref name="message"/>.</param>
            <param name="innerException">The <see cref="T:System.Exception"/> for
            <see cref="P:System.Exception.InnerException"/>.</param>
        </member>
        <member name="T:Libplanet.Tx.TxSuccess">
            <summary>
            Summarizes an execution result of a successful <see cref="T:Libplanet.Tx.Transaction`1"/>.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxSuccess.#ctor(Libplanet.Blocks.BlockHash,Libplanet.Tx.TxId,System.Collections.Generic.List{System.Collections.Generic.List{System.String}},System.Collections.Immutable.IImmutableDictionary{Libplanet.Address,Bencodex.Types.IValue},System.Collections.Immutable.IImmutableDictionary{Libplanet.Address,System.Collections.Immutable.IImmutableDictionary{Libplanet.Assets.Currency,Libplanet.Assets.FungibleAssetValue}},System.Collections.Immutable.IImmutableDictionary{Libplanet.Address,System.Collections.Immutable.IImmutableDictionary{Libplanet.Assets.Currency,Libplanet.Assets.FungibleAssetValue}})">
            <summary>
            Creates a <see cref="T:Libplanet.Tx.TxSuccess"/> instance.
            </summary>
            <param name="blockHash">The <see cref="P:Libplanet.Blocks.Block`1.Hash"/> of the <see cref="T:Libplanet.Blocks.Block`1"/>
            that the <see cref="T:Libplanet.Tx.Transaction`1"/> is executed within.</param>
            <param name="txId">The executed <see cref="T:Libplanet.Tx.Transaction`1"/>'s <see
            cref="P:Libplanet.Tx.Transaction`1.Id"/>.</param>
            <param name="actionsLogsList">The logs recorded while executing actions.</param>
            <param name="updatedStates">The states delta made by the actions in
            the transaction within the block.</param>
            <param name="fungibleAssetsDelta"><see cref="T:Libplanet.Address"/>es and sets of
            <see cref="T:Libplanet.Assets.Currency"/> whose fungible assets have been updated by the actions in
            the transaction within the block.  Included <see cref="T:Libplanet.Assets.FungibleAssetValue"/>s are
            the delta values (plus or minus) that the transaction makes.</param>
            <param name="updatedFungibleAssets"><see cref="T:Libplanet.Address"/>es and sets of
            <see cref="T:Libplanet.Assets.Currency"/> whose fungible assets have been updated by the actions in
            the transaction within the block.  Included <see cref="T:Libplanet.Assets.FungibleAssetValue"/>s are
            the final balances right after the transaction is executed.</param>
        </member>
        <member name="P:Libplanet.Tx.TxSuccess.UpdatedStates">
            <summary>
            The states delta made by the actions in the transaction within the block.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.TxSuccess.FungibleAssetsDelta">
            <summary>
            <see cref="T:Libplanet.Address"/>es and sets of
            <see cref="T:Libplanet.Assets.Currency"/> whose fungible assets have been updated by the actions in
            the transaction within the block.  Included <see cref="T:Libplanet.Assets.FungibleAssetValue"/>s are
            the delta values (plus or minus) that the transaction makes.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.TxSuccess.UpdatedFungibleAssets">
            <summary>
            <see cref="T:Libplanet.Address"/>es and sets of <see cref="T:Libplanet.Assets.Currency"/> whose fungible assets have
            been updated by the actions in the transaction within the block.  Included
            <see cref="T:Libplanet.Assets.FungibleAssetValue"/>s are the final balances right after the transaction is
            executed.
            </summary>
        </member>
        <member name="P:Libplanet.Tx.TxSuccess.UpdatedAddresses">
            <summary>
            All <seealso cref="T:Libplanet.Address"/>es of the accounts that have been updated by the actions
            in the transaction within the block.
            </summary>
        </member>
        <member name="M:Libplanet.Tx.TxSuccess.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
    </members>
</doc>
