<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BitFaster.Caching</name>
    </assembly>
    <members>
        <member name="T:BitFaster.Caching.Atomic.AsyncAtomicFactory`2">
            <summary>
            A class that provides simple, lightweight exactly once initialization for values
            stored in a cache.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.AsyncAtomicFactory`2"/> class.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.AsyncAtomicFactory`2"/> class with the
            specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.GetValueAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Gets the value. If <see cref="P:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.IsValueCreated"/> is false, calling <see cref="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.GetValueAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})"/> will force initialization via the <paramref name="valueFactory"/> parameter.
            </summary>
            <param name="key">The key associated with the value.</param>
            <param name="valueFactory">The value factory to use to create the value when it is not initialized.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.GetValueAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)">
            <summary>
            Gets the value. If <see cref="P:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.IsValueCreated"/> is false, calling <see cref="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.GetValueAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)"/> will force initialization via the <paramref name="valueFactory"/> parameter.
            </summary>
            <typeparam name="TArg">The type of the value factory argument.</typeparam>
            <param name="key">The key associated with the value.</param>
            <param name="valueFactory">The value factory to use to create the value when it is not initialized.</param>
            <param name="factoryArgument">The value factory argument.</param>
            <returns>The value.</returns>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.IsValueCreated">
            <summary>
            Gets a value indicating whether the value has been initialized.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.ValueIfCreated">
            <summary>
            Gets the value if it has been initialized, else default.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.Equals(BitFaster.Caching.Atomic.AsyncAtomicFactory{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AsyncAtomicFactory`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Atomic.AtomicFactory`2">
            <summary>
            A class that provides simple, lightweight exactly once initialization for values stored
            in a cache. Exceptions are propogated to the caller.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.AtomicFactory`2"/> class.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.AtomicFactory`2"/> class with the
            specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.GetValue(`0,System.Func{`0,`1})">
            <summary>
            Gets the value. If <see cref="P:BitFaster.Caching.Atomic.AtomicFactory`2.IsValueCreated"/> is false, calling <see cref="M:BitFaster.Caching.Atomic.AtomicFactory`2.GetValue(`0,System.Func{`0,`1})"/> will force initialization via the <paramref name="valueFactory"/> parameter.
            </summary>
            <param name="key">The key associated with the value.</param>
            <param name="valueFactory">The value factory to use to create the value when it is not initialized.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.GetValue``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Gets the value. If <see cref="P:BitFaster.Caching.Atomic.AtomicFactory`2.IsValueCreated"/> is false, calling <see cref="M:BitFaster.Caching.Atomic.AtomicFactory`2.GetValue``1(`0,System.Func{`0,``0,`1},``0)"/> will force initialization via the <paramref name="valueFactory"/> parameter.
            </summary>
            <typeparam name="TArg">The type of the value factory argument.</typeparam>
            <param name="key">The key associated with the value.</param>
            <param name="valueFactory">The value factory to use to create the value when it is not initialized.</param>
            <param name="factoryArgument">The value factory argument.</param>
            <returns>The value.</returns>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactory`2.IsValueCreated">
            <summary>
            Gets a value indicating whether the value has been initialized.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactory`2.ValueIfCreated">
            <summary>
            Gets the value if it has been initialized, else default.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.CreateValue``1(`0,``0)">
            <summary>
            Note the failure case works like this:
            1. Thread A enters AtomicFactory.CreateValue then Initializer.CreateValue and holds the lock.
            2. Thread B enters AtomicFactory.CreateValue then Initializer.CreateValue and queues on the lock.
            3. Thread A calls value factory, and after 1 second throws an exception. The exception is 
            captured in exceptionDispatch, lock is released, and an exeption is thrown.
            4. AtomicFactory.CreateValue catches the exception and creates a fresh initializer.
            5. Thread B enters the lock, finds exceptionDispatch is populated and immediately throws.
            6. Thread C can now start from a clean state.
            This mitigates lock convoys where many queued threads will fail slowly one by one, introducing delays
            and multiplying the number of calls to the failing resource.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.Equals(BitFaster.Caching.Atomic.AtomicFactory{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactory`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2">
            <summary>
            A cache decorator for working with  <see cref="T:BitFaster.Caching.Atomic.AsyncAtomicFactory`2"/> wrapped values, giving exactly once initialization.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.#ctor(BitFaster.Caching.ICache{`0,BitFaster.Caching.Atomic.AsyncAtomicFactory{`0,`1}})">
            <summary>
            Initializes a new instance of the AtomicFactoryAsyncCache class with the specified inner cache.
            </summary>
            <param name="cache">The decorated cache.</param>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.Keys">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.Policy">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.GetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.GetOrAddAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to asynchronously generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>A task that represents the asynchronous GetOrAdd operation.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.TryGet(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryAsyncCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Atomic.AtomicFactoryCache`2">
            <summary>
            A cache decorator for working with  <see cref="T:BitFaster.Caching.Atomic.AtomicFactory`2"/> wrapped values, giving exactly once initialization.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.#ctor(BitFaster.Caching.ICache{`0,BitFaster.Caching.Atomic.AtomicFactory{`0,`1}})">
            <summary>
            Initializes a new instance of the ScopedCache class with the specified inner cache.
            </summary>
            <param name="cache">The decorated cache.</param>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryCache`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryCache`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryCache`2.Keys">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryCache`2.Policy">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.GetOrAdd(`0,System.Func{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already 
            in the cache, or the new value if the key was not in the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.TryGet(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2">
            <summary>
            A cache decorator for working with  <see cref="T:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2"/> wrapped values, giving exactly once initialization.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.#ctor(BitFaster.Caching.ICache{`0,BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory{`0,`1}})">
            <summary>
            Initializes a new instance of the AtomicFactoryScopedAsyncCache class with the specified inner cache.
            </summary>
            <param name="cache">The decorated cache.</param>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.Keys">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.ScopedGetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{BitFaster.Caching.Scoped{`1}}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.ScopedGetOrAddAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{BitFaster.Caching.Scoped{`1}}},``0)">
            <summary>
            Adds a key/scoped value pair to the cache if the key does not already exist. Returns a lifetime for either 
            the new value, or the existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to asynchronously generate a scoped value for the key.</param>
            <param name="factoryArgument"></param>
            <returns>A task that represents the asynchronous ScopedGetOrAdd operation.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.ScopedTryGet(`0,BitFaster.Caching.Lifetime{`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedAsyncCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2">
            <summary>
            A cache decorator for working with  <see cref="T:BitFaster.Caching.Atomic.ScopedAtomicFactory`2"/> wrapped values, giving exactly once initialization.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.#ctor(BitFaster.Caching.ICache{`0,BitFaster.Caching.Atomic.ScopedAtomicFactory{`0,`1}})">
            <summary>
            Initializes a new instance of the AtomicFactoryScopedCache class with the specified inner cache.
            </summary>
            <param name="cache">The decorated cache.</param>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.Keys">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.ScopedGetOrAdd(`0,System.Func{`0,BitFaster.Caching.Scoped{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.ScopedGetOrAdd``1(`0,System.Func{`0,``0,BitFaster.Caching.Scoped{`1}},``0)">
            <summary>
            Adds a key/scoped value pair to the cache if the key does not already exist. Returns a lifetime for either 
            the new value, or the existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a scoped value for the key.</param>
            <param name="factoryArgument"></param>
            <returns>The lifetime for the value associated with the key. The lifetime will be either reference the 
            existing value for the key if the key is already in the cache, or the new value if the key was not in 
            the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.ScopedTryGet(`0,BitFaster.Caching.Lifetime{`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Atomic.AtomicFactoryScopedCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions">
            <summary>
            Convenience methods for using AtomicFactory with ConcurrentDictionary. 
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.GetOrAdd``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AtomicFactory{``0,``1}},``0,System.Func{``0,``1})">
            <summary>
            Adds a key/value pair to the ConcurrentDictionary if the key does not already exist. Returns the new value, or the existing value if the key already exists.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.GetOrAdd``3(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AtomicFactory{``0,``1}},``0,System.Func{``0,``2,``1},``2)">
            <summary>
            Adds a key/value pair to the ConcurrentDictionary by using the specified function and an argument if the key does not already exist, or returns the existing value if the key exists.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.GetOrAddAsync``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AsyncAtomicFactory{``0,``1}},``0,System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Adds a key/value pair to the ConcurrentDictionary if the key does not already exist. Returns the new value, or the existing value if the key already exists.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.GetOrAddAsync``3(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AsyncAtomicFactory{``0,``1}},``0,System.Func{``0,``2,System.Threading.Tasks.Task{``1}},``2)">
            <summary>
            Adds a key/value pair to the ConcurrentDictionary by using the specified function and an argument if the key does not already exist, or returns the existing value if the key exists.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.TryGetValue``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AtomicFactory{``0,``1}},``0,``1@)">
            <summary>
            Attempts to get the value associated with the specified key from the ConcurrentDictionary.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the object from the ConcurrentDictionary that has the specified key, or the default value of the type if the operation failed.</param>
            <returns>true if the key was found in the ConcurrentDictionary; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.TryGetValue``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AsyncAtomicFactory{``0,``1}},``0,``1@)">
            <summary>
            Attempts to get the value associated with the specified key from the ConcurrentDictionary.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the object from the ConcurrentDictionary that has the specified key, or the default value of the type if the operation failed.</param>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.TryRemove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AtomicFactory{``0,``1}},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="item">The KeyValuePair representing the key and value to remove.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.TryRemove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AsyncAtomicFactory{``0,``1}},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="item">The KeyValuePair representing the key and value to remove.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.TryRemove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AtomicFactory{``0,``1}},``0,``1@)">
            <summary>
            Attempts to remove and return the value that has the specified key from the ConcurrentDictionary.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the element to remove and return.</param>
            <param name="value">When this method returns, contains the object removed from the ConcurrentDictionary, or the default value of the TValue type if key does not exist.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ConcurrentDictionaryExtensions.TryRemove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,BitFaster.Caching.Atomic.AsyncAtomicFactory{``0,``1}},``0,``1@)">
            <summary>
            Attempts to remove and return the value that has the specified key from the ConcurrentDictionary.
            </summary>
            <param name="dictionary">The ConcurrentDictionary to use.</param>
            <param name="key">The key of the element to remove and return.</param>
            <param name="value">When this method returns, contains the object removed from the ConcurrentDictionary, or the default value of the TValue type if key does not exist.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="T:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2">
            <summary>
            A class that provides simple, lightweight exactly once initialization for scoped values
            stored in a cache.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2"/> class.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2"/> class with the
            specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.IsScopeCreated">
            <summary>
            Gets a value indicating whether the scope has been initialized.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.ScopeIfCreated">
            <summary>
            Gets the scope if it has been initialized, else default.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.TryCreateLifetime(BitFaster.Caching.Lifetime{`1}@)">
            <summary>
            Attempts to create a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <param name="lifetime">When this method returns, contains the Lifetime that was created, or the default value of the type if the operation failed.</param>
            <returns>true if the Lifetime was created; otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.TryCreateLifetimeAsync(`0,System.Func{`0,System.Threading.Tasks.Task{BitFaster.Caching.Scoped{`1}}})">
            <summary>
            Attempts to create a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <param name="key">The key associated with the scoped value.</param>
            <param name="valueFactory">The value factory to use to create the scoped value when it is not initialized.</param>
            <returns>true if the Lifetime was created; otherwise false. If the lifetime was created, the new lifetime is also returned.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.TryCreateLifetimeAsync``1(`0,``0)">
            <summary>
            Attempts to create a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <typeparam name="TFactory">The type of the value factory.</typeparam>
            <param name="key">The key associated with the scoped value.</param>
            <param name="valueFactory">The value factory to use to create the scoped value when it is not initialized.</param>
            <returns>true if the Lifetime was created; otherwise false. If the lifetime was created, the new lifetime is also returned.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAsyncAtomicFactory`2.Dispose">
            <summary>
            Terminates the scope and disposes the value. Once the scope is terminated, it is no longer
            possible to create new lifetimes for the value.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Atomic.ScopedAtomicFactory`2">
             <summary>
             A class that provides simple, lightweight exactly once initialization for scoped values
             stored in a cache.
             </summary>
             <typeparam name="K">The type of the key.</typeparam>
             <typeparam name="V">The type of the value.</typeparam>
             <remarks>
             Requirements:
             <list type="number">
                <item>
                    <description>Exactly once disposal.</description>
                </item>
                <item>
                    <term>Exactly once invocation of value factory</term>
                    <description>Values are created atomically.</description>
                </item>
                <item>
                    <term>Resolve race between create dispose init</term>
                    <description>If disposed is called before value is created, scoped value is disposed for life.</description>
                </item>
            </list>
             </remarks>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.ScopedAtomicFactory`2"/> class.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:BitFaster.Caching.Atomic.ScopedAtomicFactory`2"/> class with the
            specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.IsScopeCreated">
            <summary>
            Gets a value indicating whether the scope has been initialized.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.ScopeIfCreated">
            <summary>
            Gets the scope if it has been initialized, else default.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.TryCreateLifetime(BitFaster.Caching.Lifetime{`1}@)">
            <summary>
            Attempts to create a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <param name="lifetime">When this method returns, contains the Lifetime that was created, or the default value of the type if the operation failed.</param>
            <returns>true if the Lifetime was created; otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.TryCreateLifetime(`0,System.Func{`0,BitFaster.Caching.Scoped{`1}},BitFaster.Caching.Lifetime{`1}@)">
            <summary>
            Attempts to create a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <param name="key">The key associated with the scoped value.</param>
            <param name="valueFactory">The value factory to use to create the scoped value when it is not initialized.</param>
            <param name="lifetime">When this method returns, contains the Lifetime that was created, or the default value of the type if the operation failed.</param>
            <returns>true if the Lifetime was created; otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.TryCreateLifetime``1(`0,``0,BitFaster.Caching.Lifetime{`1}@)">
            <summary>
            Attempts to create a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <typeparam name="TFactory">The type of the value factory.</typeparam>
            <param name="key">The key associated with the scoped value.</param>
            <param name="valueFactory">The value factory to use to create the scoped value when it is not initialized.</param>
            <param name="lifetime">When this method returns, contains the Lifetime that was created, or the default value of the type if the operation failed.</param>
            <returns>true if the Lifetime was created; otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Atomic.ScopedAtomicFactory`2.Dispose">
            <summary>
            Terminates the scope and disposes the value. Once the scope is terminated, it is no longer
            possible to create new lifetimes for the value.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.BitOps">
            <summary>
            Provides utility methods for bit-twiddling operations.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.BitOps.CeilingPowerOfTwo(System.Int32)">
            <summary>
            Calculate the smallest power of 2 greater than the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>Smallest power of two greater than or equal to x.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.CeilingPowerOfTwo(System.Int64)">
            <summary>
            Calculate the smallest power of 2 greater than the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>Smallest power of two greater than or equal to x.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.CeilingPowerOfTwo(System.UInt32)">
            <summary>
            Calculate the smallest power of 2 greater than the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>Smallest power of two greater than or equal to x.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.CeilingPowerOfTwo(System.UInt64)">
            <summary>
            Calculate the smallest power of 2 greater than the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>Smallest power of two greater than or equal to x.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.TrailingZeroCount(System.Int64)">
            <summary>
            Counts the number of trailing zero bits in the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>The number of trailing zero bits.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.TrailingZeroCount(System.UInt64)">
            <summary>
            Counts the number of trailing zero bits in the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>The number of trailing zero bits.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.BitCount(System.Int32)">
            <summary>
            Counts the number of 1 bits in the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>The number of 1 bits.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.BitCount(System.UInt32)">
            <summary>
            Counts the number of 1 bits in the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>The number of 1 bits.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.BitCount(System.Int64)">
            <summary>
            Counts the number of 1 bits in the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>The number of 1 bits.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.BitCount(System.UInt64)">
            <summary>
            Counts the number of 1 bits in the input parameter.
            </summary>
            <param name="x">The input parameter.</param>
            <returns>The number of 1 bits.</returns>
        </member>
        <member name="M:BitFaster.Caching.BitOps.Mix64(System.UInt64)">
            <summary>
            Computes Stafford variant 13 of 64-bit mix function.
            </summary>
            <param name="z">The input parameter.</param>
            <returns>A bit mix of the input parameter.</returns>
            <remarks>
            See http://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html
            </remarks>
        </member>
        <member name="T:BitFaster.Caching.Buffers.BufferStatus">
            <summary>
            Specifies the status of buffer operations.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Buffers.BufferStatus.Full">
            <summary>
            The buffer is full.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Buffers.BufferStatus.Empty">
            <summary>
            The buffer is empty.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Buffers.BufferStatus.Success">
            <summary>
            The buffer operation succeeded.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Buffers.BufferStatus.Contended">
            <summary>
            The buffer operation was contended.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1">
            <summary>
            Provides a multi-producer, multi-consumer thread-safe ring buffer. When the buffer is full,
            TryAdd fails and returns false. When the buffer is empty, TryTake fails and returns false.
            </summary>
            Based on the Segment internal class from the .NET ConcurrentQueue class.
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the MpmcBoundedBuffer class with the specified bounded capacity.
            </summary>
            <param name="boundedLength">The bounded length.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.Count">
            <summary>
            Gets the number of items contained in the buffer.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.Capacity">
            <summary>
            The bounded capacity.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.TryTake(`0@)">
            <summary>
            Tries to remove an item.
            </summary>
            <param name="item">The item to be removed.</param>
            <returns>A BufferStatus value indicating whether the operation succeeded.</returns>
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.TryAdd(`0)">
            <summary>
            Tries to add the specified item.
            </summary>
            <param name="item">The item to be added.</param>
            <returns>A BufferStatus value indicating whether the operation succeeded.</returns>
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.Clear">
            <summary>
            Removes all values from the buffer.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.Slot.Item">
            <summary>The item.</summary>
        </member>
        <member name="F:BitFaster.Caching.Buffers.MpmcBoundedBuffer`1.Slot.SequenceNumber">
            <summary>The sequence number for this slot, used to synchronize between enqueuers and dequeuers.</summary>
        </member>
        <member name="T:BitFaster.Caching.Buffers.MpscBoundedBuffer`1">
            <summary>
            Provides a multi-producer, single-consumer thread-safe ring buffer. When the buffer is full,
            TryAdd fails and returns false. When the buffer is empty, TryTake fails and returns false.
            </summary>
            Based on the BoundedBuffer class in the Caffeine library by ben.manes@gmail.com (Ben Manes).
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpscBoundedBuffer`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the MpscBoundedBuffer class with the specified bounded capacity.
            </summary>
            <param name="boundedLength">The bounded length.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:BitFaster.Caching.Buffers.MpscBoundedBuffer`1.Capacity">
            <summary>
            The bounded capacity.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Buffers.MpscBoundedBuffer`1.Count">
            <summary>
            Gets the number of items contained in the buffer.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpscBoundedBuffer`1.TryAdd(`0)">
            <summary>
            Tries to add the specified item.
            </summary>
            <param name="item">The item to be added.</param>
            <returns>A BufferStatus value indicating whether the operation succeeded.</returns>
            <remarks>
            Thread safe.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpscBoundedBuffer`1.TryTake(`0@)">
            <summary>
            Tries to remove an item.
            </summary>
            <param name="item">The item to be removed.</param>
            <returns>A BufferStatus value indicating whether the operation succeeded.</returns>
            <remarks>
            Thread safe for single try take/drain + multiple try add.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpscBoundedBuffer`1.DrainTo(System.ArraySegment{`0})">
            <summary>
            Drains the buffer into the specified array segment.
            </summary>
            <param name="output">The output buffer</param>
            <returns>The number of items written to the output buffer.</returns>
            <remarks>
            Thread safe for single try take/drain + multiple try add.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Buffers.MpscBoundedBuffer`1.Clear">
            <summary>
            Removes all values from the buffer.
            </summary>
            <remarks>
            Clear must be called from the single consumer thread.
            </remarks>
        </member>
        <member name="T:BitFaster.Caching.Buffers.StripedMpscBuffer`1">
            <summary>
            Provides a striped bounded buffer. Add operations use thread ID to index into
            the underlying array of buffers, and if TryAdd is contended the thread ID is 
            rehashed to select a different buffer to retry up to 3 times. Using this approach
            writes scale linearly with number of concurrent threads.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Buffers.StripedMpscBuffer`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the StripedMpscBuffer class with the specified stripe count and buffer size.
            </summary>
            <param name="stripeCount">The stripe count.</param>
            <param name="bufferSize">The buffer size.</param>
        </member>
        <member name="P:BitFaster.Caching.Buffers.StripedMpscBuffer`1.Count">
            <summary>
            Gets the number of items contained in the buffer.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Buffers.StripedMpscBuffer`1.Capacity">
            <summary>
            The bounded capacity.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Buffers.StripedMpscBuffer`1.DrainTo(`0[])">
            <summary>
            Drains the buffer into the specified array.
            </summary>
            <param name="outputBuffer">The output buffer</param>
            <returns>The number of items written to the output buffer.</returns>
            <remarks>
            Thread safe for single try take/drain + multiple try add.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Buffers.StripedMpscBuffer`1.TryAdd(`0)">
            <summary>
            Tries to add the specified item.
            </summary>
            <param name="item">The item to be added.</param>
            <returns>A BufferStatus value indicating whether the operation succeeded.</returns>
            <remarks>
            Thread safe.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Buffers.StripedMpscBuffer`1.Clear">
            <summary>
            Removes all values from the buffer.
            </summary>
            <remarks>
            Clear must be called from the single consumer thread.
            </remarks>
        </member>
        <member name="T:BitFaster.Caching.CacheEventProxyBase`3">
            <summary>
            Represents a base class for converting cache events for decorated caches such that the inner cache wrapper
            type can be hidden from the outer cache.
            </summary>
            <typeparam name="K">The type of the key</typeparam>
            <typeparam name="TInner">The inner value type</typeparam>
            <typeparam name="TOuter">The outer value type</typeparam>
        </member>
        <member name="M:BitFaster.Caching.CacheEventProxyBase`3.#ctor(BitFaster.Caching.ICacheEvents{`0,`1})">
            <summary>
            Initializes a new instance of the CacheEventProxyBase class with the specified inner cache events.
            </summary>
            <param name="events">The inner cache events.</param>
        </member>
        <member name="E:BitFaster.Caching.CacheEventProxyBase`3.ItemRemoved">
            <inheritdoc/>
        </member>
        <member name="E:BitFaster.Caching.CacheEventProxyBase`3.ItemUpdated">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.CacheEventProxyBase`3.TranslateOnRemoved(BitFaster.Caching.ItemRemovedEventArgs{`0,`1})">
            <summary>
            Translate the ItemRemovedEventArgs by converting the inner arg type to the outer arg type.
            </summary>
            <param name="inner">The inner arg.</param>
            <returns>The translated arg.</returns>
        </member>
        <member name="M:BitFaster.Caching.CacheEventProxyBase`3.TranslateOnUpdated(BitFaster.Caching.ItemUpdatedEventArgs{`0,`1})">
            <summary>
            Translate the ItemUpdatedEventArgs by converting the inner arg type to the outer arg type.
            </summary>
            <param name="inner">The inner arg.</param>
            <returns>The translated arg.</returns>
        </member>
        <member name="T:BitFaster.Caching.CachePolicy">
            <summary>
            Represents the cache policy. Cache policy is dependent on the parameters chosen
            when constructing the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.CachePolicy.#ctor(BitFaster.Caching.Optional{BitFaster.Caching.IBoundedPolicy},BitFaster.Caching.Optional{BitFaster.Caching.ITimePolicy})">
            <summary>
            Initializes a new instance of the CachePolicy class with the specified eviction and expire after write policies.
            </summary>
            <param name="eviction">The eviction policy.</param>
            <param name="expireAfterWrite">The expire after write policy.</param>
        </member>
        <member name="M:BitFaster.Caching.CachePolicy.#ctor(BitFaster.Caching.Optional{BitFaster.Caching.IBoundedPolicy},BitFaster.Caching.Optional{BitFaster.Caching.ITimePolicy},BitFaster.Caching.Optional{BitFaster.Caching.ITimePolicy},BitFaster.Caching.Optional{BitFaster.Caching.IDiscreteTimePolicy})">
            <summary>
            Initializes a new instance of the CachePolicy class with the specified policies.
            </summary>
            <param name="eviction">The eviction policy.</param>
            <param name="expireAfterWrite">The expire after write policy.</param>
            <param name="expireAfterAccess">The expire after access policy.</param>
            <param name="expireAfter">The expire after policy.</param>
        </member>
        <member name="P:BitFaster.Caching.CachePolicy.Eviction">
            <summary>
            Gets the bounded size eviction policy. This policy evicts items from the cache
            if it exceeds capacity.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.CachePolicy.ExpireAfterWrite">
            <summary>
            Gets the expire after write policy, if any. This policy evicts items after a 
            fixed duration since an entry's creation or most recent replacement.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.CachePolicy.ExpireAfterAccess">
            <summary>
            Gets the expire after access policy, if any. This policy evicts items after a 
            fixed duration since an entry's creation or most recent read/write access.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.CachePolicy.ExpireAfter">
            <summary>
            Gets the expire after policy, if any. This policy evicts items based on
            a time to expire computed from the key and value.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.ConcurrentDictionarySize.Estimate(System.Int32)">
            <summary>
            Estimate the size of the ConcurrentDictionary constructor capacity arg to use for the given desired cache size.
            </summary>
            <remarks>
            To minimize collisions, ideal case is is for ConcurrentDictionary to have a prime number of buckets, and 
            for the bucket count to be about 33% greater than the cache capacity (load factor of 0.75). 
            See load factor here: https://en.wikipedia.org/wiki/Hash_table
            </remarks>
            <param name="desiredSize">The desired cache size</param>
            <returns>The estimated optimal ConcurrentDictionary capacity</returns>
        </member>
        <member name="T:BitFaster.Caching.Counters.Counter">
            <summary>
            A thread-safe counter suitable for high throuhgput counting across many concurrent threads.
            </summary>
            Based on the LongAdder class by Doug Lea.
        </member>
        <member name="M:BitFaster.Caching.Counters.Counter.#ctor">
            <summary>
            Creates a new Counter with an intial sum of zero.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Counters.Counter.Count">
            <summary>
            Computes the current count.
            </summary>
            <returns>The current sum.</returns>
        </member>
        <member name="M:BitFaster.Caching.Counters.Counter.Increment">
            <summary>
            Increment by 1.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Counters.Counter.Add(System.Int64)">
            <summary>
            Adds the specified value.
            </summary>
            <param name="value">The value to add.</param>
        </member>
        <member name="T:BitFaster.Caching.Counters.PaddedLong">
            <summary>
            A long value padded by the size of a CPU cache line to mitigate false sharing.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Counters.PaddedLong.value">
            <summary>
            The value.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Counters.PaddedLong.VolatileRead">
            <summary>
            Reads the value of the field, and on systems that require it inserts a memory barrier to 
            prevent reordering of memory operations.
            </summary>
            <returns>The value that was read.</returns>
        </member>
        <member name="M:BitFaster.Caching.Counters.PaddedLong.CompareAndSwap(System.Int64,System.Int64)">
            <summary>
            Compares the current value with an expected value, if they are equal replaces the current value.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="updated">The updated value.</param>
            <returns>True if the value is updated, otherwise false.</returns>
        </member>
        <member name="T:BitFaster.Caching.Counters.Striped64">
            <summary>
            Mmaintains a lazily-initialized table of atomically updated variables, plus an extra 
            "base" field. The table size is a power of two. Indexing uses masked thread IDs.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Counters.Striped64.base">
            <summary>
            The base value used mainly when there is no contention, but also as a fallback 
            during table initialization races. Updated via CAS.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Counters.Striped64.Cells">
            <summary>
            When non-null, size is a power of 2.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Counters.Striped64.Cell">
            <summary>
            A wrapper for PaddedLong.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Counters.Striped64.Cell.value">
            <summary>
            The value of the cell.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Counters.Striped64.Cell.#ctor(System.Int64)">
            <summary>
            Initializes a new cell with the specified value.
            </summary>
            <param name="x">The value.</param>
        </member>
        <member name="M:BitFaster.Caching.Counters.Striped64.CasCellsBusy">
            CASes the cellsBusy field from 0 to 1 to acquire lock.
        </member>
        <member name="M:BitFaster.Caching.Counters.Striped64.GetProbe">
            Returns the probe value for the current thread.
            Duplicated from ThreadLocalRandom because of packaging restrictions.
        </member>
        <member name="M:BitFaster.Caching.Counters.Striped64.AdvanceProbe(System.Int32)">
            Pseudo-randomly advances and records the given probe value for the
            given thread.
            Duplicated from ThreadLocalRandom because of packaging restrictions.
        </member>
        <member name="M:BitFaster.Caching.Counters.Striped64.LongAccumulate(System.Int64,System.Boolean)">
             Handles cases of updates involving initialization, resizing,
             creating new Cells, and/or contention. See above for
             explanation. This method suffers the usual non-modularity
             problems of optimistic retry code, relying on rechecked sets of
             reads.
            
             @param x the value
             @param wasUncontended false if CAS failed before call
        </member>
        <member name="T:BitFaster.Caching.Disposer`1">
            <summary>
            A generic wrapper for object disposal.
            </summary>
            <typeparam name="T">The type of object to dispose</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Disposer`1.Dispose(`0)">
            <summary>
            Dispose value if it implements the IDisposable interface.
            </summary>
            <param name="value">The value to dispose.</param>
        </member>
        <member name="T:BitFaster.Caching.Duration">
            <summary>
            Represents a fixed length of time.
            </summary>
            <remarks>
            This struct is used to abstract away the use of different time sources with different precision. 
            This enables use of native time values (which may be ticks or millisecs), only converting 
            to TimeSpan for non perf critical user code. Using long without a mul/div makes cache lookups 
            about 30% faster on .NET6.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Duration.SinceEpoch">
            <summary>
            Gets the time since the system epoch.
            </summary>
            <returns>A duration</returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.ToTimeSpan">
            <summary>
            Converts the duration to a TimeSpan.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.FromTimeSpan(System.TimeSpan)">
            <summary>
            Returns a Duration that represents a specified TimeSpan.
            </summary>
            <param name="timeSpan">The TimeSpan to convert.</param>
            <returns>A duration.</returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.FromMilliseconds(System.Double)">
            <summary>
            Returns a Duration that represents a specified number of milliseconds.
            </summary>
            <param name="value">A number of milliseconds</param>
            <returns></returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.FromSeconds(System.Double)">
            <summary>
            Returns a Duration that represents a specified number of seconds.
            </summary>
            <param name="value">A number of seconds</param>
            <returns></returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.FromMinutes(System.Double)">
            <summary>
            Returns a Duration that represents a specified number of minutes.
            </summary>
            <param name="value">A number of minutes</param>
            <returns></returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.FromHours(System.Double)">
            <summary>
            Returns a Duration that represents a specified number of hours.
            </summary>
            <param name="value">A number of hours</param>
            <returns></returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.FromDays(System.Double)">
            <summary>
            Returns a Duration that represents a specified number of days.
            </summary>
            <param name="value">A number of days</param>
            <returns></returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.op_Addition(BitFaster.Caching.Duration,BitFaster.Caching.Duration)">
            <summary>
            Adds two specified Duration instances.
            </summary>
            <param name="a">The first duration to add.</param>
            <param name="b">The second duration to add.</param>
            <returns>An duration whose value is the sum of the values of a and b.</returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.op_Subtraction(BitFaster.Caching.Duration,BitFaster.Caching.Duration)">
            <summary>
            Subtracts a specified Duration from another specified Duration.
            </summary>
            <param name="a">The minuend.</param>
            <param name="b">The subtrahend.</param>
            <returns>An duration whose value is the result of the value of a minus the value of b.</returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.op_GreaterThan(BitFaster.Caching.Duration,BitFaster.Caching.Duration)">
            <summary>
            Returns a value that indicates whether a specified Duration is greater than another specified Duration.    
            </summary>
            <param name="a">The first duration to compare.</param>
            <param name="b">The second duration to compare.</param>
            <returns>true if the value of a is greater than the value of b; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Duration.op_LessThan(BitFaster.Caching.Duration,BitFaster.Caching.Duration)">
            <summary>
            Returns a value that indicates whether a specified Duration is less than another specified Duration.    
            </summary>
            <param name="a">The first duration to compare.</param>
            <param name="b">The second duration to compare.</param>
            <returns>true if the value of a is less than the value of b; otherwise, false.</returns>
        </member>
        <member name="T:BitFaster.Caching.IAsyncCache`2">
            <summary>
            Represents a generic cache of key/value pairs.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="P:BitFaster.Caching.IAsyncCache`2.Count">
            <summary>
            Gets the number of items currently held in the cache.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IAsyncCache`2.Metrics">
            <summary>
            Gets the cache metrics, if configured.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IAsyncCache`2.Events">
            <summary>
            Gets the cache events, if configured.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IAsyncCache`2.Policy">
            <summary>
            Gets the cache policy.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IAsyncCache`2.Keys">
            <summary>
            Gets a collection containing the keys in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCache`2.TryGet(`0,`1@)">
            <summary>
            Attempts to get the value associated with the specified key from the cache.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the object from the cache that has the specified key, or the default value of the type if the operation failed.</param>
            <returns>true if the key was found in the cache; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCache`2.GetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to asynchronously generate a value for the key.</param>
            <returns>A task that represents the asynchronous GetOrAdd operation.</returns>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCache`2.TryRemove(`0)">
            <summary>
            Attempts to remove the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCache`2.TryUpdate(`0,`1)">
            <summary>
            Attempts to update the value that has the specified key.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
            <returns>true if the object was updated successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCache`2.AddOrUpdate(`0,`1)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist, or updates a key/value pair if the 
            key already exists.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCache`2.Clear">
            <summary>
            Removes all keys and values from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.IAsyncCacheExt`2">
            <summary>
            Represents a generic cache of key/value pairs.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <remarks>This interface enables .NET Standard to use cache methods added to IAsyncCache since v2.0. It will be removed in the next major version.</remarks>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCacheExt`2.GetOrAddAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to asynchronously generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>A task that represents the asynchronous GetOrAdd operation.</returns>
            <remarks>The default implementation given here is the fallback that provides backwards compatibility for classes that implement ICache on prior versions</remarks>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCacheExt`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <param name="value">When this method returns, contains the object removed, or the default value of the value type if key does not exist.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IAsyncCacheExt`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Attempts to remove the specified key value pair.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>true if the item was removed successfully; otherwise, false.</returns>
        </member>
        <member name="T:BitFaster.Caching.IBoundedPolicy">
            <summary>
            Represents a bounded size cache policy.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IBoundedPolicy.Capacity">
            <summary>
            Gets the total number of items that can be stored in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IBoundedPolicy.Trim(System.Int32)">
            <summary>
            Trim the specified number of items from the cache.
            </summary>
            <param name="itemCount">The number of items to remove.</param>
        </member>
        <member name="T:BitFaster.Caching.ICache`2">
            <summary>
            Represents a generic cache of key/value pairs.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="P:BitFaster.Caching.ICache`2.Count">
            <summary>
            Gets the number of items currently held in the cache.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICache`2.Metrics">
            <summary>
            Gets the cache metrics, if configured.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICache`2.Events">
            <summary>
            Gets the cache events, if configured.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICache`2.Policy">
            <summary>
            Gets the cache policy.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICache`2.Keys">
            <summary>
            Gets a collection containing the keys in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.ICache`2.TryGet(`0,`1@)">
            <summary>
            Attempts to get the value associated with the specified key from the cache.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the object from the cache that has the specified key, or the default value of the type if the operation failed.</param>
            <returns>true if the key was found in the cache; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.ICache`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a value for the key.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already 
            in the cache, or the new value if the key was not in the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.ICache`2.TryRemove(`0)">
            <summary>
            Attempts to remove the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.ICache`2.TryUpdate(`0,`1)">
            <summary>
            Attempts to update the value that has the specified key.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
            <returns>true if the object was updated successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.ICache`2.AddOrUpdate(`0,`1)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist, or updates a key/value pair if the 
            key already exists.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
        </member>
        <member name="M:BitFaster.Caching.ICache`2.Clear">
            <summary>
            Removes all keys and values from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.ICacheEvents`2">
            <summary>
            Represents the events that fire when actions are performed on the cache.
            </summary>
        </member>
        <member name="E:BitFaster.Caching.ICacheEvents`2.ItemRemoved">
            <summary>
            Occurs when an item is removed from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.ICacheExt`2">
            <summary>
            Represents a generic cache of key/value pairs. This is a new interface with new methods to avoid breaking backward compatibility.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <remarks>This interface enables .NET Standard to use cache methods added to ICache since v2.0. It will be removed in the next major version.</remarks>
        </member>
        <member name="M:BitFaster.Caching.ICacheExt`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already 
            in the cache, or the new value if the key was not in the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.ICacheExt`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <param name="value">When this method returns, contains the object removed, or the default value of the value type if key does not exist.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.ICacheExt`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Attempts to remove the specified key value pair.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>true if the item was removed successfully; otherwise, false.</returns>
        </member>
        <member name="T:BitFaster.Caching.ICacheMetrics">
            <summary>
            Represents cache metrics collected over the lifetime of the cache.
            If metrics are disabled.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICacheMetrics.HitRatio">
            <summary>
            Gets the ratio of hits to misses, where a value of 1 indicates 100% hits.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICacheMetrics.Total">
            <summary>
            Gets the total number of requests made to the cache.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICacheMetrics.Hits">
            <summary>
            Gets the total number of cache hits.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICacheMetrics.Misses">
            <summary>
            Gets the total number of cache misses.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ICacheMetrics.Evicted">
            <summary>
            Gets the total number of evicted items.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.IDiscreteTimePolicy">
            <summary>
            Represents a per item time based cache policy.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IDiscreteTimePolicy.TryGetTimeToExpire``1(``0,System.TimeSpan@)">
            <summary>
            Gets the time to expire for an item in the cache.
            </summary>
            <param name="key">The key of the item.</param>
            <param name="timeToExpire">If the key exists, the time to live for the item with the specified key.</param>
            <returns>True if the key exists, otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IDiscreteTimePolicy.TrimExpired">
            <summary>
            Remove all expired items from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.IExpiryCalculator`2">
            <summary>
            Defines a mechanism to calculate when cache entries expire based on the item key, value 
            or existing time to expire.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IExpiryCalculator`2.GetExpireAfterCreate(`0,`1)">
            <summary>
            Specify the inital time to expire after an entry is created.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IExpiryCalculator`2.GetExpireAfterRead(`0,`1,BitFaster.Caching.Duration)">
            <summary>
            Specify the time to expire after an entry is read. The current time to expire may be
            be returned to not modify the expiration time.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IExpiryCalculator`2.GetExpireAfterUpdate(`0,`1,BitFaster.Caching.Duration)">
            <summary>
            Specify the time to expire after an entry is updated.The current time to expire may be
            be returned to not modify the expiration time.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.IsaProbe">
            <summary>
            Represents a marker interface to enable instruction set hardware intrinsics.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IsaProbe.IsAvx2Supported">
            <summary>
            Gets a value indicating whether AVX2 is supported.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.DetectIsa">
            <summary>
            Detect support for hardware instructions via intrinsics.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.DetectIsa.IsAvx2Supported">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.DisableHardwareIntrinsics">
            <summary>
            Force disable hardware instructions via intrinsics.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.DisableHardwareIntrinsics.IsAvx2Supported">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.IScoped`1">
            <summary>
            A marker interface for scopes to enable type constraints.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BitFaster.Caching.IScopedAsyncCache`2">
            <summary>
            Represents a generic cache of key/scoped IDisposable value pairs.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="P:BitFaster.Caching.IScopedAsyncCache`2.Count">
            <summary>
            Gets the number of items currently held in the cache.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IScopedAsyncCache`2.Metrics">
            <summary>
            Gets the cache metrics, if configured.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IScopedAsyncCache`2.Events">
            <summary>
            Gets the cache events, if configured.
            </summary>
            <remarks>
            Events expose the Scoped instance wrapping each value. To keep the value alive (blocking Dispose), try to 
            create a Lifetime from the scope.
            </remarks>
        </member>
        <member name="P:BitFaster.Caching.IScopedAsyncCache`2.Policy">
            <summary>
            Gets the cache policy.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IScopedAsyncCache`2.Keys">
            <summary>
            Gets a collection containing the keys in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IScopedAsyncCache`2.ScopedTryGet(`0,BitFaster.Caching.Lifetime{`1}@)">
            <summary>
            Attempts to create a lifetime for the value associated with the specified key from the cache
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="lifetime">When this method returns, contains a lifetime for the object from the cache that 
            has the specified key, or the default value of the type if the operation failed.</param>
            <returns>true if the key was found in the cache; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedAsyncCache`2.ScopedGetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{BitFaster.Caching.Scoped{`1}}})">
            <summary>
            Adds a key/scoped value pair to the cache if the key does not already exist. Returns a lifetime for either 
            the new value, or the existing value if the key already exists.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to asynchronously generate a scoped value for the key.</param>
            <returns>A task that represents the asynchronous ScopedGetOrAdd operation.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedAsyncCache`2.TryRemove(`0)">
            <summary>
            Attempts to remove the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedAsyncCache`2.TryUpdate(`0,`1)">
            <summary>
            Attempts to update the value that has the specified key.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
            <returns>true if the object was updated successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedAsyncCache`2.AddOrUpdate(`0,`1)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist, or updates a key/value pair if the 
            key already exists.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
        </member>
        <member name="M:BitFaster.Caching.IScopedAsyncCache`2.Clear">
            <summary>
            Removes all keys and values from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.IScopedCache`2">
            <summary>
            Represents a generic cache of key/scoped IDisposable value pairs.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="P:BitFaster.Caching.IScopedCache`2.Count">
            <summary>
            Gets the number of items currently held in the cache.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IScopedCache`2.Metrics">
            <summary>
            Gets the cache metrics, if configured.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IScopedCache`2.Events">
            <summary>
            Gets the cache events, if configured.
            </summary>
            <remarks>
            Events expose the Scoped instance wrapping each value. To keep the value alive (blocking Dispose), try to 
            create a Lifetime from the scope.
            </remarks>
        </member>
        <member name="P:BitFaster.Caching.IScopedCache`2.Policy">
            <summary>
            Gets the cache policy.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.IScopedCache`2.Keys">
            <summary>
            Gets a collection containing the keys in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IScopedCache`2.ScopedTryGet(`0,BitFaster.Caching.Lifetime{`1}@)">
            <summary>
            Attempts to create a lifetime for the value associated with the specified key from the cache
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="lifetime">When this method returns, contains a lifetime for the object from the cache that 
            has the specified key, or the default value of the type if the operation failed.</param>
            <returns>true if the key was found in the cache; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedCache`2.ScopedGetOrAdd(`0,System.Func{`0,BitFaster.Caching.Scoped{`1}})">
            <summary>
            Adds a key/scoped value pair to the cache if the key does not already exist. Returns a lifetime for either 
            the new value, or the existing value if the key already exists.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a scoped value for the key.</param>
            <returns>The lifetime for the value associated with the key. The lifetime will be either reference the 
            existing value for the key if the key is already in the cache, or the new value if the key was not in 
            the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedCache`2.TryRemove(`0)">
            <summary>
            Attempts to remove the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedCache`2.TryUpdate(`0,`1)">
            <summary>
            Attempts to update the value that has the specified key.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
            <returns>true if the object was updated successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.IScopedCache`2.AddOrUpdate(`0,`1)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist, or updates a key/value pair if the 
            key already exists.
            </summary>
            <param name="key">The key of the element to update.</param>
            <param name="value">The new value.</param>
        </member>
        <member name="M:BitFaster.Caching.IScopedCache`2.Clear">
            <summary>
            Removes all keys and values from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.ItemRemovedEventArgs`2">
            <summary>
            Provides data for the ItemRemoved event.
            </summary>
            <typeparam name="K">The type of the removed item key.</typeparam>
            <typeparam name="V">The type of the removed item value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.ItemRemovedEventArgs`2.#ctor(`0,`1,BitFaster.Caching.ItemRemovedReason)">
            <summary>
            Initializes a new instance of the ItemRemovedEventArgs class using the specified key, value and reason.
            </summary>
            <param name="key">The key of the item that was removed from the cache.</param>
            <param name="value">The value of the item that was removed from the cache.</param>
            <param name="reason">The reason the item was removed from the cache.</param>
        </member>
        <member name="P:BitFaster.Caching.ItemRemovedEventArgs`2.Key">
            <summary>
            Gets the key of the item that was removed from the cache.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ItemRemovedEventArgs`2.Value">
            <summary>
            Gets the value of the item that was removed from the cache.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ItemRemovedEventArgs`2.Reason">
            <summary>
            Gets the reason the item was removed from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.ItemRemovedReason">
            <summary>
            Specifies the reason an item was removed from the Cache.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.ItemRemovedReason.Removed">
            <summary>
            The item was removed from the cache by a remove method call.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.ItemRemovedReason.Evicted">
            <summary>
            The item was removed from the cache by the cache eviction policy.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.ItemRemovedReason.Cleared">
            <summary>
            The item was removed from the cache by a clear method call.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.ItemRemovedReason.Trimmed">
            <summary>
            The item was removed from the cache by a trim method call.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.ItemUpdatedEventArgs`2">
            <summary>
            Provides data for the ItemUpdated event.
            </summary>
            <typeparam name="K">The type of the updated item key.</typeparam>
            <typeparam name="V">The type of the updated item value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.ItemUpdatedEventArgs`2.#ctor(`0,`1,`1)">
            <summary>
            Initializes a new instance of the ItemUpdatedEventArgs class using the specified key, old value and new value.
            </summary>
            <param name="key">The key of the item that was updated.</param>
            <param name="oldValue">The old cache value.</param>
            <param name="newValue">The new cache value.</param>
        </member>
        <member name="P:BitFaster.Caching.ItemUpdatedEventArgs`2.Key">
            <summary>
            Gets the key of the item that was updated.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ItemUpdatedEventArgs`2.OldValue">
            <summary>
            Gets the old value of the item.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ItemUpdatedEventArgs`2.NewValue">
            <summary>
            Gets the new value of the item.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.ITimePolicy">
            <summary>
            Represents a fixed time based cache policy.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ITimePolicy.TimeToLive">
            <summary>
            Gets the time to expire for items in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.ITimePolicy.TrimExpired">
            <summary>
            Remove all expired items from the cache.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.IValueFactory`2">
            <summary>
            Represents a cache value factory.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IValueFactory`2.Create(`0)">
            <summary>
            Creates a value.
            </summary>
            <param name="key">The key used to create the value.</param>
            <returns>The value created.</returns>
        </member>
        <member name="T:BitFaster.Caching.ValueFactory`2">
            <summary>
            A wrapper for a cache value factory delegate.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value</typeparam>
        </member>
        <member name="M:BitFaster.Caching.ValueFactory`2.#ctor(System.Func{`0,`1})">
            <summary>
            Initializes a new ValueFactory value.
            </summary>
            <param name="factory">The factory to wrap.</param>
        </member>
        <member name="M:BitFaster.Caching.ValueFactory`2.Create(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.ValueFactoryArg`3">
            <summary>
            A wrapper for a cache value factory delegate that takes an argument.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="TArg">The type of the factory argument</typeparam>
            <typeparam name="V">The type of the cache value</typeparam>
        </member>
        <member name="M:BitFaster.Caching.ValueFactoryArg`3.#ctor(System.Func{`0,`1,`2},`1)">
            <summary>
            Initializes a new ValueFactoryArg value.
            </summary>
            <param name="factory">The factory to wrap.</param>
            <param name="arg">The argument to pass to the factory.</param>
        </member>
        <member name="M:BitFaster.Caching.ValueFactoryArg`3.Create(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.IAsyncValueFactory`2">
            <summary>
            Represents an async cache value factory.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.IAsyncValueFactory`2.CreateAsync(`0)">
            <summary>
            Creates a value.
            </summary>
            <param name="key">The key used to create the value.</param>
            <returns>The value created.</returns>
        </member>
        <member name="T:BitFaster.Caching.AsyncValueFactory`2">
            <summary>
            A wrapper for an async cache value factory delegate.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value</typeparam>
        </member>
        <member name="M:BitFaster.Caching.AsyncValueFactory`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Initializes a new ValueFactoryAsync value.
            </summary>
            <param name="factory">The factory to wrap.</param>
        </member>
        <member name="M:BitFaster.Caching.AsyncValueFactory`2.CreateAsync(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.AsyncValueFactoryArg`3">
            <summary>
            A wrapper for an async cache value factory delegate that takes an argument.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="TArg">The type of the factory argument</typeparam>
            <typeparam name="V">The type of the cache value</typeparam>
        </member>
        <member name="M:BitFaster.Caching.AsyncValueFactoryArg`3.#ctor(System.Func{`0,`1,System.Threading.Tasks.Task{`2}},`1)">
            <summary>
            Initializes a new ValueFactoryAsyncArg value.
            </summary>
            <param name="factory">The factory to wrap.</param>
            <param name="arg">The argument to pass to the factory.</param>
        </member>
        <member name="M:BitFaster.Caching.AsyncValueFactoryArg`3.CreateAsync(`0)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.AsyncConcurrentLfuBuilder`2">
            <summary>
            A builder for creating a ConcurrentLfu as IAsyncCache.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.AsyncConcurrentLfuBuilder`2.WithExpireAfter(BitFaster.Caching.IExpiryCalculator{`0,`1})">
            <summary>
            Evict after a duration calculated for each item using the specified IExpiryCalculator.
            </summary>
            <param name="expiry">The expiry calculator that determines item time to expire.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.AsyncConcurrentLfuBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.AtomicAsyncConcurrentLfuBuilder`2">
            <summary>
            A builder for creating a ConcurrentLfu as IAsyncCache with atomic value creation.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.AtomicAsyncConcurrentLfuBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.AtomicConcurrentLfuBuilder`2">
            <summary>
            A builder for creating a ConcurrentLfu as IAsyncCache with atomic value creation.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.AtomicConcurrentLfuBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.AtomicScopedAsyncConcurrentLfuBuilder`2">
            <summary>
            A builder for creating a ConcurrentLfu as IScopedAsyncCache with atomic value creation.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.AtomicScopedAsyncConcurrentLfuBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.AtomicScopedConcurrentLfuBuilder`2">
            <summary>
            A builder for creating a ConcurrentLfu with scoped values.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.AtomicScopedConcurrentLfuBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4">
            <summary>
            Represents the base class to be extended by LFU builder implementations.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <typeparam name="TBuilder">The type of the builder.</typeparam>
            <typeparam name="TCacheReturn">The return type of the builder.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4.WithCapacity(System.Int32)">
            <summary>
            Set the maximum number of values to keep in the cache. If more items than this are added, 
            the cache eviction policy will determine which values to remove.
            </summary>
            <param name="capacity">The maximum number of values to keep in the cache.</param>
            <returns>A ConcurrentLfuBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4.WithConcurrencyLevel(System.Int32)">
            <summary>
            Use the specified concurrency level.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the cache concurrently.</param>
            <returns>A ConcurrentLfuBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4.WithScheduler(BitFaster.Caching.Scheduler.IScheduler)">
            <summary>
            Use the specified scheduler to perform maintenance operations.
            </summary>
            <param name="scheduler">The scheduler to use for maintenance operations.</param>
            <returns>A ConcurrentLfuBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4.WithKeyComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Use the specified equality comparison implementation to compare keys.
            </summary>
            <param name="comparer">The equality comparison implementation to use when comparing keys.</param>
            <returns>A ConcurrentLfuBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4.WithExpireAfterWrite(System.TimeSpan)">
            <summary>
            Evict after a fixed duration since an entry's creation or most recent replacement.
            </summary>
            <param name="expiration">The length of time before an entry is automatically removed.</param>
            <returns>A ConcurrentLfuBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4.WithExpireAfterAccess(System.TimeSpan)">
            <summary>
            Evict after a fixed duration since an entry's most recent read or write.
            </summary>
            <param name="expiration">The length of time before an entry is automatically removed.</param>
            <returns>A ConcurrentLfuBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.LfuBuilderBase`4.Build">
            <summary>
            Builds a cache configured via the method calls invoked on the builder instance.
            </summary>
            <returns>A cache.</returns>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.ScopedAsyncConcurrentLfuBuilder`2">
            <summary>
            A builder for creating a ConcurrentLfu as IScopedAsyncCache.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.ScopedAsyncConcurrentLfuBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.Builder.ScopedConcurrentLfuBuilder`3">
            <summary>
            A builder for creating a ConcurrentLfu with scoped values.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
            <typeparam name="W">The type of the wrapped cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.Builder.ScopedConcurrentLfuBuilder`3.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.CmSketch`1">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.CmSketch`1.#ctor(System.Int64,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the CmSketch class with the specified maximum size and equality comparer.
            </summary>
            <param name="maximumSize">The maximum size.</param>
            <param name="comparer">The equality comparer.</param>
        </member>
        <member name="T:BitFaster.Caching.Lfu.CmSketchCore`2">
            <summary>
            A probabilistic data structure used to estimate the frequency of a given value. Periodic aging reduces the
            accumulated count across all values over time, such that a historic popular value will decay to zero frequency
            over time if it is not accessed.
            </summary>
            <remarks>
            The maximum frequency of an element is limited to 15 (4-bits). Each element is hashed to a 64 byte 'block'
            consisting of 4 segments of 32 4-bit counters. The 64 byte blocks are the same size as x64 L1 cache lines.
            While the blocks are not guaranteed to be aligned, this scheme minimizes L1 cache misses resulting in a
            significant speedup. When supported, a vectorized AVX2 code path provides a further speedup. Together, block 
            and AVX2 are approximately 2x faster than the original implementation.
            </remarks>
            This is a direct C# translation of FrequencySketch in the Caffeine library by ben.manes@gmail.com (Ben Manes).
            https://github.com/ben-manes/caffeine
        </member>
        <member name="M:BitFaster.Caching.Lfu.CmSketchCore`2.#ctor(System.Int64,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the CmSketch class with the specified maximum size and equality comparer.
            </summary>
            <param name="maximumSize">The maximum size.</param>
            <param name="comparer">The equality comparer.</param>
        </member>
        <member name="P:BitFaster.Caching.Lfu.CmSketchCore`2.ResetSampleSize">
            <summary>
            Gets the reset sample size.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lfu.CmSketchCore`2.Size">
            <summary>
            Gets the size.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lfu.CmSketchCore`2.EstimateFrequency(`0)">
            <summary>
            Estimate the frequency of the specified value, up to the maximum of 15.
            </summary>
            <param name="value">The value.</param>
            <returns>The estimated frequency of the value.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.CmSketchCore`2.Increment(`0)">
            <summary>
            Increment the count of the specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:BitFaster.Caching.Lfu.CmSketchCore`2.Clear">
            <summary>
            Clears the count for all items.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lfu.ConcurrentLfu`2">
            <summary>
            An approximate LFU based on the W-TinyLfu eviction policy. W-TinyLfu tracks items using a window LRU list, and 
            a main space LRU divided into protected and probation segments. Reads and writes to the cache are stored in buffers
            and later applied to the policy LRU lists in batches under a lock. Each read and write is tracked using a compact 
            popularity sketch to probalistically estimate item frequency. Items proceed through the LRU lists as follows:
            <list type="number">
              <item><description>New items are added to the window LRU. When acessed window items move to the window MRU position.</description></item>
              <item><description>When the window is full, candidate items are moved to the probation segment in LRU order.</description></item>
              <item><description>When the main space is full, the access frequency of each window candidate is compared 
              to probation victims in LRU order. The item with the lowest frequency is evicted until the cache size is within bounds.</description></item>
              <item><description>When a probation item is accessed, it is moved to the protected segment. If the protected segment is full, 
              the LRU protected item is demoted to probation.</description></item>
              <item><description>When a protected item is accessed, it is moved to the protected MRU position.</description></item>
            </list>
            The size of the admission window and main space are adapted over time to iteratively improve hit rate using a 
            hill climbing algorithm. A larger window favors workloads with high recency bias, whereas a larger main space
            favors workloads with frequency bias.
            </summary>
            Based on the Caffeine library by ben.manes@gmail.com (Ben Manes).
            https://github.com/ben-manes/caffeine
        </member>
        <member name="F:BitFaster.Caching.Lfu.ConcurrentLfu`2.DefaultBufferSize">
            <summary>
            The default buffer size.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the ConcurrentLfu class with the specified capacity.
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.#ctor(System.Int32,System.Int32,BitFaster.Caching.Scheduler.IScheduler,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the ConcurrentLfu class with the specified concurrencyLevel, capacity, scheduler, equality comparer and buffer size.
            </summary>
            <param name="concurrencyLevel">The concurrency level.</param>
            <param name="capacity">The capacity.</param>
            <param name="scheduler">The scheduler.</param>
            <param name="comparer">The equality comparer.</param>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentLfu`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentLfu`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentLfu`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentLfu`2.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentLfu`2.Keys">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentLfu`2.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentLfu`2.Scheduler">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.DoMaintenance">
            <summary>
            Synchronously perform all pending policy maintenance. Drain the read and write buffers then
            use the eviction policy to preserve bounded size and remove expired items.
            </summary>
            <remarks>
            Note: maintenance is automatically performed asynchronously immediately following a read or write.
            It is not necessary to call this method, <see cref="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.DoMaintenance"/> is provided purely to enable tests to reach a consistent state.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.GetOrAdd(`0,System.Func{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.GetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.GetOrAddAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.Trim(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.TryGet(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Attempts to remove the specified key value pair.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>true if the item was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <param name="value">When this method returns, contains the object removed, or the default value of the value type if key does not exist.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfu`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.ConcurrentLfuBuilder`2">
            <summary>
            A builder of ICache and IScopedCache instances with the following configuration
            settings:
            <list type="bullet">
              <item><description>The maximum size.</description></item>
              <item><description>The concurrency level.</description></item>
              <item><description>The key comparer.</description></item>
            </list>
            The following features can be selected which change the underlying cache implementation: 
            <list type="bullet">
              <item><description>Scoped IDisposable values.</description></item>
              <item><description>Atomic value factory.</description></item>
            </list>
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilder`2.#ctor">
            <summary>
            Creates a ConcurrentLfuBuilder. Chain method calls onto ConcurrentLfuBuilder to configure the cache then call Build to create a cache instance.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilder`2.WithExpireAfter(BitFaster.Caching.IExpiryCalculator{`0,`1})">
            <summary>
            Evict after a duration calculated for each item using the specified IExpiryCalculator.
            </summary>
            <param name="expiry">The expiry calculator that determines item time to expire.</param>
            <returns>A ConcurrentLfuBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions">
            <summary>
            Extension methods to support building all cache variants.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lfu.ConcurrentLfuBuilder{``0,``1})">
            <summary>
            Build an IScopedCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>A ScopedConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lfu.Builder.AsyncConcurrentLfuBuilder{``0,``1})">
            <summary>
            Build an IScopedAsyncCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AsyncConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>A ScopedAsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lfu.Builder.AtomicAsyncConcurrentLfuBuilder{``0,``1})">
            <summary>
            Build an IScopedAsyncCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicAsyncConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedAsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lfu.ConcurrentLfuBuilder{``0,``1})">
            <summary>
            Build an IAsyncCache, the GetOrAdd method becomes GetOrAddAsync. 
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lfu.Builder.AtomicConcurrentLfuBuilder{``0,``1})">
            <summary>
            Build an IAsyncCache, the GetOrAdd method becomes GetOrAddAsync. 
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicAsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lfu.Builder.ScopedConcurrentLfuBuilder{``0,``1,BitFaster.Caching.Scoped{``1}})">
            <summary>
            Build an IScopedAsyncCache, the ScopedGetOrAdd method becomes ScopedGetOrAddAsync. 
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ScopedConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>A ScopedAsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lfu.Builder.AtomicScopedConcurrentLfuBuilder{``0,``1})">
            <summary>
            Build an IScopedAsyncCache, the ScopedGetOrAdd method becomes ScopedGetOrAddAsync.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicScopedConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedAsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.WithAtomicGetOrAdd``2(BitFaster.Caching.Lfu.ConcurrentLfuBuilder{``0,``1})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.WithAtomicGetOrAdd``2(BitFaster.Caching.Lfu.Builder.AsyncConcurrentLfuBuilder{``0,``1})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AsyncConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicAsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.WithAtomicGetOrAdd``3(BitFaster.Caching.Lfu.Builder.ScopedConcurrentLfuBuilder{``0,``1,``2})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <typeparam name="W">The wrapped value type.</typeparam>
            <param name="builder">The ScopedConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.WithAtomicGetOrAdd``2(BitFaster.Caching.Lfu.Builder.ScopedAsyncConcurrentLfuBuilder{``0,``1})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ScopedAsyncConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedAsyncConcurrentLfuBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentLfuBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lfu.Builder.AtomicConcurrentLfuBuilder{``0,``1})">
            <summary>
            Build an IScopedCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicConcurrentLfuBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedConcurrentLfuBuilder.</returns>
        </member>
        <member name="T:BitFaster.Caching.Lfu.ConcurrentLfuCore`4">
            <summary>
            An approximate LFU based on the W-TinyLfu eviction policy. W-TinyLfu tracks items using a window LRU list, and 
            a main space LRU divided into protected and probation segments. Reads and writes to the cache are stored in buffers
            and later applied to the policy LRU lists in batches under a lock. Each read and write is tracked using a compact 
            popularity sketch to probalistically estimate item frequency. Items proceed through the LRU lists as follows:
            <list type="number">
              <item><description>New items are added to the window LRU. When acessed window items move to the window MRU position.</description></item>
              <item><description>When the window is full, candidate items are moved to the probation segment in LRU order.</description></item>
              <item><description>When the main space is full, the access frequency of each window candidate is compared 
              to probation victims in LRU order. The item with the lowest frequency is evicted until the cache size is within bounds.</description></item>
              <item><description>When a probation item is accessed, it is moved to the protected segment. If the protected segment is full, 
              the LRU protected item is demoted to probation.</description></item>
              <item><description>When a protected item is accessed, it is moved to the protected MRU position.</description></item>
            </list>
            The size of the admission window and main space are adapted over time to iteratively improve hit rate using a 
            hill climbing algorithm. A larger window favors workloads with high recency bias, whereas a larger main space
            favors workloads with frequency bias.
            </summary>
            Based on the Caffeine library by ben.manes@gmail.com (Ben Manes).
            https://github.com/ben-manes/caffeine
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Keys">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Scheduler">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.GetOrAdd(`0,System.Func{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.GetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.GetOrAddAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.Trim(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.TryGet(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.TryGetTimeToExpire``1(``0,System.TimeSpan@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lfu.ConcurrentTLfu`2.TrimExpired">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lfu.LfuCapacityPartition">
            <summary>
            Represents the LFU capacity partition. Uses a hill climbing algorithm to optimze partition sizes over time.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lfu.LfuCapacityPartition.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the LfuCapacityPartition class with the specified total capacity.
            </summary>
            <param name="totalCapacity">The total capacity.</param>
        </member>
        <member name="P:BitFaster.Caching.Lfu.LfuCapacityPartition.Window">
            <summary>
            Gets the number of items permitted in the window LRU.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lfu.LfuCapacityPartition.Protected">
            <summary>
            Gets the number of items permitted in the protected LRU.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lfu.LfuCapacityPartition.Probation">
            <summary>
            Gets the number of items permitted in the probation LRU.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lfu.LfuCapacityPartition.Capacity">
            <summary>
            Gets the total capacity.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lfu.LfuCapacityPartition.OptimizePartitioning(BitFaster.Caching.ICacheMetrics,System.Int32)">
            <summary>
            Optimize the size of the window and main LRUs based on changes in hit rate.
            </summary>
            <param name="metrics">The cache metrics.</param>
            <param name="sampleThreshold">The number of cache requests to sample before attempting to optimize LRU sizes.</param>
            <remarks>
            window = recency-biased, main = frequency-biased.
            </remarks>
        </member>
        <member name="P:BitFaster.Caching.Lfu.LfuNode`2.WasRemoved">
            <summary>
            Node was removed from the dictionary, but is still present in the LRU lists.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lfu.LfuNode`2.WasDeleted">
            <summary>
            Node has been removed both from the dictionary and the LRU lists.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lfu.LfuNodeList`2">
            <summary>
            Adapted from the .NET linked list code, but with arg checking only applied in debug builds. 
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lfu.TimerWheel`2.Advance``2(BitFaster.Caching.Lfu.ConcurrentLfuCore{`0,`1,``0,``1}@,BitFaster.Caching.Duration)">
            <summary>
             Advances the timer and evicts entries that have expired.
            </summary>
            <param name="cache"></param>
            <param name="currentTime"></param>
        </member>
        <member name="M:BitFaster.Caching.Lfu.TimerWheel`2.Schedule(BitFaster.Caching.Lfu.TimeOrderNode{`0,`1})">
            <summary>
            Schedules a timer event for the node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:BitFaster.Caching.Lfu.TimerWheel`2.Reschedule(BitFaster.Caching.Lfu.TimeOrderNode{`0,`1})">
            <summary>
            Reschedules an active timer event for the node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:BitFaster.Caching.Lfu.TimerWheel`2.Deschedule(BitFaster.Caching.Lfu.TimeOrderNode{`0,`1})">
            <summary>
            Removes a timer event for this entry if present.
            </summary>
            <param name="node"></param>
        </member>
        <member name="T:BitFaster.Caching.Lifetime`1">
            <summary>
            Represents the lifetime of a value. The value is alive and valid for use until the 
            lifetime is disposed.
            </summary>
            <typeparam name="T">The type of value</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lifetime`1.#ctor(BitFaster.Caching.ReferenceCount{`0},System.Action)">
            <summary>
            Initializes a new instance of the Lifetime class.
            </summary>
            <param name="value">The value to keep alive.</param>
            <param name="onDisposeAction">The action to perform when the lifetime is terminated.</param>
        </member>
        <member name="P:BitFaster.Caching.Lifetime`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lifetime`1.ReferenceCount">
            <summary>
            Gets the count of Lifetime instances referencing the same value.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lifetime`1.Dispose">
            <summary>
            Terminates the lifetime and performs any cleanup required to release the value.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.AfterAccessPolicy`2">
            <summary>
            Implement an expire after access policy.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.AfterAccessPolicy`2.TimeToLive">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the AfterReadTickCount64Policy class with the specified time to live.
            </summary>
            <param name="timeToLive">The time to live.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.CreateItem(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.Touch(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.Update(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.ShouldDiscard(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.CanDiscard">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.RouteHot(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.RouteWarm(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.AfterAccessPolicy`2.RouteCold(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.AsyncConcurrentLruBuilder`2">
            <summary>
            A builder for creating a ConcurrentLru.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.AsyncConcurrentLruBuilder`2.WithExpireAfter(BitFaster.Caching.IExpiryCalculator{`0,`1})">
            <summary>
            Evict after a duration calculated for each item using the specified IExpiryCalculator.
            </summary>
            <param name="expiry">The expiry calculator that determines item time to expire.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.AsyncConcurrentLruBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.AtomicAsyncConcurrentLruBuilder`2">
            <summary>
            A builder for creating a ConcurrentLru as IAsyncCache with atomic value creation.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.AtomicAsyncConcurrentLruBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.AtomicConcurrentLruBuilder`2">
            <summary>
            A builder for creating a ConcurrentLru as ICache with atomic value creation.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.AtomicConcurrentLruBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.AtomicScopedAsyncConcurrentLruBuilder`2">
            <summary>
            A builder for creating a ConcurrentLru with scoped values.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.AtomicScopedAsyncConcurrentLruBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.AtomicScopedConcurrentLruBuilder`2">
            <summary>
            A builder for creating a ConcurrentLru with scoped values.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.AtomicScopedConcurrentLruBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.LruBuilderBase`4">
            <summary>
            Recursive generic base class enables builder inheritance.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.#ctor(BitFaster.Caching.Lru.Builder.LruInfo{`0})">
            <summary>
            Creates an LruBuilderBase.
            </summary>
            <param name="info">The LRU info</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.WithCapacity(System.Int32)">
            <summary>
            Set the maximum number of values to keep in the cache. If more items than this are added, 
            the cache eviction policy will determine which values to remove.
            </summary>
            <param name="capacity">The maximum number of values to keep in the cache.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.WithCapacity(BitFaster.Caching.Lru.ICapacityPartition)">
            <summary>
            Set the maximum number of values to keep in the cache. If more items than this are added, 
            the cache eviction policy will determine which values to remove.
            </summary>
            <param name="capacity">The capacity partition scheme to use.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.WithConcurrencyLevel(System.Int32)">
            <summary>
            Use the specified concurrency level.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the cache concurrently.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.WithKeyComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Use the specified equality comparison implementation to compare keys.
            </summary>
            <param name="comparer">The equality comparison implementation to use when comparing keys.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.WithMetrics">
            <summary>
            Collect cache metrics, such as Hit rate. Metrics have a small performance penalty.
            </summary>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.WithExpireAfterWrite(System.TimeSpan)">
            <summary>
            Evict after a fixed duration since an entry's creation or most recent replacement.
            </summary>
            <param name="expiration">The length of time before an entry is automatically removed.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.WithExpireAfterAccess(System.TimeSpan)">
            <summary>
            Evict after a fixed duration since an entry's most recent read or write.
            </summary>
            <param name="expiration">The length of time before an entry is automatically removed.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruBuilderBase`4.Build">
            <summary>
            Builds a cache configured via the method calls invoked on the builder instance.
            </summary>
            <returns>A cache.</returns>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.LruInfo`1">
            <summary>
            Parameters for buiding an LRU.
            </summary>
            <typeparam name="K">The LRU key type</typeparam>
        </member>
        <member name="P:BitFaster.Caching.Lru.Builder.LruInfo`1.Capacity">
            <summary>
            Gets or sets the capacity partition.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.Builder.LruInfo`1.ConcurrencyLevel">
            <summary>
            Gets or sets the concurrency level.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.Builder.LruInfo`1.TimeToExpireAfterWrite">
            <summary>
            Gets or sets the time to expire after write.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.Builder.LruInfo`1.TimeToExpireAfterAccess">
            <summary>
            Gets or sets the time to expire after access.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruInfo`1.SetExpiry``1(BitFaster.Caching.IExpiryCalculator{`0,``0})">
            <summary>
            Set the custom expiry.
            </summary>
            <param name="expiry">The expiry</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.LruInfo`1.GetExpiry``1">
            <summary>
            Get the custom expiry.
            </summary>
            <returns>The expiry.</returns>
        </member>
        <member name="P:BitFaster.Caching.Lru.Builder.LruInfo`1.WithMetrics">
            <summary>
            Gets or sets a value indicating whether to use metrics.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.Builder.LruInfo`1.KeyComparer">
            <summary>
            Gets or sets the KeyComparer.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.ScopedAsyncConcurrentLruBuilder`2">
            <summary>
            A builder for creating a ConcurrentLru with scoped values.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.ScopedAsyncConcurrentLruBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.Builder.ScopedConcurrentLruBuilder`3">
            <summary>
            A builder for creating a ConcurrentLru with scoped values.
            </summary>
            <typeparam name="K">The type of the cache key.</typeparam>
            <typeparam name="V">The type of the cache value.</typeparam>
            <typeparam name="W">The type of the wrapped cache value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.Builder.ScopedConcurrentLruBuilder`3.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.CapacityPartitionExtensions">
            <summary>
            Extension methods for ICapacityPartition.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.CapacityPartitionExtensions.Validate(BitFaster.Caching.Lru.ICapacityPartition)">
            <summary>
            Validates the specified capacity partition.
            </summary>
            <param name="capacity">The capacity partition to validate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Any of the hot, warm or cold capacities is less than 1.</exception>
        </member>
        <member name="T:BitFaster.Caching.Lru.ClassicLru`2">
            <summary>
            LRU implementation where Lookup operations are backed by a ConcurrentDictionary and the LRU list is protected
            by a global lock. All list operations performed within the lock are fast O(1) operations. 
            </summary>
            <remarks>
            Due to the lock protecting list operations, this class may suffer lock contention under heavy load.
            </remarks>
            <typeparam name="K">The type of the key</typeparam>
            <typeparam name="V">The type of the value</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the ClassicLru class with the specified capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the ClassicLru class with the specified concurrencyLevel, capacity and equality comparer.
            </summary>
            <param name="concurrencyLevel">The concurrency level.</param>
            <param name="capacity">The capacity.</param>
            <param name="comparer">The key comparer</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:BitFaster.Caching.Lru.ClassicLru`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ClassicLru`2.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ClassicLru`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ClassicLru`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ClassicLru`2.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ClassicLru`2.Keys">
            <summary>
            Gets a collection containing the keys in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the cache.</summary>
            <returns>An enumerator for the cache.</returns>
            <remarks>
            The enumerator returned from the cache is safe to use concurrently with
            reads and writes, however it does not represent a moment-in-time snapshot.  
            The contents exposed through the enumerator may contain modifications
            made after <see cref="M:BitFaster.Caching.Lru.ClassicLru`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.TryGet(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.GetOrAdd(`0,System.Func{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already 
            in the cache, or the new value if the key was not in the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.GetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.GetOrAddAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to asynchronously generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>A task that represents the asynchronous GetOrAdd operation.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Attempts to remove the specified key value pair.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>true if the item was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <param name="value">When this method returns, contains the object removed, or the default value of the value type if key does not exist.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.TryUpdate(`0,`1)">
            <inheritdoc/>
            <remarks>Note: Calling this method does not affect LRU order.</remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
            <remarks>Note: Updates to existing items do not affect LRU order. Added items are at the top of the LRU.</remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.Trim(System.Int32)">
            <inheritdoc/>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="itemCount"/> is less than 0./</exception>
             <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="itemCount"/> is greater than capacity./</exception>
        </member>
        <member name="M:BitFaster.Caching.Lru.ClassicLru`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through the cache.</summary>
            <returns>An enumerator for the cache.</returns>
            <remarks>
            The enumerator returned from the cache is safe to use concurrently with
            reads and writes, however it does not represent a moment-in-time snapshot.  
            The contents exposed through the enumerator may contain modifications
            made after <see cref="M:BitFaster.Caching.Lru.ClassicLru`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="T:BitFaster.Caching.Lru.ConcurrentLru">
            <summary>
            Factory class for creating ConcurrentLru variants.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLru.Create``2(BitFaster.Caching.Lru.Builder.LruInfo{``0})">
            <summary>
            Creates a ConcurrentLru instance based on the provided LruInfo.
            </summary>
            <param name="info">The LruInfo</param>
            <returns>A ConcurrentLru</returns>
        </member>
        <member name="T:BitFaster.Caching.Lru.ConcurrentLruBuilder`2">
            <summary>
            A builder of ICache and IScopedCache instances with the following configuration
            settings:
            <list type="bullet">
              <item><description>The maximum size.</description></item>
              <item><description>The concurrency level.</description></item>
              <item><description>The key comparer.</description></item>
            </list>
            The following features can be selected which change the underlying cache implementation: 
            <list type="bullet">
              <item><description>Collect metrics (e.g. hit rate). Small perf penalty.</description></item>
              <item><description>Time based expiration, measured since last write.</description></item>
              <item><description>Time based expiration, measured since last read.</description></item>
              <item><description>Scoped IDisposable values.</description></item>
              <item><description>Atomic value factory.</description></item>
            </list>
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilder`2.#ctor">
            <summary>
            Creates a ConcurrentLruBuilder. Chain method calls onto ConcurrentLruBuilder to configure the cache then call Build to create a cache instance.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilder`2.WithExpireAfter(BitFaster.Caching.IExpiryCalculator{`0,`1})">
            <summary>
            Evict after a duration calculated for each item using the specified IExpiryCalculator.
            </summary>
            <param name="expiry">The expiry calculator that determines item time to expire.</param>
            <returns>A ConcurrentLruBuilder</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilder`2.Build">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions">
            <summary>
            Extension methods to support building all cache variants.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lru.ConcurrentLruBuilder{``0,``1})">
            <summary>
            Build an IScopedCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ConcurrentLruBuilder to chain method calls onto.</param>
            <returns>A ScopedConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lru.Builder.AtomicConcurrentLruBuilder{``0,``1})">
            <summary>
            Build an IScopedCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lru.Builder.AsyncConcurrentLruBuilder{``0,``1})">
            <summary>
            Build an IScopedAsyncCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AsyncConcurrentLruBuilder to chain method calls onto.</param>
            <returns>A ScopedAsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsScopedCache``2(BitFaster.Caching.Lru.Builder.AtomicAsyncConcurrentLruBuilder{``0,``1})">
            <summary>
            Build an IScopedAsyncCache. IDisposable values are wrapped in a lifetime scope. Scoped caches return lifetimes that prevent
            values from being disposed until the calling code completes.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicAsyncConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedAsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.WithAtomicGetOrAdd``2(BitFaster.Caching.Lru.ConcurrentLruBuilder{``0,``1})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.WithAtomicGetOrAdd``3(BitFaster.Caching.Lru.Builder.ScopedConcurrentLruBuilder{``0,``1,``2})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <typeparam name="W">The wrapped value type.</typeparam>
            <param name="builder">The ScopedConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.WithAtomicGetOrAdd``2(BitFaster.Caching.Lru.Builder.AsyncConcurrentLruBuilder{``0,``1})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AsyncConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicAsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.WithAtomicGetOrAdd``2(BitFaster.Caching.Lru.Builder.ScopedAsyncConcurrentLruBuilder{``0,``1})">
            <summary>
            Execute the cache's GetOrAdd method atomically, such that it is applied at most once per key. Other threads
            attempting to update the same key will be blocked until value factory completes. Incurs a small performance
            penalty.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ScopedAsyncConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedAsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lru.ConcurrentLruBuilder{``0,``1})">
            <summary>
            Build an IAsyncCache, the GetOrAdd method becomes GetOrAddAsync. 
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lru.Builder.ScopedConcurrentLruBuilder{``0,``1,BitFaster.Caching.Scoped{``1}})">
            <summary>
            Build an IScopedAsyncCache, the ScopedGetOrAdd method becomes ScopedGetOrAddAsync. 
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The ScopedConcurrentLruBuilder to chain method calls onto.</param>
            <returns>A ScopedAsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lru.Builder.AtomicConcurrentLruBuilder{``0,``1})">
            <summary>
            Build an IAsyncCache, the GetOrAdd method becomes GetOrAddAsync. 
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicAsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruBuilderExtensions.AsAsyncCache``2(BitFaster.Caching.Lru.Builder.AtomicScopedConcurrentLruBuilder{``0,``1})">
            <summary>
            Build an IScopedAsyncCache, the ScopedGetOrAdd method becomes ScopedGetOrAddAsync.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
            <param name="builder">The AtomicScopedConcurrentLruBuilder to chain method calls onto.</param>
            <returns>An AtomicScopedAsyncConcurrentLruBuilder.</returns>
        </member>
        <member name="T:BitFaster.Caching.Lru.ConcurrentLruCore`5">
             <summary>
             A pseudo LRU based on the TU-Q eviction policy. The LRU list is composed of 3 segments: hot, warm and cold. 
             Cost of maintaining segments is amortized across requests. Items are only cycled when capacity is exceeded. 
             Pure read does not cycle items if all segments are within capacity constraints. There are no global locks. 
             On cache miss, a new item is added. Tail items in each segment are dequeued, examined, and are either enqueued 
             or discarded.
             The TU-Q scheme of hot, warm and cold is similar to that used in MemCached (https://memcached.org/blog/modern-lru/)
             and OpenBSD (https://flak.tedunangst.com/post/2Q-buffer-cache-algorithm), but does not use a background thread
             to maintain the internal queues.
             </summary>
             <remarks>
             Each segment has a capacity. When segment capacity is exceeded, items are moved as follows:
             <list type="number">
               <item><description>New items are added to hot, WasAccessed = false.</description></item>
               <item><description>When items are accessed, update WasAccessed = true.</description></item>
               <item><description>When items are moved WasAccessed is set to false.</description></item>
               <item><description>When hot is full, hot tail is moved to either Warm or Cold depending on WasAccessed.</description></item>
               <item><description>When warm is full, warm tail is moved to warm head or cold depending on WasAccessed.</description></item>
               <item><description>When cold is full, cold tail is moved to warm head or removed from dictionary on depending on WasAccessed.</description></item>
            </list>
             </remarks>
        </member>
        <member name="F:BitFaster.Caching.Lru.ConcurrentLruCore`5.telemetryPolicy">
            <summary>
            The telemetry policy.
            </summary>
            <remarks>
            Since T is a struct, making it readonly will force the runtime to make defensive copies
            if mutate methods are called. Therefore, field must be mutable to maintain count.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.#ctor(System.Int32,BitFaster.Caching.Lru.ICapacityPartition,System.Collections.Generic.IEqualityComparer{`0},`3,`4)">
            <summary>
            Initializes a new instance of the ConcurrentLruCore class with the specified concurrencyLevel, capacity, equality comparer, item policy and telemetry policy.
            </summary>
            <param name="concurrencyLevel">The concurrency level.</param>
            <param name="capacity">The capacity.</param>
            <param name="comparer">The equality comparer.</param>
            <param name="itemPolicy">The item policy.</param>
            <param name="telemetryPolicy">The telemetry policy.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.HotCount">
            <summary>
            Gets the number of hot items.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.WarmCount">
            <summary>
            Gets the number of warm items.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.ColdCount">
            <summary>
            Gets the number of cold items.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.ConcurrentLruCore`5.Keys">
            <summary>
            Gets a collection containing the keys in the cache.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.GetEnumerator">
            <summary>Returns an enumerator that iterates through the cache.</summary>
            <returns>An enumerator for the cache.</returns>
            <remarks>
            The enumerator returned from the cache is safe to use concurrently with
            reads and writes, however it does not represent a moment-in-time snapshot.  
            The contents exposed through the enumerator may contain modifications
            made after <see cref="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.TryGet(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.GetOrAdd(`0,System.Func{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already 
            in the cache, or the new value if the key was not in the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.GetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.GetOrAddAsync``1(`0,System.Func{`0,``0,System.Threading.Tasks.Task{`1}},``0)">
            <summary>
            Adds a key/value pair to the cache if the key does not already exist. Returns the new value, or the 
            existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to asynchronously generate a value for the key.</param>
            <param name="factoryArgument">An argument value to pass into valueFactory.</param>
            <returns>A task that represents the asynchronous GetOrAdd operation.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Attempts to remove the specified key value pair.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>true if the item was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <param name="value">When this method returns, contains the object removed, or the default value of the value type if key does not exist.</param>
            <returns>true if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.TryUpdate(`0,`1)">
            <inheritdoc/>
            <remarks>Note: Calling this method does not affect LRU order.</remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.AddOrUpdate(`0,`1)">
            <inheritdoc/>
            <remarks>Note: Updates to existing items do not affect LRU order. Added items are at the top of the LRU.</remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.Trim(System.Int32)">
            <summary>
            Trim the specified number of items from the cache. Removes all discardable items per IItemPolicy.ShouldDiscard(), then 
            itemCount-discarded items in LRU order, if any.
            </summary>
            <param name="itemCount">The number of items to remove.</param>
            <returns>The number of items removed from the cache.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="itemCount"/> is less than 0./</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="itemCount"/> is greater than capacity./</exception>
            <remarks>
            Note: Trim affects LRU order. Calling Trim resets the internal accessed status of items.
            </remarks>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.TrimAllDiscardedItems">
            <summary>
            Trim discarded items from all queues.
            </summary>
            <returns>The number of items removed.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through the cache.</summary>
            <returns>An enumerator for the cache.</returns>
            <remarks>
            The enumerator returned from the cache is safe to use concurrently with
            reads and writes, however it does not represent a moment-in-time snapshot.  
            The contents exposed through the enumerator may contain modifications
            made after <see cref="M:BitFaster.Caching.Lru.ConcurrentLruCore`5.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="T:BitFaster.Caching.Lru.ConcurrentLru`2">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLru`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the ConcurrentLru class with the specified capacity that has the default 
            concurrency level, and uses the default comparer for the key type.
            </summary>
            <param name="capacity">The maximum number of elements that the ConcurrentLru can contain.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLru`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the ConcurrentLru class that has the specified concurrency level, has the 
            specified initial capacity, and uses the specified IEqualityComparer.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the ConcurrentLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the ConcurrentLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentLru`2.#ctor(System.Int32,BitFaster.Caching.Lru.ICapacityPartition,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the ConcurrentLru class that has the specified concurrency level, has the 
            specified initial capacity, and uses the specified IEqualityComparer.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the ConcurrentLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the ConcurrentLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
        </member>
        <member name="T:BitFaster.Caching.Lru.ConcurrentTLru`2">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentTLru`2.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the ConcurrentTLru class with the specified capacity and time to live that has the default 
            concurrency level, and uses the default comparer for the key type.
            </summary>
            <param name="capacity">The maximum number of elements that the ConcurrentTLru can contain.</param>
            <param name="timeToLive">The time to live for cached values.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentTLru`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.TimeSpan)">
            <summary>
            Initializes a new instance of the ConcurrentTLru class that has the specified concurrency level, has the 
            specified initial capacity, uses the specified IEqualityComparer, and has the specified time to live.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the ConcurrentTLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the ConcurrentTLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
            <param name="timeToLive">The time to live for cached values.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.ConcurrentTLru`2.#ctor(System.Int32,BitFaster.Caching.Lru.ICapacityPartition,System.Collections.Generic.IEqualityComparer{`0},System.TimeSpan)">
            <summary>
            Initializes a new instance of the ConcurrentTLru class that has the specified concurrency level, has the 
            specified initial capacity, uses the specified IEqualityComparer, and has the specified time to live.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the ConcurrentTLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the ConcurrentTLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
            <param name="timeToLive">The time to live for cached values.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.CreateItem(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.Touch(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.Update(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.ShouldDiscard(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.CanDiscard">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.RouteHot(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.RouteWarm(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.DiscretePolicy`2.RouteCold(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.EqualCapacityPartition">
            <summary>
            A simple partitioning scheme to put an approximately equal number of items in each queue.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.EqualCapacityPartition.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the EqualCapacityPartition class with the specified total capacity.
            </summary>
            <param name="totalCapacity">The total capacity.</param>
        </member>
        <member name="P:BitFaster.Caching.Lru.EqualCapacityPartition.Cold">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.EqualCapacityPartition.Warm">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.EqualCapacityPartition.Hot">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.FastConcurrentLru`2">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.FastConcurrentLru`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the FastConcurrentLru class with the specified capacity that has the default 
            concurrency level, and uses the default comparer for the key type.
            </summary>
            <param name="capacity">The maximum number of elements that the FastConcurrentLru can contain.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.FastConcurrentLru`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the FastConcurrentLru class that has the specified concurrency level, has the 
            specified initial capacity, and uses the specified IEqualityComparer.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the FastConcurrentLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the FastConcurrentLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.FastConcurrentLru`2.#ctor(System.Int32,BitFaster.Caching.Lru.ICapacityPartition,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the FastConcurrentLru class that has the specified concurrency level, has the 
            specified initial capacity, and uses the specified IEqualityComparer.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the FastConcurrentLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the FastConcurrentLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
        </member>
        <member name="T:BitFaster.Caching.Lru.FastConcurrentTLru`2">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.FastConcurrentTLru`2.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the FastConcurrentTLru class with the specified capacity and time to live that has the default 
            concurrency level, and uses the default comparer for the key type.
            </summary>
            <param name="capacity">The maximum number of elements that the FastConcurrentTLru can contain.</param>
            <param name="timeToLive">The time to live for cached values.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.FastConcurrentTLru`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.TimeSpan)">
            <summary>
            Initializes a new instance of the FastConcurrentTLru class that has the specified concurrency level, has the 
            specified initial capacity, uses the specified IEqualityComparer, and has the specified time to live.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the FastConcurrentTLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the FastConcurrentTLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
            <param name="timeToLive">The time to live for cached values.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.FastConcurrentTLru`2.#ctor(System.Int32,BitFaster.Caching.Lru.ICapacityPartition,System.Collections.Generic.IEqualityComparer{`0},System.TimeSpan)">
            <summary>
            Initializes a new instance of the FastConcurrentLru class that has the specified concurrency level, has the 
            specified initial capacity, and uses the specified IEqualityComparer.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the FastConcurrentLru concurrently.</param>
            <param name="capacity">The maximum number of elements that the FastConcurrentLru can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
            <param name="timeToLive">The time to live for cached values.</param>
        </member>
        <member name="T:BitFaster.Caching.Lru.FavorWarmPartition">
            <summary>
            A capacity partitioning scheme that favors frequently accessed items by allocating 80% 
            capacity to the warm queue.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Lru.FavorWarmPartition.DefaultWarmRatio">
            <summary>
            Default to 80% capacity allocated to warm queue, 20% split equally for hot and cold.
            This favors frequently accessed items.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.FavorWarmPartition.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the FavorWarmPartition class with the specified capacity and the default warm ratio.
            </summary>
            <param name="totalCapacity">The total capacity.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.FavorWarmPartition.#ctor(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the FavorWarmPartition class with the specified capacity and warm ratio.
            </summary>
            <param name="totalCapacity">The total capacity.</param>
            <param name="warmRatio">The ratio of warm items to hot and cold items.</param>
        </member>
        <member name="P:BitFaster.Caching.Lru.FavorWarmPartition.Cold">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.FavorWarmPartition.Warm">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.FavorWarmPartition.Hot">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.ICapacityPartition">
            <summary>
            Represents a partitioning scheme for the internal queues within concurrent LRU.
            </summary>
            <remarks>
            In general, increasing the size of the hot queue favors recent items and increasing
            the size of the warm queue favors frequent items.
            </remarks>
        </member>
        <member name="P:BitFaster.Caching.Lru.ICapacityPartition.Cold">
            <summary>
            Gets the capacity of the cold queue.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.ICapacityPartition.Warm">
            <summary>
            Gets the capacity of the warm queue.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.ICapacityPartition.Hot">
            <summary>
            Gets the capacity of the hot queue.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.IDiscreteItemPolicy`2">
            <summary>
            A marker interface for discrete expiry policies.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:BitFaster.Caching.Lru.IItemPolicy`3">
            <summary>
            Represents an LRU item policy.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
            <typeparam name="I">The type of the LRU item.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.CreateItem(`0,`1)">
            <summary>
            Creates an LRU item.
            </summary>
            <param name="key">The item key.</param>
            <param name="value">The item value.</param>
            <returns>An LRU item.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.Touch(`2)">
            <summary>
            Touch an item on read.
            </summary>
            <param name="item">The item to touch.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.Update(`2)">
            <summary>
            Update an item.
            </summary>
            <param name="item">The item to update.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.ShouldDiscard(`2)">
            <summary>
            Determine whether an item should be discarded.
            </summary>
            <param name="item">The item to check.</param>
            <returns>true if the item should be discarded, otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.CanDiscard">
            <summary>
            Gets a value indicating whether this policy can discard items.
            </summary>
            <returns>true if the policy can discard items, otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.RouteHot(`2)">
            <summary>
            Route a hot item.
            </summary>
            <param name="item">The item to route.</param>
            <returns>The destination for the specified item.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.RouteWarm(`2)">
            <summary>
            Route a warm item.
            </summary>
            <param name="item">The item to route.</param>
            <returns>The destination for the specified item.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.IItemPolicy`3.RouteCold(`2)">
            <summary>
            Route a cold item.
            </summary>
            <param name="item">The item to route.</param>
            <returns>The destination for the specified item.</returns>
        </member>
        <member name="P:BitFaster.Caching.Lru.IItemPolicy`3.TimeToLive">
            <summary>
            The item time to live defined by the policy.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.ITelemetryPolicy`2">
            <summary>
            Represents a telemetry policy.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.ITelemetryPolicy`2.IncrementMiss">
            <summary>
            Increment the miss counter.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.ITelemetryPolicy`2.IncrementHit">
            <summary>
            Increment the hit counter.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Lru.ITelemetryPolicy`2.OnItemRemoved(`0,`1,BitFaster.Caching.ItemRemovedReason)">
            <summary>
            Register the removal of an item.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="reason">The reason for removal.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.ITelemetryPolicy`2.SetEventSource(System.Object)">
            <summary>
            Set the event source for any events that are fired.
            </summary>
            <param name="source">The event source.</param>
        </member>
        <member name="T:BitFaster.Caching.Lru.ItemDestination">
            <summary>
            Specifies the destination for routing LRU items.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Lru.ItemDestination.Warm">
            <summary>
            Route to the warm queue.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Lru.ItemDestination.Cold">
            <summary>
            Route to the cold queue.
            </summary>
        </member>
        <member name="F:BitFaster.Caching.Lru.ItemDestination.Remove">
            <summary>
            Remove the item.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.LongTickCountLruItem`2">
            <summary>
            Represents an LRU item that also stores tick count.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.LongTickCountLruItem`2.#ctor(`0,`1,System.Int64)">
            <summary>
            Initializes a new instance of the LongTickCountLruItem class with the specified key and value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="tickCount">The tick count.</param>
        </member>
        <member name="P:BitFaster.Caching.Lru.LongTickCountLruItem`2.TickCount">
            <summary>
            Gets or sets the tick count.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.LruItem`2">
            <summary>
            Represents an LRU item.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruItem`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the LruItem class with the specified key and value.
            </summary>
            <param name="k">The key.</param>
            <param name="v">The value.</param>
        </member>
        <member name="F:BitFaster.Caching.Lru.LruItem`2.Key">
            <summary>
            Gets the key.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.LruItem`2.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.LruItem`2.WasAccessed">
            <summary>
            Gets or sets a value indicating whether the item was accessed.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.LruItem`2.WasRemoved">
            <summary>
            Gets or sets a value indicating whether the item was removed.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.LruPolicy`2">
            <summary>
            Discards the least recently used items first. 
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.LruPolicy`2.TimeToLive">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.CreateItem(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.Touch(BitFaster.Caching.Lru.LruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.Update(BitFaster.Caching.Lru.LruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.ShouldDiscard(BitFaster.Caching.Lru.LruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.CanDiscard">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.RouteHot(BitFaster.Caching.Lru.LruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.RouteWarm(BitFaster.Caching.Lru.LruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.LruPolicy`2.RouteCold(BitFaster.Caching.Lru.LruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.NoTelemetryPolicy`2">
            <summary>
            Represents a telemtry policy that does not count or have events (is disabled).
            This enables use of the cache without telemetry where maximum performance is required.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="P:BitFaster.Caching.Lru.NoTelemetryPolicy`2.HitRatio">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.NoTelemetryPolicy`2.Total">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.NoTelemetryPolicy`2.Hits">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.NoTelemetryPolicy`2.Misses">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.NoTelemetryPolicy`2.Updated">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.NoTelemetryPolicy`2.Evicted">
            <inheritdoc/>
        </member>
        <member name="E:BitFaster.Caching.Lru.NoTelemetryPolicy`2.ItemRemoved">
            <inheritdoc/>
        </member>
        <member name="E:BitFaster.Caching.Lru.NoTelemetryPolicy`2.ItemUpdated">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.NoTelemetryPolicy`2.IncrementMiss">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.NoTelemetryPolicy`2.IncrementHit">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.NoTelemetryPolicy`2.OnItemRemoved(`0,`1,BitFaster.Caching.ItemRemovedReason)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.NoTelemetryPolicy`2.OnItemUpdated(`0,`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.NoTelemetryPolicy`2.SetEventSource(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.TelemetryPolicy`2">
            <summary>
            Represents a telemetry policy with counters and events.
            </summary>
            <typeparam name="K">The type of the Key</typeparam>
            <typeparam name="V">The type of the value</typeparam>
        </member>
        <member name="E:BitFaster.Caching.Lru.TelemetryPolicy`2.ItemRemoved">
            <inheritdoc/>
        </member>
        <member name="E:BitFaster.Caching.Lru.TelemetryPolicy`2.ItemUpdated">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.TelemetryPolicy`2.HitRatio">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.TelemetryPolicy`2.Total">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.TelemetryPolicy`2.Hits">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.TelemetryPolicy`2.Misses">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.TelemetryPolicy`2.Evicted">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Lru.TelemetryPolicy`2.Updated">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TelemetryPolicy`2.IncrementMiss">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TelemetryPolicy`2.IncrementHit">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TelemetryPolicy`2.OnItemRemoved(`0,`1,BitFaster.Caching.ItemRemovedReason)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TelemetryPolicy`2.OnItemUpdated(`0,`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TelemetryPolicy`2.SetEventSource(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.TickCountLruItem`2">
            <summary>
            Represents an LRU item that also stores tick count.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.TickCountLruItem`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the TickCountLruItem class with the specified key and value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:BitFaster.Caching.Lru.TickCountLruItem`2.TickCount">
            <summary>
            Gets or sets the tick count.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.Time">
            <summary>
            During reads, the policy evaluates ShouldDiscard and Touch. To avoid Getting the current time twice
            introduce a simple time class that holds the last time. This is class with a mutable field, because the 
            policy structs are readonly.
            </summary>
            <remarks>
            This class mitigates torn writes when running on 32-bit systems using Interlocked read and write.
            </remarks>
        </member>
        <member name="P:BitFaster.Caching.Lru.Time.Last">
            <summary>
            Gets or sets the last time.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.TimeStampedLruItem`2">
            <summary>
            Represents an LRU item that also stores the item time stamp.
            </summary>
            <typeparam name="K">The type of the key.</typeparam>
            <typeparam name="V">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Lru.TimeStampedLruItem`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the TimeStampedLruItem class with the specified key and value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:BitFaster.Caching.Lru.TimeStampedLruItem`2.TimeStamp">
            <summary>
            Gets or sets the time stamp.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Lru.TLruDateTimePolicy`2">
            <summary>
            Time aware Least Recently Used (TLRU) is a variant of LRU which discards the least 
            recently used items first, and any item that has expired.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.TLruDateTimePolicy`2.TimeToLive">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the TLruDateTimePolicy class with the specified time to live.
            </summary>
            <param name="timeToLive">The time to live.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.CreateItem(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.Touch(BitFaster.Caching.Lru.TimeStampedLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.Update(BitFaster.Caching.Lru.TimeStampedLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.ShouldDiscard(BitFaster.Caching.Lru.TimeStampedLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.CanDiscard">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.RouteHot(BitFaster.Caching.Lru.TimeStampedLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.RouteWarm(BitFaster.Caching.Lru.TimeStampedLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruDateTimePolicy`2.RouteCold(BitFaster.Caching.Lru.TimeStampedLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Lru.TLruLongTicksPolicy`2">
            <summary>
            Time aware Least Recently Used (TLRU) is a variant of LRU which discards the least 
            recently used items first, and any item that has expired.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.TimeToLive">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the TLruTicksPolicy class with the specified time to live.
            </summary>
            <param name="timeToLive">The time to live.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.CreateItem(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.Touch(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.Update(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.ShouldDiscard(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.CanDiscard">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.RouteHot(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.RouteWarm(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.RouteCold(BitFaster.Caching.Lru.LongTickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.ToTicks(System.TimeSpan)">
            <summary>
            Convert from TimeSpan to ticks.
            </summary>
            <param name="timespan">The time represented as a TimeSpan.</param>
            <returns>The time represented as ticks.</returns>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruLongTicksPolicy`2.FromTicks(System.Int64)">
            <summary>
            Convert from ticks to a TimeSpan.
            </summary>
            <param name="ticks">The time represented as ticks.</param>
            <returns>The time represented as a TimeSpan.</returns>
        </member>
        <member name="T:BitFaster.Caching.Lru.TLruTicksPolicy`2">
            <summary>
            Time aware Least Recently Used (TLRU) is a variant of LRU which discards the least 
            recently used items first, and any item that has expired.
            </summary>
            <remarks>
            This class measures time using Environment.TickCount, which is significantly faster
            than DateTime.Now. However, if the process runs for longer than 24.8 days, the integer
            value will wrap and time measurement will become invalid.
            </remarks>
        </member>
        <member name="P:BitFaster.Caching.Lru.TLruTicksPolicy`2.TimeToLive">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the TLruTicksPolicy class with the specified time to live.
            </summary>
            <param name="timeToLive">The time to live.</param>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.CreateItem(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.Touch(BitFaster.Caching.Lru.TickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.Update(BitFaster.Caching.Lru.TickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.ShouldDiscard(BitFaster.Caching.Lru.TickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.CanDiscard">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.RouteHot(BitFaster.Caching.Lru.TickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.RouteWarm(BitFaster.Caching.Lru.TickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Lru.TLruTicksPolicy`2.RouteCold(BitFaster.Caching.Lru.TickCountLruItem{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Optional`1">
            <summary>
            Represents an optional value.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Optional`1.#ctor">
            <summary>
            Initializes a new instance of the Optional class.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Optional`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the Optional class with the specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:BitFaster.Caching.Optional`1.Value">
            <summary>
            Gets the value of the current Optional object if it has been assigned a valid underlying value.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Optional`1.HasValue">
            <summary>
            Gets a value indicating whether the current Optional object has a valid value of its underlying type.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Optional`1.None">
            <summary>
            Creates an empty Optional.
            </summary>
            <returns>An empty Optional.</returns>
        </member>
        <member name="T:BitFaster.Caching.ReferenceCount`1">
            <summary>
            A reference counting class suitable for use with compare and swap algorithms.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the ReferenceCount class with the specified value.
            Initial count is 1.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:BitFaster.Caching.ReferenceCount`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.ReferenceCount`1.Count">
            <summary>
            Gets the count.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.IncrementCopy">
            <summary>
            Create a copy of the ReferenceCount with the count incremented by 1.
            </summary>
            <returns>A copy of the ReferenceCount with the count incremented by 1.</returns>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.DecrementCopy">
            <summary>
            Create a copy of the ReferenceCount with the count decremented by 1.
            </summary>
            <returns>A copy of the ReferenceCount with the count decremented by 1.</returns>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.Equals(BitFaster.Caching.ReferenceCount{`0})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.op_Equality(BitFaster.Caching.ReferenceCount{`0},BitFaster.Caching.ReferenceCount{`0})">
            <summary>
            Determines whether two ReferenceCount instances are the exact same value via a reference equality check.
            </summary>
            <param name="left">The left ReferenceCount to compare, or null.</param>
            <param name="right">The right ReferenceCount to compare, or null.</param>
            <returns>true if the value of left is the same as the value of right; otherwise, false.</returns>
        </member>
        <member name="M:BitFaster.Caching.ReferenceCount`1.op_Inequality(BitFaster.Caching.ReferenceCount{`0},BitFaster.Caching.ReferenceCount{`0})">
            <summary>
            Determines whether two ReferenceCount instances are different via a reference equality check.
            </summary>
            <param name="left">The left ReferenceCount to compare, or null.</param>
            <param name="right">The right ReferenceCount to compare, or null.</param>
            <returns>true if the value of left is different from the value of right; otherwise, false.</returns>
        </member>
        <member name="T:BitFaster.Caching.Scheduler.BackgroundThreadScheduler">
            <summary>
            Represents a scheduler that handles queuing tasks on a long running background thread.
            </summary>
            <remarks>
            Goals:
            1. Background thread awaits work, does not block a thread pool thread.
            2. Does not allocate when scheduling.
            3. Is faster than Task.Run/TaskFactory.StartNew.
            </remarks>
        </member>
        <member name="F:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.MaxBacklog">
            <summary>
            The maximum number of work items to store.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.#ctor">
            <summary>
            Initializes a new instance of the BackgroundThreadScheduler class.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.Completion">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.IsBackground">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.RunCount">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.LastException">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.Run(System.Action)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Scheduler.BackgroundThreadScheduler.Dispose">
            <summary>
            Terminate the background thread.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Scheduler.ForegroundScheduler">
            <summary>
            Represents a scheduler that runs tasks synchronously.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.ForegroundScheduler.IsBackground">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.ForegroundScheduler.RunCount">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.ForegroundScheduler.LastException">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Scheduler.ForegroundScheduler.Run(System.Action)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Scheduler.IScheduler">
            <summary>
            Represents a scheduler that handles the low-level work of queuing tasks onto threads.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.IScheduler.IsBackground">
            <summary>
            Gets a value indicating whether this scheduler runs tasks in the background.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.IScheduler.RunCount">
            <summary>
            Gets the count of scheduled work items.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Scheduler.IScheduler.Run(System.Action)">
            <summary>
            Queues the specified work to run.
            </summary>
            <param name="action">The work to execute.</param>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.IScheduler.LastException">
            <summary>
            Gets the last exception, if any.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.Scheduler.NullScheduler">
            <summary>
            Represents a scheduler that does no scheduling. Scheduled Tasks will not be run.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.NullScheduler.IsBackground">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.NullScheduler.RunCount">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.NullScheduler.LastException">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Scheduler.NullScheduler.Run(System.Action)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Scheduler.ThreadPoolScheduler">
            <summary>
            Represents a scheduler that handles queuing tasks to execute in the ThreadPool.
            </summary>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.ThreadPoolScheduler.IsBackground">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.ThreadPoolScheduler.RunCount">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.Scheduler.ThreadPoolScheduler.LastException">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.Scheduler.ThreadPoolScheduler.Run(System.Action)">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.Scoped`1">
            <summary>
            A lifetime scope for IDisposable objects stored in a cache. If the object is used in a long
            running operation and disposed by a cache, the scope can create a lifetime that prevents
            the wrapped object from being diposed until the calling code completes.
            </summary>
            <typeparam name="T">The type of scoped value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.Scoped`1.#ctor(`0)">
            <summary>
            Initializes a new Scoped value.
            </summary>
            <param name="value">The value to scope.</param>
        </member>
        <member name="P:BitFaster.Caching.Scoped`1.IsDisposed">
            <summary>
            Gets a value indicating whether the scope is disposed.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.Scoped`1.TryCreateLifetime(BitFaster.Caching.Lifetime{`0}@)">
            <summary>
            Attempts to create a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <param name="lifetime">When this method returns, contains the Lifetime that was created, or the default value of the type if the operation failed.</param>
            <returns>true if the Lifetime was created; otherwise false.</returns>
        </member>
        <member name="M:BitFaster.Caching.Scoped`1.CreateLifetime">
            <summary>
            Creates a lifetime for the scoped value. The lifetime guarantees the value is alive until 
            the lifetime is disposed.
            </summary>
            <returns>A value lifetime.</returns>
            <exception cref="T:System.ObjectDisposedException">The scope is disposed.</exception>
        </member>
        <member name="M:BitFaster.Caching.Scoped`1.Dispose">
            <summary>
            Terminates the scope and disposes the value. Once the scope is terminated, it is no longer
            possible to create new lifetimes for the value.
            </summary>
        </member>
        <member name="T:BitFaster.Caching.ScopedAsyncCache`2">
            <summary>
            A cache decorator for working with Scoped IDisposable values. The Scoped methods (e.g. ScopedGetOrAdd)
            are threadsafe and create lifetimes that guarantee the value will not be disposed until the
            lifetime is disposed.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.#ctor(BitFaster.Caching.IAsyncCache{`0,BitFaster.Caching.Scoped{`1}})">
            <summary>
            Initializes a new instance of the ScopedAsyncCache class with the specified inner cache.
            </summary>
            <param name="cache">The decorated cache.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:BitFaster.Caching.ScopedAsyncCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedAsyncCache`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedAsyncCache`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedAsyncCache`2.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedAsyncCache`2.Keys">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.ScopedGetOrAddAsync(`0,System.Func{`0,System.Threading.Tasks.Task{BitFaster.Caching.Scoped{`1}}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.ScopedTryGet(`0,BitFaster.Caching.Lifetime{`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedAsyncCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.ScopedCache`2">
            <summary>
            A cache decorator for working with Scoped IDisposable values. The Scoped methods (e.g. ScopedGetOrAdd)
            are threadsafe and create lifetimes that guarantee the value will not be disposed until the
            lifetime is disposed.
            </summary>
            <typeparam name="K">The type of keys in the cache.</typeparam>
            <typeparam name="V">The type of values in the cache.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.#ctor(BitFaster.Caching.ICache{`0,BitFaster.Caching.Scoped{`1}})">
            <summary>
            Initializes a new instance of the ScopedCache class with the specified inner cache.
            </summary>
            <param name="cache">The decorated cache.</param>
        </member>
        <member name="P:BitFaster.Caching.ScopedCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedCache`2.Metrics">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedCache`2.Events">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedCache`2.Policy">
            <inheritdoc/>
        </member>
        <member name="P:BitFaster.Caching.ScopedCache`2.Keys">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.AddOrUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.ScopedGetOrAdd(`0,System.Func{`0,BitFaster.Caching.Scoped{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.ScopedGetOrAdd``1(`0,System.Func{`0,``0,BitFaster.Caching.Scoped{`1}},``0)">
            <summary>
            Adds a key/scoped value pair to the cache if the key does not already exist. Returns a lifetime for either 
            the new value, or the existing value if the key already exists.
            </summary>
            <typeparam name="TArg">The type of an argument to pass into valueFactory.</typeparam>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The factory function used to generate a scoped value for the key.</param>
            <param name="factoryArgument"></param>
            <returns>The lifetime for the value associated with the key. The lifetime will be either reference the 
            existing value for the key if the key is already in the cache, or the new value if the key was not in 
            the cache.</returns>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.ScopedTryGet(`0,BitFaster.Caching.Lifetime{`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.TryRemove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.TryUpdate(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:BitFaster.Caching.ScopedCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:BitFaster.Caching.SingletonCache`2">
            <summary>
            Cache a single value for each key, and maintain in memory only the values that have been acquired 
            but not yet released.
            </summary>
            <remarks>Based on LockObjectCache by Mayank Mehta.</remarks>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:BitFaster.Caching.SingletonCache`2.#ctor">
            <summary>
            Initializes a new instance of the SingletonCache class that is empty, has the default concurrency level, 
            has the default initial capacity, and uses the default comparer for the key type.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.SingletonCache`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the SingletonCache that has the specified concurrency level, has the 
            specified initial capacity, and uses the specified IEqualityComparer.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the SingletonCache concurrently.</param>
            <param name="capacity">The initial number of elements that the SingletonCache can contain.</param>
            <param name="comparer">The IEqualityComparer implementation to use when comparing keys.</param>
        </member>
        <member name="M:BitFaster.Caching.SingletonCache`2.Acquire(`0,System.Func{`0,`1})">
            <summary>
            Acquire a singleton value for the specified key. The lifetime guarantees the value is alive and is a singleton 
            for the given key until the lifetime is disposed.
            </summary>
            <param name="key">The key of the item</param>
            <param name="valueFactory">The value factory</param>
            <returns>A value lifetime</returns>
        </member>
        <member name="T:BitFaster.Caching.SingletonCacheExtensions">
            <summary>
            Extension methods for the SingletonCache class.
            </summary>
        </member>
        <member name="M:BitFaster.Caching.SingletonCacheExtensions.Acquire``2(BitFaster.Caching.SingletonCache{``0,``1},``0)">
            <summary>
            Acquire a singleton value for the specified key. The lifetime guarantees the value is alive and is a singleton 
            for the given key until the lifetime is disposed.
            </summary>
            <param name="cache">The cache to use.</param>
            <param name="key">The key of the item</param>
            <returns>A value lifetime</returns>
        </member>
        <member name="F:BitFaster.Caching.TypeProps`1.IsWriteAtomic">
            <summary>Whether T's type can be written atomically (i.e., with no danger of torn reads).</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
    </members>
</doc>
