<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NetMQ</name>
    </assembly>
    <members>
        <member name="T:NetMQ.IBufferPool">
            <summary>
            The IBufferPool interface specifies two methods: Take, and Return.
            These provide for taking byte-array data from a common pool, and returning it.
            </summary>
        </member>
        <member name="M:NetMQ.IBufferPool.Take(System.Int32)">
            <summary>
            Take byte-array storage from the buffer-pool.
            </summary>
            <param name="size">the number of bytes to take</param>
            <returns>a byte-array that comes from the buffer-pool</returns>
        </member>
        <member name="M:NetMQ.IBufferPool.Return(System.Byte[])">
            <summary>
            Return the given byte-array buffer to the common buffer-pool.
            </summary>
            <param name="buffer">the byte-array to return to the buffer-pool</param>
        </member>
        <member name="T:NetMQ.BufferManagerBufferPool">
            <summary>
            This implementation of <see cref="T:NetMQ.IBufferPool"/> uses WCF's <see cref="T:System.ServiceModel.Channels.BufferManager"/>
            class to manage a pool of buffers.
            </summary>
        </member>
        <member name="M:NetMQ.BufferManagerBufferPool.#ctor(System.Int64,System.Int32)">
            <summary>
            Create a new BufferManagerBufferPool with the specified maximum buffer pool size
            and a maximum size for each individual buffer in the pool.
            </summary>
            <param name="maxBufferPoolSize">the maximum size to allow for the buffer pool</param>
            <param name="maxBufferSize">the maximum size to allow for each individual buffer in the pool</param>
            <exception cref="T:System.InsufficientMemoryException">There was insufficient memory to create the requested buffer pool.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Either maxBufferPoolSize or maxBufferSize was less than zero.</exception>
        </member>
        <member name="M:NetMQ.BufferManagerBufferPool.Take(System.Int32)">
            <summary>
            Return a byte-array buffer of at least the specified size from the pool.
            </summary>
            <param name="size">the size in bytes of the requested buffer</param>
            <returns>a byte-array that is the requested size</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">size cannot be less than zero</exception>
        </member>
        <member name="M:NetMQ.BufferManagerBufferPool.Return(System.Byte[])">
            <summary>
            Return the given buffer to this manager pool.
            </summary>
            <param name="buffer">a reference to the buffer being returned</param>
            <exception cref="T:System.ArgumentException">the Length of buffer does not match the pool's buffer length property</exception>
            <exception cref="T:System.ArgumentNullException">the buffer reference cannot be null</exception>
        </member>
        <member name="M:NetMQ.BufferManagerBufferPool.Dispose">
            <summary>
            Release the buffers currently cached in this manager.
            </summary>
        </member>
        <member name="M:NetMQ.BufferManagerBufferPool.Dispose(System.Boolean)">
            <summary>
            Release the buffers currently cached in this manager.
            </summary>
            <param name="disposing">true if managed resources are to be disposed</param>
        </member>
        <member name="T:NetMQ.GCBufferPool">
            <summary>
            This simple implementation of <see cref="T:NetMQ.IBufferPool"/> does no buffer pooling. Instead, it uses regular
            .NET memory management to allocate a buffer each time <see cref="M:NetMQ.GCBufferPool.Take(System.Int32)"/> is called. Unused buffers
            passed to <see cref="M:NetMQ.GCBufferPool.Return(System.Byte[])"/> are simply left for the .NET garbage collector to deal with.
            </summary>
        </member>
        <member name="M:NetMQ.GCBufferPool.Take(System.Int32)">
            <summary>
            Return a newly-allocated byte-array buffer of at least the specified size from the pool.
            </summary>
            <param name="size">the size in bytes of the requested buffer</param>
            <returns>a byte-array that is the requested size</returns>
            <exception cref="T:System.OutOfMemoryException">there is not sufficient memory to allocate the requested memory</exception>
        </member>
        <member name="M:NetMQ.GCBufferPool.Return(System.Byte[])">
            <summary>
            The expectation of an actual buffer-manager is that this method returns the given buffer to the manager pool.
            This particular implementation does nothing.
            </summary>
            <param name="buffer">a reference to the buffer being returned</param>
        </member>
        <member name="M:NetMQ.GCBufferPool.Dispose">
            <summary>
            The expectation of an actual buffer-manager is that the Dispose method will release the buffers currently cached in this manager.
            This particular implementation does nothing.
            </summary>
        </member>
        <member name="M:NetMQ.GCBufferPool.Dispose(System.Boolean)">
            <summary>
            Release the buffers currently cached in this manager (however in this case, this does nothing).
            </summary>
            <param name="disposing">true if managed resources are to be disposed</param>
        </member>
        <member name="T:NetMQ.BufferPool">
            <summary>
            Contains a singleton instance of <see cref="T:NetMQ.IBufferPool"/> used for allocating byte arrays
            for <see cref="T:NetMQ.Msg"/> instances with type <see cref="F:NetMQ.MsgType.Pool"/>.
            </summary>
            <remarks>
            Sending and receiving message frames requires the use of buffers (byte arrays), which are expensive to create and destroy.
            You can use the BufferPool class to pool buffers for reuse, reducing allocation, deallocation and garbage collection.
            <para/>
            The default implementation is <see cref="T:NetMQ.GCBufferPool"/>.
            <list type="bullet">
            <item>Call <see cref="M:NetMQ.BufferPool.SetBufferManagerBufferPool(System.Int64,System.Int32)"/> to replace it with a <see cref="T:NetMQ.BufferManagerBufferPool"/>.</item>
            <item>Call <see cref="M:NetMQ.BufferPool.SetGCBufferPool"/> to reinstate the default <see cref="T:NetMQ.GCBufferPool"/>.</item>
            <item>Call <see cref="M:NetMQ.BufferPool.SetCustomBufferPool(NetMQ.IBufferPool)"/> to substitute a custom implementation for the allocation and
            deallocation of message buffers.</item>
            </list>
            </remarks>
        </member>
        <member name="M:NetMQ.BufferPool.SetGCBufferPool">
            <summary>
            Set BufferPool to use the <see cref="T:NetMQ.GCBufferPool"/> (which it does by default).
            </summary>
        </member>
        <member name="M:NetMQ.BufferPool.SetBufferManagerBufferPool(System.Int64,System.Int32)">
            <summary>
            Set BufferPool to use the <see cref="T:NetMQ.BufferManagerBufferPool"/> to manage the buffer-pool.
            </summary>
            <param name="maxBufferPoolSize">the maximum size to allow for the buffer pool</param>
            <param name="maxBufferSize">the maximum size to allow for each individual buffer in the pool</param>
            <exception cref="T:System.InsufficientMemoryException">There was insufficient memory to create the requested buffer pool.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Either maxBufferPoolSize or maxBufferSize was less than zero.</exception>
        </member>
        <member name="M:NetMQ.BufferPool.SetCustomBufferPool(NetMQ.IBufferPool)">
            <summary>
            Set BufferPool to use the specified IBufferPool implementation to manage the buffer-pool.
            </summary>
            <param name="bufferPool">the implementation of <see cref="T:NetMQ.IBufferPool"/> to use</param>
        </member>
        <member name="M:NetMQ.BufferPool.Take(System.Int32)">
            <summary>
            Allocate a buffer of at least <paramref name="size"/> bytes from the current <see cref="T:NetMQ.IBufferPool"/>.
            </summary>
            <param name="size">The minimum size required, in bytes.</param>
            <returns>A byte array having at least <paramref name="size"/> bytes.</returns>
        </member>
        <member name="M:NetMQ.BufferPool.Return(System.Byte[])">
            <summary>
            Returns <paramref name="buffer"/> to the <see cref="T:NetMQ.IBufferPool"/>.
            </summary>
            <param name="buffer">The byte array to be returned to the pool.</param>
        </member>
        <member name="T:NetMQ.Core.Address">
            <summary>
            Class Address contains a specification of a protocol and an MqEndPoint.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Address.InProcProtocol">
            <summary>
            The string-literal "inproc"
            - this denotes in-process, or inter-thread, communication.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Address.TcpProtocol">
            <summary>
            The string-literal "tcp"
            - this denotes TCP communication over the network.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Address.IpcProtocol">
            <summary>
            The string-literal "ipc"
            - this denotes inter-process communication, which on NetMQ is exactly the same as TCP.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Address.PgmProtocol">
            <summary>
            The string-literal "pgm"
            - this denotes the Pragmatic General Multicast (PGM) reliable multicast protocol.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Address.EpgmProtocol">
            <summary>
            The string-literal "epgm"
            - this denotes the Encapsulated PGM protocol.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Address.IZAddress">
            <summary>
            Interface IZAddress specifies that Resolve and property Address must be implemented.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Address.#ctor(System.String,System.String)">
            <summary>
            Create a new Address instance with the given protocol and text expression of an address.
            </summary>
            <param name="protocol">the protocol of this Address - as in tcp, ipc, pgm</param>
            <param name="address">a text representation of the address</param>
        </member>
        <member name="M:NetMQ.Core.Address.#ctor(System.Net.EndPoint)">
            <summary>
            Create a new Address instance based upon the given endpoint, assuming a protocol of tcp.
            </summary>
            <param name="endpoint">the subclass of EndPoint to base this Address upon</param>
        </member>
        <member name="T:NetMQ.Core.Command">
            <summary>
            Defines a command sent between threads.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Command.#ctor(NetMQ.Core.ZObject,NetMQ.Core.CommandType,System.Object)">
            <summary>
            Create a new Command object for the given destination, type, and optional argument.
            </summary>
            <param name="destination">a ZObject that denotes the destination for this command</param>
            <param name="type">the CommandType of the new command</param>
            <param name="arg">an Object to comprise the argument for the command (optional)</param>
        </member>
        <member name="P:NetMQ.Core.Command.Destination">
            <summary>The destination to which the command should be applied.</summary>
        </member>
        <member name="P:NetMQ.Core.Command.CommandType">
            <summary>The type of this command.</summary>
        </member>
        <member name="P:NetMQ.Core.Command.Arg">
            <summary>
            Get the argument to this command.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Command.ToString">
            <summary>
            Override of ToString, which returns a string in the form [ command-type, destination ].
            </summary>
            <returns>a string that denotes the command-type and destination</returns>
        </member>
        <member name="T:NetMQ.Core.CommandType">
            <summary>
            Enumeration of possible <see cref="T:NetMQ.Core.Command"/> types.
            </summary>
            <remarks>
            The value of <see cref="P:NetMQ.Core.Command.CommandType"/> denotes what action
            the command will perform.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.CommandType.Stop">
            <summary>
            Sent to I/O thread to let it know that it should
            terminate itself.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Plug">
            <summary>
            Sent to I/O object to make it register with its I/O thread
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Own">
            <summary>
            Sent to socket to let it know about the newly created object.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Attach">
            <summary>
            Attach the engine to the session. If engine is NULL, it informs
            session that the connection has failed.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Bind">
            <summary>
            Sent from session to socket to establish pipe(s) between them.
            Caller must have used inc_seqnum before sending the command.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.ActivateRead">
            <summary>
            Sent by pipe writer to inform dormant pipe reader that there
            are messages in the pipe.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.ActivateWrite">
            <summary>
            Sent by pipe reader to inform pipe writer how many
            messages it has read so far.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Hiccup">
            <summary>
            Sent by pipe reader to writer after creating a new inpipe.
            The parameter is actually of type pipe_t::upipe_t, however,
            its definition is private so we'll have to do with void*.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.PipeTerm">
            <summary>
            Sent by pipe reader to pipe writer to ask it to terminate
            its end of the pipe.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.PipeTermAck">
            <summary>
            Pipe writer acknowledges pipe_term command.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.TermReq">
            <summary>
            Sent by I/O object to the socket to request the shutdown of
            the I/O object.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Term">
            <summary>
            Sent by socket to I/O object to start its shutdown.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.TermAck">
            <summary>
            Sent by I/O object to the socket to acknowledge it has
            shut down.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Reap">
            <summary>
            Transfers the ownership of the closed socket
            to the reaper thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Reaped">
            <summary>
            Closed socket notifies the reaper that it's already deallocated.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.Done">
            <summary>
            Sent by reaper thread to the term thread when all the sockets
            have successfully been deallocated.
            </summary>
        </member>
        <member name="F:NetMQ.Core.CommandType.ForceStop">
            <summary>
            Send to reaper to stop the reaper immediatly
            </summary>
        </member>
        <member name="T:NetMQ.Core.Config">
            <summary>
            This class exists to hold constant values that comprise the internal configuration of the messaging system.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.MessagePipeGranularity">
            <summary>
            Number of new messages in message pipe needed to trigger new memory
            allocation. Setting this parameter to 256 decreases the impact of
            memory allocation by approximately 99.6%
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.CommandPipeGranularity">
            <summary>
            Commands in pipe per allocation event.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.InboundPollRate">
            <summary>
            Determines how often does socket poll for new commands when it
            still has unprocessed messages to handle. Thus, if it is set to 100,
            socket will process 100 inbound messages before doing the poll.
            If there are no unprocessed messages available, poll is done
            immediately. Decreasing the value trades overall latency for more
            real-time behaviour (less latency peaks).
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.InBatchSize">
            <summary>
            Maximal batching size for engines with receiving functionality.
            So, if there are 10 messages that fit into the batch size, all of
            them may be read by a single 'recv' system call, thus avoiding
            unnecessary network stack traversals.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.OutBatchSize">
            <summary>
            Maximal batching size for engines with sending functionality.
            So, if there are 10 messages that fit into the batch size, all of
            them may be written by a single 'send' system call, thus avoiding
            unnecessary network stack traversals.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.MaxWatermarkDelta">
            <summary>
            Maximal delta between high and low watermark.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.MaxIOEvents">
            <summary>
            Maximum number of events the I/O thread can process in one go.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.MaxCommandDelay">
            <summary>
            Maximal delay to process command in API thread (in CPU ticks).
            3,000,000 ticks equals to 1 - 2 milliseconds on current CPUs.
            Note that delay is only applied when there is continuous stream of
            messages to process. If not so, commands are processed immediately.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.ClockPrecision">
            <summary>
            Low-precision clock precision in CPU ticks. 1ms. Value of 1000000
            should be OK for CPU frequencies above 1GHz. If should work
            reasonably well for CPU frequencies above 500MHz. For lower CPU
            frequencies you may consider lowering this value to get best
            possible latencies.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.PgmMaxTPDU">
            <summary>
            Maximum transport data unit size for PGM (TPDU).
            </summary>
        </member>
        <member name="F:NetMQ.Core.Config.SignalerPort">
            <summary>
            On some OSes the signaler has to be emulated using a TCP
            connection. In such cases following port is used.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Ctx">
            <summary>
            Objects of class Ctx are intended to encapsulate all of the global state
            associated with the NetMQ library. This contains the sockets, and manages interaction
            between them.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Ctx.Endpoint">
            <summary>
            Information associated with inproc endpoint. Note that endpoint options
            are registered as well so that the peer can access them without a need
            for synchronisation, handshaking or similar.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Ctx.Endpoint.#ctor(NetMQ.Core.SocketBase,NetMQ.Core.Options)">
            <summary>
            Create a new Endpoint with the given socket.
            </summary>
            <param name="socket">the socket for this new Endpoint</param>
            <param name="options">the Options to assign to this new Endpoint</param>
        </member>
        <member name="P:NetMQ.Core.Ctx.Endpoint.Socket">
            <summary>
            Get the socket associated with this Endpoint.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Ctx.Endpoint.Options">
            <summary>
            Get the Options of this Endpoint.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_sockets">
            <summary>
            Sockets belonging to this context. We need the list so that
            we can notify the sockets when zmq_term() is called. The sockets
            will return ETERM then.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_emptySlots">
            <summary>
            List of unused thread slots.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_starting">
            <summary>
            If true, zmq_init has been called but no socket has been created
            yet. Launching of I/O threads is delayed.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_terminating">
            <summary>
            If true, zmq_term was already called.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_slotSync">
            <summary>
            This object is for synchronisation of accesses to global slot-related data:
            sockets, empty_slots, terminating. It also synchronises
            access to zombie sockets as such (as opposed to slots) and provides
            a memory barrier to ensure that all CPU cores see the same data.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_reaper">
            <summary>
            The reaper thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_ioThreads">
            <summary>
            List of I/O threads.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_slotCount">
            <summary>
            Length of the mailbox-array.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_slots">
            <summary>
            Array of pointers to mailboxes for both application and I/O threads.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_termMailbox">
            <summary>
            Mailbox for zmq_term thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_endpoints">
            <summary>
            Dictionary containing the inproc endpoints within this context.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_endpointsSync">
            <summary>
            This object provides synchronisation of access to the list of inproc endpoints.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.s_maxSocketId">
            <summary>
            The highest socket-id that has been assigned thus far.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_maxSockets">
            <summary>
            The maximum number of sockets that can be opened at the same time.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_ioThreadCount">
            <summary>
            The number of I/O threads to launch.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.m_optSync">
            <summary>
            This object is used to synchronize access to context options.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.TermTid">
            <summary>
            The thread-id for the termination (the equivalent of the zmq_term) thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Ctx.ReaperTid">
            <summary>
            This is the thread-id to assign to the Reaper (value is 1).
            </summary>
        </member>
        <member name="M:NetMQ.Core.Ctx.Terminate(System.Boolean)">
            <summary>
            This function is called when user invokes zmq_term. If there are
            no more sockets open it'll cause all the infrastructure to be shut
            down. If there are open sockets still, the deallocation happens
            after the last one is closed.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Ctx.CreateSocket(NetMQ.ZmqSocketType)">
            <summary>
            Create and return a new socket of the given type, and initialize this Ctx if this is the first one.
            </summary>
            <param name="type">the type of socket to create</param>
            <returns>the newly-created socket</returns>
            <exception cref="T:NetMQ.TerminatingException">Cannot create new socket while terminating.</exception>
            <exception cref="T:NetMQ.NetMQException">Maximum number of sockets reached.</exception>
            <exception cref="T:NetMQ.TerminatingException">The context (Ctx) must not be already terminating.</exception>
        </member>
        <member name="M:NetMQ.Core.Ctx.DestroySocket(NetMQ.Core.SocketBase)">
            <summary>
            Destroy the given socket - which means to remove it from the list of active sockets,
            and add it to the list of unused sockets to be terminated.
            </summary>
            <param name="socket">the socket to destroy</param>
            <remarks>
            If this was the last socket, then stop the reaper.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Ctx.GetReaper">
            <summary>
            Returns reaper thread object.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Ctx.SendCommand(System.Int32,NetMQ.Core.Command)">
            <summary>
            Send a command to the given destination thread.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Ctx.ChooseIOThread(System.Int64)">
            <summary>
            Returns the <see cref="T:NetMQ.Core.IOThread"/> that is the least busy at the moment.
            </summary>
            <paramref name="affinity">Which threads are eligible (0 = all).</paramref>
            <returns>The least busy thread, or <c>null</c> if none is available.</returns>
        </member>
        <member name="M:NetMQ.Core.Ctx.RegisterEndpoint(System.String,NetMQ.Core.Ctx.Endpoint)">
            <summary>
            Save the given address and Endpoint within our internal list.
            This is used for management of inproc endpoints.
            </summary>
            <param name="address">the textual name to give this endpoint</param>
            <param name="endpoint">the Endpoint to remember</param>
            <returns>true if the given address was NOT already registered</returns>
        </member>
        <member name="M:NetMQ.Core.Ctx.UnregisterEndpoint(System.String,NetMQ.Core.SocketBase)">
            <summary>
            Un-register the given address/socket, by removing it from the contained list of endpoints.
            </summary>
            <param name="address">the (string) address denoting the endpoint to unregister</param>
            <param name="socket">the socket associated with that endpoint</param>
            <returns>true if the endpoint having this address and socket is found, false otherwise</returns>
        </member>
        <member name="M:NetMQ.Core.Ctx.UnregisterEndpoints(NetMQ.Core.SocketBase)">
            <summary>
            Remove from the list of endpoints, all endpoints that reference the given socket.
            </summary>
            <param name="socket">the socket to remove all references to</param>
        </member>
        <member name="M:NetMQ.Core.Ctx.FindEndpoint(System.String)">
            <summary>
            Return the EndPoint that has the given address, and increments the seqnum of the associated socket.
            </summary>
            <param name="addr">the (string) address to match against the endpoints</param>
            <returns>the Endpoint that was found</returns>
            <exception cref="T:NetMQ.EndpointNotFoundException">The given address was not found in the list of endpoints.</exception>
            <remarks>
            By calling this method, the socket associated with that returned EndPoint has it's Seqnum incremented,
            in order to prevent it from being de-allocated before a command can be sent to it.
            </remarks>
        </member>
        <member name="T:NetMQ.Core.ErrorHelper">
            <summary>
            Class ErrorHelper provides one static method - ToErrorCode, for converting a SocketError to the equivalent ErrorCode.
            </summary>
        </member>
        <member name="M:NetMQ.Core.ErrorHelper.ToErrorCode(System.Net.Sockets.SocketError)">
            <summary>
            Return the ErrorCode that is the closest equivalent to the given SocketError.
            </summary>
            <param name="error">the SocketError to convert from</param>
            <returns>an ErrorCode that corresponds to the given SocketError</returns>
        </member>
        <member name="T:NetMQ.Core.IMsgSink">
            <summary>
            Interface IMsgSink mandates a PushMsg( Msg ) method.
            </summary>
        </member>
        <member name="M:NetMQ.Core.IMsgSink.PushMsg(NetMQ.Msg@)">
            <summary>
            Deliver a message. Return true if successful; false otherwise.
            This function takes ownership of the passed message.
            </summary>
            <param name="msg">the message (of type Msg) to deliver</param>
        </member>
        <member name="T:NetMQ.Core.IMsgSource">
            <summary>
            Classes that implement IMsgSource are able to fetch a message, with the method: PullMsg.
            </summary>
        </member>
        <member name="M:NetMQ.Core.IMsgSource.PullMsg(NetMQ.Msg@)">
            <summary>
            Fetch a message.
            If successful - returns true and writes the message instance to the msg argument.
            If not successful - return false and write null to the msg argument.
            </summary>
            <param name="msg">the Msg to write the fetched message into</param>
            <returns>true if successful - and writes the message to the msg argument</returns>
        </member>
        <member name="T:NetMQ.Core.IOObject">
            <summary>
            Simple base class for objects that live in I/O threads.
            It makes communication with the poller object easier and
            makes defining unneeded event handlers unnecessary.
            </summary>
        </member>
        <member name="M:NetMQ.Core.IOObject.#ctor(NetMQ.Core.IOThread)">
            <summary>
            Create a new IOObject object and plug it into the given IOThread.
            </summary>
            <param name="ioThread">the IOThread to plug this new IOObject into.</param>
        </member>
        <member name="M:NetMQ.Core.IOObject.Plug(NetMQ.Core.IOThread)">
            <summary>
            "Plug in" this IOObject to the given IOThread, - ie associate this with the specified IOThread.
            </summary>
            <param name="ioThread">the IOThread for this object to live in</param>
            <remarks>
            When migrating an object from one I/O thread to another, first
            unplug it, then migrate it, then plug it to the new thread.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.IOObject.Unplug">
            <summary>
            "Un-Plug" this IOObject from its current IOThread, and set its handler to null.
            </summary>
            <remarks>
            When migrating an object from one I/O thread to another, first
            unplug it, then migrate it, then plug it to the new thread.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.IOObject.AddSocket(AsyncIO.AsyncSocket)">
            <summary>
            Add the given socket to the Proactor.
            </summary>
            <param name="socket">the AsyncSocket to add</param>
        </member>
        <member name="M:NetMQ.Core.IOObject.RemoveSocket(AsyncIO.AsyncSocket)">
            <summary>
            Remove the given socket from the Proactor.
            </summary>
            <param name="socket">the AsyncSocket to remove</param>
        </member>
        <member name="M:NetMQ.Core.IOObject.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is called when a message receive operation has been completed. This forwards it on to the handler's InCompleted method.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
        </member>
        <member name="M:NetMQ.Core.IOObject.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is called when a message Send operation has been completed. This forwards it on to the handler's OutCompleted method.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
        </member>
        <member name="M:NetMQ.Core.IOObject.TimerEvent(System.Int32)">
            <summary>
            This is called when the timer expires.
            </summary>
            <param name="id">an integer used to identify the timer</param>
        </member>
        <member name="F:NetMQ.Core.IOThread.m_mailbox">
            <summary>
            I/O thread accesses incoming commands via this mailbox.
            </summary>
        </member>
        <member name="F:NetMQ.Core.IOThread.m_proactor">
            <summary>
            I/O multiplexing is performed using a poller object.
            </summary>
        </member>
        <member name="M:NetMQ.Core.IOThread.#ctor(NetMQ.Core.Ctx,System.Int32)">
            <summary>
            Create a new IOThread object within the given context (Ctx) and thread.
            </summary>
            <param name="ctx">the Ctx (context) for this thread to live within</param>
            <param name="threadId">the integer thread-id for this new IOThread</param>
        </member>
        <member name="T:NetMQ.Core.IPollEvents">
            <summary>
            Classes that implement IPollEvents provide two methods (InEvent and OutEvent) that are invoked when ready for reading or writing.
            </summary>
        </member>
        <member name="M:NetMQ.Core.IPollEvents.InEvent">
            <summary>
            Called by the I/O thread when the file descriptor is ready for reading.
            </summary>
        </member>
        <member name="M:NetMQ.Core.IPollEvents.OutEvent">
            <summary>
            Called by the I/O thread when the file descriptor is ready for writing.
            </summary>
        </member>
        <member name="T:NetMQ.Core.IProactorEvents">
            <summary>
            This is an ITimerEvent, with InCompleted and OutCompleted callback-methods,
            used for implementing a Proactor pattern.
            </summary>
        </member>
        <member name="M:NetMQ.Core.IProactorEvents.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This is the "Input-Completed" method - called by the I/O-thread when the file descriptor is ready for reading.
            </summary>
            <param name="socketError">this is set to any socket-error that has occurred</param>
            <param name="bytesTransferred">the number of bytes that are now ready to be read</param>
        </member>
        <member name="M:NetMQ.Core.IProactorEvents.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This is the "Output-Completed" method - called by the I/O thread when the file descriptor is ready for writing.
            </summary>
            <param name="socketError">this is set to any socket-error that has occurred</param>
            <param name="bytesTransferred">the number of bytes that are now ready to be written</param>
        </member>
        <member name="T:NetMQ.Core.ITimerEvent">
            <summary>
            The ITimerEvent interface mandates a TimerEvent( int id ) method,
            that is called with an id-value when the timer expires.
            </summary>
        </member>
        <member name="M:NetMQ.Core.ITimerEvent.TimerEvent(System.Int32)">
            <summary>
            This is called when the timer expires.
            </summary>
            <param name="id">an integer used to identify the timer</param>
        </member>
        <member name="F:NetMQ.Core.IOThreadMailbox.m_sync">
            <summary>
            There's only one thread receiving from the mailbox, but there
            is arbitrary number of threads sending. Given that ypipe requires
            synchronised access on both of its endpoints, we have to synchronize
            the sending side.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Mailbox.m_commandPipe">
            <summary>
            The pipe to store actual commands.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Mailbox.m_signaler">
            <summary>
            Signaler to pass signals from writer thread to reader thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Mailbox.m_sync">
            <summary>
            There's only one thread receiving from the mailbox, but there
            is an arbitrary number of threads sending. Given that <see cref="T:NetMQ.Core.YPipe`1"/> requires
            synchronised access on both of its endpoints, we have to synchronize
            the sending side.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Mailbox.m_active">
            <summary>
            True if the underlying pipe is active, ie. when we are allowed to
            read commands from it.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Mailbox.#ctor(System.String)">
            <summary>
            Create a new Mailbox with the given name.
            </summary>
            <param name="name">the name to give this new Mailbox</param>
        </member>
        <member name="P:NetMQ.Core.Mailbox.Handle">
            <summary>
            Get the socket-handle contained by the Signaler.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Mailbox.Send(NetMQ.Core.Command)">
            <summary>
            Send the given Command out across the command-pipe.
            </summary>
            <param name="cmd">the Command to send</param>
        </member>
        <member name="M:NetMQ.Core.Mailbox.TryRecv(System.Int32,NetMQ.Core.Command@)">
            <summary>
            Receive and return a Command from the command-pipe.
            </summary>
            <param name="timeout">how long to wait for a command (in milliseconds) before returning</param>
            <param name="command"></param>
        </member>
        <member name="M:NetMQ.Core.Mailbox.Close">
            <summary>
            Close the contained Signaler.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Options">
            <summary>
            Class Options is essentially a container for socket-related option-settings.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Options.#ctor">
            <summary>
            Create a new Options object with all default values.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.Affinity">
            <summary>
            Get or set the I/O-thread affinity.
            The default value is 0.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.Backlog">
            <summary>
            Maximum backlog for pending connections.
            The default value is 100.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.DelayAttachOnConnect">
            <summary>
            Get or set whether connecting pipes are not attached immediately, meaning a send()
            on a socket with only connecting pipes would block.
            The default value is false.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.DelayOnClose">
            <summary>
            If true, session reads all the pending messages from the pipe and
            sends them to the network when socket is closed.
            The default value is true.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.DelayOnDisconnect">
            <summary>
            If true, socket reads all the messages from the pipe and delivers
            them to the user when the peer terminates.
            The default value is true.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.Endian">
            <summary>
            Get or set the Endian-ness, which indicates whether the most-significant bits are placed higher or lower in memory.
            The default value is Endianness.Big.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.Filter">
            <summary>
            If true, (X)SUB socket should filter the messages. If false (which is the default), it should not.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.Identity">
            <summary>
            Get or set the byte-array that represents the Identity.
            The initial value is null.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.IdentitySize">
            <summary>
            Get or set the size of the socket-identity byte-array.
            The initial value is 0, until the Identity property is set.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.IPv4Only">
            <summary>
            Get or set whether this allows the use of IPv4 sockets only.
            If true (the default), it will not be possible to communicate with IPv6-only hosts.
            If false, the socket can connect to and accept connections from both IPv4 and IPv6 hosts.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.LastEndpoint">
            <summary>
            Get or set the last socket endpoint resolved URI
            The initial value is null.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.Linger">
            <summary>
            Get or set the Linger time, in milliseconds.
            The default value is -1; The XSub ctor sets this to 0.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.MaxMessageSize">
            <summary>
            Get or set the maximum size of message to handle.
            The default value is -1, which indicates no limit.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.MulticastHops">
            <summary>
            Sets the time-to-live field in every multicast packet sent.
            The default value is 1.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.Rate">
            <summary>
            Get or set the maximum transfer rate [Kb/s]. The default is 100 Kb/s.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.RawSocket">
            <summary>
            If true, router socket accepts non-zmq tcp connections
            The default value is false, except the Stream ctor initialises this to true.
            Setting this to true changes RecvIdentity to false.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.RecvIdentity">
            <summary>
            If true, the identity message is forwarded to the socket.
            The default value is false.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.ReconnectIvl">
            <summary>
            Get or set the minimum interval between attempts to reconnect, in milliseconds.
            The default is 100 ms
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.ReconnectIvlMax">
            <summary>
            Get or set the maximum interval between attempts to reconnect, in milliseconds.
            The default is 0 (unused).
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.RecoveryIvl">
            <summary>
            Get or set the recovery time interval [ms]. The default is 10 seconds.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.SendBuffer">
            <summary>
            SO_SNDBUF and SO_RCVBUF to be passed to underlying transport sockets.
            The initial value is 0.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.ReceiveBuffer">
            <summary>
            Get or set the size of the receive-buffer.
            The initial value is 0.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.SendHighWatermark">
            <summary>
            Get or set the high-water marks for message pipes.
            The default value is 1000.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.ReceiveHighWatermark">
            <summary>
            Get or set the high-water mark for message reception.
            The default value is 1000.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.SendLowWatermark">
            <summary>
            The low-water mark for message transmission.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.ReceiveLowWatermark">
            <summary>
            The low-water mark for message reception.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.SendTimeout">
            <summary>
            Get or set the timeout for send operations for this socket.
            The default value is -1, which means no timeout.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.SocketId">
            <summary>
            Get or set the ID of the socket.
            The default value is 0.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.SocketType">
            <summary>
            Get or set the type of socket (ZmqSocketType).
            The default value is ZmqSocketType.None.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.TcpKeepalive">
            <summary>
            TCP keep-alive settings.
            Defaults to -1 = do not change socket options
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.TcpKeepaliveCnt">
            <summary>
            Get or set the TCP Keep-Alive Count.
            The default value is -1.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.TcpKeepaliveIdle">
            <summary>
            Get or set the TCP Keep-Alive interval to use when at idle.
            The default value is -1.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.TcpKeepaliveIntvl">
            <summary>
            Get or set the TCP Keep-Alive Interval
            The default value is -1.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.DisableTimeWait">
            <summary>
            Disable TIME_WAIT tcp state when client disconnect.
            The default value is false.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Options.PgmMaxTransportServiceDataUnitLength">
            <summary>
            Controls the maximum datagram size for PGM.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Options.SetSocketOption(NetMQ.Core.ZmqSocketOption,System.Object)">
            <summary>
            Assign the given optionValue to the specified option.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to set</param>
            <param name="optionValue">an Object that is the value to set that option to</param>
            <exception cref="T:NetMQ.InvalidException">The option and optionValue must be valid.</exception>
        </member>
        <member name="M:NetMQ.Core.Options.GetSocketOption(NetMQ.Core.ZmqSocketOption)">
            <summary>
            Get the value of the specified option.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to get</param>
            <returns>an Object that is the value of that option</returns>
            <exception cref="T:NetMQ.InvalidException">A valid option must be specified.</exception>
        </member>
        <member name="T:NetMQ.Core.Own">
            <summary>
            Base class for objects forming a part of ownership hierarchy.
            It handles initialisation and destruction of such objects.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Own.m_options">
            <summary>
            The Options of this Own.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Own.m_terminating">
            <summary>
            True if termination was already initiated. If so, we can destroy
            the object if there are no more child objects or pending term acks.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Own.m_sentSeqnum">
            <summary>
            Sequence number of the last command sent to this object.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Own.m_processedSeqnum">
            <summary>
            Sequence number of the last command processed by this object.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Own.m_owner">
            <summary>
            Socket owning this object. It's responsible for shutting down
            this object.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Own.m_owned">
            <summary>
            List of all objects owned by this socket. We are responsible
            for deallocating them before we quit.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Own.m_termAcks">
            <summary>
            Number of events we have to get before we can destroy the object.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Own.#ctor(NetMQ.Core.Ctx,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NetMQ.Core.Own" /> class that is running on a thread outside of 0MQ infrastructure.
            </summary>
            <param name="parent">The parent context.</param>
            <param name="threadId">The thread id.</param>
            <remarks>
            Note that the owner is unspecified in the constructor. It'll be assigned later on using <see cref="M:NetMQ.Core.Own.SetOwner(NetMQ.Core.Own)"/>
            when the object is plugged in.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Own.#ctor(NetMQ.Core.IOThread,NetMQ.Core.Options)">
            <summary>
            Initializes a new instance of the <see cref="T:NetMQ.Core.Own" /> class that is running within I/O thread.
            </summary>
            <param name="ioThread">The I/O thread.</param>
            <param name="options">The options.</param>
            <remarks>
            Note that the owner is unspecified in the constructor. It'll be assigned later on using <see cref="M:NetMQ.Core.Own.SetOwner(NetMQ.Core.Own)"/>
            when the object is plugged in.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Own.Destroy">
            <summary>
            Eliminate any contained resources that need to have this explicitly done.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Own.ProcessDestroy">
            <summary>
            A place to hook in when physical destruction of the object is to be delayed.
            Unless overridden, this simply calls Destroy.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Own.SetOwner(NetMQ.Core.Own)">
            <summary>
            Set the owner of *this* Own object, to be the given owner.
            </summary>
            <param name="owner">the Own object to be our new owner</param>
        </member>
        <member name="M:NetMQ.Core.Own.IncSeqnum">
            <summary>
            When another owned object wants to send a command to this object it calls this function
            to let it know it should not shut down before the command is delivered.
            </summary>
            <remarks>
            This function may be called from a different thread!
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Own.LaunchChild(NetMQ.Core.Own)">
            <summary>
            Launch the supplied object and become its owner.
            </summary>
            <param name="obj">The object to be launched.</param>
        </member>
        <member name="M:NetMQ.Core.Own.TermChild(NetMQ.Core.Own)">
            <summary>
            Terminate owned object.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Own.ProcessTermReq(NetMQ.Core.Own)">
            <summary>
            Process a termination-request for the given Own obj,
            removing it from the listed of owned things.
            </summary>
            <param name="obj">the Own object to remove and terminate</param>
        </member>
        <member name="M:NetMQ.Core.Own.ProcessOwn(NetMQ.Core.Own)">
            <summary>
            Add the given Own object to the list of owned things.
            </summary>
            <param name="obj">the Own object to add to our list</param>
            <remarks>
            If *this* Own is already terminating, then send a request to the given Own obj
            to terminate itself.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Own.Terminate">
            <summary>
            Ask owner object to terminate this object. It may take a while actual termination is started.
            </summary>
            <remarks>
            This function should not be called more than once.
            </remarks>
        </member>
        <member name="P:NetMQ.Core.Own.IsTerminating">
            <summary>
            Returns true if the object is in process of termination.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Own.ProcessTerm(System.Int32)">
            <summary>
            Send termination requests to all of the owned objects, and then runs the termination process.
            </summary>
            <param name="linger">the linger time, in milliseconds</param>
            <remarks>
            Termination handler is protected rather than private so that it can be intercepted by the derived class.
            This is useful to add custom steps to the beginning of the termination process.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Own.RegisterTermAcks(System.Int32)">
            <summary>
            Add the given number to the termination-acknowledgement count.
            </summary>
            <remarks>
            The methods RegisterTermAcks and <see cref="M:NetMQ.Core.Own.UnregisterTermAck"/> are used to wait for arbitrary events before
            terminating. Just add the number of events to wait for, and when the event occurs - call <see cref="M:NetMQ.Core.Own.UnregisterTermAck"/>.
            When the number of pending termination-acknowledgements reaches zero, this object will be deallocated.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Own.UnregisterTermAck">
            <summary>
            Decrement the termination-acknowledgement count, and if it reaches zero
            then send a termination-ack to the owner.
            </summary>
            <remarks>
            The methods <see cref="M:NetMQ.Core.Own.RegisterTermAcks(System.Int32)"/> and UnregisterTermAck are used to wait for arbitrary events before
            terminating. Just add the number of events to wait for, and when the event occurs - call UnregisterTermAck.
            When the number of pending termination-acknowledgements reaches zero, this object will be deallocated.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Own.ProcessTermAck">
            <summary>
            Process the first termination-acknowledgement.
            Unless this is overridden, it simply calls <see cref="M:NetMQ.Core.Own.UnregisterTermAck"/>.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Own.CheckTermAcks">
            <summary>
            If terminating, and we've already worked through the Seq-nums that were sent,
            then send a termination-ack to the owner (if there is one) and destroy itself.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Patterns.Dealer">
            <summary>
            A Dealer socket is a SocketBase that is used as the parent-class of the Req socket.
            It provides for a pre-fetched Msg, and skips identity-messages.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Patterns.Dealer.DealerSession">
            <summary>
            A DealerSession is a SessionBase subclass that is contained within the Dealer class.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.DealerSession.#ctor(NetMQ.Core.IOThread,System.Boolean,NetMQ.Core.SocketBase,NetMQ.Core.Options,NetMQ.Core.Address)">
            <summary>
            Create a new DealerSession (which is just a SessionBase).
            </summary>
            <param name="ioThread">the I/O-thread to associate this with</param>
            <param name="connect"></param>
            <param name="socket"></param>
            <param name="options"></param>
            <param name="addr"></param>
        </member>
        <member name="F:NetMQ.Core.Patterns.Dealer.m_fairQueueing">
            <summary>
            Messages are fair-queued from inbound pipes. And load-balanced to
            the outbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Dealer.m_prefetched">
            <summary>
            Have we prefetched a message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Dealer.m_prefetchedMsg">
            <summary>
            The Msg that we have pre-fetched.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.#ctor(NetMQ.Core.Ctx,System.Int32,System.Int32)">
            <summary>
            Create a new Dealer socket that holds the prefetched message.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.Destroy">
            <summary>
            Destroy this Dealer-socket and close out any pre-fetched Msg.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.XRecv(NetMQ.Msg@)">
            <summary>
            For a Dealer socket: If there's a pre-fetched message, snatch that.
            Otherwise, dump any identity messages and get the first non-identity message,
            or return false if there are no messages available.
            </summary>
            <param name="msg">a Msg to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.ReceiveInternal(NetMQ.Msg@)">
            <summary>
            If there's a pre-fetched message, snatch that.
            Otherwise, dump any identity messages and get the first non-identity message,
            or return false if there are no messages available.
            </summary>
            <param name="msg">a Msg to receive the message into</param>
            <returns>false if there were no messages to receive</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.XHasIn">
            <summary>
            If there is a message available and one has not been pre-fetched yet,
            preserve that message as our pre-fetched one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This gets called by the WriteActivated method
            and gets overridden by the different sockets
            to provide their own concrete implementation.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Dealer.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pair.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pair.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pair.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket
            - however in the case of Pair, this does nothing.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pair.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket,
            however in the case of this Pair socket - this does nothing.
            This method gets called by the WriteActivated method.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pair.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pair.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="T:NetMQ.Core.Patterns.Peer">
            <summary>
            A Router is a subclass of SocketBase
            </summary>
        </member>
        <member name="T:NetMQ.Core.Patterns.Peer.Outpipe">
            <summary>
            An instance of class Outpipe contains a Pipe and a boolean property Active.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Peer.m_fairQueueing">
            <summary>
            Fair queueing object for inbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Peer.m_prefetchedMsg">
            <summary>
            Holds the prefetched message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Peer.m_outpipes">
            <summary>
            Outbound pipes indexed by the peer IDs.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Peer.m_currentOut">
            <summary>
            The pipe we are currently writing to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Peer.m_receivingState">
            <summary>
            State of the recv operation
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Peer.m_sendingState">
            <summary>
            State of the sending operation
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Peer.m_nextPeerId">
            <summary>
            Peer ID are generated. It's a simple increment and wrap-over
            algorithm. This value is the next ID to use (if not used already).
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Peer.#ctor(NetMQ.Core.Ctx,System.Int32,System.Int32)">
            <summary>
            Create a new Router instance with the given parent-Ctx, thread-id, and socket-id.
            </summary>
            <param name="parent">the Ctx that will contain this Router</param>
            <param name="threadId">the integer thread-id value</param>
            <param name="socketId">the integer socket-id value</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Peer.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Peer.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Peer.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Peer.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This gets called by the WriteActivated method.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Peer.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
            <exception cref="T:NetMQ.HostUnreachableException">The receiving host must be identifiable.</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Peer.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pub.XRecv(NetMQ.Msg@)">
            <summary>
            This override of the abstract XRecv method, simply throws a NotSupportedException because XRecv is not supported on a Pub socket.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <exception cref="T:System.NotSupportedException">Messages cannot be received from PUB socket</exception>
        </member>
        <member name="F:NetMQ.Core.Patterns.Pull.m_fairQueueing">
            <summary>
            Fair queueing object for inbound pipes.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pull.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pull.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pull.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Pull.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="F:NetMQ.Core.Patterns.Push.m_loadBalancer">
            <summary>
            Load balancer managing the outbound pipes.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Push.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Push.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This gets called by the WriteActivated method.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Push.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Push.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
        </member>
        <member name="F:NetMQ.Core.Patterns.Rep.m_sendingReply">
            <summary>
            If true, we are in process of sending the reply. If false we are
            in process of receiving a request.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Rep.m_requestBegins">
            <summary>
            If true, we are starting to receive a request. The beginning
            of the request is the backtrace stack.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Rep.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
            <exception cref="T:NetMQ.FiniteStateMachineException">XSend must only be called on Rep when in the state of sending a reply.</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Rep.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
            <exception cref="T:NetMQ.FiniteStateMachineException">XRecv must not be called on Rep while in the state of sending a reply.</exception>
        </member>
        <member name="T:NetMQ.Core.Patterns.Req">
            <summary>
            A Req is a Dealer socket that serves as the Request in a Request/Response pattern.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Req.m_receivingReply">
            <summary>
            If true, request was already sent and reply wasn't received yet or
            was received partially.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Req.m_messageBegins">
            <summary>
            If true, we are starting to send/receive a message. The first part
            of the message must be empty message part (backtrace stack bottom).
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Req.#ctor(NetMQ.Core.Ctx,System.Int32,System.Int32)">
            <summary>
            Create a new Req (Request) socket with the given parent Ctx, thread and socket id.
            </summary>
            <param name="parent">the Ctx to contain this socket</param>
            <param name="threadId">an integer thread-id for this socket to execute on</param>
            <param name="socketId">the socket-id for this socket</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Req.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
            <exception cref="T:NetMQ.FiniteStateMachineException">Cannot XSend on a Req while awaiting reply.</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Req.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
            <exception cref="T:NetMQ.FiniteStateMachineException">Req.XRecv expecting send, not receive.</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Req.ReqSession.PushMsg(NetMQ.Msg@)">
            <exception cref="T:NetMQ.FaultException">ReqSession must be in a valid state when PushMsg is called.</exception>
        </member>
        <member name="T:NetMQ.Core.Patterns.Router">
            <summary>
            A Router is a subclass of SocketBase
            </summary>
        </member>
        <member name="T:NetMQ.Core.Patterns.Router.Outpipe">
            <summary>
            An instance of class Outpipe contains a Pipe and a boolean property Active.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_fairQueueing">
            <summary>
            Fair queueing object for inbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_prefetched">
            <summary>
            True if there is a message held in the pre-fetch buffer.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_identitySent">
            <summary>
            If true, the receiver got the message part with
            the peer's identity.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_prefetchedId">
            <summary>
            Holds the prefetched identity.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_prefetchedMsg">
            <summary>
            Holds the prefetched message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_moreIn">
            <summary>
            If true, more incoming message parts are expected.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_anonymousPipes">
            <summary>
            We keep a set of pipes that have not been identified yet.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_outpipes">
            <summary>
            Outbound pipes indexed by the peer IDs.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_currentOut">
            <summary>
            The pipe we are currently writing to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_currentIn">
            <summary>
            The pipe we are currently reading from.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_moreOut">
            <summary>
            If true, more outgoing message parts are expected.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_nextPeerId">
            <summary>
            Peer ID are generated. It's a simple increment and wrap-over
            algorithm. This value is the next ID to use (if not used already).
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_mandatory">
            <summary>
            If true, report EHOSTUNREACH to the caller instead of silently dropping
            the message targeting an unknown peer.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_rawSocket">
            <summary>
            If true, router socket accepts non-zmq tcp connections
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Router.m_handover">
            <summary>
            When enabled new router connections with same identity take over old ones
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Router.#ctor(NetMQ.Core.Ctx,System.Int32,System.Int32)">
            <summary>
            Create a new Router instance with the given parent-Ctx, thread-id, and socket-id.
            </summary>
            <param name="parent">the Ctx that will contain this Router</param>
            <param name="threadId">the integer thread-id value</param>
            <param name="socketId">the integer socket-id value</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Router.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Router.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Router.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Router.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This gets called by the WriteActivated method.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Router.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
            <exception cref="T:NetMQ.HostUnreachableException">The receiving host must be identifiable.</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Router.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_fairQueueing">
            <summary>
            Fair queueing object for inbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_prefetched">
            <summary>
            True if there is a message held in the pre-fetch buffer.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_identitySent">
            <summary>
            If true, the receiver got the message part with
            the peer's identity.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_prefetchedId">
            <summary>
            Holds the prefetched identity.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_prefetchedMsg">
            <summary>
            Holds the prefetched message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_outpipes">
            <summary>
            Outbound pipes indexed by the peer IDs.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_currentOut">
            <summary>
            The pipe we are currently writing to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_moreOut">
            <summary>
            If true, more outgoing message parts are expected.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Stream.m_nextPeerId">
            <summary>
            Peer ID are generated. It's a simple increment and wrap-over
            algorithm. This value is the next ID to use (if not used already).
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Stream.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Stream.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Stream.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Stream.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This gets called by the WriteActivated method.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Stream.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
            <exception cref="T:NetMQ.HostUnreachableException">In Stream.XSend</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Stream.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Sub.XSetSocketOption(NetMQ.Core.ZmqSocketOption,System.Object)">
            <summary>
            Set the specified option on this socket - which must be either a SubScribe or an Unsubscribe.
            </summary>
            <param name="option">which option to set</param>
            <param name="optionValue">the value to set the option to</param>
            <returns><c>true</c> if successful</returns>
            <exception cref="T:NetMQ.InvalidException">optionValue must be a String or a byte-array.</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Sub.XSend(NetMQ.Msg@)">
            <summary>
            XSend transmits a given message. The <c>Send</c> method calls this to do the actual sending.
            This override of that abstract method simply throws NotSupportedException because XSend is not supported on a Sub socket.
            </summary>
            <param name="msg">the message to transmit</param>
            <exception cref="T:System.NotSupportedException">XSend not supported on Sub socket</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.Sub.XHasOut">
            <summary>
            Return false to indicate that XHasOut is not applicable on a Sub socket.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.ArrayExtensions.Resize``1(``0[],System.Int32,System.Boolean)">
            <summary>
            Make resize operation on array.
            </summary>
            <typeparam name="T">Type of containing data.</typeparam>
            <param name="src">Source array.</param>
            <param name="size">New size of array.</param>
            <param name="ended">If grow/shrink operation should be applied to the end of array.</param>
            <returns>Resized array.</returns>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.Distribution.m_pipes">
            <summary>
            List of outbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.Distribution.m_matching">
            <summary>
            Number of all the pipes to send the next message to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.Distribution.m_active">
            <summary>
            Number of active pipes. All the active pipes are located at the
            beginning of the pipes array. These are the pipes the messages
            can be sent to at the moment.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.Distribution.m_eligible">
            <summary>
            Number of pipes eligible for sending messages to. This includes all
            the active pipes plus all the pipes that we can in theory send
            messages to (the HWM is not yet reached), but sending a message
            to them would result in partial message being delivered, ie. message
            with initial parts missing.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.Distribution.m_more">
            <summary>
            True if last we are in the middle of a multipart message.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.#ctor">
            <summary>
            Create a new, empty Distribution object.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.Attach(NetMQ.Core.Pipe)">
            <summary>
            Adds the pipe to the distributor object.
            </summary>
            <param name="pipe"></param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.Match(NetMQ.Core.Pipe)">
            <summary>
            Mark the pipe as matching. Subsequent call to send_to_matching
            will send message also to this pipe.
            </summary>
            <param name="pipe"></param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.Unmatch">
            <summary>
            Mark all pipes as non-matching.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.Terminated(NetMQ.Core.Pipe)">
            <summary>
            This gets called by ProcessPipeTermAck or XTerminated to respond to the termination of the given pipe from the distributor.
            </summary>
            <param name="pipe">the pipe that was terminated</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.Activated(NetMQ.Core.Pipe)">
            <summary>
            Activates pipe that have previously reached high watermark.
            </summary>
            <param name="pipe"></param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.SendToAll(NetMQ.Msg@)">
            <summary>
            Send the message to all the outbound pipes.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.SendToMatching(NetMQ.Msg@)">
            <summary>
            Send the message to the matching outbound pipes.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.Distribute(NetMQ.Msg@)">
            <summary>
            Put the message to all active pipes.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Distribution.Write(NetMQ.Core.Pipe,NetMQ.Msg@)">
            <summary>
            Write the message to the pipe. Make the pipe inactive if writing
            fails. In such a case false is returned.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Patterns.Utils.FairQueueing">
            <summary>
            This class manages a set of inbound pipes. On receive it performs fair
            queueing so that senders gone berserk won't cause denial of
            service for decent senders.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.FairQueueing.m_pipes">
            <summary>
            Inbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.FairQueueing.m_active">
            <summary>
            Number of active pipes. All the active pipes are located at the
            beginning of the pipes array.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.FairQueueing.m_current">
            <summary>
            Index of the next bound pipe to read a message from.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.FairQueueing.m_more">
            <summary>
            If true, part of a multipart message was already received, but
            there are following parts still waiting in the current pipe.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.FairQueueing.Terminated(NetMQ.Core.Pipe)">
            <summary>
            This gets called by ProcessPipeTermAck or XTerminated to respond to the termination of the given pipe.
            </summary>
            <param name="pipe">the pipe that was terminated</param>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.LoadBalancer.m_pipes">
            <summary>
            List of outbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.LoadBalancer.m_active">
            <summary>
            Number of active pipes. All the active pipes are located at the
            beginning of the pipes array.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.LoadBalancer.m_current">
            <summary>
            Points to the last pipe that the most recent message was sent to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.LoadBalancer.m_more">
            <summary>
            True if last we are in the middle of a multipart message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.Utils.LoadBalancer.m_dropping">
            <summary>
            True if we are dropping current message.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.LoadBalancer.Terminated(NetMQ.Core.Pipe)">
            <summary>
            This gets called by ProcessPipeTermAck or XTerminated to respond to the termination of the given pipe.
            </summary>
            <param name="pipe">the pipe that was terminated</param>
        </member>
        <member name="T:NetMQ.Core.Patterns.Utils.MultiTrie">
            <summary>
            Multi-trie. Each node in the trie is a set of pointers to pipes.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.MultiTrie.Add(System.Byte[],System.Int32,System.Int32,NetMQ.Core.Pipe)">
            <summary>
            Add key to the trie. Returns true if it's a new subscription
            rather than a duplicate.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.MultiTrie.RemoveHelper(NetMQ.Core.Pipe,NetMQ.Core.Patterns.Utils.MultiTrie.MultiTrieDelegate,System.Object)">
            <summary>
            Remove all subscriptions for a specific peer from the trie.
            If there are no subscriptions left on some topics, invoke the
            supplied callback function.
            </summary>
            <param name="pipe"></param>
            <param name="func"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.MultiTrie.Remove(System.Byte[],System.Int32,System.Int32,NetMQ.Core.Pipe)">
            <summary>
            Remove specific subscription from the trie. Return true is it was
            actually removed rather than de-duplicated.
            </summary>
            <param name="prefix"></param>
            <param name="start"></param>
            <param name="size"></param>
            <param name="pipe"></param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.MultiTrie.Match(System.Byte[],System.Int32,System.Int32,NetMQ.Core.Patterns.Utils.MultiTrie.MultiTrieDelegate,System.Object)">
            <summary>
            Signal all the matching pipes.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Trie.Add(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add key to the trie. Returns true if this is a new item in the trie
            rather than a duplicate.
            </summary>
            <param name="prefix"></param>
            <param name="start"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Trie.Remove(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Remove key from the trie. Returns true if the item is actually
            removed from the trie.
            </summary>
            <param name="prefix"></param>
            <param name="start"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.Utils.Trie.Check(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Check whether particular key is in the trie.
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="F:NetMQ.Core.Patterns.XPub.m_subscriptions">
            <summary>
            List of all subscriptions mapped to corresponding pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XPub.m_distribution">
            <summary>
            Distributor of messages holding the list of outbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XPub.m_verbose">
            <summary>
            If true, send all subscription messages upstream, not just
            unique ones. The default is false.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XPub.m_manual">
             <summary>
            
             The default value is false.
             </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XPub.m_moreOut">
            <summary>
            True if we are in the middle of sending a multipart message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XPub.m_moreIn">
            <summary>
            True if we are in the middle of receiving a multipart message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XPub.m_pendingMessages">
            <summary>
            List of pending (un)subscriptions, ie. those that were already
            applied to the trie, but not yet received by the user.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.XPub.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">if true - subscribe to all data on the pipe</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XPub.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XPub.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This gets called by the WriteActivated method.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XPub.XSetSocketOption(NetMQ.Core.ZmqSocketOption,System.Object)">
            <summary>
            Set the specified option on this socket.
            </summary>
            <param name="option">which option to set</param>
            <param name="optionValue">the value to set the option to</param>
            <returns><c>true</c> if successful</returns>
            <exception cref="T:NetMQ.InvalidException">optionValue must be a byte-array.</exception>
        </member>
        <member name="M:NetMQ.Core.Patterns.XPub.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XPub.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.XPub.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="T:NetMQ.Core.Patterns.XSub.XSubSession">
            <summary>
            An XSubSession is a subclass of SessionBase that provides nothing more.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XSub.m_fairQueueing">
            <summary>
            Fair queueing object for inbound pipes.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XSub.m_distribution">
            <summary>
            Object for distributing the subscriptions upstream.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XSub.m_subscriptions">
            <summary>
            The repository of subscriptions.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XSub.m_hasMessage">
            <summary>
            If true, 'message' contains a matching message to return on the
            next recv call.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Patterns.XSub.m_moreIn">
            <summary>
            If true, part of a multipart message was already received, but
            there are following parts still waiting.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Patterns.XSub.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">not used</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XSub.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XSub.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This gets called by the WriteActivated method.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XSub.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            This is an override of the abstract method that gets called to signal that the given pipe is to be removed from this socket.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.Patterns.XSub.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <c>Send</c> method calls this to do the actual sending.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
        </member>
        <member name="M:NetMQ.Core.Patterns.XSub.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="T:NetMQ.Core.Pipe">
            <summary>
            A pipe is a ZObject with ..
            </summary>
            <remarks>
            Note that pipe can be stored in three different arrays.
            The array of inbound pipes (1), the array of outbound pipes (2) and
            the generic array of pipes to deallocate (3).
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Pipe.IPipeEvents.ReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate that the given pipe is now ready for reading.
            Pipe calls this on it's sink in response to ProcessActivateRead.
            When called upon an instance of SocketBase, this simply calls XReadActivated.
            </summary>
            <param name="pipe">the pipe to indicate is ready for reading</param>
        </member>
        <member name="M:NetMQ.Core.Pipe.IPipeEvents.Terminated(NetMQ.Core.Pipe)">
            <summary>
            This gets called by ProcessPipeTermAck or XTerminated to respond to the termination of the given pipe.
            </summary>
            <param name="pipe">the pipe that was terminated</param>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_inboundPipe">
            <summary>
            The underlying pipe for reading from.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_outboundPipe">
            <summary>
            The underlying pipe for writing to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_inActive">
            <summary>
            This indicates whether this pipe can be read from.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_outActive">
            <summary>
            This indicates whether this pipe be written to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_highWatermark">
            <summary>
            High watermark for the outbound pipe.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_lowWatermark">
            <summary>
            Low watermark for the inbound pipe.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_numberOfMessagesRead">
            <summary>
            Number of messages read so far.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_numberOfMessagesWritten">
            <summary>
            Number of messages written so far.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_peersMsgsRead">
            <summary>
            Last received peer's msgs_read. The actual number in the peer
            can be higher at the moment.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_peer">
            <summary>
            The pipe object on the other side of the pipe-pair.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_sink">
            <summary>
            Sink to send events to.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Pipe.State">
            <summary>
            Specifies the state of the pipe endpoint.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.State.Active">
            <summary> Active is common state before any termination begins. </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.State.Delimited">
            <summary> Delimited means that delimiter was read from pipe before term command was received. </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.State.Pending">
            <summary> Pending means that term command was already received from the peer but there are still pending messages to read. </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.State.Terminating">
            <summary> Terminating means that all pending messages were already read and all we are waiting for is ack from the peer. </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.State.Terminated">
            <summary> Terminated means that 'terminate' was explicitly called by the user. </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.State.DoubleTerminated">
            <summary> Double_terminated means that user called 'terminate' and then we've got term command from the peer as well. </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_delay">
            <summary>
            If <c>true</c>, we receive all the pending inbound messages before terminating.
            If <c>false</c>, we terminate immediately when the peer asks us to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Pipe.m_parent">
            <summary>
            Identity of the writer. Used uniquely by the reader side.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Pipe.#ctor(NetMQ.Core.ZObject,NetMQ.Core.YPipe{NetMQ.Msg},NetMQ.Core.YPipe{NetMQ.Msg},System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a new Pipe object with the given parent, and inbound and outbound YPipes.
            </summary>
            <remarks>
            Constructor is private as pipe can only be created using <see cref="M:NetMQ.Core.Pipe.PipePair(NetMQ.Core.ZObject[],System.Int32[],System.Int32[],System.Boolean[])"/> method.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Pipe.PipePair(NetMQ.Core.ZObject[],System.Int32[],System.Int32[],System.Boolean[])">
            <summary>
            Create a pipe pair for bi-directional transfer of messages.
            </summary>
            <param name="parents">The parents.</param>
            <param name="highWaterMarks">First HWM is for messages passed from first pipe to the second pipe.
            Second HWM is for messages passed from second pipe to the first pipe.</param>
            <param name="lowWaterMarks">First LWM is for messages passed from first pipe to the second pipe.
            Second LWM is for messages passed from second pipe to the first pipe.</param>
            <param name="delays">Delay specifies how the pipe behaves when the peer terminates. If true
            pipe receives all the pending messages before terminating, otherwise it
            terminates straight away.</param>
            <returns>A pipe pair for bi-directional transfer of messages. </returns>
        </member>
        <member name="M:NetMQ.Core.Pipe.SetPeer(NetMQ.Core.Pipe)">
            <summary>
            <see cref="M:NetMQ.Core.Pipe.PipePair(NetMQ.Core.ZObject[],System.Int32[],System.Int32[],System.Boolean[])"/> uses this function to let us know about the peer pipe object.
            </summary>
            <param name="peer">The peer to be assigned.</param>
        </member>
        <member name="M:NetMQ.Core.Pipe.SetEventSink(NetMQ.Core.Pipe.IPipeEvents)">
            <summary>
            Specifies the object to send events to.
            </summary>
            <param name="sink"> The receiver of the events. </param>
        </member>
        <member name="P:NetMQ.Core.Pipe.Identity">
            <summary>
            Get or set the byte-array that comprises the identity of this Pipe.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Pipe.RoutingId">
            <summary>
            Get or set the byte-array that comprises the routing id of this Pipe.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Pipe.CheckRead">
            <summary>
            Checks if there is at least one message to read in the pipe.
            </summary>
            <returns> Returns <c>true</c> if there is at least one message to read in the pipe; <c>false</c> otherwise. </returns>
        </member>
        <member name="M:NetMQ.Core.Pipe.Read(NetMQ.Msg@)">
            <summary>
            Read a message from the underlying inbound pipe, and write it to the provided Msg argument.
            </summary>
            <returns>true if a message is read from the pipe, false if pipe is terminated or no messages are available</returns>
        </member>
        <member name="M:NetMQ.Core.Pipe.CheckWrite">
            <summary>
            Check whether messages can be written to the pipe. If writing
            the message would cause high watermark the function returns false.
            </summary>
            <returns><c>true</c> if message can be written to the pipe; <c>false</c> otherwise. </returns>
        </member>
        <member name="M:NetMQ.Core.Pipe.Write(NetMQ.Msg@)">
            <summary>
            Write a message to the underlying pipe.
            </summary>
            <param name="msg">The message to write.</param>
            <returns>false if the message cannot be written because high watermark was reached.</returns>
        </member>
        <member name="M:NetMQ.Core.Pipe.Rollback">
            <summary>
            Remove unfinished parts of the outbound message from the pipe.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Pipe.Flush">
            <summary>
            Flush the messages downstream.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Pipe.ProcessHiccup(System.Object)">
            <summary>
            This method is called to assign the specified pipe as a replacement for the outbound pipe that was being used.
            </summary>
            <param name="pipe">the pipe to use for writing</param>
            <remarks>
            A "Hiccup" occurs when an outbound pipe experiences something like a transient disconnect or for whatever other reason
            is no longer available for writing to.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Pipe.ProcessPipeTermAck">
            <summary>
            Process the pipe-termination ack.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Pipe.Terminate(System.Boolean)">
            <summary>
            Ask pipe to terminate. The termination will happen asynchronously
            and user will be notified about actual deallocation by 'terminated'
            event.
            </summary>
            <param name="delay">if set to <c>true</c>, the pending messages will be processed
            before actual shutdown. </param>
        </member>
        <member name="M:NetMQ.Core.Pipe.ComputeLowWatermark(System.Int32,System.Int32)">
            <summary>
            Compute an appropriate low watermark from the given high-watermark.
            </summary>
            <param name="highWatermark">the given high-watermark value to compute it from</param>
            <param name="predefinedLowWatermark">predefined low watermark value coming from configuration</param>
            <returns>the computed low-watermark</returns>
        </member>
        <member name="M:NetMQ.Core.Pipe.Delimit">
            <summary>
            Handles the delimiter read from the pipe.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Pipe.Hiccup">
            <summary>
            Temporarily disconnects the inbound message stream and drops
            all the messages on the fly. Causes 'hiccuped' event to be generated in the peer.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Pipe.ToString">
            <summary>
            Override the ToString method to return a string denoting the type and the parent.
            </summary>
            <returns>a string containing this type and also the value of the parent-property</returns>
        </member>
        <member name="T:NetMQ.Core.Reaper">
            <summary>
            Class Reaper is a ZObject and implements IPollEvents.
            The Reaper is dedicated toward handling socket shutdown asynchronously and cleanly.
            By passing this task off to the Reaper, the message-queueing subsystem can terminate immediately.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Reaper.m_mailbox">
            <summary>
            Reaper thread accesses incoming commands via this mailbox.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Reaper.m_mailboxHandle">
            <summary>
            This is a Socket, used as the handle associated with the mailbox's file descriptor.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Reaper.m_poller">
            <summary>
            I/O multiplexing is performed using a poller object.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Reaper.m_sockets">
            <summary>
            Number of sockets being reaped at the moment.
            These are the reason for having a reaper: to take over the task of terminating these sockets.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Reaper.m_terminating">
            <summary>
            If true, we were already asked to terminate.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Reaper.#ctor(NetMQ.Core.Ctx,System.Int32)">
            <summary>
            Create a new Reaper with the given thread-id.
            This will have a new Poller with the name "reaper-" + thread-id, and a Mailbox of that same name.
            </summary>
            <param name="ctx">the Ctx for this to be in</param>
            <param name="threadId">an integer id to give to the thread this will live on</param>
        </member>
        <member name="M:NetMQ.Core.Reaper.Destroy">
            <summary>
            Release any contained resources - by destroying the poller and closing the mailbox.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Reaper.Mailbox">
            <summary>
            Get the Mailbox that this Reaper uses for communication with the rest of the message-queueing subsystem.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Reaper.Start">
            <summary>
            Start the contained Poller to begin polling.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Reaper.Stop">
            <summary>
            Issue the Stop command to this Reaper object.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Reaper.InEvent">
            <summary>
            Handle input-ready events, by receiving and processing any commands
            that are waiting in the mailbox.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Reaper.OutEvent">
            <summary>
            This method normally is for handling output-ready events, which don't apply here.
            </summary>
            <exception cref="T:System.NotSupportedException">You must not call OutEvent on a Reaper.</exception>
        </member>
        <member name="M:NetMQ.Core.Reaper.TimerEvent(System.Int32)">
            <summary>
            This would be called when a timer expires - however in this event NotSupportedException would be thrown.
            </summary>
            <param name="id">an integer used to identify the timer</param>
            <exception cref="T:System.NotSupportedException">You must not call TimerEvent on a Reaper.</exception>
        </member>
        <member name="M:NetMQ.Core.Reaper.ProcessStop">
            <summary>
            Respond to the Stop command by signaling the polling-loop to terminate,
            and if there're no sockets left to reap - stop the poller.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Reaper.ProcessReap(NetMQ.Core.SocketBase)">
            <summary>
            Add the given socket to the list to be reaped (terminated).
            </summary>
            <param name="socket">the socket to add to the list for termination</param>
        </member>
        <member name="M:NetMQ.Core.Reaper.ProcessReaped">
            <summary>
            Respond to having one of the sockets that are marked for reaping, - finished being reaped,
            and if there are none left - send the Done command and stop the poller.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_connect">
            <summary>
            If true, this session (re)connects to the peer. Otherwise, it's
            a transient session created by the listener.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_pipe">
            <summary>
            Pipe connecting the session to its socket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_terminatingPipes">
            <summary>
            This set is added to with pipes we are disconnecting, but haven't yet completed
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_incompleteIn">
            <summary>
            This flag is true if the remainder of the message being processed
            is still in the pipe.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_pending">
            <summary>
            True if termination have been suspended to push the pending
            messages to the network.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_engine">
            <summary>
            The protocol I/O engine connected to the session.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_socket">
            <summary>
            The socket the session belongs to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_ioThread">
            <summary>
            I/O thread the session is living in. It will be used to plug in
            the engines into the same thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.LingerTimerId">
            <summary>
            ID of the linger timer (0x20)
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_hasLingerTimer">
            <summary>
            True is linger timer is running.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_identitySent">
            <summary>
            If true, identity has been sent to the network.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_identityReceived">
            <summary>
            If true, identity has been received from the network.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SessionBase.m_addr">
            <summary>
            Protocol and address to use when connecting.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.Create(NetMQ.Core.IOThread,System.Boolean,NetMQ.Core.SocketBase,NetMQ.Core.Options,NetMQ.Core.Address)">
            <summary>
            Create a return a new session.
            The specific subclass of SessionBase that is created is dictated by the SocketType specified by the options argument.
            </summary>
            <param name="ioThread">the <c>IOThread</c> for this session to run in</param>
            <param name="connect">whether to immediately connect</param>
            <param name="socket">the socket to connect</param>
            <param name="options">an <c>Options</c> that provides the SocketType that dictates which type of session to create</param>
            <param name="addr">an <c>Address</c> object that specifies the protocol and address to connect to</param>
            <returns>the newly-created instance of whichever subclass of SessionBase is specified by the options</returns>
            <exception cref="T:NetMQ.InvalidException">The socket must be of the correct type.</exception>
        </member>
        <member name="M:NetMQ.Core.SessionBase.#ctor(NetMQ.Core.IOThread,System.Boolean,NetMQ.Core.SocketBase,NetMQ.Core.Options,NetMQ.Core.Address)">
            <summary>
            Create a new SessionBase object from the given IOThread, socket, and Address.
            </summary>
            <param name="ioThread">the IOThread for this session to run on</param>
            <param name="connect">this flag dictates whether to connect</param>
            <param name="socket">the socket to contain</param>
            <param name="options">Options that dictate the settings of this session</param>
            <param name="addr">an Address that dictates the protocol and IP-address to use when connecting</param>
        </member>
        <member name="M:NetMQ.Core.SessionBase.Destroy">
            <summary>
            Terminate and release any contained resources.
            This cancels the linger-timer if that exists, and terminates the protocol-engine if that exists.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.AttachPipe(NetMQ.Core.Pipe)">
            <summary>
            Attach the given pipe to this session.
            </summary>
            <remarks>
            This is to be used once only, when creating the session.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.SessionBase.PullMsg(NetMQ.Msg@)">
            <summary>
            Read a message from the pipe.
            </summary>
            <param name="msg">a reference to a Msg to put the message into</param>
            <returns>true if the Msg is successfully sent</returns>
        </member>
        <member name="M:NetMQ.Core.SessionBase.PushMsg(NetMQ.Msg@)">
            <summary>
            Write the given Msg to the pipe.
            </summary>
            <param name="msg">the Msg to push to the pipe</param>
            <returns>true if the Msg was successfully sent</returns>
        </member>
        <member name="M:NetMQ.Core.SessionBase.Reset">
            <summary>
            Set the identity-sent and identity-received flags to false.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.Flush">
            <summary>
            Flush any messages that are in the pipe downstream.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.CleanPipes">
            <summary>
            Remove any half processed messages. Flush unflushed messages.
            Call this function when engine disconnect to get rid of leftovers.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.Terminated(NetMQ.Core.Pipe)">
            <summary>
            This gets called by ProcessPipeTermAck or XTerminated to respond to the termination of the given pipe.
            </summary>
            <param name="pipe">the pipe that was terminated</param>
        </member>
        <member name="M:NetMQ.Core.SessionBase.ReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate that the given pipe is now ready for reading.
            Pipe calls this on it's sink in response to ProcessActivateRead.
            </summary>
            <param name="pipe">the pipe to indicate is ready for reading</param>
        </member>
        <member name="P:NetMQ.Core.SessionBase.Socket">
            <summary>
            Get the contained socket.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.ProcessPlug">
            <summary>
            Process the Plug-request by setting this SessionBase as the handler for the io-object
            and starting connecting (without waiting).
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.ProcessAttach(NetMQ.Core.Transports.IEngine)">
            <summary>
            Process the Attach-request by hooking up the pipes
            and plugging in the given engine.
            </summary>
            <param name="engine">the IEngine to plug in</param>
        </member>
        <member name="M:NetMQ.Core.SessionBase.Detach">
            <summary>
            Flush out any leftover messages and call Detached.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.ProcessTerm(System.Int32)">
            <summary>
            Process a termination request.
            </summary>
            <param name="linger">a time (in milliseconds) for this to linger before actually going away. -1 means infinite.</param>
        </member>
        <member name="M:NetMQ.Core.SessionBase.ProceedWithTerm">
            <summary>
            Call this function to move on with the delayed process-termination request.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.TimerEvent(System.Int32)">
            <summary>
            This is called when the timer expires.
            </summary>
            <param name="id">an integer used to identify the timer</param>
        </member>
        <member name="M:NetMQ.Core.SessionBase.Detached">
            <summary>
            The parent SessionBase class calls this when the Detach method finishes detaching.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SessionBase.StartConnecting(System.Boolean)">
            <summary>
            Begin connecting.
            </summary>
            <param name="wait">Whether to wait a bit before actually attempting to connect</param>
        </member>
        <member name="M:NetMQ.Core.SessionBase.ToString">
            <summary>
            Override the ToString method to also show the socket-id.
            </summary>
            <returns>the type of this object and [ socket-id ]</returns>
        </member>
        <member name="M:NetMQ.Core.SessionBase.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method would be called when a message receive operation has been completed, although here it only throws a NotSupportedException.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on the SessionBase class.</exception>
        </member>
        <member name="M:NetMQ.Core.SessionBase.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method would be called when a message Send operation has been completed, although here it only throws a NotSupportedException.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on the SessionBase class.</exception>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_isStopped">
            <summary>If true, associated context was already terminated.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_destroyed">
            <summary>
            If true, object should have been already destroyed. However,
            destruction is delayed while we unwind the stack to the point
            where it doesn't intersect the object being destroyed.
            </summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_mailbox">
            <summary>Socket's mailbox object.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_pipes">
            <summary>List of attached pipes.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_poller">
            <summary>Reaper's poller.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_handle">
            <summary>The handle of this socket within the reaper's poller.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_lastTsc">
            <summary>Timestamp of when commands were processed the last time.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_ticks">
            <summary>Number of messages received since last command processing.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_rcvMore">
            <summary>True if the last message received had MORE flag set.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_monitorSocket">
            <summary>Monitor socket.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_monitorEvents">
            <summary>Bitmask of events being monitored.</summary>
        </member>
        <member name="F:NetMQ.Core.SocketBase.m_port">
            <summary>The tcp port that was bound to, if any.</summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.#ctor(NetMQ.Core.Ctx,System.Int32,System.Int32)">
            <summary>
            Create a new SocketBase within the given Ctx, with the specified thread-id and socket-id.
            </summary>
            <param name="parent">the Ctx context that this socket will live within</param>
            <param name="threadId">the id of the thread upon which this socket will execute</param>
            <param name="socketId">the integer id for the new socket</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XAttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Abstract method for attaching a given pipe to this socket.
            The concrete implementations are defined by the individual socket types.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">if true - subscribe to all data on the pipe</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XTerminated(NetMQ.Core.Pipe)">
            <summary>
            Abstract method that gets called to signal that the given pipe is to be removed from this socket.
            The concrete implementations of SocketBase override this to provide their own implementation
            of how to terminate the pipe.
            </summary>
            <param name="pipe">the Pipe that is being removed</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.CheckDisposed">
            <summary>Throw <see cref="T:System.ObjectDisposedException"/> if this socket is already disposed.</summary>
            <exception cref="T:System.ObjectDisposedException">This object is already disposed.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.CheckContextTerminated">
            <summary>
            Throw <see cref="T:NetMQ.TerminatingException"/> if the message-queueing system has started terminating.
            </summary>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Create(NetMQ.ZmqSocketType,NetMQ.Core.Ctx,System.Int32,System.Int32)">
            <summary>
            Create a socket of a specified type.
            </summary>
            <param name="type">a ZmqSocketType specifying the type of socket to create</param>
            <param name="parent">the parent context</param>
            <param name="threadId">the thread for this new socket to run on</param>
            <param name="socketId">an integer id for this socket</param>
            <exception cref="T:NetMQ.InvalidException">The socket type must be valid.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Destroy">
            <summary>
            Destroy this socket - which means to stop monitoring the queue for messages.
            This simply calls StopMonitor, and then verifies that the destroyed-flag is set.
            </summary>
        </member>
        <member name="P:NetMQ.Core.SocketBase.Mailbox">
            <summary>
            Return the Mailbox associated with this socket.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Stop">
            <summary>
            Interrupt a blocking call if the socket is stuck in one.
            This function can be called from a different thread!
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.CheckProtocol(System.String)">
            <summary>
            Check whether the transport protocol, as specified in connect or
            bind, is available and compatible with the socket type.
            </summary>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">the specified protocol is not supported</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">the socket type and protocol do not match</exception>
            <remarks>
            The supported protocols are "inproc", "ipc", "tcp", "pgm", and "epgm".
            If the protocol is either "pgm" or "epgm", then this socket must be of type Pub, Sub, XPub, or XSub.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.SocketBase.AttachPipe(NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Register the given pipe with this socket.
            </summary>
            <param name="pipe">the Pipe to attach</param>
            <param name="icanhasall">if true - subscribe to all data on the pipe (optional - default is false)</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.SetSocketOption(NetMQ.Core.ZmqSocketOption,System.Object)">
            <summary>
            Set the specified socket option.
            </summary>
            <param name="option">which option to set</param>
            <param name="optionValue">the value to set the option to</param>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.GetSocketOption(NetMQ.Core.ZmqSocketOption)">
            <summary>
            Return the integer-value of the specified option.
            </summary>
            <param name="option">which option to get</param>
            <returns>the value of the specified option, or -1 if error</returns>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <remarks>
            If the ReceiveMore option is specified, then 1 is returned if it is true, 0 if it is false.
            If the Events option is specified, then process any outstanding commands, and return -1 if that throws a TerminatingException.
                then return an integer that is the bitwise-OR of the PollEvents.PollOut and PollEvents.PollIn flags.
            Otherwise, cast the specified option value to an integer and return it.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.SocketBase.GetSocketOptionX(NetMQ.Core.ZmqSocketOption)">
            <summary>
            Return the value of the specified option as an Object.
            </summary>
            <param name="option">which option to get</param>
            <returns>the value of the option</returns>
            <exception cref="T:NetMQ.TerminatingException">The socket has already been stopped.</exception>
            <remarks>
            If the Handle option is specified, then return the handle of the contained mailbox.
            If the Events option is specified, then process any outstanding commands, and return -1 if that throws a TerminatingException.
                then return a PollEvents that is the bitwise-OR of the PollEvents.PollOut and PollEvents.PollIn flags.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Bind(System.String)">
            <summary>
            Bind this socket to the given address.
            </summary>
            <param name="addr">a string denoting the endpoint-address to bind to</param>
            <exception cref="T:NetMQ.AddressAlreadyInUseException">the address specified to bind to must not be already in use</exception>
            <exception cref="T:System.ArgumentException">The requested protocol is not supported.</exception>
            <exception cref="T:NetMQ.FaultException">the socket bind failed</exception>
            <exception cref="T:NetMQ.NetMQException">No IO thread was found, or the protocol's listener encountered an
            error during initialisation.</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">the specified protocol is not supported</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">the socket type and protocol do not match</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <remarks>
            The supported protocols are "inproc", "ipc", "tcp", "pgm", and "epgm".
            If the protocol is either "pgm" or "epgm", then this socket must be of type Pub, Sub, XPub, or XSub.
            If the protocol is "inproc", you cannot bind to the same address more than once.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.SocketBase.BindRandomPort(System.String)">
            <summary>Bind the specified TCP address to an available port, assigned by the operating system.</summary>
            <param name="addr">a string denoting the endpoint to bind to</param>
            <returns>the port-number that was bound to</returns>
            <exception cref="T:NetMQ.ProtocolNotSupportedException"><paramref name="addr"/> uses a protocol other than TCP.</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.AddressAlreadyInUseException">The specified address is already in use.</exception>
            <exception cref="T:NetMQ.NetMQException">No IO thread was found, or the protocol's listener errored during
            initialisation.</exception>
            <exception cref="T:NetMQ.FaultException">the socket bind failed</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Connect(System.String)">
            <summary>
            Connect this socket to the given address.
            </summary>
            <param name="addr">a string denoting the endpoint to connect to</param>
            <exception cref="T:NetMQ.AddressAlreadyInUseException">The specified address is already in use.</exception>
            <exception cref="T:NetMQ.NetMQException">No IO thread was found.</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">the specified protocol is not supported</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">the socket type and protocol do not match</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <remarks>
            The supported protocols are "inproc", "ipc", "tcp", "pgm", and "epgm".
            If the protocol is either "pgm" or "epgm", then this socket must be of type Pub, Sub, XPub, or XSub.
            </remarks>
            <exception cref="T:NetMQ.EndpointNotFoundException">The given address was not found in the list of endpoints.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.DecodeAddress(System.String,System.String@,System.String@)">
            <summary>
            Given a string containing an endpoint address like "tcp://127.0.0.1:5555,
            break-it-down into the address part ("127.0.0.1:5555") and the protocol part ("tcp").
            </summary>
            <param name="addr">a string denoting the endpoint, to take the parts from</param>
            <param name="address">the IP-address portion of the end-point address</param>
            <param name="protocol">the protocol portion of the end-point address (such as "tcp")</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.AddEndpoint(System.String,NetMQ.Core.Own,NetMQ.Core.Pipe)">
            <summary>
            Take ownership of the given <paramref name="endpoint"/> and register it against the given <paramref name="address"/>.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.TermEndpoint(System.String)">
            <summary>
            Disconnect from the given endpoint.
            </summary>
            <param name="addr">the endpoint to disconnect from</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="addr"/> is <c>null</c>.</exception>
            <exception cref="T:NetMQ.EndpointNotFoundException">Endpoint was not found and cannot be disconnected.</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">The specified protocol must be valid.</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.TrySend(NetMQ.Msg@,System.TimeSpan,System.Boolean)">
            <summary>
            Transmit the given Msg across the message-queueing system.
            </summary>
            <param name="msg">The <see cref="T:NetMQ.Msg"/> to send.</param>
            <param name="timeout">The timeout to wait before returning <c>false</c>. Pass <see cref="F:NetMQ.SendReceiveConstants.InfiniteTimeout"/> to disable timeout.</param>
            <param name="more">Whether this message will contain another frame after this one.</param>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.FaultException"><paramref name="msg"/> is not initialised.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.TryRecv(NetMQ.Msg@,System.TimeSpan)">
            <summary>
            Receive a frame into the given <paramref name="msg"/> and return <c>true</c> if successful, <c>false</c> if it timed out.
            </summary>
            <param name="msg">the <c>Msg</c> to read the received message into</param>
            <param name="timeout">this controls whether the call blocks, and for how long.</param>
            <returns><c>true</c> if successful, <c>false</c> if it timed out</returns>
            <remarks>
            For <paramref name="timeout"/>, there are three categories of value:
            <list type="bullet">
              <item><see cref="F:System.TimeSpan.Zero"/> - return <c>false</c> immediately if no message is available</item>
              <item><see cref="F:NetMQ.SendReceiveConstants.InfiniteTimeout"/> (or a negative value) - wait indefinitely, always returning <c>true</c></item>
              <item>Any positive value - return <c>false</c> after the corresponding duration if no message has become available</item>
            </list>
            </remarks>
            <exception cref="T:NetMQ.FaultException">the Msg must already have been uninitialised</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket must not already be stopped.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Close">
            <summary>
            Close this socket. Mark it as disposed, and send ownership of it to the reaper thread to
            attend to the rest of it's shutdown process.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.HasIn">
            <summary>
            These functions are used by the polling mechanism to determine
            which events are to be reported from this socket.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.HasOut">
            <summary>
            These functions are used by the polling mechanism to determine
            which events are to be reported from this socket.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.StartReaping(NetMQ.Core.Utils.Poller)">
            <summary>
            Using this function reaper thread ask the socket to register with
            its poller.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ProcessCommands(System.Int32,System.Boolean)">
            <summary>
            Processes commands sent to this socket (if any).
            If <paramref name="timeout"/> is <c>-1</c>, the call blocks until at least one command was processed.
            If <paramref name="throttle"/> is <c>true</c>, commands are processed at most once in a predefined time period.
            </summary>
            <param name="timeout">how much time to allow to wait for a command, before returning (in milliseconds)</param>
            <param name="throttle">if true - throttle the rate of command-execution by doing only one per call</param>
            <exception cref="T:NetMQ.TerminatingException">The Ctx context must not already be terminating.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ProcessStop">
            <summary>
            Process a termination command on this socket, by stopping monitoring and marking this as terminated.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ProcessBind(NetMQ.Core.Pipe)">
            <summary>
            Process a Bind command by attaching the given Pipe.
            </summary>
            <param name="pipe">the Pipe to attach</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ProcessTerm(System.Int32)">
            <summary>
            Process a termination request.
            </summary>
            <param name="linger">a time (in milliseconds) for this to linger before actually going away. -1 means infinite.</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ProcessDestroy">
            <summary>
            Mark this socket as having been destroyed. Delay actual destruction of the socket.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XSetSocketOption(NetMQ.Core.ZmqSocketOption,System.Object)">
            <summary>
            The default implementation assumes there are no specific socket
            options for the particular socket type. If not so, overload this
            method.
            </summary>
            <param name="option">a ZmqSocketOption specifying which option to set</param>
            <param name="optionValue">an Object that is the value to set the option to</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XHasOut">
            <summary>
            This gets called when outgoing messages are ready to be sent out.
            On SocketBase, this does nothing and simply returns false.
            </summary>
            <returns>this method on SocketBase only returns false</returns>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XSend(NetMQ.Msg@)">
            <summary>
            Transmit the given message. The <see cref="M:NetMQ.Core.SocketBase.TrySend(NetMQ.Msg@,System.TimeSpan,System.Boolean)"/> method calls this to do the actual sending.
            This abstract method gets overridden by the different socket types
            to provide their concrete implementation of sending messages.
            </summary>
            <param name="msg">the message to transmit</param>
            <returns><c>true</c> if the message was sent successfully</returns>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XHasIn">
            <summary>
            This gets called when incoming messages are ready to be received.
            On SocketBase, this does nothing and simply returns false.
            </summary>
            <returns>this method on SocketBase only returns false</returns>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XRecv(NetMQ.Msg@)">
            <summary>
            Receive a message. The <c>Recv</c> method calls this lower-level method to do the actual receiving.
            This abstract method gets overridden by the different socket types
            to provide their concrete implementation of receiving messages.
            </summary>
            <param name="msg">the <c>Msg</c> to receive the message into</param>
            <returns><c>true</c> if the message was received successfully, <c>false</c> if there were no messages to receive</returns>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for reading by this socket.
            This abstract method gets overridden by the different sockets
            to provide their own concrete implementation.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for reading</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.XWriteActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate the given pipe as being ready for writing to by this socket.
            This abstract method gets called by the WriteActivated method
            and gets overridden by the different sockets
            to provide their own concrete implementation.
            </summary>
            <param name="pipe">the <c>Pipe</c> that is now becoming available for writing</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.InEvent">
            <summary>
            Handle input-ready events by receiving and processing any incoming commands.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.OutEvent">
            <summary>
            Handle output-ready events.
            </summary>
            <exception cref="T:System.NotSupportedException">This is not supported on instances of the parent class SocketBase.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.TimerEvent(System.Int32)">
            <summary>
            In subclasses of SocketBase this is overridden, to handle the expiration of a timer.
            </summary>
            <param name="id">an integer used to identify the timer</param>
            <exception cref="T:System.NotSupportedException">You must not call TimerEvent on an instance of class SocketBase.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.CheckDestroy">
            <summary>
            To be called after processing commands or invoking any command
            handlers explicitly. If required, it will deallocate the socket.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ReadActivated(NetMQ.Core.Pipe)">
            <summary>
            Indicate that the given pipe is now ready for reading.
            Pipe calls this on it's sink in response to ProcessActivateRead.
            When called upon an instance of SocketBase, this simply calls XReadActivated.
            </summary>
            <param name="pipe">the pipe to indicate is ready for reading</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.WriteActivated(NetMQ.Core.Pipe)">
            <summary>
            When called upon an instance of SocketBase, this simply calls XWriteActivated.
            </summary>
            <param name="pipe">the pipe to indicate is ready for writing</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Terminated(NetMQ.Core.Pipe)">
            <summary>
            This gets called by ProcessPipeTermAck or XTerminated to respond to the termination of the given pipe.
            </summary>
            <param name="pipe">the pipe that was terminated</param>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ExtractFlags(NetMQ.Msg@)">
            <summary>
            Moves the flags from the message to local variables,
            to be later retrieved by getsockopt.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.Monitor(System.String,NetMQ.SocketEvents)">
            <summary>
            Register the given events to monitor on the given endpoint.
            </summary>
            <param name="addr">a string denoting the endpoint to monitor. If this is null - monitoring is stopped.</param>
            <param name="events">the SocketEvent to monitor for</param>
            <exception cref="T:NetMQ.NetMQException">Maximum number of sockets reached.</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">The protocol of <paramref name="addr"/> is not supported.</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.Core.SocketBase.StopMonitor">
            <summary>
            If there is a monitor-socket, close it and set monitor-events to 0.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.ToString">
            <summary>
            Override the ToString method in order to also show the socket-id.
            </summary>
            <returns>A string that denotes this object type followed by [ socket-id ]</returns>
        </member>
        <member name="P:NetMQ.Core.SocketBase.Handle">
            <summary>
            Get the Socket (Handle) - which is actually the Handle of the contained mailbox.
            </summary>
        </member>
        <member name="M:NetMQ.Core.SocketBase.GetTypeString">
            <summary>
            Return a short bit of text that denotes the SocketType of this socket.
            </summary>
            <returns>a short type-string such as PAIR, PUB, OR UNKNOWN</returns>
        </member>
        <member name="T:NetMQ.Core.Transports.ByteArraySegment">
            <summary>
            The class ByteArraySegment provides for containing a simple byte-array, an Offset property,
            and a variety of operations that may be performed upon it.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.#ctor(System.Byte[])">
            <summary>
            Create a new ByteArraySegment containing the given byte-array buffer.
            </summary>
            <param name="buffer">the byte-array for the new ByteArraySegment to contain</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.#ctor(System.Byte[],System.Int32)">
            <summary>
            Create a new ByteArraySegment containing the given byte-array buffer with the given offset.
            </summary>
            <param name="buffer">the byte-array for the new ByteArraySegment to contain</param>
            <param name="offset">the value for the Offset property</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.#ctor(NetMQ.Core.Transports.ByteArraySegment)">
            <summary>
            Create a new ByteArraySegment that is a shallow-copy of the given ByteArraySegment (with a reference to the same buffer).
            </summary>
            <param name="otherSegment">the source-ByteArraySegment to make a copy of</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.#ctor(NetMQ.Core.Transports.ByteArraySegment,System.Int32)">
            <summary>
            Create a new ByteArraySegment that is a shallow-copy of the given ByteArraySegment (with a reference to the same buffer)
            but with a different offset.
            </summary>
            <param name="otherSegment">the source-ByteArraySegment to make a copy of</param>
            <param name="offset">a value for the Offset property that is distinct from that of the source ByteArraySegment</param>
        </member>
        <member name="P:NetMQ.Core.Transports.ByteArraySegment.Size">
            <summary>
            Get the number of bytes within the buffer that is past the Offset (ie, buffer-length minus offset).
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.AdvanceOffset(System.Int32)">
            <summary>
            Add the given value to the offset.
            </summary>
            <param name="delta">the delta value to add to the offset.</param>
        </member>
        <member name="P:NetMQ.Core.Transports.ByteArraySegment.Offset">
            <summary>
            Get the offset into the buffer.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.PutLong(NetMQ.Endianness,System.Int64,System.Int32)">
            <summary>
            Write the given 64-bit value into the buffer, at the position marked by the offset plus the given index i.
            </summary>
            <param name="endian">an Endianness to specify in which order to write the bytes</param>
            <param name="value">the 64-bit value to write into the byte-array buffer</param>
            <param name="i">the index position beyond the offset to start writing the bytes</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.PutUnsignedShort(NetMQ.Endianness,System.UInt16,System.Int32)">
            <summary>
            Write the given 16-bit value into the buffer, at the position marked by the offset plus the given index i.
            </summary>
            <param name="endian">an Endianness to specify in which order to write the bytes</param>
            <param name="value">the 16-bit value to write into the byte-array buffer</param>
            <param name="i">the index position beyond the offset to start writing the bytes</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.PutInteger(NetMQ.Endianness,System.Int32,System.Int32)">
            <summary>
            Write the given 32-bit value into the buffer, at the position marked by the offset plus the given index i.
            </summary>
            <param name="endian">an Endianness to specify in which order to write the bytes</param>
            <param name="value">the 32-bit value to write into the byte-array buffer</param>
            <param name="i">the index position beyond the offset to start writing the bytes</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.PutString(System.String,System.Int32,System.Int32)">
            <summary>
            Encode the given String into a byte-array using the ASCII encoding
            and write that into the buffer.
            </summary>
            <param name="s">the String to write to the buffer</param>
            <param name="length">the number of encoded bytes to copy into the buffer</param>
            <param name="i">an index-offset, in addition to the Offset property, that marks where in the buffer to start writing bytes to</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.PutString(System.String,System.Int32)">
            <summary>
            Encode the given String into a byte-array using the ASCII encoding
            and write that into the buffer.
            </summary>
            <param name="s">the String to write to the buffer</param>
            <param name="i">an index-offset, in addition to the Offset property, that marks where in the buffer to start writing bytes to</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.GetLong(NetMQ.Endianness,System.Int32)">
            <summary>
            Return a 64-bit numeric value that is read from the buffer, starting at the position marked by the offset plus the given index i,
            based upon the given byte-ordering.
            </summary>
            <param name="endian">an Endianness to specify which byte-ordering to use to interpret the source bytes</param>
            <param name="i">the index position beyond the offset to start reading the bytes</param>
            <returns>a long that is read from the bytes of the buffer</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.GetUnsignedLong(NetMQ.Endianness,System.Int32)">
            <summary>
            Return a 64-bit unsigned numeric value (ulong) that is read from the buffer, starting at the position marked by the offset plus the given index i,
            based upon the given byte-ordering.
            </summary>
            <param name="endian">an Endianness to specify which byte-ordering to use to interpret the source bytes</param>
            <param name="i">the index position beyond the offset to start reading the bytes</param>
            <returns>an unsigned long that is read from the bytes of the buffer</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.GetInteger(NetMQ.Endianness,System.Int32)">
            <summary>
            Return a 32-bit integer that is read from the buffer, starting at the position marked by the offset plus the given index i,
            based upon the given byte-ordering.
            </summary>
            <param name="endian">an Endianness to specify which byte-ordering to use to interpret the source bytes</param>
            <param name="i">the index position beyond the offset to start reading the bytes</param>
            <returns>an integer that is read from the bytes of the buffer</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.GetUnsignedShort(NetMQ.Endianness,System.Int32)">
            <summary>
            Return a 16-bit unsigned integer (ushort) value that is read from the buffer, starting at the position marked by the offset plus the given index i,
            based upon the given byte-ordering.
            </summary>
            <param name="endian">an Endianness to specify which byte-ordering to use to interpret the source bytes</param>
            <param name="i">the index position beyond the offset to start reading the bytes</param>
            <returns>a ushort that is read from the bytes of the buffer</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.GetString(System.Int32,System.Int32)">
            <summary>
            Return a String that is read from the byte-array buffer, decoded using the ASCII encoding,
            starting at the position marked by the offset plus the given index i.
            </summary>
            <param name="length">the length of the part of the buffer to read</param>
            <param name="i">the index position beyond the offset to start reading the bytes</param>
            <returns>a String decoded from the bytes of the buffer</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.CopyTo(NetMQ.Core.Transports.ByteArraySegment,System.Int32)">
            <summary>
            Write the bytes of this ByteArraySegment to the specified destination-ByteArraySegment.
            </summary>
            <param name="otherSegment">the destination-ByteArraySegment</param>
            <param name="toCopy">the number of bytes to copy</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.CopyTo(System.Int32,NetMQ.Core.Transports.ByteArraySegment,System.Int32,System.Int32)">
            <summary>
            Write the bytes of this ByteArraySegment to the specified destination-ByteArraySegment.
            </summary>
            <param name="fromOffset">an offset within this source buffer to start copying from</param>
            <param name="dest">the destination-ByteArraySegment</param>
            <param name="destOffset">an offset within the destination buffer to start copying to</param>
            <param name="toCopy">the number of bytes to copy</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.Clone">
            <summary>
            Return a shallow-copy of this ByteArraySegment.
            </summary>
            <returns>a new ByteArraySegment that is a shallow-copy of this one</returns>
        </member>
        <member name="P:NetMQ.Core.Transports.ByteArraySegment.Item(System.Int32)">
            <summary>
            Get or set the byte of the buffer at the i-th index position (zero-based).
            </summary>
            <param name="i">the index of the byte to access</param>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.Reset">
            <summary>
            Set the offset to zero.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.op_Addition(NetMQ.Core.Transports.ByteArraySegment,System.Int32)">
            <summary>
            Return a new ByteArraySegment that has the data of this one, but with the given offset.
            </summary>
            <param name="byteArray">the source-ByteArraySegment</param>
            <param name="offset">the offset-value to give the new ByteArraySegment</param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.op_Implicit(System.Byte[])~NetMQ.Core.Transports.ByteArraySegment">
            <summary>
            Return a new ByteArraySegment that contains the given byte-array buffer.
            </summary>
            <param name="buffer">the source byte-array buffer</param>
            <returns>a new ByteArraySegment that contains the given buffer</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.op_Explicit(NetMQ.Core.Transports.ByteArraySegment)~System.Byte[]">
            <summary>
            Return the byte-array buffer of this ByteArraySegment.
            </summary>
            <param name="buffer">the source-ByteArraySegment</param>
            <returns>the byte-array that is the buffer of this ByteArraySegment</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.ByteArraySegment.Equals(System.Object)">
            <summary>
            Return true if the given Object is a ByteArraySegment and has the same buffer and offset.
            </summary>
            <param name="otherObject">an Object to compare for equality to this one</param>
            <returns>true only if the otherObject has the same buffer and offset</returns>
            <remarks>
            The given Object is considered to be Equal if it also is a ByteArraySegment,
            and has the same Offset property value
            and it's buffer points to the SAME byte-array as the otherObject does.
            </remarks>
        </member>
        <member name="T:NetMQ.Core.Transports.DecoderBase">
             <summary>
             Helper base class for decoders that know the amount of data to read
             in advance at any moment.
             This class is the state machine that parses the incoming buffer.
             Derived classes should implement individual state machine actions.
             </summary>
             <remarks>
             Knowing the amount in advance is a property
             of the protocol used. 0MQ framing protocol is based size-prefixed
             paradigm, which qualifies it to be parsed by this class.
            
             On the other hand, XML-based transports (like XMPP or SOAP) don't allow
             for knowing the size of data to read in advance and should use different
             decoding algorithms.
             </remarks>
        </member>
        <member name="F:NetMQ.Core.Transports.DecoderBase.m_readPos">
            <summary>
            Where to store the read data.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.DecoderBase.m_toRead">
            <summary>
            How much data to read before taking next step.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.DecoderBase.m_bufsize">
            <summary>
            The buffer for data to decode.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.DecoderBase.Stalled">
            <summary>
            Returns true if the decoder has been fed all required data
            but cannot proceed with the next decoding step.
            False is returned if the decoder has encountered an error.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.DecoderBase.GetBuffer(NetMQ.Core.Transports.ByteArraySegment@,System.Int32@)">
            <summary>
            Returns a buffer to be filled with binary data.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.DecoderBase.ProcessBuffer(NetMQ.Core.Transports.ByteArraySegment,System.Int32)">
            <summary>
            Processes the data in the buffer previously allocated using
            get_buffer function. size argument specifies the number of bytes
            actually filled into the buffer. Function returns number of
            bytes actually processed.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.EncoderBase.m_writePos">
            <summary>
            Where to get the data to write from.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.EncoderBase.m_beginning">
            <summary>
            If true, first byte of the message is being written.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.EncoderBase.m_toWrite">
            <summary>
            How much data to write before the next step should be executed.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.EncoderBase.m_buffer">
            <summary>
            The buffer for encoded data.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.EncoderBase.m_bufferSize">
            <summary>
            The size of the encoded-data buffer
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.EncoderBase.m_error">
            <summary>
            This flag indicates whether there has been an encoder error.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.EncoderBase.#ctor(System.Int32,NetMQ.Endianness)">
            <summary>
            Create a new EncoderBase with a buffer of the given size.
            </summary>
            <param name="bufferSize">how big of an internal buffer to allocate (in bytes)</param>
            <param name="endian">the <see cref="T:NetMQ.Endianness"/> to set this EncoderBase to</param>
        </member>
        <member name="P:NetMQ.Core.Transports.EncoderBase.Endian">
            <summary>
            Get the Endianness (Big or Little) that this EncoderBase uses.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.EncoderBase.GetData(NetMQ.Core.Transports.ByteArraySegment@,System.Int32@)">
            <summary>
            This returns a batch of binary data. The data
            are filled to a supplied buffer. If no buffer is supplied (data_
            points to NULL) decoder object will provide buffer of its own.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.EncoderBase.EncodingError">
            <summary>
            Set a flag that indicates that there has been an encoding-error.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.EncoderBase.IsError">
            <summary>
            Return true if there has been an encoding error.
            </summary>
            <returns>the state of the error-flag</returns>
        </member>
        <member name="T:NetMQ.Core.Transports.IEncoder">
            <summary>
            Interface IEncoder mandates SetMsgSource and GetData methods.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.IEncoder.SetMsgSource(NetMQ.Core.IMsgSource)">
            <summary>
            Set message producer.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.IEncoder.GetData(NetMQ.Core.Transports.ByteArraySegment@,System.Int32@)">
            <summary>
            Get a ByteArraySegment of binary data. The data
            are filled to a supplied buffer. If no buffer is supplied (data is null)
            encoder will provide buffer of its own.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Transports.IEngine">
            <summary>
            Abstract interface to be implemented by various engines.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.IEngine.Plug(NetMQ.Core.IOThread,NetMQ.Core.SessionBase)">
            <summary>
            Plug the engine to the session.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.IEngine.Terminate">
            <summary>
            Terminate and deallocate the engine. Note that 'detached'
            events are not fired on termination.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.IEngine.ActivateIn">
            <summary>
            This method is called by the session to signal that more
            messages can be written to the pipe.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.IEngine.ActivateOut">
            <summary>
            This method is called by the session to signal that there
            are messages to send available.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Transports.Ipc.IpcConnector">
            <summary>
            IpcConnecter is a subclass of TcpConnector, which provides absolutely nothing beyond what TcpConnector does.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Transports.Ipc.IpcListener">
            <summary>
            An IpcListener is a TcpListener that also has an Address property and a SetAddress method.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Ipc.IpcListener.#ctor(NetMQ.Core.IOThread,NetMQ.Core.SocketBase,NetMQ.Core.Options)">
            <summary>
            Create a new IpcListener with the given IOThread, socket, and Options.
            </summary>
            <param name="ioThread"></param>
            <param name="socket">the SocketBase to listen to</param>
            <param name="options">an Options value that dictates the settings for this IpcListener</param>
        </member>
        <member name="P:NetMQ.Core.Transports.Ipc.IpcListener.Address">
            <summary>
            Get the bound address for use with wildcards
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Ipc.IpcListener.SetAddress(System.String)">
            <summary>
            Set address to listen on.
            </summary>
            <param name="addr">a string denoting the address to listen to</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmAddress.#ctor(System.String)">
            <exception cref="T:NetMQ.InvalidException">Unable to parse the address's port number, or the IP address could not be parsed.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmAddress.Resolve(System.String,System.Boolean)">
            <exception cref="T:NetMQ.InvalidException">Unable to parse the address's port number, or the IP address could not be parsed.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmListener.Init(System.String)">
            <exception cref="T:NetMQ.InvalidException">Unable to parse the address's port number, or the IP address could not be parsed.</exception>
            <exception cref="T:NetMQ.NetMQException">Error establishing underlying socket.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmListener.ProcessTerm(System.Int32)">
            <summary>
            Process a termination request.
            </summary>
            <param name="linger">a time (in milliseconds) for this to linger before actually going away. -1 means infinite.</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmListener.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is called when a message receive operation has been completed.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmListener.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method would be called when a message Send operation has been completed, although here it only throws a NotSupportedException.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on the PgmListener class.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmListener.TimerEvent(System.Int32)">
            <summary>
            This would be called when the a expires, although here it only throws a NotSupportedException.
            </summary>
            <param name="id">an integer used to identify the timer (not used here)</param>
            <exception cref="T:System.NotSupportedException">This operation is not supported on the PgmListener class.</exception>
        </member>
        <member name="F:NetMQ.Core.Transports.Pgm.PgmSender.ReconnectTimerId">
            <summary>
            ID of the timer used to delay the reconnection. Value is 1.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSender.TimerEvent(System.Int32)">
            <summary>
            This would be called when a timer expires, although here it only throws a NotSupportedException.
            </summary>
            <param name="id">an integer used to identify the timer (not used here)</param>
            <exception cref="T:System.NotImplementedException">This method must not be called on instances of PgmSender.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSender.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is called when a message Send operation has been completed.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:NetMQ.NetMQException">A non-recoverable socket error occurred.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSender.GetNewReconnectIvl">
            <summary>
            Internal function to return a reconnect back-off delay.
            Will modify the current_reconnect_ivl used for next call
            Returns the currently used interval
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSender.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method would be called when a message receive operation has been completed, although here it only throws a NotSupportedException.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:System.NotImplementedException">This method must not be called on instances of PgmSender.</exception>
        </member>
        <member name="T:NetMQ.Core.Transports.Pgm.PgmSession.State">
            <summary>
            This enum-type is Idle, Receiving, Stuck, or Error.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSession.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is be called when a message receive operation has been completed.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSession.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method would be called when a message Send operation has been completed, except in this case this method does nothing.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSession.TimerEvent(System.Int32)">
            <summary>
            This would be called when a timer expires, although here it does nothing.
            </summary>
            <param name="id">an integer used to identify the timer (not used here)</param>
        </member>
        <member name="T:NetMQ.Core.Transports.Pgm.PgmSocketType">
            <summary>
            This enum-type denotes the type of Pragmatic General Multicast (PGM) socket.
            Publisher, Receiver, or Listener.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Transports.Pgm.PgmSocket">
            <summary>
            A PgmSocket utilizes the Pragmatic General Multicast (PGM) multicast protocol, which is also referred to as "reliable multicast".
            This is only supported on Windows when Microsoft Message Queueing (MSMQ) is installed.
            See RFC 3208.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Pgm.PgmSocket.RM_RATE_WINDOW_SIZE">
            <summary>
            Set/Query rate (Kb/Sec) + window size (Kb and/or MSec) -- described by RM_SEND_WINDOW below
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Pgm.PgmSocket.RM_SET_SEND_IF">
            <summary>
            set IP multicast outgoing interface
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Pgm.PgmSocket.RM_ADD_RECEIVE_IF">
            <summary>
            add IP multicast incoming interface
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Pgm.PgmSocket.RM_SET_MCAST_TTL">
            <summary>
            Set the Time-To-Live (TTL) of the MCast packets -- (ULONG)
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSocket.Init">
            <summary>
            Perform initialization of this PgmSocket, including creating the socket handle.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Pgm.PgmSocket.ToString">
            <summary>
            Override the ToString method to produce a more descriptive, useful description.
            </summary>
            <returns>a useful description of this object's state</returns>
        </member>
        <member name="T:NetMQ.Core.Transports.StreamEngine.State">
            <summary>
            This enum-type denotes the operational state of this StreamEngine - whether Closed, doing Handshaking, Active, or Stalled.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.StreamEngine.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is be called when a message receive operation has been completed.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
        </member>
        <member name="M:NetMQ.Core.Transports.StreamEngine.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is called when a message Send operation has been completed.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
        </member>
        <member name="M:NetMQ.Core.Transports.StreamEngine.EndWrite(System.Net.Sockets.SocketError,System.Int32)">
            <param name="socketError">the SocketError that resulted from the write - which could be Success (no error at all)</param>
            <param name="bytesTransferred">this indicates the number of bytes that were transferred in the write</param>
            <returns>the number of bytes transferred if successful, -1 otherwise</returns>
            <exception cref="T:NetMQ.NetMQException">If the socketError is not Success then it must be a valid recoverable error or the number of bytes transferred must be zero.</exception>
            <remarks>
            If socketError is SocketError.Success and bytesTransferred is > 0, then this returns bytesTransferred.
            If bytes is zero, or the socketError is one of NetworkDown, NetworkReset, HostUn, Connection Aborted, TimedOut, or ConnectionReset, - then -1 is returned.
            Otherwise, a NetMQException is thrown.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Transports.StreamEngine.EndRead(System.Net.Sockets.SocketError,System.Int32)">
            <param name="socketError">the SocketError that resulted from the read - which could be Success (no error at all)</param>
            <param name="bytesTransferred">this indicates the number of bytes that were transferred in the read</param>
            <returns>the number of bytes transferred if successful, -1 otherwise</returns>
            <exception cref="T:NetMQ.NetMQException">If the socketError is not Success then it must be a valid recoverable error or the number of bytes transferred must be zero.</exception>
            <remarks>
            If socketError is SocketError.Success and bytesTransferred is > 0, then this returns bytesTransferred.
            If bytes is zero, or the socketError is one of NetworkDown, NetworkReset, HostUn, Connection Aborted, TimedOut, or ConnectionReset, - then -1 is returned.
            Otherwise, a NetMQException is thrown.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Transports.StreamEngine.TimerEvent(System.Int32)">
            <summary>
            This would be called when a timer expires, although here it only throws NotSupportedException.
            </summary>
            <param name="id">an integer used to identify the timer (not used here)</param>
            <exception cref="T:System.NotSupportedException">TimerEvent is not supported on StreamEngine.</exception>
        </member>
        <member name="T:NetMQ.Core.Transports.Tcp.TcpAddress">
            <summary>
            A TcpAddress implements IZAddress, and contains an IPEndPoint (the Address property)
            and a Protocol property.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpAddress.ToString">
            <summary>
            Override ToString to provide a detailed description of this object's state
            in the form:  Protocol://[AddressFamily]:Port
            </summary>
            <returns>a string in the form Protocol://[AddressFamily]:Port</returns>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpAddress.Resolve(System.String,System.Boolean)">
            <summary>
            Given a string that should identify an endpoint-address, resolve it to an actual IP address
            and set the Address property to a valid corresponding value.
            </summary>
            <param name="name">the endpoint-address to resolve</param>
            <param name="ip4Only">whether the address must be only-IPv4</param>
            <exception cref="T:NetMQ.InvalidException">The name must contain the colon delimiter.</exception>
            <exception cref="T:NetMQ.InvalidException">The specified port must be a valid nonzero integer.</exception>
            <exception cref="T:NetMQ.InvalidException">Must be able to find the IP-address.</exception>
        </member>
        <member name="P:NetMQ.Core.Transports.Tcp.TcpAddress.Address">
            <summary>
            Get the Address implementation - which here is an IPEndPoint,
            which contains Address, AddressFamily, and Port properties.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Transports.Tcp.TcpAddress.Protocol">
            <summary>
            Get the textual-representation of the communication protocol implied by this TcpAddress,
            which here is simply "tcp".
            </summary>
        </member>
        <member name="T:NetMQ.Core.Transports.Tcp.TcpConnector">
            <summary>
            If 'delay' is true connector first waits for a while, then starts connection process.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.ReconnectTimerId">
            <summary>
            ID of the timer used to delay the reconnection. Value is 1.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_addr">
            <summary>
            Address to connect to. Owned by session_base_t.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_s">
            <summary>
            The underlying AsyncSocket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_handleValid">
            <summary>
            If true file descriptor is registered with the poller and 'handle'
            contains valid value.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_delayedStart">
            <summary>
            If true, connector is waiting a while before trying to connect.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_timerStarted">
            <summary>
            True if a timer has been started.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_session">
            <summary>
            Reference to the session we belong to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_currentReconnectIvl">
            <summary>
            Current reconnect-interval. This gets updated for back-off strategy.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_endpoint">
            <summary>
            String representation of endpoint to connect to
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpConnector.m_socket">
            <summary>
            Socket
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.#ctor(NetMQ.Core.IOThread,NetMQ.Core.SessionBase,NetMQ.Core.Options,NetMQ.Core.Address,System.Boolean)">
            <summary>
            Create a new TcpConnector object.
            </summary>
            <param name="ioThread">the I/O-thread for this TcpConnector to live on.</param>
            <param name="session">the session that will contain this</param>
            <param name="options">Options that define this new TcpC</param>
            <param name="addr">the Address for this Tcp to connect to</param>
            <param name="delayedStart">this boolean flag dictates whether to wait before trying to connect</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.Destroy">
            <summary>
            This does nothing.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.ProcessPlug">
            <summary>
            Begin connecting.  If a delayed-start was specified - then the reconnect-timer is set, otherwise this starts immediately.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.ProcessTerm(System.Int32)">
            <summary>
            Process a termination request.
            This cancels the reconnect-timer, closes the AsyncSocket, and marks the socket-handle as invalid.
            </summary>
            <param name="linger">a time (in milliseconds) for this to linger before actually going away. -1 means infinite.</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method would be called when a message receive operation has been completed, although here it only throws a NotImplementedException.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:System.NotImplementedException">InCompleted must not be called on a TcpConnector.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.StartConnecting">
            <summary>
            Internal function to start the actual connection establishment.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method is called when a message Send operation has been completed.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:NetMQ.NetMQException">A non-recoverable socket error occurred.</exception>
            <exception cref="T:NetMQ.NetMQException">If the socketError is not Success then it must be a valid recoverable error.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.TimerEvent(System.Int32)">
            <summary>
            This is called when the timer expires - to start trying to connect.
            </summary>
            <param name="id">The timer-id. This is not used.</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.AddReconnectTimer">
            <summary>
            Internal function to add a reconnect timer
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.GetNewReconnectIvl">
            <summary>
            Internal function to return a reconnect back-off delay.
            Will modify the current_reconnect_ivl used for next call
            Returns the currently used interval
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpConnector.Close">
            <summary>
            Close the connecting socket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpListener.m_address">
            <summary>
            Address to listen on.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpListener.m_handle">
            <summary>
            Underlying socket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpListener.m_socket">
            <summary>
            Socket the listener belongs to.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpListener.m_endpoint">
            <summary>
            String representation of endpoint to bind to
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.Tcp.TcpListener.m_port">
            <summary>
            The port that was bound on
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.#ctor(NetMQ.Core.IOThread,NetMQ.Core.SocketBase,NetMQ.Core.Options)">
            <summary>
            Create a new TcpListener on the given IOThread and socket.
            </summary>
            <param name="ioThread">the IOThread for this to live within</param>
            <param name="socket">a SocketBase to listen on</param>
            <param name="options">socket-related Options</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.Destroy">
            <summary>
            Release any contained resources (here - does nothing).
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.ProcessTerm(System.Int32)">
            <summary>
            Process a termination request.
            </summary>
            <param name="linger">a time (in milliseconds) for this to linger before actually going away. -1 means infinite.</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.SetAddress(System.String)">
            <summary>
            Set address to listen on.
            </summary>
            <param name="addr">a string denoting the address to set this to</param>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.InCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This is called when socket input has been completed.
            </summary>
            <param name="socketError">This indicates the status of the input operation - whether Success or some error.</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:NetMQ.NetMQException">A non-recoverable socket-error occurred.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.Close">
            <summary>
            Close the listening socket.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Transports.Tcp.TcpListener.Address">
            <summary>
            Get the bound address for use with wildcards
            </summary>
        </member>
        <member name="P:NetMQ.Core.Transports.Tcp.TcpListener.Port">
            <summary>
            Get the port-number to listen on.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.NetMQ#Core#IProactorEvents#OutCompleted(System.Net.Sockets.SocketError,System.Int32)">
            <summary>
            This method would be called when a message Send operation has been completed - except in this case it simply throws a NotImplementedException.
            </summary>
            <param name="socketError">a SocketError value that indicates whether Success or an error occurred</param>
            <param name="bytesTransferred">the number of bytes that were transferred</param>
            <exception cref="T:System.NotImplementedException">OutCompleted is not implemented on TcpListener.</exception>
        </member>
        <member name="M:NetMQ.Core.Transports.Tcp.TcpListener.TimerEvent(System.Int32)">
            <summary>
            This would be called when a timer expires, although here it only throws a NotSupportedException.
            </summary>
            <param name="id">an integer used to identify the timer (not used here)</param>
            <exception cref="T:System.NotSupportedException">TimerEvent is not supported on TcpListener.</exception>
        </member>
        <member name="F:NetMQ.Core.Transports.V1Decoder.m_maxMessageSize">
            <summary>
            The maximum message-size. If this is -1 then there is no maximum.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.V1Decoder.#ctor(System.Int32,System.Int64,NetMQ.Endianness)">
            <summary>
            Create a new V1Decoder with the given buffer-size, maximum-message-size and Endian-ness.
            </summary>
            <param name="bufsize">the buffer-size to give the contained buffer</param>
            <param name="maxMessageSize">the maximum message size. -1 indicates no limit.</param>
            <param name="endian">the Endianness to specify for it - either Big or Little</param>
        </member>
        <member name="M:NetMQ.Core.Transports.V1Decoder.SetMsgSink(NetMQ.Core.IMsgSink)">
            <summary>
            Set the receiver of decoded messages.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Transports.V2Decoder.SetMsgSink(NetMQ.Core.IMsgSink)">
            <summary>
            Set the receiver of decoded messages.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Transports.V2Encoder">
            <summary>
            Encoder for 0MQ framing protocol. Converts messages into data stream.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Transports.V2Protocol">
            <summary>
            V2Protocol is a class that contains two integer constants: MoreFlag and LargeFlag.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.V2Protocol.MoreFlag">
            <summary>
            This is a constant-integer with the value 1.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Transports.V2Protocol.LargeFlag">
            <summary>
            This is a constant-integer with the value 2.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Utils.AtomicCounter">
            <summary>
            This class simply provides a counter-value, which may be set, increased, and decremented.
            Increase and Decrement are both thread-safe operations.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.AtomicCounter.#ctor">
            <summary>
            Create a new AtomicCounter object with an initial counter-value of zero.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.AtomicCounter.Set(System.Int32)">
            <summary>
            Assign the given amount to the counter-value.
            </summary>
            <param name="amount">the integer value to set the counter to</param>
        </member>
        <member name="M:NetMQ.Core.Utils.AtomicCounter.Increase(System.Int32)">
            <summary>
            Add the given amount to the counter-value, in an atomic thread-safe manner.
            </summary>
            <param name="amount">the integer amount to add to the counter-value</param>
        </member>
        <member name="M:NetMQ.Core.Utils.AtomicCounter.Decrement(System.Int32)">
            <summary>
            Subtract the given amount from the counter-value, in an atomic thread-safe manner.
            </summary>
            <param name="amount">the integer amount to subtract from to the counter-value (default value is 1)</param>
            <returns>the new value of the counter</returns>
        </member>
        <member name="T:NetMQ.Core.Utils.ByteArrayEqualityComparer">
            <summary>
            Class ByteArrayEqualityComparer is an IEqualityComparer for byte-arrays,
            and provides an Equals methods to compare two byte-arrays for equality in value
            and GetHashCode.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.ByteArrayEqualityComparer.Equals(System.Byte[],System.Byte[])">
            <summary>
            Return true only if the two byte-arrays are equal in length and contain the same values.
            </summary>
            <param name="x">one of the two byte-arrays to compare</param>
            <param name="y">the other byte-array to compare against</param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Core.Utils.ByteArrayEqualityComparer.GetHashCode(System.Byte[])">
            <summary>
            Return a numeric hashcode of the given byte-array.
            </summary>
            <param name="data">the given byte-array to compute the hashcode of</param>
            <returns>an integer that contains a hashcode computed over the byte-array</returns>
        </member>
        <member name="T:NetMQ.Core.Utils.Clock">
            <summary>
            The Clock class provides properties for getting timer-counts in either milliseconds or microseconds,
            and the CPU's timestamp-counter if available.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Clock.s_lastTsc">
            <summary>
            TSC timestamp of when last time measurement was made.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Clock.s_lastTime">
            <summary>
            Physical time corresponding to the TSC above (in milliseconds).
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Clock.s_rdtscSupported">
            <summary>
            This flag indicates whether the rdtsc instruction is supported on this platform.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.Clock.NowUs">
            <summary>
            Return the High-Precision timestamp, as a 64-bit integer that denotes microseconds.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.Clock.NowMs">
            <summary>
            Return the Low-Precision timestamp, as a 64-bit integer denoting milliseconds.
            In tight loops generating it can be 10 to 100 times faster than the High-Precision timestamp.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.Clock.Rdtsc">
            <summary>
            Return the CPU's timestamp counter, or 0 if it's not available.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Utils.Poller.PollSet">
            <summary>
            A PollSet contains a single Socket and an IPollEvents Handler
            that provides methods that signal when that socket is ready for reading or writing.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Utils.Poller.PollSet.Socket">
            <summary>
            Get the Socket that this PollSet contains.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Utils.Poller.PollSet.Handler">
            <summary>
            Get the IPollEvents object that has methods to signal when ready for reading or writing.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Utils.Poller.PollSet.Cancelled">
            <summary>
            Get or set whether this PollSet is cancelled.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.PollSet.#ctor(System.Net.Sockets.Socket,NetMQ.Core.IPollEvents)">
            <summary>
            Create a new PollSet object to hold the given Socket and IPollEvents handler.
            </summary>
            <param name="socket">the Socket to contain</param>
            <param name="handler">the IPollEvents to signal when ready for reading or writing</param>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_handles">
            <summary>
            This is the list of registered descriptors (PollSets).
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_addList">
            <summary>
            List of sockets to add at the start of the next loop
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_retired">
            <summary>
            If true, there's at least one retired event source.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_stopping">
            <summary>
            This flag is used to tell the polling-loop thread to shut down,
            wherein it will stop at the end of it's current loop iteration.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_stopped">
            <summary>
            This indicates whether the polling-thread is not presently running. Default is true.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_workerThread">
            <summary>
            This is the background-thread that performs the polling-loop.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_name">
            <summary>
            This is the name associated with this Poller.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_checkRead">
            <summary>
            The set of Sockets to check for read-readiness.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.Poller.m_checkError">
            <summary>
            The set of Sockets to check for any errors.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.#ctor(System.String)">
            <summary>
            Create a new Poller object with the given name.
            </summary>
            <param name="name">a name to assign to this Poller</param>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.Destroy">
            <summary>
            Unless the polling-loop is already stopped,
            tell it to stop at the end of the current polling iteration, and wait for that thread to finish.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.AddHandle(System.Net.Sockets.Socket,NetMQ.Core.IPollEvents)">
            <summary>
            Add a new PollSet containing the given Socket and IPollEvents at the next iteration through the loop,
            and also add the Socket to the list of those to check for errors.
            </summary>
            <param name="handle">the Socket to add</param>
            <param name="events">the IPollEvents to include in the new PollSet to add</param>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.RemoveHandle(System.Net.Sockets.Socket)">
            <summary>
            Remove the given Socket from this Poller.
            </summary>
            <param name="handle">the System.Net.Sockets.Socket to remove</param>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.SetPollIn(System.Net.Sockets.Socket)">
            <summary>
            Add the given Socket to the list to be checked for read-readiness at each poll-iteration.
            </summary>
            <param name="handle">the Socket to add</param>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.Start">
            <summary>
            Begin running the polling-loop, on a background thread.
            </summary>
            <remarks>
            The name of that background-thread is the same as the name of this Poller object.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.Stop">
            <summary>
            Signal that we want to stop the polling-loop.
            This method returns immediately - it does not wait for the polling thread to stop.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.Poller.Loop">
            <summary>
            This method is the polling-loop that is invoked on a background thread when Start is called.
            As long as Stop hasn't been called: execute the timers, and invoke the handler-methods on each of the saved PollSets.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Utils.PollerBase">
            <summary>
            This serves as the parent-class for Poller and Proactor.
            It provides for managing a list of timers (ITimerEvents) - adding, cancelling, and executing them,
            and a Load property.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.PollerBase.m_load">
            <summary>
            Load of the poller. Currently the number of file descriptors registered.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Utils.PollerBase.TimerInfo">
            <summary>
            Instances of this class contain a ITimerEvent sink and an integer Id.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.PollerBase.TimerInfo.#ctor(NetMQ.Core.ITimerEvent,System.Int32)">
            <summary>
            Create a new TimerInfo object from the given sink and id.
            </summary>
            <param name="sink">an ITimerEvent that acts as a sink for when the timer expires</param>
            <param name="id">an integer id that identifies this timer</param>
        </member>
        <member name="P:NetMQ.Core.Utils.PollerBase.TimerInfo.Sink">
            <summary>
            Get the ITimerEvent that serves as the event-sink.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Utils.PollerBase.TimerInfo.Id">
            <summary>
            Get the integer Id of this TimerInfo.
            </summary>
        </member>
        <member name="F:NetMQ.Core.Utils.PollerBase.m_timers">
            <summary>
            This is a list of key/value pairs, with the keys being timeout numbers and the corresponding values being a list of TimerInfo objects.
            It is sorted by the keys - which are timeout values. Thus, by walking down the list, you encounter the soonest timeouts first.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.PollerBase.#ctor">
            <summary>
            Create a new PollerBase object - which simply creates an empty m_timers collection.
            </summary>
        </member>
        <member name="P:NetMQ.Core.Utils.PollerBase.Load">
            <summary>
            Get the load of this poller. Note that this function can be
            invoked from a different thread!
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.PollerBase.AdjustLoad(System.Int32)">
            <summary>
            Add the given amount to the load.
            This is called by individual poller implementations to manage the load.
            </summary>
            <remarks>
            This is thread-safe.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Utils.PollerBase.AddTimer(System.Int64,NetMQ.Core.IProactorEvents,System.Int32)">
            <summary>
            Add a <see cref="T:NetMQ.Core.Utils.PollerBase.TimerInfo"/> to the internal list, created from the given sink and id - to expire in the given number of milliseconds.
            Afterward the expiration method TimerEvent on the sink object will be called with argument set to id.
            </summary>
            <param name="timeout">the timeout-period in milliseconds of the new timer</param>
            <param name="sink">the IProactorEvents to add for the sink of the new timer</param>
            <param name="id">the Id to assign to the new TimerInfo</param>
        </member>
        <member name="M:NetMQ.Core.Utils.PollerBase.CancelTimer(NetMQ.Core.ITimerEvent,System.Int32)">
            <summary>
            Cancel the timer that was created with the given sink object with the given Id.
            </summary>
            <param name="sink">the ITimerEvent that the timer was created with</param>
            <param name="id">the Id of the timer to cancel</param>
            <remarks>
            The complexity of this operation is O(n). We assume it is rarely used.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Utils.PollerBase.ExecuteTimers">
            <summary>
            Execute any timers that are due. Return the number of milliseconds
            to wait to match the next timer or 0 meaning "no timers".
            </summary>
            <returns>the time to wait for the next timer, in milliseconds, or zero if there are no more timers</returns>
        </member>
        <member name="M:NetMQ.Core.Utils.Proactor.Loop">
            <exception cref="T:System.ArgumentOutOfRangeException">The completionStatuses item must have a valid OperationType.</exception>
        </member>
        <member name="M:NetMQ.Core.Utils.Signaler.Close">
            <summary>
            Close the read and write sockets.
            </summary>
        </member>
        <member name="T:NetMQ.Core.Utils.SocketUtility">
            <summary>
            This class exists only to provide a wrapper for the Socket.Select method,
            such that the call may be handled slightly differently on .NET 3.5 as opposed to later versions.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.SocketUtility.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
             <summary>
             Determine the status of one or more sockets.
             After returning, the lists will be filled with only those sockets that satisfy the conditions.
             </summary>
             <param name="checkRead">a list of Sockets to check for readability</param>
             <param name="checkWrite">a list of Sockets to check for writability</param>
             <param name="checkError">a list of Sockets to check for errors</param>
             <param name="microSeconds">a timeout value, in microseconds. A value of -1 indicates an infinite timeout.</param>
             <remarks>
             If you are in a listening state, readability means that a call to Accept will succeed without blocking.
             If you have already accepted the connection, readability means that data is available for reading. In these cases,
             all receive operations will succeed without blocking. Readability can also indicate whether the remote Socket
             has shut down the connection - in which case a call to Receive will return immediately, with zero bytes returned.
            
             Select returns when at least one of the sockets of interest (ie any of the sockets in the checkRead, checkWrite, or checkError
             lists) meets its specified criteria, or the microSeconds parameter is exceeded - whichever comes first.
             Setting microSeconds to -1 specifies an infinite timeout.
            
             If you make a non-blocking call to Connect, writability means that you have connected successfully. If you already
             have a connection established, writability means that all send operations will succeed without blocking.
             If you have made a non-blocking call to Connect, the checkError parameter identifies sockets that have not connected successfully.
            
             See this reference for further details of the operation of the Socket.Select method:
             https://msdn.microsoft.com/en-us/library/system.net.sockets.socket.select(v=vs.110).aspx
            
             This may possibly throw an ArgumentNullException, if all three lists are null or empty,
             and a SocketException if an error occurred when attempting to access a socket.
            
             Use the Poll method if you only want to determine the status of a single Socket.
            
             This method cannot detect certain kinds of connection problems,
             such as a broken network cable, or that the remote host was shut down ungracefully.
             You must attempt to send or receive data to detect these kinds of errors.
             </remarks>
             <exception cref="T:System.ArgumentNullException">none of the three lists of sockets may be null.</exception>
             <exception cref="T:System.Net.Sockets.SocketException">an error occurred when attempting to access the socket.</exception>
        </member>
        <member name="T:NetMQ.Core.Utils.StringLib">
            <summary>
            StringLib is a static class whose purpose is to provide miscellaneous string-related utility methods
            and extension properties.
            </summary>
        </member>
        <member name="M:NetMQ.Core.Utils.StringLib.AsString(System.Collections.Generic.List{System.Net.Sockets.Socket})">
            <summary>
            Return a string that gives detailed information of the state of the given List of Sockets,
            for debugging purposes.
            </summary>
            <param name="list">the List of Sockets to describe</param>
            <returns>a string detailing the list contents, including the state of each Socket</returns>
            <remarks>
            This is intended just for debugging purposes, as when adding detailed information to the Message of an
            exception when an error occurs. In DEBUG mode more detail is provided.
            </remarks>
        </member>
        <member name="M:NetMQ.Core.Utils.StringLib.AsString(System.Net.Sockets.Socket)">
            <summary>
            Return a detailed textual description of the state of this Socket (if DEBUG is defined).
            </summary>
            <param name="socket">the System.Net.Sockets.Socket to describe</param>
            <returns>a string containing a detailed listing of the properties of the Socket</returns>
            <remarks>
            This is intended just for debugging purposes, as when adding detailed information to the Message of an
            exception when an error occurs. In DEBUG mode more detail is provided.
            </remarks>
        </member>
        <member name="T:NetMQ.Core.Utils.YQueue`1">
            <summary>A FIFO queue.</summary>
            <remarks>
            The class supports:
            <list type="bullet">
            <item>Push-front via <see cref="M:NetMQ.Core.Utils.YQueue`1.Push(`0@)"/>.</item>
            <item>Pop-back via <see cref="M:NetMQ.Core.Utils.YQueue`1.Pop"/>.</item>
            <item>Pop-front via <see cref="M:NetMQ.Core.Utils.YQueue`1.Unpush"/>.</item>
            </list>
            As such it is only one operation short of being a double-ended queue (dequeue or deque).
            <para/>
            The internal implementation consists of a doubly-linked list of fixed-size arrays.
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NetMQ.Core.Utils.YQueue`1.Chunk">
            <summary>Individual memory chunk to hold N elements.</summary>
        </member>
        <member name="P:NetMQ.Core.Utils.YQueue`1.Chunk.GlobalOffset">
            <summary>Contains global index positions of elements in the chunk.</summary>
        </member>
        <member name="P:NetMQ.Core.Utils.YQueue`1.Chunk.Previous">
            <summary>Optional link to the previous <see cref="T:NetMQ.Core.Utils.YQueue`1.Chunk"/>.</summary>
        </member>
        <member name="P:NetMQ.Core.Utils.YQueue`1.Chunk.Next">
            <summary>Optional link to the next <see cref="T:NetMQ.Core.Utils.YQueue`1.Chunk"/>.</summary>
        </member>
        <member name="M:NetMQ.Core.Utils.YQueue`1.#ctor(System.Int32)">
            <param name="chunkSize">the size to give the new YQueue</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="chunkSize"/> should be no less than 2</exception>
        </member>
        <member name="P:NetMQ.Core.Utils.YQueue`1.FrontPos">
            <summary>Gets the index of the front element of the queue.</summary>
            <value>The index of the front element of the queue.</value>
            <remarks>If the queue is empty, it should be equal to <see cref="P:NetMQ.Core.Utils.YQueue`1.BackPos"/>.</remarks>
        </member>
        <member name="P:NetMQ.Core.Utils.YQueue`1.Front">
            <summary>Gets the front element of the queue. If the queue is empty, behaviour is undefined.</summary>
            <value>The front element of the queue.</value>
        </member>
        <member name="P:NetMQ.Core.Utils.YQueue`1.BackPos">
            <summary>Gets the index of the back element of the queue.</summary>
            <value>The index of the back element of the queue.</value>
            <remarks>If the queue is empty, it should be equal to <see cref="P:NetMQ.Core.Utils.YQueue`1.FrontPos"/>.</remarks>
        </member>
        <member name="M:NetMQ.Core.Utils.YQueue`1.Pop">
            <summary>Retrieves the element at the front of the queue.</summary>
            <returns>The element taken from queue.</returns>
        </member>
        <member name="M:NetMQ.Core.Utils.YQueue`1.Push(`0@)">
            <summary>Adds an element to the back end of the queue.</summary>
            <param name="val">The value to be pushed.</param>
        </member>
        <member name="M:NetMQ.Core.Utils.YQueue`1.Unpush">
            <summary>Removes element from the back end of the queue, rolling back the last call to <see cref="M:NetMQ.Core.Utils.YQueue`1.Push(`0@)"/>.</summary>
            <remarks>The caller must guarantee that the queue isn't empty when calling this method.
            It cannot be done automatically as the read side of the queue can be managed by different,
            completely unsynchronized threads.</remarks>
            <returns>The last item passed to <see cref="M:NetMQ.Core.Utils.YQueue`1.Push(`0@)"/>.</returns>
        </member>
        <member name="F:NetMQ.Core.YPipe`1.m_queue">
            <summary>
            Allocation-efficient queue to store pipe items.
            Front of the queue points to the first prefetched item, back of
            the pipe points to last un-flushed item. Front is used only by
            reader thread, while back is used only by writer thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.YPipe`1.m_flushFromIndex">
            <summary>
            Points to the first un-flushed item. This variable is used
            exclusively by writer thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.YPipe`1.m_readToIndex">
            <summary>
            Points to the first un-prefetched item. This variable is used
            exclusively by reader thread.
            </summary>
        </member>
        <member name="F:NetMQ.Core.YPipe`1.m_flushToIndex">
            <summary>
            Points to the first item to be flushed in the future.
            </summary>
        </member>
        <member name="F:NetMQ.Core.YPipe`1.m_lastAllowedToReadIndex">
            <summary>
            The single point of contention between writer and reader thread.
            Points past the last flushed item. If it is NULL,
            reader is asleep. This pointer should be always accessed using
            atomic operations.
            </summary>
        </member>
        <member name="M:NetMQ.Core.YPipe`1.Write(`0@,System.Boolean)">
            <summary>
            Write an item to the pipe.  Don't flush it yet. If incomplete is
            set to true the item is assumed to be continued by items
            subsequently written to the pipe. Incomplete items are never
            flushed down the stream.
            </summary>
        </member>
        <member name="M:NetMQ.Core.YPipe`1.Unwrite(`0@)">
            <summary>
            Pop an incomplete item from the pipe.
            </summary>
            <returns>the element revoked if such item exists, <c>null</c> otherwise.</returns>
        </member>
        <member name="M:NetMQ.Core.YPipe`1.Flush">
            <summary>
            Flush all the completed items into the pipe.
            </summary>
            <returns> Returns <c>false</c> if the reader thread is sleeping. In that case, caller is obliged to
            wake the reader up before using the pipe again.
            </returns>
        </member>
        <member name="M:NetMQ.Core.YPipe`1.CheckRead">
            <summary>
            Check whether item is available for reading.
            </summary>
        </member>
        <member name="M:NetMQ.Core.YPipe`1.TryRead(`0@)">
            <summary>
            Attempts to read an item from the pipe.
            </summary>
            <returns><c>true</c> if the read succeeded, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.Core.YPipe`1.Probe">
            <summary>
            Applies the function fn to the first element in the pipe
            and returns the value returned by the fn.
            The pipe mustn't be empty or the function crashes.
            </summary>
        </member>
        <member name="T:NetMQ.Core.ZmqSocketOption">
            <summary>
            This enum-type serves to identity a particular socket-option.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Affinity">
            <summary>
            The I/O-thread affinity.
            0 means no affinity, meaning that work shall be distributed fairly among all I/O threads.
            For non-zero values, the lowest bit corresponds to thread 1, second lowest bit to thread 2, and so on.
            </summary>
            <remarks>
            The I/O-thread <c>Affinity</c> is a 64-bit value used to specify which threads from the I/O thread-pool
            associated with the socket's context shall handle newly-created connections.
            0 means no affinity, meaning that work shall be distributed fairly among all I/O threads.
            For non-zero values, the lowest bit corresponds to thread 1, second lowest bit to thread 2, and so on.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Identity">
            <summary>
            The unique identity of the socket, from a message-queueing router's perspective.
            </summary>
            <remarks>
            This is at most 255 bytes long.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Subscribe">
            <summary>
            Setting this option subscribes a socket to messages that have the given topic. This is valid only for Subscriber and XSubscriber sockets.
            </summary>
            <remarks>
            You subscribe a socket to a given topic when you want that socket to receive messages of that topic.
            A topic is simply a specific prefix (in the form of a byte-array or the equivalent text).
            This is valid only for Subscriber and XSubscriber sockets.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Unsubscribe">
            <summary>
            Set this option to un-subscribe a socket from a given topic. Only for Subscriber and XSubscriber sockets.
            </summary>
            <remarks>
            You un-subscribe a socket from the given topic when you no longer want that socket to receive
            messages of that topic. A topic is simply a specific prefix (in the form of a byte-array or the equivalent text).
            This is valid only for Subscriber and XSubscriber sockets.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Rate">
            <summary>
            The maximum send or receive data rate for multicast transports on the specified socket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.RecoveryIvl">
            <summary>
            The recovery-interval, in milliseconds, for multicast transports using the specified socket.
            Default is 10,000 ms (10 seconds).
            </summary>
            <remarks>
            This option determines the maximum time that a receiver can be absent from a multicast group
            before unrecoverable data loss will occur. Default is 10,000 ms (10 seconds).
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.SendBuffer">
            <summary>
            The size of the transmit buffer for the specified socket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.ReceiveBuffer">
            <summary>
            The size of the receive buffer for the specified socket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.ReceiveMore">
            <summary>
            This indicates more messages are to be received.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Handle">
            <summary>
            The file descriptor associated with the specified socket.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Events">
            <summary>
            The event state for the specified socket.
            This is a combination of:
              PollIn - at least one message may be received without blocking
              PollOut - at least one messsage may be sent without blocking
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Linger">
            <summary>
            This option specifies the linger period for the specified socket,
            which determines how long pending messages which have yet to be sent to a peer
            shall linger in memory after a socket is closed.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.ReconnectIvl">
            <summary>
            The initial reconnection interval for the specified socket.
            -1 means no reconnection.
            </summary>
            <remarks>
            This is the period to wait between attempts to reconnect disconnected peers
            when using connection-oriented transports.
            A value of -1 means no reconnection.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Backlog">
            <summary>
            This is the maximum length of the queue of outstanding peer connections
            for the specified socket. This only applies to connection-oriented transports.
            Default is 100.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.ReconnectIvlMax">
            <summary>
            The maximum reconnection interval for the specified socket.
            The default value of zero means no exponential backoff is performed.
            </summary>
            <remarks>
            This option value denotes the maximum reconnection interval for a socket.
            It is used when a connection drops and NetMQ attempts to reconnect.
            On each attempt to reconnect, the previous interval is doubled
            until this maximum period is reached.
            The default value of zero means no exponential backoff is performed.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.MaxMessageSize">
            <summary>
            The upper limit to the size for inbound messages.
            -1 (the default value) means no limit.
            </summary>
            <remarks>
            If a peer sends a message larger than this it is disconnected.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.SendHighWatermark">
            <summary>
            The high-water mark for message transmission, which is the number of messages that are allowed to queue up
            before mitigative action is taken. The default value is 1000.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.ReceiveHighWatermark">
            <summary>
            The high-water mark for message reception, which is the number of messages that are allowed to queue up
            before mitigative action is taken. The default value is 1000.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.MulticastHops">
            <summary>
            The time-to-live (maximum number of hops) that outbound multicast packets
            are allowed to propagate.
            The default value of 1 means that the multicast packets don't leave the local network.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.SendTimeout">
            <summary>
            Specifies the amount of time after which a synchronous send call will time out.
            A value of 0 means Send will return immediately, with a EAGAIN error if the message cannot be sent.
            -1 means to block until the message is sent.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.IPv4Only">
            <summary>
            This indicates the underlying native socket type.
            </summary>
            <remarks>
            An IPv4 socket will only use IPv4, while an IPv6 socket lets applications
            connect to and accept connections from both IPv4 and IPv6 hosts.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.LastEndpoint">
            <summary>
            The last endpoint bound for TCP and IPC transports.
            The returned value will be a string in the form of a ZMQ DSN.
            </summary>
            <remarks>
            If the TCP host is ANY, indicated by a *, then the returned address
            will be 0.0.0.0 (for IPv4).
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.RouterMandatory">
            <summary>
            Sets the RouterSocket behavior when an unroutable message is encountered.
            A value of 0 is the default and discards the message silently when it cannot be routed.
            A value of 1 returns an EHOSTUNREACH error code if the message cannot be routed.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.TcpKeepalive">
            <summary>
            Whether to use TCP keep-alive on this socket.
            0 = no, 1 = yes,
            -1 (the default value) means to skip any overrides and leave it to the OS default.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.TcpKeepaliveIdle">
            <summary>
            The keep-alive time - the duration between two keepalive transmissions in idle condition.
            </summary>
            <remarks>
            The TCP keepalive period is required by socket implementers to be configurable and by default is
            set to no less than 2 hours.
            In 0MQ, -1 (the default value) means to just leave it to the OS default.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.TcpKeepaliveIntvl">
            <summary>
            The TCP keep-alive interval - the duration between two keepalive transmission if no response was received to a previous keepalive probe.
            </summary>
            <remarks>
            By default a keepalive packet is sent every 2 hours or 7,200,000 milliseconds
            if no other data have been carried over the TCP connection.
            If there is no response to a keepalive, it is repeated once every KeepAliveInterval seconds.
            The default is one second.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.DelayAttachOnConnect">
            <summary>
            The list of accept-filters, which denote the addresses that a socket may accept.
            Setting this to null clears the filter.
            </summary>
            <remarks>
            This applies to IPv4 addresses only.
            </remarks>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.XpubVerbose">
            <summary>
            This applies only to XPub sockets.
            If true, send all subscription messages upstream, not just unique ones.
            The default is false.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.RouterRawSocket">
            <summary>
            If true, router socket accepts non-zmq tcp connections
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.XPublisherWelcomeMessage">
            <summary>
            This is an XPublisher-socket welcome-message.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.XPublisherBroadcast">
            <summary>
            This applies only to XPub sockets.
            If true, enable broadcast option on XPublishers
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.SendLowWatermark">
            <summary>
            The low-water mark for message transmission. This is the number of messages that should be processed
            before transmission is unblocked (in case it was blocked by reaching high-watermark). The default value is
            calculated using relevant high-watermark (HWM): HWM > 2048 ? HWM - 1024 : (HWM + 1) / 2
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.ReceiveLowWatermark">
            <summary>
            The low-water mark for message reception. This is the number of messages that should be processed
            before reception is unblocked (in case it was blocked by reaching high-watermark). The default value is
            calculated using relevant high-watermark (HWM): HWM > 2048 ? HWM - 1024 : (HWM + 1) / 2
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.RouterHandover">
            <summary>
            When enabled new router connections with same identity take over old ones
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.LastPeerRoutingId">
            <summary>
            Returns the last peer routing id connect to the PEER socket
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.Endian">
            <summary>
            Specifies the byte-order: big-endian, vs little-endian.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZmqSocketOption.PgmMaxTransportServiceDataUnitLength">
            <summary>
            Specifies the max datagram size for PGM.
            </summary>
        </member>
        <member name="T:NetMQ.Core.ZObject">
            <summary>
            This is the base-class for all objects that participate in inter-thread communication.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZObject.m_ctx">
            <summary>
            This Ctx is the context that provides access to the global state.
            </summary>
        </member>
        <member name="F:NetMQ.Core.ZObject.m_threadId">
            <summary>
            This is the thread-ID of the thread that this object belongs to.
            </summary>
        </member>
        <member name="M:NetMQ.Core.ZObject.#ctor(NetMQ.Core.Ctx,System.Int32)">
            <summary>
            Create a new ZObject with the given context and thread-id.
            </summary>
            <param name="ctx">the context for the new ZObject to live within</param>
            <param name="threadId">the integer thread-id for the new ZObject to be associated with</param>
        </member>
        <member name="M:NetMQ.Core.ZObject.#ctor(NetMQ.Core.ZObject)">
            <summary>
            Create a new ZObject that has the same context and thread-id as the given parent-ZObject.
            </summary>
            <param name="parent">another ZObject that provides the context and thread-id for this one</param>
        </member>
        <member name="P:NetMQ.Core.ZObject.ThreadId">
            <summary>
            Get the id of the thread that this object belongs to.
            </summary>
        </member>
        <member name="P:NetMQ.Core.ZObject.Ctx">
            <summary>
            Get the context that provides access to the global state.
            </summary>
        </member>
        <member name="M:NetMQ.Core.ZObject.FindEndpoint(System.String)">
            <exception cref="T:NetMQ.EndpointNotFoundException">The given address was not found in the list of endpoints.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ChooseIOThread(System.Int64)">
            <summary>
            Returns the <see cref="T:NetMQ.Core.IOThread"/> that is the least busy at the moment.
            </summary>
            <paramref name="affinity">Which threads are eligible (0 = all).</paramref>
            <returns>The least busy thread, or <c>null</c> if none is available.</returns>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendStop">
            <summary>
            Send the Stop command.
            </summary>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendPlug(NetMQ.Core.Own,System.Boolean)">
            <summary>
            Send the Plug command, incrementing the destinations sequence-number if incSeqnum is true.
            </summary>
            <param name="destination">the Own to send the command to</param>
            <param name="incSeqnum">a flag that dictates whether to increment the sequence-number on the destination (optional - defaults to false)</param>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendOwn(NetMQ.Core.Own,NetMQ.Core.Own)">
            <summary>
            Send the Own command, and increment the sequence-number of the destination
            </summary>
            <param name="destination">the Own to send the command to</param>
            <param name="obj">the object to Own</param>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendAttach(NetMQ.Core.SessionBase,NetMQ.Core.Transports.IEngine,System.Boolean)">
            <summary>
            Send the Attach command
            </summary>
            <param name="destination">the Own to send the command to</param>
            <param name="engine"></param>
            <param name="incSeqnum"></param>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendBind(NetMQ.Core.Own,NetMQ.Core.Pipe,System.Boolean)">
            <summary>
            Send the Bind command
            </summary>
            <param name="destination"></param>
            <param name="pipe"></param>
            <param name="incSeqnum"></param>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendTermReq(NetMQ.Core.Own,NetMQ.Core.Own)">
            <summary>
            For owned objects, asks the owner (<paramref name="destination"/>) to terminate <paramref name="obj"/>.
            </summary>
            <param name="destination"></param>
            <param name="obj"></param>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendDone">
            <summary>
            Send a Done command to the Ctx itself (null destination).
            </summary>
        </member>
        <member name="M:NetMQ.Core.ZObject.SendCommand(NetMQ.Core.Command)">
            <summary>
            Send the given Command, on that commands Destination thread.
            </summary>
            <param name="cmd">the Command to send</param>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessStop">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessForceStop">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessPlug">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessOwn(NetMQ.Core.Own)">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessAttach(NetMQ.Core.Transports.IEngine)">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessBind(NetMQ.Core.Pipe)">
            <summary>
            Process the bind command with the given pipe.
            </summary>
            <param name="pipe"></param>
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessActivateRead">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessActivateWrite(System.Int64)">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessHiccup(System.Object)">
            <summary>
            This method would be called to assign the specified pipe as a replacement for the outbound pipe that was being used.
            This, is an abstract method that is to be overridden by subclasses to provide their own concrete implementation.
            </summary>
            <param name="pipe">the pipe to use for writing</param>
            <remarks>
            A "Hiccup" occurs when an outbound pipe experiences something like a transient disconnect or for whatever other reason
            is no longer available for writing to.
            </remarks>
            <exception cref="T:System.NotSupportedException">No supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessPipeTerm">
            <summary>
            Process the terminate-pipe command.
            </summary>
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessPipeTermAck">
            <summary>
            Process the terminate-pipe acknowledgement command.
            </summary>
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessTermReq(NetMQ.Core.Own)">
            <summary>
            Process a termination-request command on the Own object.
            </summary>
            <param name="obj"></param>
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessTerm(System.Int32)">
            <summary>
            Process a termination request.
            </summary>
            <param name="linger">a time (in milliseconds) for this to linger before actually going away. -1 means infinite.</param>
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessTermAck">
            <summary>
            Process the termination-acknowledgement command.
            </summary>
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessReaped">
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="M:NetMQ.Core.ZObject.ProcessSeqnum">
            <summary>
            Special handler called after a command that requires a seqnum
            was processed. The implementation should catch up with its counter
            of processed commands here.
            </summary>
            <exception cref="T:System.NotSupportedException">Not supported on the ZObject class.</exception>
        </member>
        <member name="T:NetMQ.Endianness">
            <summary>
            This enum-type specifies either big-endian (Big) or little-endian (Little),
            which indicate whether the most-significant bits are placed first or last in memory.
            </summary>
        </member>
        <member name="F:NetMQ.Endianness.Big">
            <summary>
            Most-significant bits are placed first in memory.
            </summary>
        </member>
        <member name="F:NetMQ.Endianness.Little">
            <summary>
            Most-significant bits are placed last in memory.
            </summary>
        </member>
        <member name="T:NetMQ.ErrorCode">
            <summary>
            This enum-type represents the various numeric socket-related error codes.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.EndpointNotFound">
            <summary>
            The provided endpoint is not connected.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.AddressAlreadyInUse">
            <summary>
            The requested address is already in use.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.TryAgain">
            <summary>
            Non-blocking mode was requested and the message cannot be sent at the moment.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.AccessDenied">
            <summary>
            Permission denied
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.Invalid">
            <summary>
            The endpoint supplied is invalid.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.InProgress">
            <summary>
            The connection is still in progress.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.ProtocolNotSupported">
            <summary>
            The requested transport protocol is not supported.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.Fault">
            <summary>
            The provided context is invalid.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.AddressNotAvailable">
            <summary>
            The requested address was not available.
            For Bind operations, that can mean the address was not local.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.NetworkDown">
            <summary>
            The network appears to be down.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.NoBufferSpaceAvailable">
            <summary>
            There is not enough buffer space for the requested operation.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.NotConnected">
            <summary>
            The socket is not connected.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.ConnectionRefused">
            <summary>
            The connection was refused.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.HostUnreachable">
            <summary>
            The host is not reachable.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.BaseErrorNumber">
            <summary>
            This is the value chosen for beginning the range of 0MQ error codes.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.MessageSize">
            <summary>
            The message is too long.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.AddressFamilyNotSupported">
            <summary>
            The address family is not supported by this protocol.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.NetworkUnreachable">
            <summary>
            The network is apparently not reachable.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.ConnectionAborted">
            <summary>
            The connection-attempt has apparently been aborted.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.ConnectionReset">
            <summary>
            The connection has apparently been reset.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.TimedOut">
            <summary>
            The operation timed-out.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.NetworkReset">
            <summary>
            The connection has apparently been reset.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.FiniteStateMachine">
            <summary>
            The operation cannot be performed on this socket at the moment due
            to the socket not being in the appropriate state.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.ContextTerminated">
            <summary>
            The context associated with the specified socket has already been terminated.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.EmptyThread">
            <summary>
            No I/O thread is available to accomplish this task.
            </summary>
        </member>
        <member name="F:NetMQ.ErrorCode.TooManyOpenSockets">
            <summary>
            Too many sockets for this process.
            </summary>
        </member>
        <member name="T:NetMQ.EventDelegator`1">
            <summary>
            Facilitates a pattern whereby an event may be decorated with logic that transforms its arguments.
            </summary>
            <remarks>
            Use of this class requires providing actions that register and unregister a handler of the source
            event that calls <see cref="M:NetMQ.EventDelegator`1.Fire(System.Object,`0)"/> with updated arguments in response.
            </remarks>
            <typeparam name="T">Argument type of the decorated event.</typeparam>
        </member>
        <member name="M:NetMQ.EventDelegator`1.#ctor(System.Action,System.Action)">
            <summary>
            Initialises a new instance.
            </summary>
            <param name="registerToEvent">an Action to perform when the first handler is registered for the event</param>
            <param name="unregisterFromEvent">an Action to perform when the last handler is unregistered from the event</param>
        </member>
        <member name="M:NetMQ.EventDelegator`1.Fire(System.Object,`0)">
            <summary>
            Raise, or "Fire", the Event.
            </summary>
            <param name="sender">the sender that the event-handler that gets notified of this event will receive</param>
            <param name="args">the subclass of EventArgs that the event-handler will receive</param>
        </member>
        <member name="T:NetMQ.InterfaceItem">
            <summary>
            class InterfaceItem provides the properties Address and BroadcastAddress (both are an IPAddress).
            This serves to convey information for each of the network interfaces present on a host.
            </summary>
        </member>
        <member name="M:NetMQ.InterfaceItem.#ctor(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Create a new InterfaceItem from the given address and broadcast-address.
            </summary>
            <param name="address">an IPAddress that will comprise the 'Address' of the new InterfaceItem</param>
            <param name="broadcastAddress">an IPAddress that will comprise the 'BroadcastAddress' of the new InterfaceItem</param>
        </member>
        <member name="P:NetMQ.InterfaceItem.Address">
            <summary>
            Get the 'address' of this network interface, as an IPAddress.
            </summary>
        </member>
        <member name="P:NetMQ.InterfaceItem.BroadcastAddress">
            <summary>
            Get the 'broadcast-address' of this network interface, as an IPAddress.
            </summary>
        </member>
        <member name="T:NetMQ.InterfaceCollection">
            <summary>
            This is a list of InterfaceItems, each of which has an Address and BroadcastAddress,
            which is derived from all of the Network Interfaces present on this host at the time an instance of this class is created.
            </summary>
        </member>
        <member name="M:NetMQ.InterfaceCollection.#ctor">
            <summary>
            Create a new InterfaceCollection that contains a list of InterfaceItems derived from all of the Network Interfaces present on this host.
            </summary>
        </member>
        <member name="M:NetMQ.InterfaceCollection.GetEnumerator">
            <summary>
            Return an IEnumerator over the InterfaceItems that this InterfaceCollection contains,
            which are all of the network interfaces that were not running, nor loopback nor PPP interfaces.
            </summary>
            <returns>an IEnumerator over the InterfaceItems that this contains</returns>
        </member>
        <member name="T:NetMQ.IOutgoingSocket">
            <summary>
            Interface IOutgoingSocket mandates a Send( Msg, SendReceiveOptions ) method.
            </summary>
        </member>
        <member name="M:NetMQ.IOutgoingSocket.TrySend(NetMQ.Msg@,System.TimeSpan,System.Boolean)">
            <summary>
            Send a message if one is available within <paramref name="timeout"/>.
            </summary>
            <param name="msg">An object with message's data to send.</param>
            <param name="timeout">The maximum length of time to try and send a message. If <see cref="F:System.TimeSpan.Zero"/>, no
            wait occurs.</param>
            <param name="more">Indicate if another frame is expected after this frame</param>
            <returns><c>true</c> if a message was sent, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:NetMQ.IReceivingSocket">
            <summary>
            Defines a socket from which message data may be read.
            </summary>
        </member>
        <member name="M:NetMQ.IReceivingSocket.TryReceive(NetMQ.Msg@,System.TimeSpan)">
            <summary>
            Receive a message if one is available within <paramref name="timeout"/>.
            </summary>
            <param name="msg">An object to receive the message's data into.</param>
            <param name="timeout">The maximum length of time to wait for a message. If <see cref="F:System.TimeSpan.Zero"/>, no
            wait occurs.</param>
            <returns><c>true</c> if a message was received, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:NetMQ.ISocketPollable">
            <summary>
            Implementations provide a <see cref="T:NetMQ.NetMQSocket"/> via the <see cref="P:NetMQ.ISocketPollable.Socket"/> property.
            </summary>
        </member>
        <member name="P:NetMQ.ISocketPollable.Socket">
            <summary>
            Gets a <see cref="T:NetMQ.NetMQSocket"/> instance.
            </summary>
        </member>
        <member name="P:NetMQ.ISocketPollable.IsDisposed">
            <summary>
            Gets whether the object has been disposed.
            </summary>
        </member>
        <member name="T:NetMQ.ISocketPollableCollection">
             <summary>
            
             </summary>
             <remarks>
             This interface provides an abstraction over the legacy Poller and newer <see cref="T:NetMQ.NetMQPoller"/> classes for use in <see cref="T:NetMQ.Monitoring.NetMQMonitor"/>.
             </remarks>
        </member>
        <member name="T:NetMQ.Monitoring.NetMQMonitor">
            <summary>
            Monitors a <see cref="T:NetMQ.NetMQSocket"/> for events, raising them via events.
            </summary>
            <remarks>
            To run a monitor instance, either:
            <list type="bullet">
              <item>Call <see cref="M:NetMQ.Monitoring.NetMQMonitor.Start"/> (blocking) and <see cref="M:NetMQ.Monitoring.NetMQMonitor.Stop"/>, or</item>
              <item>Call <see cref="M:NetMQ.Monitoring.NetMQMonitor.AttachToPoller(NetMQ.NetMQPoller)"/> and <see cref="M:NetMQ.Monitoring.NetMQMonitor.DetachFromPoller"/>.</item>
            </list>
            </remarks>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitor.#ctor(NetMQ.NetMQSocket,System.String,System.Boolean)">
            <summary>
            Initialises a monitor on <paramref name="socket"/> for a specified <paramref name="endpoint"/>.
            </summary>
            <remarks>
            This constructor matches the signature used by clrzmq.
            </remarks>
            <param name="socket">The socket to monitor.</param>
            <param name="endpoint">a string denoting the endpoint which will be the monitoring address</param>
            <param name="ownsSocket">
            A flag indicating whether ownership of <paramref name="socket"/> is transferred to the monitor.
            If <c>true</c>, disposing the monitor will also dispose <paramref name="socket"/>.
            </param>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitor.Endpoint">
            <summary>
            The monitoring address.
            </summary>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitor.IsRunning">
            <summary>
            Get whether this monitor is currently running.
            </summary>
            <remarks>
            Start the monitor running via either <see cref="M:NetMQ.Monitoring.NetMQMonitor.Start"/> or <see cref="M:NetMQ.Monitoring.NetMQMonitor.AttachToPoller(NetMQ.NetMQPoller)"/>.
            Stop the monitor via either <see cref="M:NetMQ.Monitoring.NetMQMonitor.Stop"/> or <see cref="M:NetMQ.Monitoring.NetMQMonitor.DetachFromPoller"/>.
            </remarks>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitor.Timeout">
            <summary>
            Gets and sets the timeout interval for poll iterations when using <see cref="M:NetMQ.Monitoring.NetMQMonitor.Start"/> and <see cref="M:NetMQ.Monitoring.NetMQMonitor.Stop"/>.
            </summary>
            <remarks>
            The higher the number the longer it may take the to stop the monitor.
            This value has no effect when the monitor is run via <see cref="M:NetMQ.Monitoring.NetMQMonitor.AttachToPoller(NetMQ.NetMQPoller)"/>.
            </remarks>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.EventReceived">
            <summary>
            Raised whenever any monitored event fires.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.Connected">
            <summary>
            Occurs when a connection is made to a socket.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.ConnectDelayed">
            <summary>
            Occurs when a synchronous connection attempt failed, and its completion is being polled for.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.ConnectRetried">
            <summary>
            Occurs when an asynchronous connect / reconnection attempt is being handled by a reconnect timer.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.Listening">
            <summary>
            Occurs when a socket is bound to an address and is ready to accept connections.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.BindFailed">
            <summary>
            Occurs when a socket could not bind to an address.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.Accepted">
            <summary>
            Occurs when a connection from a remote peer has been established with a socket's listen address.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.AcceptFailed">
            <summary>
            Occurs when a connection attempt to a socket's bound address fails.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.Closed">
            <summary>
            Occurs when a connection was closed.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.CloseFailed">
            <summary>
            Occurs when a connection couldn't be closed.
            </summary>
        </member>
        <member name="E:NetMQ.Monitoring.NetMQMonitor.Disconnected">
            <summary>
            Occurs when the stream engine (TCP and IPC specific) detects a corrupted / broken session.
            </summary>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitor.Start">
            <summary>
            Start monitor the socket, the method doesn't start a new thread and will block until the monitor poll is stopped
            </summary>
            <exception cref="T:System.InvalidOperationException">The Monitor must not have already started nor attached to a poller.</exception>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitor.StartAsync">
            <summary>
            Start a background task for the monitoring operation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitor.Stop">
            <summary>
            Stop monitoring. Blocks until monitoring completed.
            </summary>
            <exception cref="T:System.InvalidOperationException">If this monitor is attached to a poller you must detach it first and not use the stop method.</exception>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitor.Dispose">
            <summary>
            Release and dispose of any contained resources.
            </summary>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitor.Dispose(System.Boolean)">
            <summary>
            Release and dispose of any contained resources.
            </summary>
            <param name="disposing">true if releasing managed resources</param>
        </member>
        <member name="T:NetMQ.Monitoring.NetMQMonitorEventArgs">
            <summary>
            Base class for all event arguments raised by <see cref="T:NetMQ.Monitoring.NetMQMonitor"/>.
            </summary>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitorEventArgs.#ctor(NetMQ.Monitoring.NetMQMonitor,System.String,NetMQ.SocketEvents)">
            <summary>
            Create a new NetMQMonitorEventArgs that contains the given monitor and address.
            </summary>
            <param name="monitor">The <see cref="T:NetMQ.Monitoring.NetMQMonitor"/> that raised this event.</param>
            <param name="address">The address of the event.</param>
            <param name="socketEvent">The type of socket event that occurred.</param>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitorEventArgs.Monitor">
            <summary>
            Gets the <see cref="T:NetMQ.Monitoring.NetMQMonitor"/> that raised this event.
            </summary>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitorEventArgs.Address">
            <summary>
            Gets the address of the event.
            </summary>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitorEventArgs.SocketEvent">
            <summary>
            Gets the type of socket event that occurred.
            </summary>
        </member>
        <member name="T:NetMQ.Monitoring.NetMQMonitorSocketEventArgs">
            <summary>
            A subclass of <see cref="T:NetMQ.Monitoring.NetMQMonitorEventArgs"/> that also holds a socket.
            </summary>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitorSocketEventArgs.#ctor(NetMQ.Monitoring.NetMQMonitor,System.String,AsyncIO.AsyncSocket,NetMQ.SocketEvents)">
            <summary>
            Create a new NetMQMonitorSocketEventArgs that contains the given monitor, address, and socket.
            </summary>
            <param name="monitor">The <see cref="T:NetMQ.Monitoring.NetMQMonitor"/> that raised this event.</param>
            <param name="address">The address of the event.</param>
            <param name="socketEvent">The type of socket event that occurred.</param>
            <param name="socket">The socket upon which this event occurred.</param>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitorSocketEventArgs.Socket">
            <summary>
            Gets the socket upon which this event occurred.
            </summary>
        </member>
        <member name="T:NetMQ.Monitoring.NetMQMonitorErrorEventArgs">
            <summary>
            A subclass of <see cref="T:NetMQ.Monitoring.NetMQMonitorEventArgs"/> that also holds an error code.
            </summary>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitorErrorEventArgs.#ctor(NetMQ.Monitoring.NetMQMonitor,System.String,NetMQ.ErrorCode,NetMQ.SocketEvents)">
            <summary>
            Create a new NetMQMonitorErrorEventArgs that contains the given monitor, address, and error-code.
            </summary>
            <param name="monitor">The <see cref="T:NetMQ.Monitoring.NetMQMonitor"/> that raised this event.</param>
            <param name="address">The address of the event.</param>
            <param name="socketEvent">The type of socket event that occurred.</param>
            <param name="errorCode">The error code associated with this event.</param>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitorErrorEventArgs.ErrorCode">
            <summary>
            Gets the error code associated with this event.
            </summary>
        </member>
        <member name="T:NetMQ.Monitoring.NetMQMonitorIntervalEventArgs">
            <summary>
            A subclass of <see cref="T:NetMQ.Monitoring.NetMQMonitorEventArgs"/> that also holds an interval.
            </summary>
        </member>
        <member name="M:NetMQ.Monitoring.NetMQMonitorIntervalEventArgs.#ctor(NetMQ.Monitoring.NetMQMonitor,System.String,System.Int32,NetMQ.SocketEvents)">
            <summary>
            Create a new NetMQMonitorIntervalEventArgs containing the given NetMQMonitor, address, and interval.
            </summary>
            <param name="monitor">the NetMQMonitor</param>
            <param name="address">The a string denoting the address</param>
            <param name="interval">The interval, in milliseconds.</param>
            <param name="socketEvent">The type of socket event that occurred.</param>
        </member>
        <member name="P:NetMQ.Monitoring.NetMQMonitorIntervalEventArgs.Interval">
            <summary>
            Gets the interval, in milliseconds.
            </summary>
        </member>
        <member name="T:NetMQ.MsgFlags">
            <summary>Defines a set of flags applicable to a <see cref="T:NetMQ.Msg"/> instance: None (default), More, Identity, Shared</summary>
        </member>
        <member name="F:NetMQ.MsgFlags.None">
            <summary>Indicates no flags are set (the default).</summary>
        </member>
        <member name="F:NetMQ.MsgFlags.More">
            <summary>Indicates that more frames of the same message follow.</summary>
        </member>
        <member name="F:NetMQ.MsgFlags.Identity">
            <summary>Indicates that this frame conveys the identity of a connected peer.</summary>
        </member>
        <member name="F:NetMQ.MsgFlags.Shared">
            <summary>Indicates that this frame's internal data is shared with other <see cref="T:NetMQ.Msg"/> objects.</summary>
        </member>
        <member name="T:NetMQ.MsgType">
            <summary>Enumeration of possible <see cref="T:NetMQ.Msg"/> types: Uninitialised, GC, Pool, Delimiter.</summary>
        </member>
        <member name="F:NetMQ.MsgType.Uninitialised">
            <summary>The <see cref="T:NetMQ.Msg"/> has not yet been initialised (default value).</summary>
        </member>
        <member name="F:NetMQ.MsgType.Empty">
            <summary>The <see cref="T:NetMQ.Msg"/> is empty.</summary>
        </member>
        <member name="F:NetMQ.MsgType.GC">
            <summary>The <see cref="T:NetMQ.Msg"/> data will be garbage collected when no longer needed.</summary>
        </member>
        <member name="F:NetMQ.MsgType.Pool">
            <summary>
            The <see cref="T:NetMQ.Msg"/> data was allocated by <see cref="T:NetMQ.BufferPool"/>, and must be released back
            to this pool when no longer needed. This happens when <see cref="M:NetMQ.Msg.Close"/> is called.
            </summary>
        </member>
        <member name="F:NetMQ.MsgType.Delimiter">
            <summary>The <see cref="T:NetMQ.Msg"/> is a delimiter frame and doesn't contain any data.</summary>
            <remarks>Delimiters are commonly used to mark a boundary between groups frames.</remarks>
        </member>
        <member name="T:NetMQ.Msg">
            <summary>
            A Msg struct is the lowest-level interpretation of a ZeroMQ message, and simply contains byte-array data
            and MsgType and MsgFlags properties.
            It supports message buffer pooling.
            </summary>
            <remarks>
            Many users will not use this class directly. However in high-performance situations it
            may be useful. When used correctly it's possible to have zero-copy and zero-allocation
            behaviour.
            </remarks>
        </member>
        <member name="F:NetMQ.Msg.m_refCount">
            <summary>An atomic reference count for knowing when to release a pooled data buffer back to the <see cref="T:NetMQ.BufferPool"/>.</summary>
            <remarks>Will be <c>null</c> unless <see cref="P:NetMQ.Msg.MsgType"/> equals <see cref="F:NetMQ.MsgType.Pool"/>.</remarks>
        </member>
        <member name="P:NetMQ.Msg.Size">
            <summary>
            Get the number of bytes within the Data property.
            </summary>
        </member>
        <member name="P:NetMQ.Msg.Offset">
            <summary>
            Gets the position of the first element in the Data property delimited by the message,
            relative to the start of the original array.
            </summary>
        </member>
        <member name="P:NetMQ.Msg.MsgType">
            <summary>Get the type of this message, from the MsgType enum.</summary>
        </member>
        <member name="P:NetMQ.Msg.IsDelimiter">
            <summary>
            Get whether the Delimiter bit is set on the Flags property,
            which would indicate that this message is intended for use simply to mark a boundary
            between other parts of some unit of communication.
            </summary>
        </member>
        <member name="P:NetMQ.Msg.IsInitialised">
            <summary>Get whether this <see cref="T:NetMQ.Msg"/> is initialised and ready for use.</summary>
            <remarks>A newly constructed <see cref="T:NetMQ.Msg"/> is uninitialised, and can be initialised via one
            of <see cref="M:NetMQ.Msg.InitEmpty"/>, <see cref="M:NetMQ.Msg.InitDelimiter"/>, <see cref="M:NetMQ.Msg.InitGC(System.Byte[],System.Int32)"/>, <see cref="M:NetMQ.Msg.InitGC(System.Byte[],System.Int32,System.Int32)"/>, or <see cref="M:NetMQ.Msg.InitPool(System.Int32)"/>.
            Calling <see cref="M:NetMQ.Msg.Close"/> will cause the <see cref="T:NetMQ.Msg"/> to become uninitialised again.</remarks>
            <returns><c>true</c> if the <see cref="T:NetMQ.Msg"/> is initialised, otherwise <c>false</c>.</returns>
        </member>
        <member name="P:NetMQ.Msg.Flags">
            <summary>
            Get the flags-enum MsgFlags value, which indicates which of the More, Identity, or Shared bits are set.
            </summary>
        </member>
        <member name="P:NetMQ.Msg.HasMore">
            <summary>
            Get the "Has-More" flag, which when set on a message-queue frame indicates that there are more frames to follow.
            </summary>
        </member>
        <member name="P:NetMQ.Msg.IsShared">
            <summary>
            Get whether the <see cref="P:NetMQ.Msg.Data"/> buffer of this <see cref="T:NetMQ.Msg"/> is shared with another instance.
            Only applies to pooled message types.
            </summary>
        </member>
        <member name="P:NetMQ.Msg.IsIdentity">
            <summary>
            Get whether the Identity bit is set on the Flags property.
            </summary>
        </member>
        <member name="M:NetMQ.Msg.SetFlags(NetMQ.MsgFlags)">
            <summary>
            Set the indicated Flags bits.
            </summary>
            <param name="flags">which Flags bits to set (More, Identity, or Shared)</param>
        </member>
        <member name="M:NetMQ.Msg.ResetFlags(NetMQ.MsgFlags)">
            <summary>
            Clear the indicated Flags bits.
            </summary>
            <param name="flags">which Flags bits to clear (More, Identity, or Shared)</param>
        </member>
        <member name="P:NetMQ.Msg.Data">
            <summary>
            Get the byte-array that represents the data payload of this <see cref="T:NetMQ.Msg"/>.
            </summary>
            <remarks>
            This value will be <c>null</c> if <see cref="P:NetMQ.Msg.MsgType"/> is <see cref="F:NetMQ.MsgType.Uninitialised"/>,
            <see cref="F:NetMQ.MsgType.Empty"/> or <see cref="F:NetMQ.MsgType.Delimiter"/>.
            </remarks>
        </member>
        <member name="M:NetMQ.Msg.InitEmpty">
            <summary>
            Clear this Msg to empty - ie, set MsgFlags to None, MsgType to Empty, and clear the Data.
            </summary>
        </member>
        <member name="M:NetMQ.Msg.InitPool(System.Int32)">
            <summary>
            Initialise this Msg to be of MsgType.Pool, with a data-buffer of the given number of bytes.
            </summary>
            <param name="size">the number of bytes to allocate in the data-buffer</param>
        </member>
        <member name="M:NetMQ.Msg.InitGC(System.Byte[],System.Int32)">
            <summary>
            Initialise this Msg to be of MsgType.GC with the given data-buffer value.
            </summary>
            <param name="data">the byte-array of data to assign to the Msg's Data property</param>
            <param name="size">the number of bytes that are in the data byte-array</param>
        </member>
        <member name="M:NetMQ.Msg.InitGC(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initialise this Msg to be of MsgType.GC with the given data-buffer value.
            </summary>
            <param name="data">the byte-array of data to assign to the Msg's Data property</param>
            <param name="offset">first byte in the data array</param>
            <param name="size">the number of bytes that are in the data byte-array</param>
        </member>
        <member name="M:NetMQ.Msg.InitDelimiter">
            <summary>
            Set this Msg to be of type MsgType.Delimiter with no bits set within MsgFlags.
            </summary>
        </member>
        <member name="M:NetMQ.Msg.Close">
            <summary>
            Clear the <see cref="P:NetMQ.Msg.Data"/> and set the MsgType to Invalid.
            If this is not a shared-data Msg (MsgFlags.Shared is not set), or it is shared but the reference-counter has dropped to zero,
            then return the data back to the BufferPool.
            </summary>
            <exception cref="T:NetMQ.FaultException">The object is not initialised.</exception>
        </member>
        <member name="M:NetMQ.Msg.AddReferences(System.Int32)">
            <summary>
            If this Msg is of MsgType.Pool, then - add the given amount number to the reference-counter
            and set the shared-data Flags bit.
            If this is not a Pool Msg, this does nothing.
            </summary>
            <param name="amount">the number to add to the internal reference-counter</param>
        </member>
        <member name="M:NetMQ.Msg.RemoveReferences(System.Int32)">
            <summary>
            If this Msg is of MsgType.Pool and is marked as Shared, then - subtract the given amount number from the reference-counter
            and, if that reaches zero - return the data to the shared-data pool.
            If this is not both a Pool Msg and also marked as Shared, this simply Closes this Msg.
            </summary>
            <param name="amount">the number to subtract from the internal reference-counter</param>
        </member>
        <member name="M:NetMQ.Msg.ToString">
            <summary>
            Override the Object ToString method to show the object-type, and values of the MsgType, Size, and Flags properties.
            </summary>
            <returns>a string that provides some detail about this Msg's state</returns>
        </member>
        <member name="M:NetMQ.Msg.Put(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy the given byte-array data to this Msg's Data buffer.
            </summary>
            <param name="src">the source byte-array to copy from</param>
            <param name="dstOffset">index within the internal Data array to copy that byte to</param>
            <param name="len">the number of bytes to copy</param>
        </member>
        <member name="M:NetMQ.Msg.Put(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy the given byte-array data to this Msg's Data buffer.
            </summary>
            <param name="src">the source byte-array to copy from</param>
            <param name="srcOffset">first byte in the source byte-array</param>
            <param name="dstOffset">index within the internal Data array to copy that byte to</param>
            <param name="len">the number of bytes to copy</param>
        </member>
        <member name="M:NetMQ.Msg.Put(System.Byte)">
            <summary>
            Copy the given single byte to this Msg's Data buffer.
            </summary>
            <param name="b">the source byte to copy from</param>
        </member>
        <member name="M:NetMQ.Msg.Put(System.Byte,System.Int32)">
            <summary>
            Copy the given single byte to this Msg's Data buffer at the given array-index.
            </summary>
            <param name="b">the source byte to copy from</param>
            <param name="i">index within the internal Data array to copy that byte to</param>
        </member>
        <member name="P:NetMQ.Msg.Item(System.Int32)">
            <summary>
            Get and set the byte value in the <see cref="P:NetMQ.Msg.Data"/> buffer at a specific index.
            </summary>
            <param name="index">The index to access</param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.Msg.Copy(NetMQ.Msg@)">
            <summary>
            Close this Msg, and effectively make this Msg a copy of the given source Msg
            by simply setting it to point to the given source Msg.
            If this is a Pool Msg, then this also increases the reference-counter and sets the Shared bit.
            </summary>
            <param name="src">the source Msg to copy from</param>
            <exception cref="T:NetMQ.FaultException">The object is not initialised.</exception>
        </member>
        <member name="M:NetMQ.Msg.TrimPrefix(System.Int32)">
            <summary>
            Increase Offset and decrease Size by the given count.
            </summary>
            <param name="count">Number of bytes to remove from a message</param>
        </member>
        <member name="M:NetMQ.Msg.Move(NetMQ.Msg@)">
            <summary>
            Close this Msg and make it reference the given source Msg, and then clear the Msg to empty.
            </summary>
            <param name="src">the source-Msg to become</param>
            <exception cref="T:NetMQ.FaultException">The object is not initialised.</exception>
        </member>
        <member name="M:NetMQ.Msg.CloneData">
            <summary>Returns a new array containing the first <see cref="P:NetMQ.Msg.Size"/> bytes of <see cref="P:NetMQ.Msg.Data"/>.</summary>
        </member>
        <member name="T:NetMQ.IShimHandler">
            <summary>
            An IShimHandler provides a Run(PairSocket) method.
            </summary>
        </member>
        <member name="M:NetMQ.IShimHandler.Run(NetMQ.Sockets.PairSocket)">
            <summary>
            Execute whatever action this <c>IShimHandler</c> represents against the given shim.
            </summary>
            <param name="shim"></param>
        </member>
        <member name="T:NetMQ.NetMQActorEventArgs">
            <summary>
            This is an EventArgs that provides an Actor property.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQActorEventArgs.#ctor(NetMQ.NetMQActor)">
            <summary>
            Create a new NetMQActorEventArgs with the given NetMQActor.
            </summary>
            <param name="actor">the NetMQActor for this exception to reference</param>
        </member>
        <member name="P:NetMQ.NetMQActorEventArgs.Actor">
            <summary>
            Get the NetMQActor that this exception references.
            </summary>
        </member>
        <member name="T:NetMQ.ShimAction">
            <summary>
            This delegate represents the action for this actor to execute.
            </summary>
            <param name="shim">the <seealso cref="T:NetMQ.Sockets.PairSocket"/> that is the shim to execute this action</param>
        </member>
        <member name="T:NetMQ.ShimAction`1">
            <summary>
            This delegate represents the action for this actor to execute - along with a state-information object.
            </summary>
            <typeparam name="T">the type to use for the state-information object</typeparam>
            <param name="shim">the <seealso cref="T:NetMQ.Sockets.PairSocket"/> that is the shim to execute this action</param>
            <param name="state">the state-information that the action will use</param>
        </member>
        <member name="T:NetMQ.NetMQActor">
            <summary>
            The Actor represents one end of a two-way pipe between 2 PairSocket(s). Where
            the actor may be passed messages, that are sent to the other end of the pipe
            which is called the "shim"
            </summary>
        </member>
        <member name="F:NetMQ.NetMQActor.EndShimMessage">
            <summary>
            The terminate-shim command.
            This is just the literal string "endPipe".
            </summary>
        </member>
        <member name="M:NetMQ.NetMQActor.ActionShimHandler`1.#ctor(NetMQ.ShimAction{`0},`0)">
            <summary>
            Create a new ActionShimHandler with the given type T to serve as the state-information,
            and the given action to operate upon that type.
            </summary>
            <param name="action">a ShimAction of type T that comprises the action to perform</param>
            <param name="state">the state-information</param>
        </member>
        <member name="M:NetMQ.NetMQActor.ActionShimHandler`1.Run(NetMQ.Sockets.PairSocket)">
            <summary>
            Perform the action upon the given shim, using our state-information.
            </summary>
            <param name="shim">a <see cref="T:NetMQ.Sockets.PairSocket"/> that is the shim to perform the action upon</param>
        </member>
        <member name="M:NetMQ.NetMQActor.ActionShimHandler.#ctor(NetMQ.ShimAction)">
            <summary>
            Create a new ActionShimHandler with a given action to operate upon that type.
            </summary>
            <param name="action">a ShimAction that comprises the action to perform</param>
        </member>
        <member name="M:NetMQ.NetMQActor.ActionShimHandler.Run(NetMQ.Sockets.PairSocket)">
            <summary>
            Perform the action upon the given shim, using our state-information.
            </summary>
            <param name="shim">a <see cref="T:NetMQ.Sockets.PairSocket"/> that is the shim to perform the action upon</param>
        </member>
        <member name="M:NetMQ.NetMQActor.Create(NetMQ.IShimHandler)">
            <summary>
            Create a new <see cref="T:NetMQ.NetMQActor"/> with the given shimHandler.
            </summary>
            <param name="shimHandler">an <c>IShimHandler</c> that provides the Run method</param>
            <returns>the newly-created <c>NetMQActor</c></returns>
        </member>
        <member name="M:NetMQ.NetMQActor.Create``1(NetMQ.ShimAction{``0},``0)">
            <summary>
            Create a new <see cref="T:NetMQ.NetMQActor"/> with the action, and state-information.
            </summary>
            <param name="action">a <c>ShimAction</c> - delegate for the action to perform</param>
            <param name="state">the state-information - of the generic type T</param>
            <returns>the newly-created <c>NetMQActor</c></returns>
        </member>
        <member name="M:NetMQ.NetMQActor.Create(NetMQ.ShimAction)">
            <summary>
            Create a new <see cref="T:NetMQ.NetMQActor"/> with the given <see cref="T:NetMQ.ShimAction"/>.
            </summary>
            <param name="action">a <c>ShimAction</c> - delegate for the action to perform</param>
            <returns>the newly-created <c>NetMQActor</c></returns>
        </member>
        <member name="M:NetMQ.NetMQActor.RunShim">
            <summary>
            Execute the shim handler's Run method, signal ok and then dispose of the shim.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQActor.TrySend(NetMQ.Msg@,System.TimeSpan,System.Boolean)">
            <summary>
            Transmit the given Msg over this actor's own socket.
            </summary>
            <param name="msg">the <c>Msg</c> to transmit</param>
            <param name="timeout">The maximum length of time to try and send a message. If <see cref="F:System.TimeSpan.Zero"/>, no
            wait occurs.</param>
            <param name="more">Indicate if another frame is expected after this frame</param>
            <returns><c>true</c> if a message was sent, otherwise <c>false</c>.</returns>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.FaultException"><paramref name="msg"/> is not initialised.</exception>
        </member>
        <member name="M:NetMQ.NetMQActor.TryReceive(NetMQ.Msg@,System.TimeSpan)">
            <summary>
            Attempt to receive a message for the specified period of time, returning true if successful or false if it times-out.
            </summary>
            <param name="msg">a <c>Msg</c> to write the received message into</param>
            <param name="timeout">a <c>TimeSpan</c> specifying how long to block, waiting for a message, before timing out</param>
            <returns>true only if a message was indeed received</returns>
        </member>
        <member name="E:NetMQ.NetMQActor.ReceiveReady">
            <summary>
            This event occurs when at least one message may be received from the socket without blocking.
            </summary>
        </member>
        <member name="E:NetMQ.NetMQActor.SendReady">
            <summary>
            This event occurs when a message is ready to be transmitted from the socket.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQActor.Dispose">
            <inheritdoc />
        </member>
        <member name="M:NetMQ.NetMQActor.Dispose(System.Boolean)">
            <summary>
            Release any contained resources.
            </summary>
            <param name="disposing">true if managed resources are to be released</param>
        </member>
        <member name="P:NetMQ.NetMQActor.IsDisposed">
            <inheritdoc />
        </member>
        <member name="T:NetMQ.NetMQBeaconEventArgs">
            <summary>
            A NetMQBeaconEventArgs is an EventArgs that provides a property that holds a NetMQBeacon.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQBeaconEventArgs.#ctor(NetMQ.NetMQBeacon)">
            <summary>
            Create a new NetMQBeaconEventArgs object containing the given NetMQBeacon.
            </summary>
            <param name="beacon">the NetMQBeacon object to hold a reference to</param>
        </member>
        <member name="P:NetMQ.NetMQBeaconEventArgs.Beacon">
            <summary>
            Get the NetMQBeacon object that this holds.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQBeacon.#ctor">
            <summary>
            Create a new NetMQBeacon.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQBeacon.HostName">
            <summary>
            Get the host name this beacon is bound to.
            </summary>
            <remarks>
            This may involve a reverse DNS lookup which can take a second or two.
            <para/>
            An empty string is returned if:
            <list type="bullet">
                <item>the beacon is not bound,</item>
                <item>the beacon is bound to all interfaces,</item>
                <item>an error occurred during reverse DNS lookup.</item>
            </list>
            </remarks>
        </member>
        <member name="P:NetMQ.NetMQBeacon.BoundTo">
            <summary>
            Get the IP address this beacon is bound to.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQBeacon.NetMQ#ISocketPollable#Socket">
            <summary>
            Get the socket of the contained actor.
            </summary>
        </member>
        <member name="E:NetMQ.NetMQBeacon.ReceiveReady">
            <summary>
            This event occurs when at least one message may be received from the socket without blocking.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQBeacon.ConfigureAllInterfaces(System.Int32)">
            <summary>
            Configure beacon for the specified port on all interfaces.
            </summary>
            <remarks>Blocks until the bind operation completes.</remarks>
            <param name="port">The UDP port to bind to.</param>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Configure(System.Int32,System.String)">
            <summary>
            Configure beacon for the specified port and, optionally, to a specific interface.
            </summary>
            <remarks>Blocks until the bind operation completes.</remarks>
            <param name="port">The UDP port to bind to.</param>
            <param name="interfaceName">IP address of the interface to bind to. Pass empty string (the default value) to use the default interface.</param>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Publish(System.String,System.TimeSpan,System.Text.Encoding)">
            <summary>
            Publish beacon immediately and continue to publish when interval elapsed
            </summary>
            <param name="transmit">Beacon to transmit.</param>
            <param name="interval">Interval to transmit beacon</param>
            <param name="encoding">Encoding for <paramref name="transmit"/>. Defaults to <see cref="P:System.Text.Encoding.UTF8"/>.</param>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Publish(System.Byte[],System.TimeSpan)">
            <summary>
            Publish beacon immediately and continue to publish when interval elapsed
            </summary>
            <param name="transmit">Beacon to transmit</param>
            <param name="interval">Interval to transmit beacon</param>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Publish(System.String,System.Text.Encoding)">
            <summary>
            Publish beacon immediately and continue to publish every second
            </summary>
            <param name="transmit">Beacon to transmit</param>
            <param name="encoding">Encoding for <paramref name="transmit"/>. Defaults to <see cref="P:System.Text.Encoding.UTF8"/>.</param>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Publish(System.Byte[])">
            <summary>
            Publish beacon immediately and continue to publish every second
            </summary>
            <param name="transmit">Beacon to transmit</param>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Silence">
            <summary>
            Stop publishing beacons.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Subscribe(System.String)">
            <summary>
            Subscribe to beacon messages that match the specified filter.
            </summary>
            <remarks>
            Beacons must prefix-match with <paramref name="filter"/>.
            Any previous subscription is replaced by this one.
            </remarks>
            <param name="filter">Beacon will be filtered by this</param>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Unsubscribe">
            <summary>
            Unsubscribe to beacon messages
            </summary>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Receive">
            <summary>
            Receives the next beacon message, blocking until it arrives.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQBeacon.TryReceive(System.TimeSpan,NetMQ.BeaconMessage@)">
            <summary>
            Receives the next beacon message if one is available before <paramref name="timeout"/> expires.
            </summary>
            <param name="timeout">The maximum amount of time to wait for the next beacon message.</param>
            <param name="message">The received beacon message.</param>
            <returns><c>true</c> if a beacon message was received, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.NetMQBeacon.Dispose">
            <inheritdoc />
        </member>
        <member name="P:NetMQ.NetMQBeacon.IsDisposed">
            <inheritdoc />
        </member>
        <member name="T:NetMQ.BeaconMessage">
            <summary>
            Contents of a message received from a beacon.
            </summary>
        </member>
        <member name="P:NetMQ.BeaconMessage.Bytes">
            <summary>
            THe beacon content as a byte array.
            </summary>
        </member>
        <member name="P:NetMQ.BeaconMessage.PeerAddress">
            <summary>
            The address of the peer that sent this message. Includes host name and port number.
            </summary>
        </member>
        <member name="P:NetMQ.BeaconMessage.String">
            <summary>
            The beacon content as a string.
            </summary>
            <remarks>Decoded using <see cref="P:System.Text.Encoding.UTF8"/>. Other encodings may be used with <see cref="P:NetMQ.BeaconMessage.Bytes"/> directly.</remarks>
        </member>
        <member name="P:NetMQ.BeaconMessage.PeerHost">
            <summary>
            The host name of the peer that sent this message.
            </summary>
            <remarks>This is simply the value of <see cref="P:NetMQ.BeaconMessage.PeerAddress"/> without the port number.</remarks>
        </member>
        <member name="M:NetMQ.NetMQConfig.Cleanup(System.Boolean)">
            <summary>
            Cleanup library resources, call this method when your process is shutting-down.
            </summary>
            <param name="block">Set to true when you want to make sure sockets send all pending messages</param>
        </member>
        <member name="P:NetMQ.NetMQConfig.Linger">
            <summary>
            Get or set the default linger period for the all sockets,
            which determines how long pending messages which have yet to be sent to a peer
            shall linger in memory after a socket is closed.
            </summary>
            <remarks>
            This also affects the termination of the socket's context.
            <para />
            -1: Specifies infinite linger period. Pending messages shall not be discarded after the socket is closed;
            attempting to terminate the socket's context shall block until all pending messages have been sent to a peer.
            <para />
            0: The default value of <see cref="F:System.TimeSpan.Zero"/> specifies no linger period. Pending messages shall be discarded immediately when the socket is closed.
            Positive values specify an upper bound for the linger period. Pending messages shall not be discarded after the socket is closed;
            attempting to terminate the socket's context shall block until either all pending messages have been sent to a peer,
            or the linger period expires, after which any pending messages shall be discarded.
            </remarks>
        </member>
        <member name="P:NetMQ.NetMQConfig.ThreadPoolSize">
            <summary>
            Get or set the number of IO Threads NetMQ will create, default is 1.
            1 is good for most cases.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQConfig.MaxSockets">
            <summary>
            Get or set the maximum number of sockets.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQConfig.ManualTerminationTakeOver">
            <summary>
            Method is obsolete, call Cleanup instead
            </summary>
        </member>
        <member name="M:NetMQ.NetMQConfig.DisableManualTermination">
            <summary>
            Method is obsolete, call Cleanup instead
            </summary>
        </member>
        <member name="M:NetMQ.NetMQConfig.ContextTerminate(System.Boolean)">
            <summary>
            Method is obsolete, call Cleanup instead
            </summary>
            <param name="block">Should the context block the thread while terminating.</param>
        </member>
        <member name="M:NetMQ.NetMQConfig.ContextCreate(System.Boolean)">
            <summary>
            Method is obsolete, context created automatically
            </summary>
        </member>
        <member name="T:NetMQ.NetMQException">
            <summary>
            Base class for custom exceptions within the NetMQ library.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="M:NetMQ.NetMQException.#ctor(System.Exception,System.String,NetMQ.ErrorCode)">
            <summary>
            Create a new NetMQException containing the given Exception, Message and ErrorCode.
            </summary>
            <param name="innerException">an Exception that this exception will expose via it's InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
            <param name="errorCode">an ErrorCode that this exception will expose via its ErrorCode property</param>
        </member>
        <member name="M:NetMQ.NetMQException.Create(System.Net.Sockets.SocketException)">
            <summary>
            Create and return a new NetMQException with no Message containing only the given SocketException.
            </summary>
            <param name="innerException">a SocketException that this exception will expose via its InnerException property</param>
            <returns>a new NetMQException</returns>
        </member>
        <member name="M:NetMQ.NetMQException.Create(System.Net.Sockets.SocketError,System.Exception)">
            <summary>
            Create and return a new NetMQException with no Message containing the given SocketError and Exception.
            </summary>
            <param name="error">a SocketError that this exception will carry and expose via its ErrorCode property</param>
            <param name="innerException">an Exception that this exception will expose via its InnerException property</param>
            <returns>a new NetMQException</returns>
        </member>
        <member name="M:NetMQ.NetMQException.Create(NetMQ.ErrorCode,System.Exception)">
            <summary>
            Create and return a new NetMQException with no Message containing the given ErrorCode and Exception.
            </summary>
            <param name="errorCode">an ErrorCode for this exception to contain and expose via its ErrorCode property</param>
            <param name="innerException">an Exception for this exception to contain and expose via its InnerException property</param>
            <returns>a new NetMQException</returns>
        </member>
        <member name="M:NetMQ.NetMQException.Create(NetMQ.ErrorCode)">
            <summary>
            Create and return a new NetMQException with no Message containing only the given ErrorCode.
            </summary>
            <param name="errorCode">an ErrorCode that this exception will carry and expose via its ErrorCode property</param>
            <returns>a new NetMQException</returns>
        </member>
        <member name="M:NetMQ.NetMQException.Create(System.String,NetMQ.ErrorCode)">
            <summary>
            Create and return a new NetMQException with the given Message and ErrorCode.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
            <param name="errorCode">an ErrorCode that this exception will carry and expose via its ErrorCode property</param>
            <returns>a new NetMQException</returns>
        </member>
        <member name="M:NetMQ.NetMQException.Create(NetMQ.ErrorCode,System.String,System.Exception)">
            <summary>
            Create and return a new NetMQException with the given ErrorCode, Message, and Exception.
            </summary>
            <param name="errorCode">an ErrorCode that this exception will contain and expose via its ErrorCode property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
            <param name="innerException">an Exception that this exception will expose via its InnerException property</param>
            <returns>a new NetMQException, or subclass of NetMQException that corresponds to the given ErrorCode</returns>
        </member>
        <member name="T:NetMQ.AddressAlreadyInUseException">
            <summary>
            AddressAlreadyInUseException is a NetMQException that is used within SocketBase.Bind to signal an address-conflict.
            </summary>
        </member>
        <member name="M:NetMQ.AddressAlreadyInUseException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new AddressAlreadyInUseException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.AddressAlreadyInUseException.#ctor(System.String)">
            <summary>
            Create a new AddressAlreadyInUseException with a given message.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.AddressAlreadyInUseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.EndpointNotFoundException">
            <summary>
            EndpointNotFoundException is a NetMQException that is used within Ctx.FindEndpoint to signal a failure to find a specified address.
            </summary>
        </member>
        <member name="M:NetMQ.EndpointNotFoundException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new EndpointNotFoundException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.EndpointNotFoundException.#ctor(System.String)">
            <summary>
            Create a new EndpointNotFoundException with a given message.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.EndpointNotFoundException.#ctor">
            <summary>
            Create a new EndpointNotFoundException with no message nor inner-exception.
            </summary>
        </member>
        <member name="M:NetMQ.EndpointNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.TerminatingException">
            <summary>
            TerminatingException is a NetMQException that is used within SocketBase and Ctx to signal
            that you're making the mistake of trying to do further work after terminating the message-queueing system.
            </summary>
        </member>
        <member name="M:NetMQ.TerminatingException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new TerminatingException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.TerminatingException.#ctor">
            <summary>
            Create a new TerminatingException with no message nor inner-exception.
            </summary>
        </member>
        <member name="M:NetMQ.TerminatingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.InvalidException">
            <summary>
            InvalidException is a NetMQException that is used within the message-queueing system to signal invalid value errors.
            </summary>
        </member>
        <member name="M:NetMQ.InvalidException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new InvalidException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.InvalidException.#ctor(System.String)">
            <summary>
            Create a new InvalidException with the given message.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.InvalidException.#ctor">
            <summary>
            Create a new InvalidException with no message nor inner-exception.
            </summary>
        </member>
        <member name="M:NetMQ.InvalidException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.FaultException">
            <summary>
            FaultException is a NetMQException that is used within the message-queueing system to signal general fault conditions.
            </summary>
        </member>
        <member name="M:NetMQ.FaultException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new FaultException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.FaultException.#ctor(System.String)">
            <summary>
            Create a new FaultException with the given message.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.FaultException.#ctor">
            <summary>
            Create a new FaultException with no message nor inner-exception.
            </summary>
        </member>
        <member name="M:NetMQ.FaultException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.ProtocolNotSupportedException">
            <summary>
            ProtocolNotSupportedException is a NetMQException that is used within the message-queueing system to signal
            mistakes in properly utilizing the communications protocols.
            </summary>
        </member>
        <member name="M:NetMQ.ProtocolNotSupportedException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new ProtocolNotSupportedException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.ProtocolNotSupportedException.#ctor(System.String)">
            <summary>
            Create a new ProtocolNotSupportedException with the given message.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.ProtocolNotSupportedException.#ctor">
            <summary>
            Create a new ProtocolNotSupportedException with no message nor inner-exception.
            </summary>
        </member>
        <member name="M:NetMQ.ProtocolNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.HostUnreachableException">
            <summary>
            HostUnreachableException is an Exception that is used within the message-queueing system
            to signal failures to communicate with a host.
            </summary>
        </member>
        <member name="M:NetMQ.HostUnreachableException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new HostUnreachableException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.HostUnreachableException.#ctor(System.String)">
            <summary>
            Create a new HostUnreachableException with the given message.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.HostUnreachableException.#ctor">
            <summary>
            Create a new HostUnreachableException with no message nor inner-exception.
            </summary>
        </member>
        <member name="M:NetMQ.HostUnreachableException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.FiniteStateMachineException">
            <summary>
            FiniteStateMachineException is an Exception that is used within the message-queueing system
            to signal errors in the send/receive order with request/response sockets.
            </summary>
        </member>
        <member name="M:NetMQ.FiniteStateMachineException.#ctor(System.Exception,System.String)">
            <summary>
            Create a new FiniteStateMachineException with a given inner-exception and message.
            </summary>
            <param name="innerException">an Exception for this new exception to contain and expose via its InnerException property</param>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.FiniteStateMachineException.#ctor(System.String)">
            <summary>
            Create a new FiniteStateMachineException with the given message.
            </summary>
            <param name="message">the textual description of what gave rise to this exception, to expose via the Message property</param>
        </member>
        <member name="M:NetMQ.FiniteStateMachineException.#ctor">
            <summary>
            Create a new FiniteStateMachineException with no message nor inner-exception.
            </summary>
        </member>
        <member name="M:NetMQ.FiniteStateMachineException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialisation.</summary>
        </member>
        <member name="T:NetMQ.NetMQFrame">
            <summary>
            Objects of class NetMQFrame serve to hold a Buffer (that consists of a byte-array containing a unit of a message-queue message)
            and provide methods to construct it given a string and an encoding.
            </summary>
        </member>
        <member name="F:NetMQ.NetMQFrame.m_messageSize">
            <summary>
            This is the length of the byte-array data buffer.
            </summary>
        </member>
        <member name="F:NetMQ.NetMQFrame.m_hash">
            <summary>
            This holds the computed hash-code for this object.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQFrame.#ctor(System.Byte[])">
            <summary>
            Create a new NetMQFrame containing the given byte-array data.
            </summary>
            <param name="buffer">a byte-array to hold as the frame's data</param>
        </member>
        <member name="M:NetMQ.NetMQFrame.#ctor(System.Byte[],System.Int32)">
            <summary>
            Instantiates a frame from the provided byte array, considering only the specified number of bytes.
            </summary>
            <remarks>This constructor may be useful to avoid copying data into a smaller array when a buffer is oversized.</remarks>
            <param name="buffer">The content of the frame.</param>
            <param name="length">The number bytes from <paramref name="buffer"/> to consider as part of the frame.</param>
        </member>
        <member name="M:NetMQ.NetMQFrame.#ctor(System.String)">
            <summary>
            Create a new NetMQFrame containing the given string-message,
            using the default ASCII encoding.
            </summary>
            <param name="message">a string containing the message-data of the frame</param>
        </member>
        <member name="M:NetMQ.NetMQFrame.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Create a new NetMQFrame containing the given string-message,
            using the given encoding to convert it into a byte-array.
            </summary>
            <param name="message">a string containing the message-data of the frame</param>
            <param name="encoding">the Encoding to use to convert the given string-message into the internal byte-array</param>
        </member>
        <member name="M:NetMQ.NetMQFrame.#ctor(System.Int32)">
            <summary>
            Create a new NetMQFrame with a data-buffer pre-sized to the given length.
            </summary>
            <param name="length">the number of bytes to allocate for the data-buffer</param>
            <exception cref="T:System.ArgumentOutOfRangeException">length must be non-negative (zero or positive).</exception>
        </member>
        <member name="P:NetMQ.NetMQFrame.MessageSize">
            <summary>
            Get or set the size of the message data contained in the frame, which here represents the number of bytes.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value must be between zero and BufferSize.</exception>
        </member>
        <member name="P:NetMQ.NetMQFrame.Buffer">
            <summary>
            Get the underlying frame-data buffer, which is an array of bytes.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQFrame.BufferSize">
            <summary>
            Get the maximum size of the frame-data buffer (ie, the number of bytes of the array).
            </summary>
        </member>
        <member name="P:NetMQ.NetMQFrame.Empty">
            <summary>
            Get a new empty <see cref="T:NetMQ.NetMQFrame"/> that may be used as message separators.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQFrame.IsEmpty">
            <summary>
            Get whether this NetMQFrame is empty - that is, has a Buffer of zero-length.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQFrame.Copy(System.Byte[])">
            <summary>
            Create and return a new NetMQFrame with a copy of the supplied byte-array buffer.
            </summary>
            <param name="buffer">the byte-array to copy into the new NetMQFrame</param>
            <returns>a new <see cref="T:NetMQ.NetMQFrame"/> containing a copy of the supplied byte-array</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        </member>
        <member name="M:NetMQ.NetMQFrame.ConvertToString">
            <summary>
            Return this frame's data-buffer converted into a string, using the default ASCII encoding.
            </summary>
            <returns>the data buffer converted to a string</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.ConvertToString(System.Text.Encoding)">
            <summary>
            Return this frame's data-buffer converted into a string using the given encoding.
            </summary>
            <param name="encoding">the Encoding to use to convert the internal byte-array buffer into a string</param>
            <returns>the data buffer converted to a string</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.ConvertToInt32">
            <summary>
            Convert the buffer to integer in network byte order (big-endian)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.ConvertToInt64">
            <summary>
            Convert the buffer to long in network byte order (big-endian)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.Copy(NetMQ.NetMQFrame)">
            <summary>
            Create a deep-copy of the supplied <see cref="T:NetMQ.NetMQFrame"/>.
            </summary>
            <param name="frame">the <see cref="T:NetMQ.NetMQFrame"/> to copy</param>
            <returns>a <see cref="T:NetMQ.NetMQFrame"/> containing a copy of <paramref name="frame"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="frame"/> is null.</exception>
        </member>
        <member name="M:NetMQ.NetMQFrame.Duplicate">
            <summary>
            Create a deep-copy of this NetMQFrame and return it.
            </summary>
            <returns>a new NetMQFrame containing a copy of this one's buffer data</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.Equals(System.Byte[])">
            <summary>
            Return true if the buffer of this NetMQFrame is equal to the given byte-array.
            </summary>
            <param name="other">a byte-array buffer to compare this frame against</param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.Equals(NetMQ.NetMQFrame)">
            <summary>
            Determine whether the specified <see cref="T:NetMQ.NetMQFrame"/> is equal to the current <see cref="T:NetMQ.NetMQFrame"/>.
            </summary>
            <param name="other">the <see cref="T:NetMQ.NetMQFrame"/> to compare with the current <see cref="T:NetMQ.NetMQFrame"/>.</param>
            <returns>true if the specified NetMQFrame is equal to this one; otherwise, false</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.Equals(System.Object)">
            <summary>
            Return true if the given Object is a NetMQFrame which has a Buffer that is identical to that of this one.
            </summary>
            <param name="obj">the Object to compare this to</param>
            <returns>true only if the given Object is a NetMQFrame equal to this one</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.op_Equality(NetMQ.NetMQFrame,NetMQ.NetMQFrame)">
            <summary>
            Return true if this one and the other NetMQFrame are equal, or both are null.
            </summary>
            <param name="one">one frame to compare against the other</param>
            <param name="other">the other frame to compare</param>
            <returns>true if both frames are equal</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.op_Inequality(NetMQ.NetMQFrame,NetMQ.NetMQFrame)">
            <summary>
            Return true if this one and the other NetMQFrame NOT are equal.
            </summary>
            <param name="one">one frame to compare against the other</param>
            <param name="other">the other frame to compare</param>
            <returns>false if both frames are equal</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.GetHashCode">
            <summary>
            Override the Object.GetHashCode method to return a hash-code derived from the content of the Buffer.
            That is only computed the first time this method is called.
            </summary>
            <returns>an integer that represents the computed hash-code</returns>
        </member>
        <member name="M:NetMQ.NetMQFrame.ToByteArray(System.Boolean)">
            <summary>
            Return an array of bytes that carries the content of this NetMQFrames Buffer.
            </summary>
            <param name="copy">if this argument is true - a new copy is made if BufferSize is equal to MessageSize</param>
            <returns>the Buffer as a byte-array, either newly-allocated or else (if copy is false) simply a reference to the actual Buffer</returns>
        </member>
        <member name="T:NetMQ.NamespaceDoc">
            <summary>
            This namespace encompasses the NetMQ message-queueing library
            and attendant utility software.
            </summary>
        </member>
        <member name="T:NetMQ.NetMQMessage">
            <summary>
            A NetMQMessage is basically a collection of NetMQFrames, and is the basic message-unit that is sent and received
            across this message-queueing subsystem.
            </summary>
        </member>
        <member name="F:NetMQ.NetMQMessage.m_frames">
            <summary>
            This is the frame-stack that comprises the message-content of this message.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQMessage.#ctor(System.Int32)">
            <summary>
            The default-constructor for NetMQMessage: create a new instance of NetMQMessage
            with an empty frame-stack.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQMessage.#ctor(System.Collections.Generic.IEnumerable{NetMQ.NetMQFrame})">
            <summary>
            Create a new instance of a NetMQMessage that contains the given collection of NetMQFrames as its frame-stack.
            </summary>
            <param name="frames">a collection of NetMQFrames, to form the frame-stack</param>
            <exception cref="T:System.ArgumentNullException">The value of 'frames' cannot be null. </exception>
        </member>
        <member name="M:NetMQ.NetMQMessage.#ctor(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Create a new instance of a NetMQMessage that contains the given collection of byte-arrays as its frame-stack.
            </summary>
            <param name="buffers">a collection of byte-array buffers, to form the frame-stack</param>
            <exception cref="T:System.ArgumentNullException">The value of 'buffers' cannot be null. </exception>
        </member>
        <member name="P:NetMQ.NetMQMessage.First">
            <summary>
            Gets the first frame in the current message.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQMessage.Last">
            <summary>
            Gets the last frame in the current message.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQMessage.IsEmpty">
            <summary>
            Gets a value indicating whether the current message is empty.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQMessage.FrameCount">
            <summary>
            Gets the number of <see cref="T:NetMQ.NetMQFrame"/> objects contained by this message.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQMessage.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:NetMQ.NetMQFrame"/> at the specified index.
            </summary>
            <param name="index">The zero-based index of the <see cref="T:NetMQ.NetMQFrame"/> to get.</param>
            <returns>The <see cref="T:NetMQ.NetMQFrame"/> at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/>is less than 0 -or- <paramref name="index"/> is equal to or greater than <see cref="P:NetMQ.NetMQMessage.FrameCount"/>.
            </exception>
        </member>
        <member name="M:NetMQ.NetMQMessage.Append(NetMQ.NetMQFrame)">
            <summary>
            Add the given NetMQFrame to this NetMQMessage, at the highest-indexed position of the frame-stack.
            </summary>
            <param name="frame">a NetMQFrame object comprising the frame to be appended onto the frame-stack</param>
        </member>
        <member name="M:NetMQ.NetMQMessage.Append(System.Byte[])">
            <summary>
            Add the given data (in this case a byte-array) to this NetMQMessage, at the highest-indexed position of the frame-stack.
            Data is not copied.
            </summary>
            <param name="buffer">a byte-array containing the message to append onto the frame-stack of this NetMQMessage</param>
        </member>
        <member name="M:NetMQ.NetMQMessage.Append(System.String)">
            <summary>
            Add the given string - which gets converted into a NetMQFrame - onto
            the highest-indexed position of the frame-stack of this NetMQMessage.
            </summary>
            <param name="message">a string containing the message to append onto the frame-stack of this NetMQMessage</param>
        </member>
        <member name="M:NetMQ.NetMQMessage.Append(System.String,System.Text.Encoding)">
            <summary>
            Add the given string - which gets converted into a NetMQFrame - onto
            the highest-indexed position of the frame-stack of this NetMQMessage.
            </summary>
            <param name="message">a string containing the message to append onto the frame-stack of this NetMQMessage</param>
            <param name="encoding">an Encoding that specifies how to convert the string into bytes</param>
        </member>
        <member name="M:NetMQ.NetMQMessage.Append(System.Int32)">
            <summary>
            Convert the given integer value into an array of bytes and add it as a new frame onto this NetMQMessage.
            </summary>
            <param name="value">a 32-bit integer value that is to be converted into bytes and added to this message</param>
        </member>
        <member name="M:NetMQ.NetMQMessage.Append(System.Int64)">
            <summary>
            Convert the given long value into an array of bytes and add it as a new frame onto this NetMQMessage.
            </summary>
            <param name="value">a 64-bit number that is to be converted into bytes and added to this message</param>
        </member>
        <member name="M:NetMQ.NetMQMessage.AppendEmptyFrame">
            <summary>
            Add an empty frame to this NetMQMessage.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQMessage.Push(NetMQ.NetMQFrame)">
            <summary>
            Push the given NetMQFrame into the frame-stack of this NetMQMessage.
            </summary>
            <param name="frame">the NetMQFrame to be inserted into the frame-stack</param>
            <remarks>
            The concept is the same as pushing an element onto a stack.
            This inserts the given NetMQFrame into the lowest-indexed position of this NetMQMessage,
            pushing all of the other frames upward in index-position.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQMessage.Push(System.Byte[])">
            <summary>
            Push a new frame containing the given byte-array into the frame-stack of this NetMQMessage.
            </summary>
            <param name="buffer">the byte-array to create a new frame from</param>
            <remarks>
            The concept is the same as pushing an element onto a stack.
            This creates a new frame from the given data (in this case a byte-array) and inserts it into the lowest-indexed position of 
            the collection of frames of this NetMQMessage,
            pushing all of the other frames upward in index-position.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQMessage.Push(System.String)">
            <summary>
            Push a new frame containing the given string (converted into a byte-array) into the frame-stack of this NetMQMessage.
            </summary>
            <param name="message">the string to create a new frame from</param>
            <remarks>
            The concept is the same as pushing an element onto a stack.
            This creates a new frame from the given data (in this case a string which gets converted into a byte-array using the default ASCII encoding) and inserts it into the lowest-indexed position of 
            the collection of frames of this NetMQMessage,
            pushing all of the other frames upward in index-position.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQMessage.Push(System.String,System.Text.Encoding)">
            <summary>
            Push a new frame containing the given string (converted into a byte-array) into the frame-stack of this NetMQMessage.
            </summary>
            <param name="message">the string to create a new frame from</param>
            <param name="encoding">the Encoding that dictates how to encode the string into bytes</param>
            <remarks>
            The concept is the same as pushing an element onto a stack.
            This creates a new frame from the given data (in this case a string which gets converted into a byte-array using the given Encoding) and inserts it into the lowest-indexed position of 
            the collection of frames of this NetMQMessage,
            pushing all of the other frames upward in index-position.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQMessage.Push(System.Int32)">
            <summary>
            Push a new frame containing the given integer (converted into a byte-array) into the frame-stack of this NetMQMessage.
            </summary>
            <param name="value">the integer to create a new frame from</param>
            <remarks>
            The concept is the same as pushing an element onto a stack.
            This creates a new frame from the given data (in this case a 32-bit integer which gets converted into a byte-array in big-endian order) and inserts it into the lowest-indexed position of 
            the collection of frames of this NetMQMessage,
            pushing all of the other frames upward in index-position.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQMessage.Push(System.Int64)">
            <summary>
            Push a new frame containing the given long (converted into a byte-array) into the frame-stack of this NetMQMessage.
            </summary>
            <param name="value">the 64-bit number to create a new frame from</param>
            <remarks>
            The concept is the same as pushing an element onto a stack.
            This creates a new frame from the given data (in this case a 64-bit long which gets converted into a byte-array in big-endian order) and inserts it into the lowest-indexed position of 
            the collection of frames of this NetMQMessage,
            pushing all of the other frames upward in index-position.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQMessage.PushEmptyFrame">
            <summary>
            Push an empty frame (a NetMQFrame.Empty) onto the frame-stack.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQMessage.Pop">
            <summary>
            Remove and return the first frame.
            </summary>
            <returns>the first frame, which was popped - which is the frame from the lowest-indexed position</returns>
        </member>
        <member name="M:NetMQ.NetMQMessage.RemoveFrame(NetMQ.NetMQFrame)">
            <summary>
            Delete the given frame from the frame-stack.
            </summary>
            <param name="frame">the frame to remove</param>
            <returns><c>true</c> if removed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.NetMQMessage.Clear">
            <summary>
            Clear (empty) the frame-stack, so that it no longer contains any frames.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQMessage.GetEnumerator">
            <summary>
            Return an enumerator over the frames contained within this message.
            </summary>
            <returns>an IEnumerator over the frames in this message</returns>
        </member>
        <member name="M:NetMQ.NetMQMessage.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Return an enumerator over the frames contained within this message.
            </summary>
            <returns>an IEnumerator over the frames in this message</returns>
        </member>
        <member name="M:NetMQ.NetMQMessage.ToString">
            <summary>
            Returns a string showing the frame contents.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetMQ.NetMQPoller.CanExecuteTaskInline">
            <summary>
            Get whether the caller is running on the scheduler's thread.
            If <c>true</c>, the caller can execute tasks directly (inline).
            If <c>false</c>, the caller must start a <see cref="T:System.Threading.Tasks.Task"/> on this scheduler.
            </summary>
            <remarks>
            This property enables avoiding the creation of a <see cref="T:System.Threading.Tasks.Task"/> object and
            potential delays to its execution due to queueing. In most cases this is just
            an optimisation.
            </remarks>
            <example>
            <code>
            if (scheduler.CanExecuteTaskInline)
            {
                socket.Send(...);
            }
            else
            {
                var task = new Task(() => socket.Send(...));
                task.Start(scheduler);
            }
            </code>
            </example>
        </member>
        <member name="P:NetMQ.NetMQPoller.MaximumConcurrencyLevel">
            <summary>
            Returns 1, as <see cref="T:NetMQ.NetMQPoller"/> runs a single thread and all tasks must execute on that thread.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQPoller.GetScheduledTasks">
            <summary>
            Not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="P:NetMQ.NetMQPoller.IsRunning">
            <summary>
            Get whether this object is currently polling its sockets and timers.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQPoller.RunAsync">
            <summary>
            Runs the poller in a background thread, returning once the poller has started.
            </summary>
            <remarks>
            The created thread is named <c>"NetMQPollerThread"</c>. Use <see cref="M:NetMQ.NetMQPoller.RunAsync(System.String)"/> to specify the thread name.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQPoller.RunAsync(System.String)">
            <summary>
            Runs the poller in a background thread, returning once the poller has started.
            </summary>
            <param name="threadName">The thread name to use.</param>
        </member>
        <member name="M:NetMQ.NetMQPoller.Run">
            <summary>
            Runs the poller on the caller's thread. Only returns when <see cref="M:NetMQ.NetMQPoller.Stop"/> or <see cref="M:NetMQ.NetMQPoller.StopAsync"/> are called from another thread.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQPoller.Run(System.Threading.SynchronizationContext)">
            <summary>
            Runs the poller on the caller's thread. Only returns when <see cref="M:NetMQ.NetMQPoller.Stop" /> or <see cref="M:NetMQ.NetMQPoller.StopAsync" /> are called from another thread.
            </summary>
            <param name="syncContext">The synchronization context that will be used.</param>
        </member>
        <member name="M:NetMQ.NetMQPoller.RunPoller">
            <summary>
            Runs the poller on the caller's thread. Only returns when <see cref="M:NetMQ.NetMQPoller.Stop"/> or <see cref="M:NetMQ.NetMQPoller.StopAsync"/> are called from another thread.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQPoller.Stop">
            <summary>
            Stops the poller.
            </summary>
            <remarks>
            If called from a thread other than the poller thread, this method will block until the poller has stopped.
            If called from the poller thread it is not possible to block.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQPoller.StopAsync">
            <summary>
            Stops the poller, returning immediately and most likely before the poller has actually stopped.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQPoller.System#Collections#IEnumerable#GetEnumerator">
            <summary>This class only implements <see cref="T:System.Collections.IEnumerable"/> in order to support collection initialiser syntax.</summary>
            <returns>An empty enumerator.</returns>
        </member>
        <member name="M:NetMQ.NetMQPoller.Dispose">
            <summary>
            Stops and disposes the poller. The poller may not be used once disposed.
            </summary>
            <remarks>
            Note that you cannot dispose the poller on the poller's thread. Doing so immediately throws an exception.
            </remarks>
            <exception cref="T:NetMQ.NetMQException">A socket in the poller has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Dispose called from the poller thread.</exception>
        </member>
        <member name="M:NetMQ.NetMQPoller.NetMQSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Dispatches an asynchronous message to a synchronization context.</summary>
        </member>
        <member name="M:NetMQ.NetMQPoller.NetMQSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Dispatches a synchronous message to a synchronization context.</summary>
        </member>
        <member name="T:NetMQ.NetMQProactor">
            <summary>
            Class to quickly handle incoming messages of socket.
            New thread is created to handle the messages. Call dispose to stop the thread.
            Provided socket will not be disposed by the class.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQProactor.#ctor(NetMQ.NetMQSocket,System.Action{NetMQ.NetMQSocket,NetMQ.NetMQMessage})">
            <summary>
            Create NetMQProactor and start dedicate thread to handle incoming messages.
            </summary>
            <param name="receiveSocket">Socket to handle messages from</param>
            <param name="handler">Handler to handle incoming messages</param>
        </member>
        <member name="M:NetMQ.NetMQProactor.Dispose">
            <summary>
            Stop the proactor. Provided socket will not be disposed.
            </summary>
        </member>
        <member name="T:NetMQ.NetMQQueue`1">
            <summary>
            Multi producer single consumer queue which you can poll on with a Poller.
            </summary>
            <typeparam name="T">Type of the item in queue</typeparam>
        </member>
        <member name="M:NetMQ.NetMQQueue`1.#ctor(System.Int32)">
            <summary>
            Create new NetMQQueue.
            </summary>
            <param name="capacity">The capacity of the queue, use zero for unlimited</param>
        </member>
        <member name="E:NetMQ.NetMQQueue`1.ReceiveReady">
            <summary>
            Register for this event for notification when there are items in the queue. Queue must be added to a poller for this to work.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQQueue`1.TryDequeue(`0@,System.TimeSpan)">
            <summary>
            Try to dequeue an item from the queue. Dequeueing and item is not thread safe.
            </summary>
            <param name="result">Will be filled with the item upon success</param>
            <param name="timeout">Timeout to try and dequeue and item</param>
            <returns>Will return false if it didn't succeed to dequeue an item after the timeout.</returns>
        </member>
        <member name="M:NetMQ.NetMQQueue`1.Dequeue">
            <summary>
            Dequeue an item from the queue, will block if queue is empty. Dequeueing and item is not thread safe.
            </summary>
            <returns>Dequeued item</returns>
        </member>
        <member name="M:NetMQ.NetMQQueue`1.Enqueue(`0)">
            <summary>
            Enqueue an item to the queue, will block if the queue is full.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NetMQ.NetMQQueue`1.Dispose">
            <summary>
            Dispose the queue.
            </summary>
        </member>
        <member name="T:NetMQ.NetMQSelector">
            <summary>
            For selecting on <see cref="T:NetMQ.NetMQSocket"/> and regular .NET <see cref="T:System.Net.Sockets.Socket"/> objects.
            </summary>
            <remarks>
            This is for advanced scenarios only.
            Most use cases are better served by <see cref="T:NetMQ.NetMQPoller"/>.
            </remarks>
        </member>
        <member name="T:NetMQ.NetMQSelector.Item">
            <summary>
            Selector Item used to hold the NetMQSocket/Socket and PollEvents
            </summary>
        </member>
        <member name="M:NetMQ.NetMQSelector.Select(NetMQ.NetMQSelector.Item[],System.Int32,System.Int64)">
            <summary>
            Select on NetMQSocket or Socket, similar behavior to Socket.Select.
            </summary>
            <param name="items">Items to select on (must not be null)</param>
            <param name="itemsCount">Number of items in the array to select on</param>
            <param name="timeout">a time-out period, in milliseconds</param>
            <returns></returns>
            <exception cref="T:NetMQ.FaultException">The internal select operation failed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is <c>null</c>.</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="T:NetMQ.NetMQSocket">
            <summary>
            Abstract base class for NetMQ's different socket types.
            </summary>
            <remarks>
            Various options are available in this base class, though their affect can vary by socket type.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQSocket.#ctor(NetMQ.ZmqSocketType,System.String,NetMQ.NetMQSocket.DefaultAction)">
            <summary>
            Create a new NetMQSocket with the given <see cref="T:NetMQ.ZmqSocketType"/>.
            </summary>
            <param name="socketType">Type of socket to create</param>
            <param name="connectionString"></param>
            <param name="defaultAction"></param>
        </member>
        <member name="M:NetMQ.NetMQSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new NetMQSocket with the given <see cref="T:NetMQ.Core.SocketBase"/>.
            </summary>
            <param name="socketHandle">a SocketBase object to assign to the new socket</param>
        </member>
        <member name="E:NetMQ.NetMQSocket.ReceiveReady">
            <summary>
            This event occurs when at least one message may be received from the socket without blocking.
            </summary>
            <remarks>
            This event is raised when a <see cref="T:NetMQ.NetMQSocket"/> is added to a running <see cref="T:NetMQ.Core.Utils.Poller"/>.
            </remarks>
        </member>
        <member name="E:NetMQ.NetMQSocket.SendReady">
            <summary>
            This event occurs when at least one message may be sent via the socket without blocking.
            </summary>
            <remarks>
            This event is raised when a <see cref="T:NetMQ.NetMQSocket"/> is added to a running <see cref="T:NetMQ.Core.Utils.Poller"/>.
            </remarks>
        </member>
        <member name="E:NetMQ.NetMQSocket.EventsChanged">
            <summary>
            Fires when either the <see cref="E:NetMQ.NetMQSocket.SendReady"/> or <see cref="E:NetMQ.NetMQSocket.ReceiveReady"/> event is set.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQSocket.InvokeEventsChanged">
            <summary>
            Raise the <see cref="E:NetMQ.NetMQSocket.EventsChanged"/> event.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQSocket.Errors">
            <summary>
            Get or set an integer that represents the number of errors that have accumulated.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQSocket.Options">
            <summary>
            Get the <see cref="T:NetMQ.SocketOptions"/> of this socket.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQSocket.SocketHandle">
            <summary>
            Get the underlying <see cref="T:NetMQ.Core.SocketBase"/>.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQSocket.Bind(System.String)">
            <summary>
            Bind the socket to <paramref name="address"/>.
            </summary>
            <param name="address">a string representing the address to bind this socket to</param>
            <exception cref="T:System.ObjectDisposedException">thrown if the socket was already disposed</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.AddressAlreadyInUseException">The specified address is already in use.</exception>
            <exception cref="T:NetMQ.NetMQException">No IO thread was found, or the protocol's listener encountered an
            error during initialisation.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.BindRandomPort(System.String)">
            <summary>Binds the specified TCP <paramref name="address"/> to an available port, assigned by the operating system.</summary>
            <returns>the chosen port-number</returns>
            <exception cref="T:System.ObjectDisposedException">thrown if the socket was already disposed</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException"><paramref name="address"/> uses a protocol other than TCP.</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.AddressAlreadyInUseException">The specified address is already in use.</exception>
            <exception cref="T:NetMQ.NetMQException">No IO thread was found, or the protocol's listener errored during
            initialisation.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.Connect(System.String)">
            <summary>
            Connect the socket to <paramref name="address"/>.
            </summary>
            <param name="address">a string denoting the address to connect this socket to</param>
            <exception cref="T:System.ObjectDisposedException">thrown if the socket was already disposed</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.NetMQException">No IO thread was found.</exception>
            <exception cref="T:NetMQ.AddressAlreadyInUseException">The specified address is already in use.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.Disconnect(System.String)">
            <summary>
            Disconnect this socket from <paramref name="address"/>.
            </summary>
            <param name="address">a string denoting the address to disconnect from</param>
            <exception cref="T:System.ObjectDisposedException">thrown if the socket was already disposed</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.EndpointNotFoundException">Endpoint was not found and cannot be disconnected.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.Unbind(System.String)">
            <summary>
            Unbind this socket from <paramref name="address"/>.
            </summary>
            <param name="address">a string denoting the address to unbind from</param>
            <exception cref="T:System.ObjectDisposedException">thrown if the socket was already disposed</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.EndpointNotFoundException">Endpoint was not found and cannot be disconnected.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.Close">
            <summary>Closes this socket, rendering it unusable. Equivalent to calling <see cref="M:NetMQ.NetMQSocket.Dispose"/>.</summary>
        </member>
        <member name="M:NetMQ.NetMQSocket.Poll">
            <summary>
            Wait until a message is ready to be received from the socket.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQSocket.Poll(System.TimeSpan)">
            <summary>
            Wait until a message is ready to be received/sent from this socket or until timeout is reached.
            If a message is available, the ReceiveReady/SendReady event is fired.
            </summary>
            <param name="timeout">a TimeSpan that represents the timeout-period</param>
            <returns>true if a message was available within the timeout, false otherwise</returns>
        </member>
        <member name="M:NetMQ.NetMQSocket.Poll(NetMQ.PollEvents,System.TimeSpan)">
            <summary>
            Poll this socket, which means wait for an event to happen within the given timeout period.
            </summary>
            <param name="pollEvents">the poll event(s) to listen for</param>
            <param name="timeout">the timeout period</param>
            <returns>
            PollEvents.None     -> no message available
            PollEvents.PollIn   -> at least one message has arrived
            PollEvents.PollOut  -> at least one message is ready to send
            PollEvents.Error    -> an error has occurred
            or any combination thereof
            </returns>
            <exception cref="T:NetMQ.FaultException">The internal select operation failed.</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.GetPollEvents">
            <summary>
            Return a <see cref="T:NetMQ.PollEvents"/> value that indicates which bit-flags have a corresponding listener,
            with PollError always set,
            and PollOut set based upon m_sendReady
            and PollIn set based upon m_receiveReady.
            </summary>
            <returns>a PollEvents value that denotes which events have a listener</returns>
        </member>
        <member name="M:NetMQ.NetMQSocket.InvokeEvents(System.Object,NetMQ.PollEvents)">
            <summary>
            Unless this socket is closed,
            based upon the given PollEvents - raise the m_receiveReady event if PollIn is set,
            and m_sendReady if PollOut is set.
            </summary>
            <param name="sender">what to use as the source of the events</param>
            <param name="events">the given PollEvents that dictates when of the two events to raise</param>
        </member>
        <member name="M:NetMQ.NetMQSocket.TryReceive(NetMQ.Msg@,System.TimeSpan)">
            <summary>Attempt to receive a message for the specified amount of time.</summary>
            <param name="msg">A reference to a <see cref="T:NetMQ.Msg"/> instance into which the received message
            data should be placed.</param>
            <param name="timeout">The maximum amount of time the call should wait for a message before returning.</param>
            <returns><c>true</c> if a message was received before <paramref name="timeout"/> elapsed,
            otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.NetMQSocket.TrySend(NetMQ.Msg@,System.TimeSpan,System.Boolean)">
            <summary>
            Send a message if one is available within <paramref name="timeout"/>.
            </summary>
            <param name="msg">An object with message's data to send.</param>
            <param name="timeout">The maximum length of time to try and send a message. If <see cref="F:System.TimeSpan.Zero"/>, no
            wait occurs.</param>
            <param name="more">Indicate if another frame is expected after this frame</param>
            <returns><c>true</c> if a message was sent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.NetMQSocket.Monitor(System.String,NetMQ.SocketEvents)">
            <summary>
            Listen to the given endpoint for SocketEvent events.
            </summary>
            <param name="endpoint">A string denoting the endpoint to monitor</param>
            <param name="events">The specific <see cref="T:NetMQ.SocketEvents"/> events to report on. Defaults to <see cref="F:NetMQ.SocketEvents.All"/> if omitted.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="endpoint"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="endpoint"/> cannot be empty or whitespace.</exception>
            <exception cref="T:System.ObjectDisposedException">This object is already disposed.</exception>
            <exception cref="T:NetMQ.ProtocolNotSupportedException">The protocol of <paramref name="endpoint"/> is not supported.</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.NetMQException">Maximum number of sockets reached.</exception>
        </member>
        <member name="P:NetMQ.NetMQSocket.HasIn">
            <summary>
            Get whether a message is waiting to be picked up (<c>true</c> if there is, <c>false</c> if there is none).
            </summary>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="P:NetMQ.NetMQSocket.HasOut">
            <summary>
            Get whether a message is waiting to be sent.
            </summary>
            <remarks>
            This is <c>true</c> if at least one message is waiting to be sent, <c>false</c> if there is none.
            </remarks>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.GetSocketOption(NetMQ.Core.ZmqSocketOption)">
            <summary>
            Get the integer-value of the specified <see cref="T:NetMQ.Core.ZmqSocketOption"/>.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to get</param>
            <returns>an integer that is the value of that option</returns>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:System.ObjectDisposedException">This object is already disposed.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.GetSocketOptionX``1(NetMQ.Core.ZmqSocketOption)">
            <summary>
            Get the (generically-typed) value of the specified <see cref="T:NetMQ.Core.ZmqSocketOption"/>.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to get</param>
            <returns>an object of the given type, that is the value of that option</returns>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:System.ObjectDisposedException">This object is already disposed.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.GetSocketOptionTimeSpan(NetMQ.Core.ZmqSocketOption)">
            <summary>
            Get the <see cref="T:System.TimeSpan"/> value of the specified ZmqSocketOption.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to get</param>
            <returns>a TimeSpan that is the value of that option</returns>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.GetSocketOptionLong(NetMQ.Core.ZmqSocketOption)">
            <summary>
            Get the 64-bit integer-value of the specified <see cref="T:NetMQ.Core.ZmqSocketOption"/>.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to get</param>
            <returns>a long that is the value of that option</returns>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.SetSocketOption(NetMQ.Core.ZmqSocketOption,System.Int32)">
            <summary>
            Assign the given integer value to the specified <see cref="T:NetMQ.Core.ZmqSocketOption"/>.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to set</param>
            <param name="value">an integer that is the value to set that option to</param>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:System.ObjectDisposedException">This object is already disposed.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.SetSocketOptionTimeSpan(NetMQ.Core.ZmqSocketOption,System.TimeSpan)">
            <summary>
            Assign the given TimeSpan to the specified <see cref="T:NetMQ.Core.ZmqSocketOption"/>.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to set</param>
            <param name="value">a TimeSpan that is the value to set that option to</param>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.SetSocketOption(NetMQ.Core.ZmqSocketOption,System.Object)">
            <summary>
            Assign the given Object value to the specified <see cref="T:NetMQ.Core.ZmqSocketOption"/>.
            </summary>
            <param name="option">a ZmqSocketOption that specifies what to set</param>
            <param name="value">an object that is the value to set that option to</param>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:System.ObjectDisposedException">This object is already disposed.</exception>
        </member>
        <member name="M:NetMQ.NetMQSocket.Dispose">
            <summary>Closes this socket, rendering it unusable. Equivalent to calling <see cref="M:NetMQ.NetMQSocket.Close"/>.</summary>
        </member>
        <member name="M:NetMQ.NetMQSocket.Dispose(System.Boolean)">
            <summary>Closes this socket, rendering it unusable. Equivalent to calling <see cref="M:NetMQ.NetMQSocket.Close"/>.</summary>
            <param name="disposing">true if releasing managed resources</param>
        </member>
        <member name="P:NetMQ.NetMQSocket.IsDisposed">
            <inheritdoc />
        </member>
        <member name="T:NetMQ.NetMQSocketEventArgs">
            <summary>
            This subclass of EventArgs contains a NetMQSocket,
            and IsReadyToReceive and IsReadyToSend flags to indicate whether ready to receive or send.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQSocketEventArgs.#ctor(NetMQ.NetMQSocket)">
            <summary>
            Create a new NetMQSocketEventArgs referencing the given socket.
            </summary>
            <param name="socket">the NetMQSocket that this is in reference to</param>
        </member>
        <member name="M:NetMQ.NetMQSocketEventArgs.Init(NetMQ.PollEvents)">
            <summary>
            Initialise the ReceiveReady and SendReady flags from the given PollEvents value.
            </summary>
            <param name="events">a PollEvents value that indicates whether the socket is ready to send or receive without blocking</param>
        </member>
        <member name="P:NetMQ.NetMQSocketEventArgs.Socket">
            <summary>
            Get the NetMQSocket that this references.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQSocketEventArgs.IsReadyToReceive">
            <summary>
            Get whether at least one message may be received by the socket without blocking.
            </summary>
        </member>
        <member name="P:NetMQ.NetMQSocketEventArgs.IsReadyToSend">
            <summary>
            Get whether at least one message may be sent by the socket without blocking.
            </summary>
        </member>
        <member name="T:NetMQ.NetMQTimerEventArgs">
            <summary>
            Class NetMQTimerEventArgs is an EventArgs that contains a reference to a NetMQTimer.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQTimerEventArgs.#ctor(NetMQ.NetMQTimer)">
            <summary>
            Create a new NetMQTimerEventArgs that contains a reference to the given NetMQTimer.
            </summary>
            <param name="timer">the NetMQTimer to hold a reference to</param>
        </member>
        <member name="P:NetMQ.NetMQTimerEventArgs.Timer">
            <summary>
            Get the NetMQTimer that this has a reference to.
            </summary>
        </member>
        <member name="T:NetMQ.NetMQTimer">
            <summary>
            A NetMQTimer instance provides the state-information for a timer function,
            which is periodically checked by a Poller or a NetMQBeacon.
            </summary>
        </member>
        <member name="F:NetMQ.NetMQTimer.m_timerEventArgs">
            <summary>
            A pre-constructed NetMQTimerEventArgs to use whenever raising the Elapsed event.
            </summary>
        </member>
        <member name="F:NetMQ.NetMQTimer.m_interval">
            <summary>
            This is the timer-interval in milliseconds.
            </summary>
        </member>
        <member name="F:NetMQ.NetMQTimer.m_enable">
            <summary>
            This flag dictates whether this timer is currently enabled.
            </summary>
        </member>
        <member name="E:NetMQ.NetMQTimer.Elapsed">
            <summary>
            This event is used to signal when the timer has expired.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQTimer.#ctor(System.TimeSpan)">
            <summary>
            Create a new NetMQTimer with the timer-interval specified by the given TimeSpan.
            </summary>
            <param name="interval">a TimeSpan that denotes the timer-interval</param>
            <remarks>
            This sets the When property to an initial value of -1, to indicate it no future-time applies as yet.
            </remarks>
        </member>
        <member name="M:NetMQ.NetMQTimer.#ctor(System.Int32)">
            <summary>
            Create a new NetMQTimer with the given timer-interval in milliseconds.
            </summary>
            <param name="interval">an integer specifying the timer-interval in milliseconds</param>
            <remarks>
            This sets the When property to an initial value of -1, to indicate it no future-time applies as yet.
            </remarks>
        </member>
        <member name="P:NetMQ.NetMQTimer.Interval">
            <summary>
            Get or set the timer-interval, in milliseconds.
            </summary>
            <remarks>
            When setting this, When is set to the future point in time from now at which the interval will expire (or -1 if not Enabled).
            </remarks>
        </member>
        <member name="P:NetMQ.NetMQTimer.Enable">
            <summary>
            Get or set whether this NetMQTimer is on.
            </summary>
            <remarks>
            When setting this to true, When is set to the future point in time from now at which the interval will expire.
            When setting this to false, When is set to -1.
            </remarks>
        </member>
        <member name="P:NetMQ.NetMQTimer.When">
            <summary>
            Get or set the value of the low-precision timestamp (a value in milliseconds) that signals when the timer is to expire,
            or -1 if not applicable at this time.
            </summary>
        </member>
        <member name="M:NetMQ.NetMQTimer.EnableAndReset">
            <summary>
            Enable the timer and reset the interval
            </summary>
        </member>
        <member name="M:NetMQ.NetMQTimer.InvokeElapsed(System.Object)">
            <summary>
            If there are any subscribers - raise the Elapsed event.
            </summary>
            <param name="sender">the sender to include within the event's event-args</param>
        </member>
        <member name="T:NetMQ.NetworkOrderBitsConverter">
            <summary>
            This static class serves to convert between byte-arrays, and various integer sizes
            - all of which assume the byte-data is in Big-endian, or "Network Byte Order".
            </summary>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.ToInt16(System.Byte[])">
            <summary>
            Given a byte-array assumed to be in Big-endian order, and an offset into it
            - return a 16-bit integer derived from the 2 bytes starting at that offset.
            </summary>
            <param name="buffer">the byte-array to get the short from</param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.GetBytes(System.Int16)">
            <summary>
            Given a 16-bit integer, return it as a byte-array in Big-endian order.
            </summary>
            <param name="value">the short to convert</param>
            <returns>a 2-byte array containing that short's bits</returns>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.PutInt16(System.Int16,System.Byte[])">
            <summary>
            Given a 16-bit integer, and a byte-array buffer and offset,
            - write the 2 bytes of that integer into the buffer starting at that offset, in Big-endian order.
            </summary>
            <param name="value">the short to convert into bytes</param>
            <param name="buffer">the byte-array to write the short's bytes into</param>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.ToInt32(System.Byte[])">
            <summary>
            Given a byte-array assumed to be in Big-endian order, and an offset into it
            - return a 32-bit integer derived from the 4 bytes starting at that offset.
            </summary>
            <param name="buffer">the byte-array to get the integer from</param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.GetBytes(System.Int32)">
            <summary>
            Given a 32-bit integer, return it as a byte-array in Big-endian order.
            </summary>
            <param name="value">the int to convert</param>
            <returns>a 4-byte array containing that integer's bits</returns>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.PutInt32(System.Int32,System.Byte[])">
            <summary>
            Given a 32-bit integer, and a byte-array buffer and offset,
            - write the 4 bytes of that integer into the buffer starting at that offset, in Big-endian order.
            </summary>
            <param name="value">the integer to convert into bytes</param>
            <param name="buffer">the byte-array to write the integer's bytes into</param>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.ToInt64(System.Byte[])">
            <summary>
            Given a byte-array assumed to be in Big-endian order, and an offset into it
            - return a 64-bit integer derived from the 8 bytes starting at that offset.
            </summary>
            <param name="buffer">the byte-array to get the Int64 from</param>
            <returns></returns>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.GetBytes(System.Int64)">
            <summary>
            Given a 64-bit integer, return it as a byte-array in Big-endian order.
            </summary>
            <param name="value">The <c>long</c> value to convert from.</param>
            <returns>The network order presentation of <paramref name="value"/> as an 8-byte array.</returns>
        </member>
        <member name="M:NetMQ.NetworkOrderBitsConverter.PutInt64(System.Int64,System.Byte[])">
            <summary>
            Given a 64-bit integer, and a byte-array buffer and offset,
            - write the 8 bytes of that integer into the buffer starting at that offset, in Big-endian order.
            </summary>
            <param name="value">the long value to convert into bytes</param>
            <param name="buffer">the byte-array to write the long value's bytes into</param>
        </member>
        <member name="T:NetMQ.OutgoingSocketExtensions">
            <summary>
            This static class serves to provide extension methods for IOutgoingSocket.
            </summary>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.Send(NetMQ.IOutgoingSocket,NetMQ.Msg@,System.Boolean)">
            <summary>
            Block until the message can be sent.
            </summary>
            <remarks>
            The call  blocks until the message can be sent and cannot be interrupted.
            Whether the message can be sent depends on the socket type.
            </remarks>
            <param name="socket">The socket to send the message on.</param>
            <param name="msg">An object with message's data to send.</param>
            <param name="more">Indicate if another frame is expected after this frame</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendFrame(NetMQ.IOutgoingSocket,System.Byte[],System.Boolean)">
            <summary>
            Transmit a byte-array of data over this socket, block until frame is sent.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="data">the byte-array of data to send</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendFrame(NetMQ.IOutgoingSocket,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Transmit a byte-array of data over this socket, block until frame is sent.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="data">the byte-array of data to send</param>
            <param name="length">the number of bytes to send from <paramref name="data"/>.</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendMoreFrame(NetMQ.IOutgoingSocket,System.Byte[])">
            <summary>
            Transmit a byte-array of data over this socket, block until frame is sent.
            Send more frame, another frame must be sent after this frame. Use to chain Send methods.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="data">the byte-array of data to send</param>
            <returns>a reference to this IOutgoingSocket so that method-calls may be chained together</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendMoreFrame(NetMQ.IOutgoingSocket,System.Byte[],System.Int32)">
            <summary>
            Transmit a byte-array of data over this socket, block until frame is sent.
            Send more frame, another frame must be sent after this frame. Use to chain Send methods.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="data">the byte-array of data to send</param>
            <param name="length">the number of bytes to send from <paramref name="data"/>.</param>
            <returns>a reference to this IOutgoingSocket so that method-calls may be chained together</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrame(NetMQ.IOutgoingSocket,System.TimeSpan,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Attempt to transmit a single frame on <paramref name="socket"/>.
            If message cannot be sent within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="timeout">The maximum period of time to try to send a message.</param>
            <param name="data">the byte-array of data to send</param>
            <param name="length">the number of bytes to send from <paramref name="data"/>.</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrame(NetMQ.IOutgoingSocket,System.TimeSpan,System.Byte[],System.Boolean)">
            <summary>
            Attempt to transmit a single frame on <paramref name="socket"/>.
            If message cannot be sent within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="timeout">The maximum period of time to try to send a message.</param>
            <param name="data">the byte-array of data to send</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrame(NetMQ.IOutgoingSocket,System.Byte[],System.Boolean)">
            <summary>
            Attempt to transmit a single frame on <paramref name="socket"/>.
            If message cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="data">the byte-array of data to send</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrame(NetMQ.IOutgoingSocket,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Attempt to transmit a single frame on <paramref name="socket"/>.
            If message cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="data">the byte-array of data to send</param>
            <param name="length">the number of bytes to send from <paramref name="data"/>.</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendMultipartBytes(NetMQ.IOutgoingSocket,System.Byte[][])">
            <summary>
            Send multiple frames on <paramref name="socket"/>, blocking until all frames are sent.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="frames">frames to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendMultipartBytes(NetMQ.IOutgoingSocket,System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Send multiple frames on <paramref name="socket"/>, blocking until all frames are sent.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="frames">frames to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendMultipartBytes(NetMQ.IOutgoingSocket,System.TimeSpan,System.Byte[][])">
            <summary>
            Attempt to transmit a multiple frames on <paramref name="socket"/>.
            If frames cannot be sent within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="timeout">The maximum period of time to try to send a message.</param>
            <param name="frames">frames to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendMultipartBytes(NetMQ.IOutgoingSocket,System.TimeSpan,System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Attempt to transmit a multiple frames on <paramref name="socket"/>.
            If frames cannot be sent within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="timeout">The maximum period of time to try to send a message.</param>
            <param name="frames">frames to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendMultipartBytes(NetMQ.IOutgoingSocket,System.Byte[][])">
            <summary>
            Attempt to transmit a multiple frames on <paramref name="socket"/>.
            If frames cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="frames">frames to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendMultipartBytes(NetMQ.IOutgoingSocket,System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Attempt to transmit a multiple frames on <paramref name="socket"/>.
            If frames cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="frames">frames to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendFrame(NetMQ.IOutgoingSocket,System.String,System.Boolean)">
            <summary>
            Transmit a string over this socket, block until frame is sent.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="message">the string to send</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendMoreFrame(NetMQ.IOutgoingSocket,System.String)">
            <summary>
            Transmit a string over this socket, block until frame is sent.
            Send more frame, another frame must be sent after this frame. Use to chain Send methods.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="message">the string to send</param>
            <returns>a reference to this IOutgoingSocket so that method-calls may be chained together</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrame(NetMQ.IOutgoingSocket,System.TimeSpan,System.String,System.Boolean)">
            <summary>
            Attempt to transmit a single string frame on <paramref name="socket"/>.
            If message cannot be sent within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="timeout">The maximum period of time to try to send a message.</param>
            <param name="message">the string to send</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrame(NetMQ.IOutgoingSocket,System.String,System.Boolean)">
            <summary>
            Attempt to transmit a single string frame on <paramref name="socket"/>.
            If message cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="message">the string to send</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendMultipartMessage(NetMQ.IOutgoingSocket,NetMQ.NetMQMessage)">
            <summary>
            Send multiple message on <paramref name="socket"/>, blocking until all entire message is sent.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="message">message to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendMultipartMessage(NetMQ.IOutgoingSocket,System.TimeSpan,NetMQ.NetMQMessage)">
            <summary>
            Attempt to transmit a multiple message on <paramref name="socket"/>.
            If message cannot be sent within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="timeout">The maximum period of time to try to send a message.</param>
            <param name="message">message to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendMultipartMessage(NetMQ.IOutgoingSocket,NetMQ.NetMQMessage)">
            <summary>
            Attempt to transmit a multiple message on <paramref name="socket"/>.
            If frames cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="message">message to transmit</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendFrameEmpty(NetMQ.IOutgoingSocket,System.Boolean)">
            <summary>
            Transmit an empty frame over this socket, block until frame is sent.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SendMoreFrameEmpty(NetMQ.IOutgoingSocket)">
            <summary>
            Transmit an empty frame over this socket, block until frame is sent.
            Send more frame, another frame must be sent after this frame. Use to chain Send methods.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <returns>a reference to this IOutgoingSocket so that method-calls may be chained together</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrameEmpty(NetMQ.IOutgoingSocket,System.TimeSpan,System.Boolean)">
            <summary>
            Attempt to transmit an empty frame on <paramref name="socket"/>.
            If message cannot be sent within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="timeout">The maximum period of time to try to send a message.</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySendFrameEmpty(NetMQ.IOutgoingSocket,System.Boolean)">
            <summary>
            Attempt to transmit an empty frame on <paramref name="socket"/>.
            If message cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="more">set this flag to true to signal that you will be immediately sending another frame (optional: default is false)</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.Signal(NetMQ.IOutgoingSocket,System.Byte)">
            <summary>
            Transmit a status-signal over this socket.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="status">a byte that contains the status signal to send</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySignal(NetMQ.IOutgoingSocket,System.Byte)">
            <summary>
            Attempt to transmit a status-signal over this socket.
            If signal cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
            <param name="status">a byte that contains the status signal to send</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SignalOK(NetMQ.IOutgoingSocket)">
            <summary>
            Transmit a specific status-signal over this socket that indicates OK.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySignalOK(NetMQ.IOutgoingSocket)">
            <summary>
            Attempt to transmit a specific status-signal over this socket that indicates OK.
            If signal cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.SignalError(NetMQ.IOutgoingSocket)">
            <summary>
            Transmit a specific status-signal over this socket that indicates there is an error.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
        </member>
        <member name="M:NetMQ.OutgoingSocketExtensions.TrySignalError(NetMQ.IOutgoingSocket)">
            <summary>
            Attempt to transmit a specific status-signal over this socket that indicates there is an error.
            If signal cannot be sent immediately, return <c>false</c>.
            </summary>
            <param name="socket">the IOutgoingSocket to transmit on</param>
        </member>
        <member name="T:NetMQ.PollEvents">
            <summary>
            This flags enum-type is simply an indication of the direction of the poll-event,
            and can be None, PollIn, PollOut, or PollError.
            </summary>
        </member>
        <member name="T:NetMQ.PollEventsExtensions">
            <summary>
            Extension methods for the <see cref="T:NetMQ.PollEvents"/> enum.
            </summary>
        </member>
        <member name="M:NetMQ.PollEventsExtensions.HasIn(NetMQ.PollEvents)">
            <summary>Test whether <paramref name="pollEvents"/> has the <see cref="F:NetMQ.PollEvents.PollIn"/> flag set.</summary>
        </member>
        <member name="M:NetMQ.PollEventsExtensions.HasOut(NetMQ.PollEvents)">
            <summary>Test whether <paramref name="pollEvents"/> has the <see cref="F:NetMQ.PollEvents.PollOut"/> flag set.</summary>
        </member>
        <member name="M:NetMQ.PollEventsExtensions.HasError(NetMQ.PollEvents)">
            <summary>Test whether <paramref name="pollEvents"/> has the <see cref="F:NetMQ.PollEvents.PollError"/> flag set.</summary>
        </member>
        <member name="T:NetMQ.Proxy">
            <summary>
            Forwards messages bidirectionally between two sockets. You can also specify a control socket tn which proxied messages will be sent.
            </summary>
            <remarks>
            This class must be explicitly started by calling <see cref="M:NetMQ.Proxy.Start"/>. If an external <see cref="T:NetMQ.NetMQPoller"/> has been specified,
            then that call will block until <see cref="M:NetMQ.Proxy.Stop"/> is called.
            <para/>
            If using an external <see cref="T:NetMQ.NetMQPoller"/>, ensure the front and back end sockets have been added to it.
            <para/>
            Users of this class must call <see cref="M:NetMQ.Proxy.Stop"/> when messages should no longer be proxied.
            </remarks>
        </member>
        <member name="M:NetMQ.Proxy.#ctor(NetMQ.NetMQSocket,NetMQ.NetMQSocket,NetMQ.NetMQSocket,NetMQ.NetMQSocket,NetMQ.INetMQPoller)">
            <summary>
            Create a new instance of a Proxy (NetMQ.Proxy)
            with the given sockets to serve as a front-end, a back-end, and a control socket.
            </summary>
            <param name="frontend">the socket that messages will be forwarded from</param>
            <param name="backend">the socket that messages will be forwarded to</param>
            <param name="controlIn">this socket will have incoming messages also sent to it - you can set this to null if not needed</param>
            <param name="controlOut">this socket will have outgoing messages also sent to it - you can set this to null if not needed</param>
            <param name="poller">an optional external poller to use within this proxy</param>
        </member>
        <member name="M:NetMQ.Proxy.#ctor(NetMQ.NetMQSocket,NetMQ.NetMQSocket,NetMQ.NetMQSocket,NetMQ.INetMQPoller)">
            <summary>
            Create a new instance of a Proxy (NetMQ.Proxy)
            with the given sockets to serve as a front-end, a back-end, and a control socket.
            </summary>
            <param name="frontend">the socket that messages will be forwarded from</param>
            <param name="backend">the socket that messages will be forwarded to</param>
            <param name="control">this socket will have messages also sent to it - you can set this to null if not needed</param>
            <param name="poller">an optional external poller to use within this proxy</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="poller"/> is not <c>null</c> and either <paramref name="frontend"/> or <paramref name="backend"/> are not contained within it.</exception>
        </member>
        <member name="M:NetMQ.Proxy.Start">
            <summary>
            Start proxying messages between the front and back ends. Blocks, unless using an external <see cref="T:NetMQ.NetMQPoller"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">The proxy has already been started.</exception>
        </member>
        <member name="M:NetMQ.Proxy.Stop">
            <summary>
            Stops the proxy, blocking until the underlying <see cref="T:NetMQ.NetMQPoller"/> has completed.
            </summary>
            <exception cref="T:System.InvalidOperationException">The proxy has not been started.</exception>
        </member>
        <member name="T:NetMQ.ReceivingSocketExtensions">
            <summary>
            Provides extension methods for the <see cref="T:NetMQ.IReceivingSocket"/> interface,
            via which messages may be received in several ways.
            </summary>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.Receive(NetMQ.IReceivingSocket,NetMQ.Msg@)">
            <summary>
            Block until the next message arrives, then make the message's data available via <paramref name="msg"/>.
            </summary>
            <remarks>
            The call  blocks until the next message arrives, and cannot be interrupted. This a convenient and safe when
            you know a message is available, such as for code within a <see cref="E:NetMQ.NetMQSocket.ReceiveReady"/> callback.
            </remarks>
            <param name="socket">The socket to receive from.</param>
            <param name="msg">An object to receive the message's data into.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveFrameBytes(NetMQ.IReceivingSocket)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <returns>The content of the received message frame.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveFrameBytes(NetMQ.IReceivingSocket,System.Boolean@)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns>The content of the received message frame.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameBytes(NetMQ.IReceivingSocket,System.Byte[]@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="bytes">The content of the received message frame, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameBytes(NetMQ.IReceivingSocket,System.Byte[]@,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>.
            If no message is immediately available, return <c>false</c>.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <param name="bytes">The content of the received message frame, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameBytes(NetMQ.IReceivingSocket,System.TimeSpan,System.Byte[]@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="bytes">The content of the received message frame, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameBytes(NetMQ.IReceivingSocket,System.TimeSpan,System.Byte[]@,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="bytes">The content of the received message frame, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveMultipartBytes(NetMQ.IReceivingSocket,System.Int32)">
            <summary>
            Receive all frames of the next message from <paramref name="socket"/>, blocking until a message arrives.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="expectedFrameCount">Optional initial <see cref="P:System.Collections.Generic.List`1.Capacity"/> for the returned <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <returns>All frames of a multipart message as a list having one or more items.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveMultipartBytes(NetMQ.IReceivingSocket,System.Collections.Generic.List{System.Byte[]}@,System.Int32)">
            <summary>
            Receive all frames of the next message from <paramref name="socket"/>, blocking until a message arrives.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="frames">Reference to a list for return values. If <c>null</c> a new instance will be assigned, otherwise the provided list will be cleared and populated.</param>
            <param name="expectedFrameCount">Optional initial <see cref="P:System.Collections.Generic.List`1.Capacity"/> for the returned <see cref="T:System.Collections.Generic.List`1"/>.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartBytes(NetMQ.IReceivingSocket,System.Collections.Generic.List{System.Byte[]}@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="frames">Reference to a list for return values. If <c>null</c> a new instance will be assigned, otherwise the provided list will be cleared and populated.</param>
            <param name="expectedFrameCount">Optional initial <see cref="P:System.Collections.Generic.List`1.Capacity"/> for the returned <see cref="T:System.Collections.Generic.List`1"/>.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartBytes(NetMQ.IReceivingSocket,System.TimeSpan,System.Collections.Generic.List{System.Byte[]}@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="frames">Reference to a list for return values. If <c>null</c> a new instance will be assigned, otherwise the provided list will be cleared and populated.</param>
            <param name="expectedFrameCount">Optional initial <see cref="P:System.Collections.Generic.List`1.Capacity"/> for the returned <see cref="T:System.Collections.Generic.List`1"/>.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveFrameString(NetMQ.IReceivingSocket)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives, and decode as a string using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <returns>The content of the received message frame as a string.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveFrameString(NetMQ.IReceivingSocket,System.Boolean@)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives, and decode as a string using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns>The content of the received message frame.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveFrameString(NetMQ.IReceivingSocket,System.Text.Encoding)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives, and decode as a string using <paramref name="encoding"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <returns>The content of the received message frame as a string.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveFrameString(NetMQ.IReceivingSocket,System.Text.Encoding,System.Boolean@)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives, and decode as a string using <paramref name="encoding"/>.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns>The content of the received message frame as a string.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.String@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.String@,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.Text.Encoding,System.String@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <paramref name="encoding"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.Text.Encoding,System.String@,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <paramref name="encoding"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.TimeSpan,System.String@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.TimeSpan,System.String@,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.TimeSpan,System.Text.Encoding,System.String@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <paramref name="encoding"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveFrameString(NetMQ.IReceivingSocket,System.TimeSpan,System.Text.Encoding,System.String@,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, and decode as a string using <paramref name="encoding"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="frameString">The content of the received message frame as a string, or <c>null</c> if no message was available.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveMultipartStrings(NetMQ.IReceivingSocket,System.Int32)">
            <summary>
            Receive all frames of the next message from <paramref name="socket"/>, blocking until they arrive, and decode as strings using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns>The content of the received message frame as a string.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveMultipartStrings(NetMQ.IReceivingSocket,System.Text.Encoding,System.Int32)">
            <summary>
            Receive all frames of the next message from <paramref name="socket"/>, blocking until they arrive, and decode as strings using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartStrings(NetMQ.IReceivingSocket,System.Collections.Generic.List{System.String}@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>, and decode them as strings using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="frames">The frames of the received message as strings. Untouched if no message was available.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartStrings(NetMQ.IReceivingSocket,System.Text.Encoding,System.Collections.Generic.List{System.String}@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>, and decode them as strings using <paramref name="encoding"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="frames">The frames of the received message as strings. Untouched if no message was available.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartStrings(NetMQ.IReceivingSocket,System.TimeSpan,System.Collections.Generic.List{System.String}@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>, and decode them as strings using <see cref="F:NetMQ.SendReceiveConstants.DefaultEncoding"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="frames">The frames of the received message as strings. Untouched if no message was available.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartStrings(NetMQ.IReceivingSocket,System.TimeSpan,System.Text.Encoding,System.Collections.Generic.List{System.String}@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>, and decode them as strings using <paramref name="encoding"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="encoding">The encoding used to convert the frame's data to a string.</param>
            <param name="frames">The frames of the received message as strings. Untouched if no message was available.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveMultipartMessage(NetMQ.IReceivingSocket,System.Int32)">
            <summary>
            Receive all frames of the next message from <paramref name="socket"/>, blocking until they arrive.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns>The content of the received message frame as a string.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartMessage(NetMQ.IReceivingSocket,NetMQ.NetMQMessage@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="message">The received message. Untouched if no message was available.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveMultipartMessage(NetMQ.IReceivingSocket,System.TimeSpan,NetMQ.NetMQMessage@,System.Int32)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="message">The received message. Untouched if no message was available.</param>
            <param name="expectedFrameCount">Specifies the initial capacity of the <see cref="T:System.Collections.Generic.List`1"/> used
            to buffer results. If the number of frames is known, set it here. If more frames arrive than expected,
            an extra allocation will occur, but the result will still be correct.</param>
            <returns><c>true</c> if a message was available, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.ReceiveSignal(NetMQ.IReceivingSocket)">
            <summary>
            Receive frames from <paramref name="socket"/>, blocking until a valid signal arrives.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <returns><c>true</c> if the received signal was zero, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveSignal(NetMQ.IReceivingSocket,System.Boolean@)">
            <summary>
            Attempt to receive a valid signal from <paramref name="socket"/>.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="signal"><c>true</c> if the received signal was zero, otherwise <c>false</c>. If no signal received, <c>false</c>.</param>
            <returns><c>true</c> if a valid signal was observed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TryReceiveSignal(NetMQ.IReceivingSocket,System.TimeSpan,System.Boolean@)">
            <summary>
            Attempt to receive a valid signal from <paramref name="socket"/>.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="signal"><c>true</c> if the received signal was zero, otherwise <c>false</c>. If no signal received, <c>false</c>.</param>
            <returns><c>true</c> if a valid signal was observed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.SkipFrame(NetMQ.IReceivingSocket)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives, then ignore its content.
            </summary>
            <param name="socket">The socket to receive from.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.SkipFrame(NetMQ.IReceivingSocket,System.Boolean@)">
            <summary>
            Receive a single frame from <paramref name="socket"/>, blocking until one arrives, then ignore its content.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TrySkipFrame(NetMQ.IReceivingSocket)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, then ignore its content.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <returns><c>true</c> if a frame was received and ignored, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TrySkipFrame(NetMQ.IReceivingSocket,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, then ignore its content.
            If no message is immediately available, return <c>false</c>.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns><c>true</c> if a frame was received and ignored, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TrySkipFrame(NetMQ.IReceivingSocket,System.TimeSpan)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, then ignore its content.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <returns><c>true</c> if a frame was received and ignored, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TrySkipFrame(NetMQ.IReceivingSocket,System.TimeSpan,System.Boolean@)">
            <summary>
            Attempt to receive a single frame from <paramref name="socket"/>, then ignore its content.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            Indicate whether further frames exist via <paramref name="more"/>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <param name="more"><c>true</c> if another frame of the same message follows, otherwise <c>false</c>.</param>
            <returns><c>true</c> if a frame was received and ignored, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.SkipMultipartMessage(NetMQ.IReceivingSocket)">
            <summary>
            Receive all frames of the next message from <paramref name="socket"/>, blocking until a message arrives, then ignore their contents.
            </summary>
            <param name="socket">The socket to receive from.</param>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TrySkipMultipartMessage(NetMQ.IReceivingSocket)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>, then ignore their contents.
            If no message is immediately available, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <returns><c>true</c> if a frame was received and ignored, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NetMQ.ReceivingSocketExtensions.TrySkipMultipartMessage(NetMQ.IReceivingSocket,System.TimeSpan)">
            <summary>
            Attempt to receive all frames of the next message from <paramref name="socket"/>, then ignore their contents.
            If no message is available within <paramref name="timeout"/>, return <c>false</c>.
            </summary>
            <param name="socket">The socket to receive from.</param>
            <param name="timeout">The maximum period of time to wait for a message to become available.</param>
            <returns><c>true</c> if a frame was received and ignored, otherwise <c>false</c>.</returns>
        </member>
        <member name="F:NetMQ.SendReceiveConstants.DefaultEncoding">
            <summary>
            The <see cref="T:System.Text.Encoding"/> used in string related methods that do
            not explicitly provide an encoding parameter.
            </summary>
        </member>
        <member name="F:NetMQ.SendReceiveConstants.InfiniteTimeout">
            <summary>Indicates an infinite timeout for send and receive operations.</summary>
        </member>
        <member name="T:NetMQ.SocketEvents">
            <summary>
            This enum-type specifies socket transport events (TCP and IPC only).
            </summary>
        </member>
        <member name="T:NetMQ.SocketOptions">
            <summary>
            A SocketOptions is simply a convenient way to access the options of a particular socket.
            This class holds a reference to the socket, and it's properties provide a concise way
            to access that socket's option values -- instead of calling GetSocketOption/SetSocketOption.
            </summary>
        </member>
        <member name="F:NetMQ.SocketOptions.m_socket">
            <summary>
            The NetMQSocket that this SocketOptions is referencing.
            </summary>
        </member>
        <member name="M:NetMQ.SocketOptions.#ctor(NetMQ.NetMQSocket)">
            <summary>
            Create a new SocketOptions that references the given NetMQSocket.
            </summary>
            <param name="socket">the NetMQSocket for this SocketOptions to hold a reference to</param>
        </member>
        <member name="P:NetMQ.SocketOptions.Affinity">
            <summary>
            Get or set the I/O-thread affinity. This is a 64-bit value used to specify  which threads from the I/O thread-pool
            associated with the socket's context shall handle newly-created connections.
            0 means no affinity, meaning that work shall be distributed fairly among all I/O threads.
            For non-zero values, the lowest bit corresponds to thread 1, second lowest bit to thread 2, and so on.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.Identity">
            <summary>
            Get or set unique identity of the socket, from a message-queueing router's perspective.
            This is a byte-array of at most 255 bytes.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.MulticastRate">
            <summary>
            Get or set the maximum send or receive data rate for multicast transports on the specified socket.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.MulticastRecoveryInterval">
            <summary>
            Get or set the recovery-interval for multicast transports using the specified socket.
            This option determines the maximum time that a receiver can be absent from a multicast group
            before unrecoverable data loss will occur. Default is 10,000 ms (10 seconds).
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.SendBuffer">
            <summary>
            Get or set the size of the transmit buffer for the specified socket.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.ReceiveBuffer">
            <summary>
            Get or set the size of the receive buffer for the specified socket.
            A value of zero means that the OS default is in effect.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.ReceiveMore">
            <summary>
            Gets whether the last frame received on the socket had the <em>more</em> flag set or not.
            </summary>
            <value><c>true</c> if receive more; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:NetMQ.SocketOptions.Linger">
            <summary>
            Get or set the linger period for the specified socket,
            which determines how long pending messages which have yet to be sent to a peer
            shall linger in memory after a socket is closed.
            </summary>
            <remarks>
            If socket created with Context default is -1 if socket created without socket (using new keyword) default is zero.
            If context is used this also affects the termination of context, otherwise this affects the exit of the process.
            -1: Specifies an infinite linger period. Pending messages shall not be discarded after the socket is closed;
            attempting to terminate the socket's context shall block until all pending messages have been sent to a peer.
            0: Specifies no linger period. Pending messages shall be discarded immediately when the socket is closed.
            Positive values specify an upper bound for the linger period. Pending messages shall not be discarded after the socket is closed;
            attempting to terminate the socket's context shall block until either all pending messages have been sent to a peer,
            or the linger period expires, after which any pending messages shall be discarded.
            </remarks>
        </member>
        <member name="P:NetMQ.SocketOptions.ReconnectInterval">
            <summary>
            Get or set the initial reconnection interval for the specified socket.
            This is the period to wait between attempts to reconnect disconnected peers
            when using connection-oriented transports. The default is 100 ms.
            -1 means no reconnection.
            </summary>
            <remarks>
            With ZeroMQ, the reconnection interval may be randomized to prevent reconnection storms
            in topologies with a large number of peers per socket.
            </remarks>
        </member>
        <member name="P:NetMQ.SocketOptions.ReconnectIntervalMax">
            <summary>
            Get or set the maximum reconnection interval for the specified socket.
            This is the maximum period to shall wait between attempts
            to reconnect. On each reconnect attempt, the previous interval shall be doubled
            until this maximum period is reached.
            The default value of zero means no exponential backoff is performed.
            </summary>
            <remarks>
            This is the maximum period NetMQ shall wait between attempts
            to reconnect. On each reconnect attempt, the previous interval shall be doubled
            until this maximum period is reached.
            This allows for an exponential backoff strategy.
            The default value of zero means no exponential backoff is performed
            and reconnect interval calculations are only based on ReconnectIvl.
            </remarks>
        </member>
        <member name="P:NetMQ.SocketOptions.Backlog">
            <summary>
            Get or set the maximum length of the queue of outstanding peer connections
            for the specified socket. This only applies to connection-oriented transports.
            Default is 100.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.MaxMsgSize">
            <summary>
            Get or set the upper limit to the size for inbound messages.
            If a peer sends a message larger than this it is disconnected.
            The default value is -1, which means no limit.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.SendHighWatermark">
            <summary>
            Get or set the high-water-mark for transmission.
            This is a hard limit on the number of messages that are allowed to queue up
            before mitigative action is taken.
            The default is 1000.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.ReceiveHighWatermark">
            <summary>
            Get or set the high-water-mark for reception.
            This is a hard limit on the number of messages that are allowed to queue up
            before mitigative action is taken.
            The default is 1000.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.SendLowWatermark">
            <summary>
            The low-water mark for message transmission.
            This is the number of messages that should be processed before transmission is
            unblocked (in case it was blocked by reaching high-watermark). The default value is
            calculated using relevant high-watermark (HWM): HWM > 2048 ? HWM - 1024 : (HWM + 1) / 2
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.ReceiveLowWatermark">
            <summary>
            The low-water mark for message reception.
            This is the number of messages that should be processed  before reception is
            unblocked (in case it was blocked by reaching high-watermark). The default value is
            calculated using relevant high-watermark (HWM): HWM > 2048 ? HWM - 1024 : (HWM + 1) / 2
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.MulticastHops">
            <summary>
            Get or set the time-to-live (maximum number of hops) that outbound multicast packets
            are allowed to propagate.
            The default value of 1 means that the multicast packets don't leave the local network.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.IPv4Only">
            <summary>
            Get or set whether the underlying socket is for IPv4 only (not IPv6),
            as opposed to one that allows connections with either IPv4 or IPv6.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.LastEndpoint">
            <summary>
            Get the last endpoint bound for TCP and IPC transports.
            The returned value will be a string in the form of a ZMQ DSN.
            </summary>
            <remarks>
            If the TCP host is ANY, indicated by a *, then the returned address
            will be 0.0.0.0 (for IPv4).
            </remarks>
        </member>
        <member name="P:NetMQ.SocketOptions.RouterMandatory">
            <summary>
            Set the RouterSocket behavior when an unroutable message is encountered.
            A value of false is the default and discards the message silently when it cannot be routed.
            A value of true causes throw of HostUnreachableException if the message cannot be routed.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.TcpKeepalive">
            <summary>
            Get or set whether to use TCP keepalive.
            </summary>
            <remarks>
            When Keepalive is enabled, then your socket will periodically send an empty keepalive probe packet
            with the ACK flag on. The remote endpoint does not need to support keepalive at all, just TCP/IP.
            If you receive a reply to your keepalive probe, you can assume that the connection is still up and running.
            This procedure is useful because if the other peers lose their connection (for example, by rebooting)
            you will notice that the connection is broken, even if you don't have traffic on it.
            If the keepalive probes are not replied to by your peer, you can assert that the connection
            cannot be considered valid and then take the corrective action.
            </remarks>
        </member>
        <member name="P:NetMQ.SocketOptions.TcpKeepaliveIdle">
            <summary>
            Get or set the keep-alive time - the duration between two keepalive transmissions in idle condition.
            The TCP keepalive period is required by socket implementers to be configurable and by default is
            set to no less than 2 hours.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.TcpKeepaliveInterval">
            <summary>
            Get or set the TCP keep-alive interval - the duration between two keepalive transmission if no response was received to a previous keepalive probe.
            </summary>
            <remarks>
            By default a keepalive packet is sent every 2 hours or 7,200,000 milliseconds
            (TODO: Check these comments concerning default values!  jh)
            if no other data have been carried over the TCP connection.
            If there is no response to a keepalive, it is repeated once every KeepAliveInterval seconds.
            The default is one second.
            </remarks>
        </member>
        <member name="P:NetMQ.SocketOptions.DelayAttachOnConnect">
            <summary>
            Get or set the attach-on-connect value.
            If set to true, this will delay the attachment of a pipe on connect until
            the underlying connection has completed. This will cause the socket
            to block if there are no other connections, but will prevent queues
            from filling on pipes awaiting connection.
            Default is false.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.XPubVerbose">
            <summary>
            This applies only to publisher sockets.
            Set whether to send all subscription messages upstream, not just unique ones.
            The default is false.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.XPubBroadcast">
            <summary>
            This applies only to publisher sockets.
            Set whether to support broadcast functionality
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.RouterRawSocket">
            <summary>
            This applies only to router sockets.
            Set whether RouterSocket allows non-zmq tcp connects.
            If true, router socket accepts non-zmq tcp connections
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.RouterHandover">
            <summary>
            When enabled new router connections with same identity take over old ones
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.Endian">
            <summary>
            Get or set the byte-order: big-endian, vs little-endian.
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.LastPeerRoutingId">
            <summary>
            Get the last PEER allocated routing id
            </summary>
        </member>
        <member name="P:NetMQ.SocketOptions.PgmMaxTransportServiceDataUnitLength">
            <summary>
            Controls the maximum datagram size for PGM.
            </summary>
        </member>
        <member name="T:NetMQ.Sockets.DealerSocket">
            <summary>
            A DealerSocket is a NetMQSocket, whereby the dealer sends messages in a way intended to achieve load-balancing
            - which are received in a fair queueing manner.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.DealerSocket.#ctor(System.String)">
            <summary>
            Create a new DealerSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new DealerSocket(">tcp://127.0.0.1:5555,@127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.DealerSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new DealerSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="T:NetMQ.Sockets.PairSocket">
            <summary>
            A PairSocket is a NetMQSocket, usually used to synchronize two threads - using only one socket on each side.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.PairSocket.#ctor(System.String)">
            <summary>
            Create a new PairSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new PairSocket(">tcp://127.0.0.1:5555,@127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.PairSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new PairSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.PairSocket.CreateSocketPair(NetMQ.Sockets.PairSocket@,NetMQ.Sockets.PairSocket@)">
            <summary>
            Create and return an inproc pipe where socket1 is bound and socket2 is connected.
            </summary>
            <param name="socket1">the Bind socket</param>
            <param name="socket2">the Connect socket</param>
        </member>
        <member name="M:NetMQ.Sockets.PairSocket.CreateSocketPair(NetMQ.Sockets.PairSocket@,NetMQ.Sockets.PairSocket@,System.Action{NetMQ.Sockets.PairSocket},System.Action{NetMQ.Sockets.PairSocket})">
            <summary>
            Create and return an inproc pipe where socket1 is bound and socket2 is connected.
            </summary>
            <param name="socket1">the Bind socket</param>
            <param name="socket2">the Connect socket</param>
            <param name="initSocket1">Method to initialize socket1 before connection</param>
            <param name="initSocket2">Method to initialize socket2 before connection</param>
        </member>
        <member name="T:NetMQ.Sockets.PeerSocket">
            <summary>
            Peer socket, the first message is always the identity of the sender
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.PeerSocket.#ctor(System.String)">
            <summary>
            Create a new PeerSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new PeerSocket(">tcp://127.0.0.1:5555,>127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.PeerSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new PeerSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.PeerSocket.ConnectPeer(System.String)">
            <summary>
            Connect the peer socket to <paramref name="address"/>.
            </summary>
            <param name="address">a string denoting the address to connect this socket to</param>
            <returns>The peer allocated routing id</returns>
            <exception cref="!:ObjectDisposedException">thrown if the socket was already disposed</exception>
            <exception cref="T:NetMQ.TerminatingException">The socket has been stopped.</exception>
            <exception cref="T:NetMQ.NetMQException">No IO thread was found.</exception>
            <exception cref="T:NetMQ.AddressAlreadyInUseException">The specified address is already in use.</exception>
        </member>
        <member name="T:NetMQ.Sockets.PublisherSocket">
            <summary>
            A PublisherSocket is a NetMQSocket intended to be used as the Pub in the PubSub pattern.
            The intended usage is for publishing messages to all subscribers which are subscribed to a given topic.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.PublisherSocket.#ctor(System.String)">
            <summary>
            Create a new PublisherSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is bind (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new PublisherSocket(">tcp://127.0.0.1:5555,>127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.PublisherSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new PublisherSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.PublisherSocket.TryReceive(NetMQ.Msg@,System.TimeSpan)">
            <summary><see cref="T:NetMQ.Sockets.PublisherSocket"/> doesn't support sending, so this override throws <see cref="T:System.NotSupportedException"/>.</summary>
            <exception cref="T:System.NotSupportedException">Receive is not supported.</exception>
        </member>
        <member name="T:NetMQ.Sockets.PullSocket">
            <summary>
            A PullSocket is a NetMQSocket intended to be used as the "Pull" part of the Push-Pull pattern.
            This will "pull" messages that have been pushed from the "push" socket.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.PullSocket.#ctor(System.String)">
            <summary>
            Create a new PullSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is bind (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new PullSocket(">tcp://127.0.0.1:5555,>127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.PullSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new PullSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="T:NetMQ.Sockets.PushSocket">
            <summary>
            A PushSocket is a NetMQSocket intended to be used as the "Push" part of the Push-Pull pattern.
            This will "push" messages to be pulled by the "pull" socket.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.PushSocket.#ctor(System.String)">
            <summary>
            Create a new PushSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new PushSocket(">tcp://127.0.0.1:5555,@127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.PushSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new PushSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.PushSocket.TryReceive(NetMQ.Msg@,System.TimeSpan)">
            <summary><see cref="T:NetMQ.Sockets.PushSocket"/> doesn't support sending, so this override throws <see cref="T:System.NotSupportedException"/>.</summary>
            <exception cref="T:System.NotSupportedException">Receive is not supported.</exception>
        </member>
        <member name="T:NetMQ.Sockets.RequestSocket">
            <summary>
            A RequestSocket is a NetMQSocket intended to be used as the Request part of the Request-Response pattern.
            This is generally paired with a ResponseSocket.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.RequestSocket.#ctor(System.String)">
            <summary>
            Create a new RequestSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new RequestSocket(">tcp://127.0.0.1:5555,@127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.RequestSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new RequestSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.RequestSocket.RequestResponseMultipartMessageWithRetry(System.String,NetMQ.NetMQMessage,System.Int32,System.TimeSpan,NetMQ.Sockets.PublisherSocket)">
            <summary>
            Try to send request message and return the response as a message, or return null if not successful
            </summary>
            <param name="address">a string denoting the address to connect to</param>
            <param name="requestMessage">The request message</param>
            <param name="numTries">The number of times to try</param>
            <param name="requestTimeout">The timeout for each request</param>
            <param name="progressPublisher">Report topics: Failure, Retry, Send, Success</param>
            <returns>the response message, or null if not successful</returns>
        </member>
        <member name="M:NetMQ.Sockets.RequestSocket.RequestResponseStringWithRetry(System.String,System.String,System.Int32,System.TimeSpan,NetMQ.Sockets.PublisherSocket)">
            <summary>
            Try to send request string and return the response string, or return null if not successful
            </summary>
            <param name="address">a string denoting the address to connect to</param>
            <param name="requestString">The request string</param>
            <param name="numTries">The number of times to try</param>
            <param name="requestTimeout">The timeout for each request</param>
            <param name="progressPublisher">Report topics: Failure, Retry, Send, Success</param>
            <returns>the response message, or null if not successful</returns>
        </member>
        <member name="T:NetMQ.Sockets.ResponseSocket">
            <summary>
            A ResponseSocket is a NetMQSocket intended to be used as the Response part of the Request-Response pattern.
            This is generally paired with a RequestSocket.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.ResponseSocket.#ctor(System.String)">
            <summary>
            Create a new ResponseSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is bind (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new ResponseSocket(">tcp://127.0.0.1:5555,>127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.ResponseSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new ResponseSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="T:NetMQ.Sockets.RouterSocket">
            <summary>
            Router socket, the first message is always the identity of the sender
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.RouterSocket.#ctor(System.String)">
            <summary>
            Create a new RouterSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is bind (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new RouterSocket(">tcp://127.0.0.1:5555,>127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.RouterSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new RouterSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="T:NetMQ.Sockets.StreamSocket">
            <summary>
            This is a NetMQSocket but provides no additional functionality.
            You can use it when you need an instance that is a NetMQSocket
            but with none of the distinguishing behavior of any of the other socket types.
            </summary>
            <remarks>
            This is provided because NetMQSocket is an abstract class, so you cannot instantiate it directly.
            </remarks>
        </member>
        <member name="M:NetMQ.Sockets.StreamSocket.#ctor(System.String)">
            <summary>
            Create a new StreamSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new StreamSocket(">tcp://127.0.0.1:5555,@127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.StreamSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new StreamSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="T:NetMQ.Sockets.SubscriberSocket">
            <summary>
            A SubscriberSocket is a NetMQSocket intended to be used as the "Sub" in the PubSub pattern.
            The intended usage is to receive messages from the  publisher socket.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.#ctor(System.String)">
            <summary>
            Create a new SubscriberSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new SubscriberSocket(">tcp://127.0.0.1:5555,@127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new SubscriberSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.Subscribe(System.String)">
            <summary>
            Subscribe this socket to the given 'topic' - which means enable this socket to receive
            messages that begin with this string prefix.
            You can set topic to an empty string to subscribe to everything.
            </summary>
            <param name="topic">this specifies what text-prefix to subscribe to, or may be an empty-string to specify ALL</param>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.Subscribe(System.String,System.Text.Encoding)">
            <summary>
            Subscribe this socket to the given 'topic' - which means enable this socket to receive
            messages that begin with this string prefix, using the given Encoding.
            You can set topic to an empty string to subscribe to everything.
            </summary>
            <param name="topic">this specifies what text-prefix to subscribe to, or may be an empty-string to specify ALL</param>
            <param name="encoding">the character-Encoding to use when converting the topic string internally into a byte-array</param>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.Subscribe(System.Byte[])">
            <summary>
            Subscribe this socket to the given 'topic' - which means enable this socket to receive
            messages that begin with this array of bytes.
            </summary>
            <param name="topic">this specifies what byte-array prefix to subscribe to</param>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.SubscribeToAnyTopic">
            <summary>
            Subscribe this socket to all topics - which means enable this socket to receive
            all messages regardless of what the string prefix is.
            This is the same as calling Subscribe with an empty-string for the topic.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.Unsubscribe(System.String)">
            <summary>
            Remove this socket's subscription to the given topic.
            </summary>
            <param name="topic">a string denoting which the topic to stop receiving</param>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.Unsubscribe(System.String,System.Text.Encoding)">
            <summary>
            Remove this socket's subscription to the given topic.
            </summary>
            <param name="topic">a string denoting which the topic to stop receiving</param>
            <param name="encoding">the Encoding to use when converting the topic string internally into a byte-array</param>
        </member>
        <member name="M:NetMQ.Sockets.SubscriberSocket.Unsubscribe(System.Byte[])">
            <summary>
            Remove this socket's subscription to the given topic.
            </summary>
            <param name="topic">a byte-array denoting which the topic to stop receiving</param>
        </member>
        <member name="T:NetMQ.Sockets.XPublisherSocket">
            <summary>
            An XPublisherSocket is a NetMQSocket intended to be used as the XPub in the XPub/XSub pattern.
            The intended usage is for serving, together with a matching XSubscriberSocket,
            as a stable intermediary between a PublisherSocket and it's SubscriberSockets.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.#ctor(System.String)">
            <summary>
            Create a new XPublisherSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is bind (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new XPublisherSocket(">tcp://127.0.0.1:5555,>127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new XPublisherSocket based upon the given <see cref="T:NetMQ.Core.SocketBase"/>.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.Subscribe(System.String)">
            <summary>
            In case of socket set to manual mode will subscribe the last subscriber to the topic
            </summary>
            <param name="topic">a string specifying the Topic to subscribe to</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.Subscribe(System.String,System.Text.Encoding)">
            <summary>
            In case of socket set to manual mode will subscribe the last subscriber to the topic
            </summary>
            <param name="topic">a string specifying the Topic to subscribe to</param>
            <param name="encoding">the character-Encoding to use when converting the topic string internally into a byte-array</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.Subscribe(System.Byte[])">
            <summary>
            In case of socket set to manual mode will subscribe the last subscriber to the topic
            </summary>
            <param name="topic">a byte-array specifying the Topic to subscribe to</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.Unsubscribe(System.String)">
            <summary>
            In case of socket set to manual mode will unsubscribe the last subscriber from a topic
            </summary>
            <param name="topic">a string specifying the Topic to unsubscribe from</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.Unsubscribe(System.String,System.Text.Encoding)">
            <summary>
            In case of socket set to manual mode will unsubscribe the last subscriber from a topic
            </summary>
            <param name="topic">a string specifying the Topic to unsubscribe from</param>
            <param name="encoding">the character-Encoding to use when converting the topic string internally into a byte-array</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.Unsubscribe(System.Byte[])">
            <summary>
            In case of socket set to manual mode will unsubscribe the last subscriber from a topic
            </summary>
            <param name="topic">a byte-array specifying the Topic to unsubscribe from</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.ClearWelcomeMessage">
            <summary>
            Publisher sockets generally send a welcome-message to subscribers to give an indication that they have successful subscribed.
            This method clears that message, such that none is sent.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.SetWelcomeMessage(System.String,System.Text.Encoding)">
            <summary>
            Publisher sockets send a welcome-message to subscribers to give an indication that they have successful subscribed.
            This method is how you set the text of that welcome-message.
            </summary>
            <param name="welcomeMessage">a string denoting the new value for the welcome-message</param>
            <param name="encoding">the character-Encoding to use when converting the topic string internally into a byte-array</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.SetWelcomeMessage(System.String)">
            <summary>
            Publisher sockets send a welcome-message to subscribers to give an indication that they have successful subscribed.
            This method is how you set the text of that welcome-message. The Encoding is assumed to be ASCII.
            </summary>
            <param name="welcomeMessage">a string denoting the new value for the welcome-message</param>
        </member>
        <member name="M:NetMQ.Sockets.XPublisherSocket.SetWelcomeMessage(System.Byte[])">
            <summary>
            Publisher sockets send a welcome-message to subscribers to give an indication that they have successful subscribed.
            This method is how you set the text of that welcome-message. The Encoding is assumed to be ASCII.
            </summary>
            <param name="welcomeMessage">a byte-array denoting the new value for the welcome-message</param>
        </member>
        <member name="T:NetMQ.Sockets.XSubscriberSocket">
            <summary>
            An XSubscriberSocket is a NetMQSocket intended to be used as the XSub in the XPub/XSub pattern.
            The intended usage is for serving, together with a matching XPublisherSocket,
            as a stable intermediary between a PublisherSocket and it's SubscriberSockets.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.#ctor(System.String)">
            <summary>
            Create a new XSubscriberSocket and attach socket to zero or more endpoints.
            </summary>
            <param name="connectionString">List of NetMQ endpoints, separated by commas and prefixed by '@' (to bind the socket) or '>' (to connect the socket).
            Default action is connect (if endpoint doesn't start with '@' or '>')</param>
            <example><code>var socket = new XSubscriberSocket(">tcp://127.0.0.1:5555,@127.0.0.1:55556");</code></example>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.#ctor(NetMQ.Core.SocketBase)">
            <summary>
            Create a new XSubscriberSocket based upon the given SocketBase.
            </summary>
            <param name="socketHandle">the SocketBase to create the new socket from</param>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.Subscribe(System.String)">
            <summary>
            Subscribe this socket to the given 'topic' - which means enable this socket to receive
            messages that begin with this string prefix.
            You can set topic to an empty string to subscribe to everything.
            </summary>
            <param name="topic">this specifies what text-prefix to subscribe to, or may be an empty-string to specify ALL</param>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.Subscribe(System.String,System.Text.Encoding)">
            <summary>
            Subscribe this socket to the given 'topic' - which means enable this socket to receive
            messages that begin with this string prefix, using the given Encoding.
            You can set topic to an empty string to subscribe to everything.
            </summary>
            <param name="topic">this specifies what text-prefix to subscribe to, or may be an empty-string to specify ALL</param>
            <param name="encoding">the Encoding to use when converting the topic string internally into a byte-array</param>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.Subscribe(System.Byte[])">
            <summary>
            Subscribe this socket to the given 'topic' - which means enable this socket to receive
            messages that begin with this array of bytes.
            </summary>
            <param name="topic">this specifies what byte-array prefix to subscribe to</param>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.SubscribeToAnyTopic">
            <summary>
            Subscribe this socket to all topics - which means enable this socket to receive
            all messages regardless of what the string prefix is.
            This is the same as calling Subscribe with an empty-string for the topic.
            </summary>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.Unsubscribe(System.String)">
            <summary>
            Remove this socket's subscription to the given topic.
            </summary>
            <param name="topic">a string denoting which the topic to stop receiving</param>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.Unsubscribe(System.String,System.Text.Encoding)">
            <summary>
            Remove this socket's subscription to the given topic.
            </summary>
            <param name="topic">a string denoting which the topic to stop receiving</param>
            <param name="encoding">the Encoding to use when converting the topic string internally into a byte-array</param>
        </member>
        <member name="M:NetMQ.Sockets.XSubscriberSocket.Unsubscribe(System.Byte[])">
            <summary>
            Remove this socket's subscription to the given topic.
            </summary>
            <param name="topic">a byte-array denoting which the topic to stop receiving</param>
        </member>
        <member name="T:NetMQ.ZmqSocketType">
            <summary>
            This enum-type is used to specify the basic type of message-queue socket
            based upon the intended pattern, such as Pub,Sub, Req,Rep, Dealer,Router, Pull,Push, Xpub,Xsub.
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.None">
            <summary>
            No socket-type is specified
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Pair">
            <summary>
            This denotes a Pair socket (usually paired with another Pair socket).
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Pub">
            <summary>
            This denotes a Publisher socket (usually paired with a Subscriber socket).
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Sub">
            <summary>
            This denotes a Subscriber socket (usually paired with a Publisher socket).
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Req">
            <summary>
            This denotes a Request socket (usually paired with a Response socket).
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Rep">
            <summary>
            This denotes a Response socket (usually paired with a Request socket).
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Dealer">
            <summary>
            This denotes an Dealer socket.
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Router">
            <summary>
            This denotes an Router socket.
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Pull">
            <summary>
            This denotes a Pull socket (usually paired with a PUsh socket).
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Push">
            <summary>
            This denotes a Push socket (usually paired with a Pull socket).
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Xpub">
            <summary>
            This denotes an XPublisher socket.
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Xsub">
            <summary>
            This denotes an XSubscriber socket.
            </summary>
        </member>
        <member name="F:NetMQ.ZmqSocketType.Stream">
            <summary>
            This denotes a Stream socket - which is a parent-class to the other socket types.
            </summary>
        </member>
    </members>
</doc>
